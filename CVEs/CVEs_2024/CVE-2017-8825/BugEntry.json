{"buggy_code": ["/*\n * libEtPan! -- a mail stuff library\n *\n * Copyright (C) 2001, 2005 - DINH Viet Hoa\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the libEtPan! project nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * $Id: mailimf.c,v 1.50 2011/06/20 23:25:26 hoa Exp $\n */\n\n#ifdef HAVE_CONFIG_H\n#\tinclude <config.h>\n#endif\n\n#include \"mailimf.h\"\n\n/*\n  RFC 2822\n\n  RFC 2821 ... \n   A message-originating SMTP system SHOULD NOT send a message that\n   already contains a Return-path header.  SMTP servers performing a\n   relay function MUST NOT inspect the message data, and especially not\n   to the extent needed to determine if Return-path headers are present.\n   SMTP servers making final delivery MAY remove Return-path headers\n   before adding their own.\n*/\n\n#include <ctype.h>\n#include \"mmapstring.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"mailmime_decode.h\"\n\n#ifndef TRUE\n#define TRUE 1\n#endif\n\n#ifndef FALSE\n#define FALSE 0\n#endif\n\n\n\n\n\n\n\nstatic inline int is_dtext(char ch);\n\nstatic int mailimf_quoted_pair_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx, char * result);\n\nstatic int mailimf_ccontent_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx);\n\nstatic int\nmailimf_comment_fws_ccontent_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx);\n\nstatic inline int mailimf_comment_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx);\n\nstatic int mailimf_qcontent_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, char * ch);\n\nstatic int mailimf_phrase_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, char ** result);\n\nstatic int mailimf_unstructured_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx, char ** result);\n\nstatic int mailimf_ignore_unstructured_parse(const char * message, size_t length,\n\t\t\t\t\t     size_t * indx);\n\nstatic int mailimf_day_of_week_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx, int * result);\n\nstatic int mailimf_day_name_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, int * result);\n\nstatic int mailimf_date_parse(const char * message, size_t length,\n\t\t\t      size_t * indx,\n\t\t\t      int * pday, int * pmonth, int * pyear);\n\nstatic int mailimf_broken_date_parse(const char * message, size_t length,\n                                     size_t * indx,\n                                     int * pday, int * pmonth, int * pyear);\n\nstatic int mailimf_year_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, int * result);\n\nstatic int mailimf_month_parse(const char * message, size_t length,\n\t\t\t       size_t * indx, int * result);\n\nstatic int mailimf_month_name_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, int * result);\n\nstatic int mailimf_day_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, int * result);\n\nstatic int mailimf_time_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, \n\t\t\t      int * phour, int * pmin,\n\t\t\t      int * psec,\n\t\t\t      int * zone);\nstatic int mailimf_time_of_day_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx,\n\t\t\t\t     int * phour, int * pmin,\n\t\t\t\t     int * psec);\n\nstatic int mailimf_hour_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, int * result);\n\nstatic int mailimf_minute_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, int * result);\n\nstatic int mailimf_second_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, int * result);\n\nstatic int mailimf_zone_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, int * result);\n\nstatic int mailimf_name_addr_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx,\n\t\t\t\t   char ** pdisplay_name,\n\t\t\t\t   char ** pangle_addr);\n\nstatic int mailimf_angle_addr_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, char ** result);\n\nstatic int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result);\n\nstatic int mailimf_display_name_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx, char ** result);\n\nstatic int mailimf_addr_spec_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx,\n\t\t\t\t   char ** address);\n\nstatic int\nmailimf_orig_date_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_orig_date ** result);\n\nstatic int\nmailimf_from_parse(const char * message, size_t length,\n\t\t   size_t * indx, struct mailimf_from ** result);\n\nstatic int\nmailimf_sender_parse(const char * message, size_t length,\n\t\t     size_t * indx, struct mailimf_sender ** result);\n\nstatic int\nmailimf_reply_to_parse(const char * message, size_t length,\n\t\t       size_t * indx, struct mailimf_reply_to ** result);\n\nstatic int\nmailimf_to_parse(const char * message, size_t length,\n\t\t size_t * indx, struct mailimf_to ** result);\n\nstatic int\nmailimf_cc_parse(const char * message, size_t length,\n\t\t size_t * indx, struct mailimf_cc ** result);\n\nstatic int\nmailimf_bcc_parse(const char * message, size_t length,\n\t\t  size_t * indx, struct mailimf_bcc ** result);\n\nstatic int mailimf_message_id_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx,\n\t\t\t\t    struct mailimf_message_id ** result);\n\nstatic int\nmailimf_in_reply_to_parse(const char * message, size_t length,\n\t\t\t  size_t * indx,\n\t\t\t  struct mailimf_in_reply_to ** result);\n\nstatic int mailimf_unstrict_msg_id_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx,\n\t\t\t\t\t char ** result);\n\nstatic int mailimf_subject_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx,\n\t\t\t\t struct mailimf_subject ** result);\n\nstatic int mailimf_comments_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_comments ** result);\n\nstatic int mailimf_keywords_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_keywords ** result);\n\nstatic int\nmailimf_resent_date_parse(const char * message, size_t length,\n\t\t\t  size_t * indx, struct mailimf_orig_date ** result);\n\nstatic int\nmailimf_resent_from_parse(const char * message, size_t length,\n\t\t\t  size_t * indx, struct mailimf_from ** result);\n\nstatic int\nmailimf_resent_sender_parse(const char * message, size_t length,\n\t\t\t    size_t * indx, struct mailimf_sender ** result);\n\nstatic int\nmailimf_resent_to_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_to ** result);\n\nstatic int\nmailimf_resent_cc_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_cc ** result);\n\nstatic int\nmailimf_resent_bcc_parse(const char * message, size_t length,\n\t\t\t size_t * indx, struct mailimf_bcc ** result);\n\nstatic int\nmailimf_resent_msg_id_parse(const char * message, size_t length,\n\t\t\t    size_t * indx,\n\t\t\t    struct mailimf_message_id ** result);\n\nstatic int mailimf_return_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx,\n\t\t\t\tstruct mailimf_return ** result);\n\nstatic int\nmailimf_path_parse(const char * message, size_t length,\n\t\t   size_t * indx, struct mailimf_path ** result);\n\nstatic int\nmailimf_optional_field_parse(const char * message, size_t length,\n\t\t\t     size_t * indx,\n\t\t\t     struct mailimf_optional_field ** result);\n\nstatic int mailimf_field_name_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, char ** result);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* *************************************************************** */\n\nstatic inline int is_digit(char ch)\n{\n  return (ch >= '0') && (ch <= '9');\n}\n\nstatic int mailimf_digit_parse(const char * message, size_t length,\n\t\t\t       size_t * indx, int * result)\n{\n  size_t cur_token;\n\n  cur_token = * indx;\n  \n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_digit(message[cur_token])) {\n    * result = message[cur_token] - '0';\n    cur_token ++;\n    * indx = cur_token;\n    return MAILIMF_NO_ERROR;\n  }\n  else\n    return MAILIMF_ERROR_PARSE;\n}\n\nLIBETPAN_EXPORT\nint\nmailimf_number_parse(const char * message, size_t length,\n\t\t     size_t * indx, uint32_t * result)\n{\n  size_t cur_token;\n  int digit;\n  uint32_t number;\n  int parsed;\n  int r;\n\n  cur_token = * indx;\n  parsed = FALSE;\n\n  number = 0;\n  while (1) {\n    r = mailimf_digit_parse(message, length, &cur_token, &digit);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else\n\treturn r;\n    }\n    number *= 10;\n    number += digit;\n    parsed = TRUE;\n  }\n\n  if (!parsed)\n    return MAILIMF_ERROR_PARSE;\n\n  * result = number;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\nLIBETPAN_EXPORT\nint mailimf_char_parse(const char * message, size_t length,\n\t\t       size_t * indx, char token)\n{\n  size_t cur_token;\n\n  cur_token = * indx;\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (message[cur_token] == token) {\n    cur_token ++;\n    * indx = cur_token;\n    return MAILIMF_NO_ERROR;\n  }\n  else\n    return MAILIMF_ERROR_PARSE;\n}\n\nLIBETPAN_EXPORT\nint mailimf_unstrict_char_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, char token)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_char_parse(message, length, &cur_token, token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n  \n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\nLIBETPAN_EXPORT\nint\nmailimf_token_case_insensitive_len_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx, char * token,\n\t\t\t\t\t size_t token_length)\n{\n  size_t cur_token;\n\n  cur_token = * indx;\n\n  if (cur_token + token_length - 1 >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (strncasecmp(message + cur_token, token, token_length) == 0) {\n    cur_token += token_length;\n    * indx = cur_token;\n    return MAILIMF_NO_ERROR;\n  }\n  else\n    return MAILIMF_ERROR_PARSE;\n}\n\nstatic int mailimf_oparenth_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx)\n{\n  return mailimf_char_parse(message, length, indx, '(');\n}\n\nstatic int mailimf_cparenth_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx)\n{\n  return mailimf_char_parse(message, length, indx, ')');\n}\n\nstatic int mailimf_comma_parse(const char * message, size_t length,\n\t\t\t       size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, ',');\n}\n\nstatic int mailimf_dquote_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx)\n{\n  return mailimf_char_parse(message, length, indx, '\\\"');\n}\n\nstatic int mailimf_colon_parse(const char * message, size_t length,\n\t\t\t       size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, ':');\n}\n\nstatic int mailimf_semi_colon_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, ';');\n}\n\nstatic int mailimf_plus_parse(const char * message, size_t length,\n\t\t\t      size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '+');\n}\n\nstatic int mailimf_minus_parse(const char * message, size_t length,\n\t\t\t       size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '-');\n}\n\nstatic int mailimf_lower_parse(const char * message, size_t length,\n\t\t\t       size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '<');\n}\n\nstatic int mailimf_greater_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '>');\n}\n\nstatic int mailimf_at_sign_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '@');\n}\n\nstatic int mailimf_point_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '.');\n}\n\nLIBETPAN_EXPORT\nint\nmailimf_custom_string_parse(const char * message, size_t length,\n\t\t\t    size_t * indx, char ** result,\n\t\t\t    int (* is_custom_char)(char))\n{\n  size_t begin;\n  size_t end;\n  char * gstr;\n\n  begin = * indx;\n\n  end = begin;\n\n  if (end >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  while (is_custom_char(message[end])) {\n    end ++;\n    if (end >= length)\n      break;\n  }\n\n  if (end != begin) {\n    /*\n    gstr = strndup(message + begin, end - begin);\n    */\n    gstr = malloc(end - begin + 1);\n    if (gstr == NULL)\n      return MAILIMF_ERROR_MEMORY;\n    strncpy(gstr, message + begin, end - begin);\n    gstr[end - begin] = '\\0';\n\n    * indx = end;\n    * result = gstr;\n    return MAILIMF_NO_ERROR;\n  }\n  else\n    return MAILIMF_ERROR_PARSE;\n}\n\n\n\n\n\n\n\ntypedef int mailimf_struct_parser(const char * message, size_t length,\n\t\t\t\t  size_t * indx, void * result);\n\ntypedef int mailimf_struct_destructor(void * result);\n\n\nstatic int\nmailimf_struct_multiple_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, clist ** result,\n\t\t\t      mailimf_struct_parser * parser,\n\t\t\t      mailimf_struct_destructor * destructor)\n{\n  clist * struct_list;\n  size_t cur_token;\n  void * value;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = parser(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  struct_list = clist_new();\n  if (struct_list == NULL) {\n    destructor(value);\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  r = clist_append(struct_list, value);\n  if (r < 0) {\n    destructor(value);\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  while (1) {\n    r = parser(message, length, &cur_token, &value);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else {\n\tres = r;\n\tgoto free;\n      }\n    }\n    r = clist_append(struct_list, value);\n    if (r < 0) {\n      (* destructor)(value);\n      res = MAILIMF_ERROR_MEMORY;\n      goto free;\n    }\n  }\n\n  * result = struct_list;\n  * indx = cur_token;\n  \n  return MAILIMF_NO_ERROR;\n\n free:\n  clist_foreach(struct_list, (clist_func) destructor, NULL);\n  clist_free(struct_list);\n err:\n  return res;\n}\n\n\n\nstatic int\nmailimf_struct_list_parse(const char * message, size_t length,\n\t\t\t  size_t * indx, clist ** result,\n\t\t\t  char symbol,\n\t\t\t  mailimf_struct_parser * parser,\n\t\t\t  mailimf_struct_destructor * destructor)\n{\n  clist * struct_list;\n  size_t cur_token;\n  void * value;\n  size_t final_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = parser(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  struct_list = clist_new();\n  if (struct_list == NULL) {\n    destructor(value);\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  r = clist_append(struct_list, value);\n  if (r < 0) {\n    destructor(value);\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  final_token = cur_token;\n\n  while (1) {\n    r = mailimf_unstrict_char_parse(message, length, &cur_token, symbol);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else {\n\tres = r;\n\tgoto free;\n      }\n    }\n\n    r = parser(message, length, &cur_token, &value);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else {\n\tres = r;\n\tgoto free;\n      }\n    }\n\n    r = clist_append(struct_list, value);\n    if (r < 0) {\n      destructor(value);\n      res = MAILIMF_ERROR_MEMORY;\n      goto free;\n    }\n\n    final_token = cur_token;\n  }\n  \n  * result = struct_list;\n  * indx = final_token;\n  \n  return MAILIMF_NO_ERROR;\n  \n free:\n  clist_foreach(struct_list, (clist_func) destructor, NULL);\n  clist_free(struct_list);\n err:\n  return res;\n}\n\nstatic inline int mailimf_wsp_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx)\n{\n  size_t cur_token;\n\n  cur_token = * indx;\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if ((message[cur_token] != ' ') && (message[cur_token] != '\\t'))\n    return MAILIMF_ERROR_PARSE;\n\n  cur_token ++;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\nLIBETPAN_EXPORT\nint mailimf_crlf_parse(const char * message, size_t length, size_t * indx)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_char_parse(message, length, &cur_token, '\\r');\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_char_parse(message, length, &cur_token, '\\n');\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n  return MAILIMF_NO_ERROR;\n}\n\nstatic int mailimf_unstrict_crlf_parse(const char * message,\n\t\t\t\t       size_t length, size_t * indx)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  mailimf_cfws_parse(message, length, &cur_token);\n\n  r = mailimf_char_parse(message, length, &cur_token, '\\r');\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_char_parse(message, length, &cur_token, '\\n');\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n  return MAILIMF_NO_ERROR;\n}\n\n/* ************************************************************************ */\n\n\n\n/* RFC 2822 grammar */\n\n/*\nNO-WS-CTL       =       %d1-8 /         ; US-ASCII control characters\n                        %d11 /          ;  that do not include the\n                        %d12 /          ;  carriage return, line feed,\n                        %d14-31 /       ;  and white space characters\n                        %d127\n*/\n\nstatic inline int is_no_ws_ctl(char ch)\n{\n  if ((ch == 9) || (ch == 10) || (ch == 13))\n    return FALSE;\n\n  if (ch == 127)\n     return TRUE;\n\n  return (ch >= 1) && (ch <= 31);\n}\n\n/*\ntext            =       %d1-9 /         ; Characters excluding CR and LF\n                        %d11 /\n                        %d12 /\n                        %d14-127 /\n                        obs-text\n*/\n\n/*\nspecials        =       \"(\" / \")\" /     ; Special characters used in\n                        \"<\" / \">\" /     ;  other parts of the syntax\n                        \"[\" / \"]\" /\n                        \":\" / \";\" /\n                        \"@\" / \"\\\" /\n                        \",\" / \".\" /\n                        DQUOTE\n*/\n\n/*\nquoted-pair     =       (\"\\\" text) / obs-qp\n*/\n\nstatic inline int mailimf_quoted_pair_parse(const char * message, size_t length,\n\t\t\t\t\t    size_t * indx, char * result)\n{\n  size_t cur_token;\n\n  cur_token = * indx;\n  \n  if (cur_token + 1 >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (message[cur_token] != '\\\\')\n    return MAILIMF_ERROR_PARSE;\n\n  cur_token ++;\n  * result = message[cur_token];\n  cur_token ++;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nFWS             =       ([*WSP CRLF] 1*WSP) /   ; Folding white space\n                        obs-FWS\n*/\n\nLIBETPAN_EXPORT\nint mailimf_fws_parse(const char * message, size_t length, size_t * indx)\n{\n  size_t cur_token;\n  size_t final_token;\n  int fws_1;\n  int fws_2;\n  int fws_3;\n  int r;\n  \n  cur_token = * indx;\n\n  fws_1 = FALSE;\n  while (1) {\n    r = mailimf_wsp_parse(message, length, &cur_token);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else\n\treturn r;\n    }\n    fws_1 = TRUE;\n  }\n  final_token = cur_token;\n\n  r = mailimf_crlf_parse(message, length, &cur_token);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    fws_2 = TRUE;\n    break;\n  case MAILIMF_ERROR_PARSE:\n    fws_2 = FALSE;\n    break;\n  default:\n      return r;\n  }\n  \n  fws_3 = FALSE;\n  if (fws_2) {\n    while (1) {\n      r = mailimf_wsp_parse(message, length, &cur_token);\n      if (r != MAILIMF_NO_ERROR) {\n\tif (r == MAILIMF_ERROR_PARSE)\n\t  break;\n\telse\n\t  return r;\n      }\n      fws_3 = TRUE;\n    }\n  }\n\n  if ((!fws_1) && (!fws_3))\n    return MAILIMF_ERROR_PARSE;\n\n  if (!fws_3)\n    cur_token = final_token;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\n/*\nctext           =       NO-WS-CTL /     ; Non white space controls\n\n                        %d33-39 /       ; The rest of the US-ASCII\n                        %d42-91 /       ;  characters not including \"(\",\n                        %d93-126        ;  \")\", or \"\\\"\n*/\n\nstatic inline int is_ctext(char ch)\n{\n  unsigned char uch = (unsigned char) ch;\n\n  if (is_no_ws_ctl(ch))\n    return TRUE;\n\n  if (uch < 33)\n    return FALSE;\n\n  if ((uch == 40) || (uch == 41))\n    return FALSE;\n  \n  if (uch == 92)\n    return FALSE;\n\n  if (uch == 127)\n    return FALSE;\n\n  return TRUE;\n}\n\n/*\nccontent        =       ctext / quoted-pair / comment\n*/\n\nstatic inline int mailimf_ccontent_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx)\n{\n  size_t cur_token;\n  char ch;\n  int r;\n  \n  cur_token = * indx;\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_ctext(message[cur_token])) {\n    cur_token ++;\n  }\n  else {\n    r = mailimf_quoted_pair_parse(message, length, &cur_token, &ch);\n    \n    if (r == MAILIMF_ERROR_PARSE)\n      r = mailimf_comment_parse(message, length, &cur_token);\n    \n    if (r == MAILIMF_ERROR_PARSE)\n      return r;\n  }\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\n[FWS] ccontent\n*/\n\nstatic inline int\nmailimf_comment_fws_ccontent_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_ccontent_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\ncomment         =       \"(\" *([FWS] ccontent) [FWS] \")\"\n*/\n\nstatic inline int mailimf_comment_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_oparenth_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  while (1) {\n    r = mailimf_comment_fws_ccontent_parse(message, length, &cur_token);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else\n\treturn r;\n    }\n  }\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_cparenth_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\n[FWS] comment\n*/\n\nstatic inline int mailimf_cfws_fws_comment_parse(const char * message, size_t length,\n\t\t\t\t\t\t size_t * indx)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_comment_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nCFWS            =       *([FWS] comment) (([FWS] comment) / FWS)\n*/\n\nLIBETPAN_EXPORT\nint mailimf_cfws_parse(const char * message, size_t length,\n\t\t       size_t * indx)\n{\n  size_t cur_token;\n  int has_comment;\n  int r;\n\n  cur_token = * indx;\n\n  has_comment = FALSE;\n  while (1) {\n    r = mailimf_cfws_fws_comment_parse(message, length, &cur_token);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else\n\treturn r;\n    }\n    has_comment = TRUE;\n  }\n\n  if (!has_comment) {\n    r = mailimf_fws_parse(message, length, &cur_token);\n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\natext           =       ALPHA / DIGIT / ; Any character except controls,\n                        \"!\" / \"#\" /     ;  SP, and specials.\n                        \"$\" / \"%\" /     ;  Used for atoms\n                        \"&\" / \"'\" /\n                        \"*\" / \"+\" /\n                        \"-\" / \"/\" /\n                        \"=\" / \"?\" /\n                        \"^\" / \"_\" /\n                        \"`\" / \"{\" /\n                        \"|\" / \"}\" /\n                        \"~\"\n*/\n\nstatic inline int is_atext(char ch)\n{\n  switch (ch) {\n  case ' ':\n  case '\\t':\n  case '\\n':\n  case '\\r':\n#if 0\n  case '(':\n  case ')':\n#endif\n  case '<':\n  case '>':\n#if 0\n  case '@':\n#endif\n  case ',':\n  case '\"':\n  case ':':\n  case ';':\n    return FALSE;\n  default:\n    return TRUE;\n  }\n}\n\n/*\natom            =       [CFWS] 1*atext [CFWS]\n*/\n\nLIBETPAN_EXPORT\nint mailimf_atom_parse(const char * message, size_t length,\n\t\t       size_t * indx, char ** result)\n{\n  size_t cur_token;\n  int r;\n  int res;\n  char * atom;\n  size_t end;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  \n  end = cur_token;\n  if (end >= length) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  while (is_atext(message[end])) {\n    end ++;\n    if (end >= length)\n      break;\n  }\n  if (end == cur_token) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  atom = malloc(end - cur_token + 1);\n  if (atom == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n  strncpy(atom, message + cur_token, end - cur_token);\n  atom[end - cur_token] = '\\0';\n\n  cur_token = end;\n\n  * indx = cur_token;\n  * result = atom;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  return res;\n}\n\nLIBETPAN_EXPORT\nstatic int mailimf_fws_atom_for_word_parse(const char * message, size_t length,\n                                           size_t * indx, char ** result, int * p_missing_closing_quote)\n{\n  size_t end;\n  size_t cur_token;\n  int r;\n  int res;\n  struct mailmime_encoded_word * word;\n  int has_fwd;\n  int missing_closing_quote;\n  char * atom;\n  \n  cur_token = * indx;\n  missing_closing_quote = 0;\n  \n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  \n  end = cur_token;\n  \n  r = mailmime_encoded_word_parse(message, length, &cur_token, &word, &has_fwd, &missing_closing_quote);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  \n  if (r == MAILIMF_ERROR_PARSE) {\n    return mailimf_fws_atom_parse(message, length, indx, result);\n  }\n  \n  mailmime_encoded_word_free(word);\n  \n  atom = malloc(cur_token - end + 1);\n  if (atom == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n  strncpy(atom, message + end, cur_token - end);\n  atom[cur_token - end] = '\\0';\n  \n  * result = atom;\n  * indx = cur_token;\n  * p_missing_closing_quote = missing_closing_quote;\n  \n  return MAILIMF_NO_ERROR;\n  \nerr:\n  return res;\n}\n\nLIBETPAN_EXPORT\nint mailimf_fws_atom_parse(const char * message, size_t length,\n\t\t\t   size_t * indx, char ** result)\n{\n  size_t cur_token;\n  int r;\n  int res;\n  char * atom;\n  size_t end;\n\n  cur_token = * indx;\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  end = cur_token;\n  if (end >= length) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  while (is_atext(message[end])) {\n    end ++;\n    if (end >= length)\n      break;\n  }\n  if (end == cur_token) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  atom = malloc(end - cur_token + 1);\n  if (atom == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n  strncpy(atom, message + cur_token, end - cur_token);\n  atom[end - cur_token] = '\\0';\n\n  cur_token = end;\n\n  * indx = cur_token;\n  * result = atom;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  return res;\n}\n\n/*\ndot-atom        =       [CFWS] dot-atom-text [CFWS]\n*/\n\n#if 0\nstatic int mailimf_dot_atom_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, char ** result)\n{\n  return mailimf_atom_parse(message, length, indx, result);\n}\n#endif\n\n/*\ndot-atom-text   =       1*atext *(\".\" 1*atext)\n*/\n\n#if 0\nstatic int\nmailimf_dot_atom_text_parse(const char * message, size_t length,\n\t\t\t    size_t * indx, char ** result)\n{\n  return mailimf_atom_parse(message, length, indx, result);\n}\n#endif\n\n/*\nqtext           =       NO-WS-CTL /     ; Non white space controls\n\n                        %d33 /          ; The rest of the US-ASCII\n                        %d35-91 /       ;  characters not including \"\\\"\n                        %d93-126        ;  or the quote character\n*/\n\nstatic inline int is_qtext(char ch)\n{\n  unsigned char uch = (unsigned char) ch;\n\n  if (is_no_ws_ctl(ch))\n    return TRUE;\n\n  if (uch < 33)\n    return FALSE;\n\n  if (uch == 34)\n    return FALSE;\n\n  if (uch == 92)\n    return FALSE;\n\n  if (uch == 127)\n    return FALSE;\n\n  return TRUE;\n}\n\n/*\nqcontent        =       qtext / quoted-pair\n*/\n\nstatic int mailimf_qcontent_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, char * result)\n{\n  size_t cur_token;\n  char ch;\n  int r;\n\n  cur_token = * indx;\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_qtext(message[cur_token])) {\n    ch = message[cur_token];\n    cur_token ++;\n  }\n  else {\n    r = mailimf_quoted_pair_parse(message, length, &cur_token, &ch);\n    \n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n  \n  * result = ch;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nquoted-string   =       [CFWS]\n                        DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                        [CFWS]\n*/\n\nLIBETPAN_EXPORT\nint mailimf_quoted_string_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, char ** result)\n{\n  size_t cur_token;\n  MMAPString * gstr;\n  char ch;\n  char * str;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  gstr = mmap_string_new(\"\");\n  if (gstr == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n#if 0\n  if (mmap_string_append_c(gstr, '\\\"') == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n#endif\n\n  while (1) {\n    r = mailimf_fws_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR) {\n      if (mmap_string_append_c(gstr, ' ') == NULL) {\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free_gstr;\n      }\n    }\n    else if (r != MAILIMF_ERROR_PARSE) {\n      res = r;\n      goto free_gstr;\n    }\n\n    r = mailimf_qcontent_parse(message, length, &cur_token, &ch);\n    if (r == MAILIMF_NO_ERROR) {\n      if (mmap_string_append_c(gstr, ch) == NULL) {\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free_gstr;\n      }\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      res = r;\n      goto free_gstr;\n    }\n  }\n\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_gstr;\n  }\n\n#if 0\n  if (mmap_string_append_c(gstr, '\\\"') == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n#endif\n\n  str = strdup(gstr->str);\n  if (str == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n  mmap_string_free(gstr);\n\n  * indx = cur_token;\n  * result = str;\n\n  return MAILIMF_NO_ERROR;\n\n free_gstr:\n  mmap_string_free(gstr);\n err:\n  return res;\n}\n\nLIBETPAN_EXPORT\nint mailimf_fws_quoted_string_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, char ** result)\n{\n  size_t cur_token;\n  MMAPString * gstr;\n  char ch;\n  char * str;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  gstr = mmap_string_new(\"\");\n  if (gstr == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n#if 0\n  if (mmap_string_append_c(gstr, '\\\"') == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n#endif\n\n  while (1) {\n    r = mailimf_fws_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR) {\n      if (mmap_string_append_c(gstr, ' ') == NULL) {\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free_gstr;\n      }\n    }\n    else if (r != MAILIMF_ERROR_PARSE) {\n      res = r;\n      goto free_gstr;\n    }\n\n    r = mailimf_qcontent_parse(message, length, &cur_token, &ch);\n    if (r == MAILIMF_NO_ERROR) {\n      if (mmap_string_append_c(gstr, ch) == NULL) {\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free_gstr;\n      }\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      res = r;\n      goto free_gstr;\n    }\n  }\n\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_gstr;\n  }\n\n#if 0\n  if (mmap_string_append_c(gstr, '\\\"') == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n#endif\n\n  str = strdup(gstr->str);\n  if (str == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n  mmap_string_free(gstr);\n\n  * indx = cur_token;\n  * result = str;\n\n  return MAILIMF_NO_ERROR;\n\n free_gstr:\n  mmap_string_free(gstr);\n err:\n  return res;\n}\n\n/*\nword            =       atom / quoted-string\n*/\n\nLIBETPAN_EXPORT\nint mailimf_word_parse(const char * message, size_t length,\n\t\t       size_t * indx, char ** result)\n{\n  size_t cur_token;\n  char * word;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_atom_parse(message, length, &cur_token, &word);\n\n  if (r == MAILIMF_ERROR_PARSE)\n    r = mailimf_quoted_string_parse(message, length, &cur_token, &word);\n\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = word;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\nLIBETPAN_EXPORT\nint mailimf_fws_word_parse(const char * message, size_t length,\n\t\t\t   size_t * indx, char ** result, int * p_missing_closing_quote)\n{\n  size_t cur_token;\n  char * word;\n  int r;\n  int missing_closing_quote;\n\n  cur_token = * indx;\n  missing_closing_quote = 0;\n\n  r = mailimf_fws_atom_for_word_parse(message, length, &cur_token, &word, &missing_closing_quote);\n\n  if (r == MAILIMF_ERROR_PARSE)\n    r = mailimf_fws_quoted_string_parse(message, length, &cur_token, &word);\n\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = word;\n  * indx = cur_token;\n  * p_missing_closing_quote = missing_closing_quote;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nphrase          =       1*word / obs-phrase\n*/\n\nstatic int mailimf_phrase_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, char ** result)\n{\n  MMAPString * gphrase;\n  char * word;\n  int first;\n  size_t cur_token;\n  int r;\n  int res;\n  char * str;\n  int has_missing_closing_quote;\n\n  cur_token = * indx;\n  has_missing_closing_quote = 0;\n\n  gphrase = mmap_string_new(\"\");\n  if (gphrase == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  first = TRUE;\n\n  while (1) {\n    int missing_quote = 0;\n    r = mailimf_fws_word_parse(message, length, &cur_token, &word, &missing_quote);\n    if (missing_quote) {\n      has_missing_closing_quote = 1;\n    }\n    if (r == MAILIMF_NO_ERROR) {\n      if (!first) {\n\tif (mmap_string_append_c(gphrase, ' ') == NULL) {\n\t  mailimf_word_free(word);\n\t  res = MAILIMF_ERROR_MEMORY;\n\t  goto free;\n\t}\n      }\n      if (mmap_string_append(gphrase, word) == NULL) {\n\tmailimf_word_free(word);\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free;\n      }\n      mailimf_word_free(word);\n      first = FALSE;\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      res = r;\n      goto free;\n    }\n  }\n\n  if (first) {\n    res = MAILIMF_ERROR_PARSE;\n    goto free;\n  }\n\n  if (has_missing_closing_quote) {\n    r = mailimf_char_parse(message, length, &cur_token, '\\\"');\n  }\n\n  str = strdup(gphrase->str);\n  if (str == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n  mmap_string_free(gphrase);\n\n  * result = str;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  mmap_string_free(gphrase);\n err:\n  return res;\n}\n\n/*\nutext           =       NO-WS-CTL /     ; Non white space controls\n                        %d33-126 /      ; The rest of US-ASCII\n                        obs-utext\n\nadded : WSP\n*/\n\nenum {\n  UNSTRUCTURED_START,\n  UNSTRUCTURED_CR,\n  UNSTRUCTURED_LF,\n  UNSTRUCTURED_WSP,\n  UNSTRUCTURED_OUT\n};\n\nstatic int mailimf_unstructured_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx, char ** result)\n{\n  size_t cur_token;\n  int state;\n  size_t begin;\n  size_t terminal;\n  char * str;\n\n  cur_token = * indx;\n\n\n  while (1) {\n    int r;\n\n    r = mailimf_wsp_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR) {\n      /* do nothing */\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      return r;\n    }\n  }\n\n  state = UNSTRUCTURED_START;\n  begin = cur_token;\n  terminal = cur_token;\n\n  while (state != UNSTRUCTURED_OUT) {\n\n    switch(state) {\n    case UNSTRUCTURED_START:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      terminal = cur_token;\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_CR:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      switch(message[cur_token]) {\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n\n    case UNSTRUCTURED_LF:\n      if (cur_token >= length) {\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n\n      switch(message[cur_token]) {\n      case '\\t':\n      case ' ':\n\tstate = UNSTRUCTURED_WSP;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_WSP:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    }\n\n    cur_token ++;\n  }\n\n  str = malloc(terminal - begin + 1);\n  if (str == NULL)\n    return MAILIMF_ERROR_MEMORY;\n  strncpy(str, message + begin,  terminal - begin);\n  str[terminal - begin] = '\\0';\n\n  * indx = terminal;\n  * result = str;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\nstatic int mailimf_ignore_unstructured_parse(const char * message, size_t length,\n\t\t\t\t\t     size_t * indx)\n{\n  size_t cur_token;\n  int state;\n  size_t terminal;\n\n  cur_token = * indx;\n\n  state = UNSTRUCTURED_START;\n  terminal = cur_token;\n\n  while (state != UNSTRUCTURED_OUT) {\n\n    switch(state) {\n    case UNSTRUCTURED_START:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n      terminal = cur_token;\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_CR:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n      switch(message[cur_token]) {\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_LF:\n      if (cur_token >= length) {\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n      switch(message[cur_token]) {\n      case '\\t':\n      case ' ':\n\tstate = UNSTRUCTURED_WSP;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_WSP:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    }\n\n    cur_token ++;\n  }\n\n  * indx = terminal;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\nLIBETPAN_EXPORT\nint mailimf_ignore_field_parse(const char * message, size_t length,\n\t\t\t       size_t * indx)\n{\n  int has_field;\n  size_t cur_token;\n  int state;\n  size_t terminal;\n\n  has_field = FALSE;\n  cur_token = * indx;\n\n  terminal = cur_token;\n  state = UNSTRUCTURED_START;\n\n  /* check if this is not a beginning CRLF */\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  switch (message[cur_token]) {\n  case '\\r':\n    return MAILIMF_ERROR_PARSE;\n  case '\\n':\n    return MAILIMF_ERROR_PARSE;\n  }\n\n  while (state != UNSTRUCTURED_OUT) {\n\n    switch(state) {\n    case UNSTRUCTURED_START:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      case ':':\n\thas_field = TRUE;\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_CR:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      switch(message[cur_token]) {\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      case ':':\n\thas_field = TRUE;\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_LF:\n      if (cur_token >= length) {\n\tterminal = cur_token;\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n\n      switch(message[cur_token]) {\n      case '\\t':\n      case ' ':\n\tstate = UNSTRUCTURED_WSP;\n\tbreak;\n      default:\n\tterminal = cur_token;\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_WSP:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      case ':':\n\thas_field = TRUE;\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    }\n\n    cur_token ++;\n  }\n\n  if (!has_field)\n    return MAILIMF_ERROR_PARSE;\n\n  * indx = terminal;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\n/*\ndate-time       =       [ day-of-week \",\" ] date FWS time [CFWS]\n*/\n\nLIBETPAN_EXPORT\nint mailimf_date_time_parse(const char * message, size_t length,\n\t\t\t    size_t * indx,\n\t\t\t    struct mailimf_date_time ** result)\n{\n  size_t cur_token;\n  int day_of_week;\n  struct mailimf_date_time * date_time;\n  int day;\n  int month;\n  int year;\n  int hour;\n  int min;\n  int sec;\n  int zone;\n  int r;\n\n  cur_token = * indx;\n\n  day_of_week = -1;\n  r = mailimf_day_of_week_parse(message, length, &cur_token, &day_of_week);\n  if (r == MAILIMF_NO_ERROR) {\n    r = mailimf_comma_parse(message, length, &cur_token);\n    if (r == MAILIMF_ERROR_PARSE) {\n      // ignore parse error.\n    }\n    else if (r != MAILIMF_NO_ERROR) {\n      return r;\n    }\n  }\n  else if (r != MAILIMF_ERROR_PARSE)\n    return r;\n\n  day = 0;\n  month = 0;\n  year = 0;\n  r = mailimf_date_parse(message, length, &cur_token, &day, &month, &year);\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_broken_date_parse(message, length, &cur_token, &day, &month, &year);\n  }\n  else if (r != MAILIMF_NO_ERROR) {\n    return r;\n  }\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n  \n  hour = 0;\n  min = 0;\n  sec = 0;\n  zone = 0;\n  r = mailimf_time_parse(message, length, &cur_token,\n\t\t\t &hour, &min, &sec, &zone);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  date_time = mailimf_date_time_new(day, month, year, hour, min, sec, zone);\n  if (date_time == NULL)\n    return MAILIMF_ERROR_MEMORY;\n\n  * indx = cur_token;\n  * result = date_time;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nday-of-week     =       ([FWS] day-name) / obs-day-of-week\n*/\n\nstatic int mailimf_day_of_week_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx, int * result)\n{\n  size_t cur_token;\n  int day_of_week;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_day_name_parse(message, length, &cur_token, &day_of_week);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n  * result = day_of_week;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nday-name        =       \"Mon\" / \"Tue\" / \"Wed\" / \"Thu\" /\n                        \"Fri\" / \"Sat\" / \"Sun\"\n*/\n\nstruct mailimf_token_value {\n  int value;\n  char * str;\n};\n\nstatic struct mailimf_token_value day_names[] = {\n  {1, \"Mon\"},\n  {2, \"Tue\"},\n  {3, \"Wed\"},\n  {4, \"Thu\"},\n  {5, \"Fri\"},\n  {6, \"Sat\"},\n  {7, \"Sun\"},\n};\n\nenum {\n  DAY_NAME_START,\n  DAY_NAME_T,\n  DAY_NAME_S\n};\n\nstatic int guess_day_name(const char * message, size_t length, size_t indx)\n{\n  int state;\n\n  state = DAY_NAME_START;\n\n  while (1) {\n\n    if (indx >= length)\n      return -1;\n\n    switch(state) {\n    case DAY_NAME_START:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'M': /* Mon */\n\treturn 1;\n\tbreak;\n      case 'T': /* Tue Thu */\n\tstate = DAY_NAME_T;\n\tbreak;\n      case 'W': /* Wed */\n\treturn 3;\n      case 'F':\n\treturn 5;\n      case 'S': /* Sat Sun */\n\tstate = DAY_NAME_S;\n\tbreak;\n      default:\n\treturn -1;\n      }\n      break;\n    case DAY_NAME_T:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'U':\n\treturn 2;\n      case 'H':\n\treturn 4;\n      default:\n\treturn -1;\n      }\n      break;\n    case DAY_NAME_S:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'A':\n\treturn 6;\n      case 'U':\n\treturn 7;\n      default:\n\treturn -1;\n      }\n      break;\n    }\n\n    indx ++;\n  }\n}\n\nstatic int mailimf_day_name_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, int * result)\n{\n  size_t cur_token;\n  int day_of_week;\n  int guessed_day;\n  int r;\n\n  cur_token = * indx;\n\n  guessed_day = guess_day_name(message, length, cur_token);\n  if (guessed_day == -1)\n    return MAILIMF_ERROR_PARSE;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token,\n\t\t\t\t\t   day_names[guessed_day - 1].str);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  day_of_week = guessed_day;\n\n  * result = day_of_week;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\ndate            =       day month year\n*/\n\nstatic int mailimf_date_parse(const char * message, size_t length,\n\t\t\t      size_t * indx,\n\t\t\t      int * pday, int * pmonth, int * pyear)\n{\n  size_t cur_token;\n  int day;\n  int month;\n  int year;\n  int r;\n\n  cur_token = * indx;\n\n  day = 1;\n  r = mailimf_day_parse(message, length, &cur_token, &day);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  month = 1;\n  r = mailimf_month_parse(message, length, &cur_token, &month);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  year = 2001;\n  r = mailimf_year_parse(message, length, &cur_token, &year);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * pday = day;\n  * pmonth = month;\n  * pyear = year;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\nstatic int mailimf_broken_date_parse(const char * message, size_t length,\n                                     size_t * indx,\n                                     int * pday, int * pmonth, int * pyear)\n{\n  size_t cur_token;\n  int day;\n  int month;\n  int year;\n  int r;\n\n  cur_token = * indx;\n\n  month = 1;\n  r = mailimf_month_parse(message, length, &cur_token, &month);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  day = 1;\n  r = mailimf_day_parse(message, length, &cur_token, &day);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  year = 2001;\n  r = mailimf_year_parse(message, length, &cur_token, &year);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * pday = day;\n  * pmonth = month;\n  * pyear = year;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nyear            =       4*DIGIT / obs-year\n*/\n\nstatic int mailimf_year_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, int * result)\n{\n  uint32_t number;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_number_parse(message, length, &cur_token, &number);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n  * result = number;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nmonth           =       (FWS month-name FWS) / obs-month\n*/\n\nstatic int mailimf_month_parse(const char * message, size_t length,\n\t\t\t       size_t * indx, int * result)\n{\n  size_t cur_token;\n  int month;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_month_name_parse(message, length, &cur_token, &month);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = month;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nmonth-name      =       \"Jan\" / \"Feb\" / \"Mar\" / \"Apr\" /\n                        \"May\" / \"Jun\" / \"Jul\" / \"Aug\" /\n                        \"Sep\" / \"Oct\" / \"Nov\" / \"Dec\"\n*/\n\nstatic struct mailimf_token_value month_names[] = {\n  {1, \"Jan\"},\n  {2, \"Feb\"},\n  {3, \"Mar\"},\n  {4, \"Apr\"},\n  {5, \"May\"},\n  {6, \"Jun\"},\n  {7, \"Jul\"},\n  {8, \"Aug\"},\n  {9, \"Sep\"},\n  {10, \"Oct\"},\n  {11, \"Nov\"},\n  {12, \"Dec\"},\n};\n\nenum {\n  MONTH_START,\n  MONTH_J,\n  MONTH_JU,\n  MONTH_M,\n  MONTH_MA,\n  MONTH_A\n};\n\nstatic int guess_month(const char * message, size_t length, size_t indx)\n{\n  int state;\n\n  state = MONTH_START;\n\n  while (1) {\n\n    if (indx >= length)\n      return -1;\n\n    switch(state) {\n    case MONTH_START:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'J': /* Jan Jun Jul */\n\tstate = MONTH_J;\n\tbreak;\n      case 'F': /* Feb */\n\treturn 2;\n      case 'M': /* Mar May */\n\tstate = MONTH_M;\n\tbreak;\n      case 'A': /* Apr Aug */\n\tstate = MONTH_A;\n\tbreak;\n      case 'S': /* Sep */\n\treturn 9;\n      case 'O': /* Oct */\n\treturn 10;\n      case 'N': /* Nov */\n\treturn 11;\n      case 'D': /* Dec */\n\treturn 12;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_J:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'A':\n\treturn 1;\n      case 'U':\n\tstate = MONTH_JU;\n\tbreak;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_JU:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'N':\n\treturn 6;\n      case 'L':\n\treturn 7;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_M:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'A':\n\tstate = MONTH_MA;\n\tbreak;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_MA:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'Y':\n\treturn 5;\n      case 'R':\n\treturn 3;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_A:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'P':\n\treturn 4;\n      case 'U':\n\treturn 8;\n      default:\n\treturn -1;\n      }\n      break;\n    }\n\n    indx ++;\n  }\n}\n\nstatic int mailimf_month_name_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, int * result)\n{\n  size_t cur_token;\n  int month;\n  int guessed_month;\n  int r;\n\n  cur_token = * indx;\n\n  guessed_month = guess_month(message, length, cur_token);\n  if (guessed_month == -1)\n    return MAILIMF_ERROR_PARSE;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token,\n\t\t\t\t\t   month_names[guessed_month - 1].str);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  month = guessed_month;\n\n  * result = month;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nday             =       ([FWS] 1*2DIGIT) / obs-day\n*/\n\nstatic int mailimf_day_parse(const char * message, size_t length,\n\t\t\t     size_t * indx, int * result)\n{\n  size_t cur_token;\n  uint32_t day;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_number_parse(message, length, &cur_token, &day);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = day;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\ntime            =       time-of-day FWS zone\n*/\n\nstatic int mailimf_time_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, \n\t\t\t      int * phour, int * pmin,\n\t\t\t      int * psec,\n\t\t\t      int * pzone)\n{\n  size_t cur_token;\n  int hour;\n  int min;\n  int sec;\n  int zone;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_time_of_day_parse(message, length, &cur_token,\n\t\t\t\t&hour, &min, &sec);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_zone_parse(message, length, &cur_token, &zone);\n  if (r == MAILIMF_NO_ERROR) {\n    /* do nothing */\n  }\n  else if (r == MAILIMF_ERROR_PARSE) {\n    zone = 0;\n  }\n  else {\n    return r;\n  }\n\n  * phour = hour;\n  * pmin = min;\n  * psec = sec;\n  * pzone = zone;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\ntime-of-day     =       hour \":\" minute [ \":\" second ]\n*/\n\nstatic int mailimf_time_of_day_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx,\n\t\t\t\t     int * phour, int * pmin,\n\t\t\t\t     int * psec)\n{\n  int hour;\n  int min;\n  int sec;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_hour_parse(message, length, &cur_token, &hour);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_minute_parse(message, length, &cur_token, &min);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r == MAILIMF_NO_ERROR) {\n    r = mailimf_second_parse(message, length, &cur_token, &sec);\n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n  else if (r == MAILIMF_ERROR_PARSE)\n    sec = 0;\n  else\n    return r;\n\n  * phour = hour;\n  * pmin = min;\n  * psec = sec;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nhour            =       2DIGIT / obs-hour\n*/\n\nstatic int mailimf_hour_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, int * result)\n{\n  uint32_t hour;\n  int r;\n\n  r = mailimf_number_parse(message, length, indx, &hour);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = hour;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nminute          =       2DIGIT / obs-minute\n*/\n\nstatic int mailimf_minute_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, int * result)\n{\n  uint32_t minute;\n  int r;\n\n  r = mailimf_number_parse(message, length, indx, &minute);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = minute;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nsecond          =       2DIGIT / obs-second\n*/\n\nstatic int mailimf_second_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, int * result)\n{\n  uint32_t second;\n  int r;\n\n  r = mailimf_number_parse(message, length, indx, &second);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = second;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nzone            =       (( \"+\" / \"-\" ) 4DIGIT) / obs-zone\n*/\n\n/*\nobs-zone        =       \"UT\" / \"GMT\" /          ; Universal Time\n                                                ; North American UT\n                                                ; offsets\n                        \"EST\" / \"EDT\" /         ; Eastern:  - 5/ - 4\n                        \"CST\" / \"CDT\" /         ; Central:  - 6/ - 5\n                        \"MST\" / \"MDT\" /         ; Mountain: - 7/ - 6\n                        \"PST\" / \"PDT\" /         ; Pacific:  - 8/ - 7\n\n                        %d65-73 /               ; Military zones - \"A\"\n                        %d75-90 /               ; through \"I\" and \"K\"\n                        %d97-105 /              ; through \"Z\", both\n                        %d107-122               ; upper and lower case\n*/\n\nenum {\n  STATE_ZONE_1 = 0,\n  STATE_ZONE_2 = 1,\n  STATE_ZONE_3 = 2,\n  STATE_ZONE_OK  = 3,\n  STATE_ZONE_ERR = 4,\n  STATE_ZONE_CONT = 5\n};\n\nstatic int mailimf_zone_parse(const char * message, size_t length,\n                              size_t * indx, int * result)\n{\n  int zone;\n  int sign;\n  size_t cur_token;\n  int r;\n  uint32_t value;\n\n  cur_token = * indx;\n\n  if (cur_token + 1 < length) {\n    if ((message[cur_token] == 'U') && (message[cur_token + 1] == 'T')) {\n      * result = TRUE;\n      * indx = cur_token + 2;\n\n      return MAILIMF_NO_ERROR;\n    }\n  }\n\n  zone = 0;\n  if (cur_token + 2 < length) {\n    int state;\n\n    state = STATE_ZONE_1;\n\n    while (state <= 2) {\n      switch (state) {\n        case STATE_ZONE_1:\n          switch (message[cur_token]) {\n            case 'G':\n              if (message[cur_token + 1] == 'M' && message[cur_token + 2] == 'T') {\n                if ((cur_token + 3 < length) && ((message[cur_token + 3] == '+') || (message[cur_token + 3] == '-'))) {\n                  cur_token += 3;\n                  state = STATE_ZONE_CONT;\n                }\n                else {\n                  zone = 0;\n                  state = STATE_ZONE_OK;\n                }\n              }\n              else {\n                state = STATE_ZONE_ERR;\n              }\n              break;\n            case 'E':\n              zone = -5;\n              state = STATE_ZONE_2;\n              break;\n            case 'C':\n              zone = -6;\n              state = STATE_ZONE_2;\n              break;\n            case 'M':\n              zone = -7;\n              state = STATE_ZONE_2;\n              break;\n            case 'P':\n              zone = -8;\n              state = STATE_ZONE_2;\n              break;\n            default:\n              state = STATE_ZONE_CONT;\n              break;\n          }\n          break;\n        case STATE_ZONE_2:\n          switch (message[cur_token + 1]) {\n            case 'S':\n              state = STATE_ZONE_3;\n              break;\n            case 'D':\n              zone ++;\n              state = STATE_ZONE_3;\n              break;\n            default:\n              state = STATE_ZONE_ERR;\n              break;\n          }\n          break;\n        case STATE_ZONE_3:\n          if (message[cur_token + 2] == 'T') {\n            zone *= 100;\n            state = STATE_ZONE_OK;\n          }\n          else\n            state = STATE_ZONE_ERR;\n          break;\n      }\n    }\n\n    switch (state) {\n      case STATE_ZONE_OK:\n        * result = zone;\n        * indx = cur_token + 3;\n        return MAILIMF_NO_ERROR;\n\n      case STATE_ZONE_ERR:\n        return MAILIMF_ERROR_PARSE;\n    }\n  }\n\n  sign = 1;\n  r = mailimf_plus_parse(message, length, &cur_token);\n  if (r == MAILIMF_NO_ERROR)\n    sign = 1;\n\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_minus_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      sign = -1;\n  }\n\n  if (r == MAILIMF_NO_ERROR) {\n    /* do nothing */\n  }\n  else if (r == MAILIMF_ERROR_PARSE)\n    sign = 1;\n  else\n    return r;\n\n  r = mailimf_number_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  zone = value * sign;\n\n  * indx = cur_token;\n  * result = zone;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\naddress         =       mailbox / group\n*/\n\nLIBETPAN_EXPORT\nint mailimf_address_parse(const char * message, size_t length,\n\t\t\t  size_t * indx,\n\t\t\t  struct mailimf_address ** result)\n{\n  int type;\n  size_t cur_token;\n  struct mailimf_mailbox * mailbox;\n  struct mailimf_group * group;\n  struct mailimf_address * address;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  mailbox = NULL;\n  group = NULL;\n\n  type = MAILIMF_ADDRESS_ERROR; /* XXX - removes a gcc warning */\n  r = mailimf_group_parse(message, length, &cur_token, &group);\n  if (r == MAILIMF_NO_ERROR)\n    type = MAILIMF_ADDRESS_GROUP;\n  \n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_mailbox_parse(message, length, &cur_token, &mailbox);\n    if (r == MAILIMF_NO_ERROR)\n      type = MAILIMF_ADDRESS_MAILBOX;\n  }\n\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  address = mailimf_address_new(type, mailbox, group);\n  if (address == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = address;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n  \n free:\n  if (mailbox != NULL)\n    mailimf_mailbox_free(mailbox);\n  if (group != NULL)\n    mailimf_group_free(group);\n err:\n  return res;\n}\n\n\n/*\nmailbox         =       name-addr / addr-spec\n*/\n\n\nLIBETPAN_EXPORT\nint mailimf_mailbox_parse(const char * message, size_t length,\n\t\t\t  size_t * indx,\n\t\t\t  struct mailimf_mailbox ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox * mailbox;\n  char * addr_spec;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  display_name = NULL;\n  addr_spec = NULL;\n\n  r = mailimf_name_addr_parse(message, length, &cur_token,\n\t\t\t      &display_name, &addr_spec);\n  if (r == MAILIMF_ERROR_PARSE)\n    r = mailimf_addr_spec_parse(message, length, &cur_token, &addr_spec);\n\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  mailbox = mailimf_mailbox_new(display_name, addr_spec);\n  if (mailbox == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = mailbox;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (display_name != NULL)\n    mailimf_display_name_free(display_name);\n  if (addr_spec != NULL)\n    mailimf_addr_spec_free(addr_spec);\n err:\n  return res;\n}\n\n/*\nname-addr       =       [display-name] angle-addr\n*/\n\nstatic int mailimf_name_addr_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx,\n\t\t\t\t   char ** pdisplay_name,\n\t\t\t\t   char ** pangle_addr)\n{\n  char * display_name;\n  char * angle_addr;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  display_name = NULL;\n  angle_addr = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_angle_addr_parse(message, length, &cur_token, &angle_addr);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  * pdisplay_name = display_name;\n  * pangle_addr = angle_addr;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_display_name:\n  if (display_name != NULL)\n    mailimf_display_name_free(display_name);\n err:\n  return res;\n}\n\n/*\nangle-addr      =       [CFWS] \"<\" addr-spec \">\" [CFWS] / obs-angle-addr\n*/\n\nstatic int mailimf_angle_addr_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, char ** result)\n{\n  size_t cur_token;\n  char * addr_spec;\n  int r;\n  \n  cur_token = * indx;\n  \n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n  \n  r = mailimf_lower_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n  \n  r = mailimf_addr_spec_parse(message, length, &cur_token, &addr_spec);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n  \n  r = mailimf_greater_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    free(addr_spec);\n    return r;\n  }\n\n  * result = addr_spec;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\ngroup           =       display-name \":\" [mailbox-list / CFWS] \";\"\n                        [CFWS]\n*/\n\nstatic int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n  struct mailimf_group * group;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  mailbox_list = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto free_display_name;\n    }\n    break;\n  default:\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n\n  * indx = cur_token;\n  * result = group;\n\n  return MAILIMF_NO_ERROR;\n\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}\n\n/*\ndisplay-name    =       phrase\n*/\n\nstatic int mailimf_display_name_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx, char ** result)\n{\n  return mailimf_phrase_parse(message, length, indx, result);\n}\n\n/*\nmailbox-list    =       (mailbox *(\",\" mailbox)) / obs-mbox-list\n*/\n\nLIBETPAN_EXPORT\nint\nmailimf_mailbox_list_parse(const char * message, size_t length,\n\t\t\t   size_t * indx,\n\t\t\t   struct mailimf_mailbox_list ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_mailbox_list * mailbox_list;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_struct_list_parse(message, length, \n\t\t\t\t&cur_token, &list, ',',\n\t\t\t\t(mailimf_struct_parser *)\n\t\t\t\tmailimf_mailbox_parse,\n\t\t\t\t(mailimf_struct_destructor *)\n\t\t\t\tmailimf_mailbox_free);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  mailbox_list = mailimf_mailbox_list_new(list);\n  if (mailbox_list == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = mailbox_list;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(list, (clist_func) mailimf_mailbox_free, NULL);\n  clist_free(list);\n err:\n  return res;\n}\t\t\t\t   \n\n/*\naddress-list    =       (address *(\",\" address)) / obs-addr-list\n*/\n\n\nLIBETPAN_EXPORT\nint\nmailimf_address_list_parse(const char * message, size_t length,\n\t\t\t   size_t * indx,\n\t\t\t   struct mailimf_address_list ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_address_list * address_list;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_struct_list_parse(message, length,\n\t\t\t\t&cur_token, &list, ',',\n\t\t\t\t(mailimf_struct_parser *)\n\t\t\t\tmailimf_address_parse,\n\t\t\t\t(mailimf_struct_destructor *)\n\t\t\t\tmailimf_address_free);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  address_list = mailimf_address_list_new(list);\n  if (address_list == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = address_list;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(list, (clist_func) mailimf_address_free, NULL);\n  clist_free(list);\n err:\n  return res;\n}\t\t\t\t   \n\n/*\naddr-spec       =       local-part \"@\" domain\n*/\n\n\nstatic int mailimf_addr_spec_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx,\n\t\t\t\t   char ** result)\n{\n  size_t cur_token;\n#if 0\n  char * local_part;\n  char * domain;\n#endif\n  char * addr_spec;\n  int r;\n  int res;\n  size_t begin;\n  size_t end;\n  int final;\n  size_t count;\n  const char * src;\n  char * dest;\n  size_t i;\n  \n  cur_token = * indx;\n  \n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  end = cur_token;\n  if (end >= length) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  begin = cur_token;\n\n  final = FALSE;\n  while (1) {\n    switch (message[end]) {\n    case '>':\n    case ',':\n    case '\\r':\n    case '\\n':\n    case '(':\n    case ')':\n    case ':':\n    case ';':\n      final = TRUE;\n      break;\n    }\n\n    if (final)\n      break;\n\n    end ++;\n    if (end >= length)\n      break;\n  }\n\n  if (end == begin) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n  \n  addr_spec = malloc(end - cur_token + 1);\n  if (addr_spec == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n  \n  count = end - cur_token;\n  src = message + cur_token;\n  dest = addr_spec;\n  for(i = 0 ; i < count ; i ++) {\n    if ((* src != ' ') && (* src != '\\t')) {\n      * dest = * src;\n      dest ++;\n    }\n    src ++;\n  }\n  * dest = '\\0';\n  \n#if 0\n  strncpy(addr_spec, message + cur_token, end - cur_token);\n  addr_spec[end - cur_token] = '\\0';\n#endif\n\n  cur_token = end;\n\n#if 0\n  r = mailimf_local_part_parse(message, length, &cur_token, &local_part);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_at_sign_parse(message, length, &cur_token);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    r = mailimf_domain_parse(message, length, &cur_token, &domain);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto free_local_part;\n    }\n    break;\n\n  case MAILIMF_ERROR_PARSE:\n    domain = NULL;\n    break;\n\n  default:\n    res = r;\n    goto free_local_part;\n  }\n\n  if (domain) {\n    addr_spec = malloc(strlen(local_part) + strlen(domain) + 2);\n    if (addr_spec == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_domain;\n    }\n    \n    strcpy(addr_spec, local_part);\n    strcat(addr_spec, \"@\");\n    strcat(addr_spec, domain);\n\n    mailimf_domain_free(domain);\n    mailimf_local_part_free(local_part);\n  }\n  else {\n    addr_spec = local_part;\n  }\n#endif\n\n  * result = addr_spec;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n#if 0\n free_domain:\n  mailimf_domain_free(domain);\n free_local_part:\n  mailimf_local_part_free(local_part);\n#endif\n err:\n  return res;\n}\n\n\n/*\n for msg id\n addr-spec       =       local-part \"@\" domain\n */\n\nstatic int mailimf_addr_spec_msg_id_parse(const char * message, size_t length,\n                                          size_t * indx,\n                                          char ** result)\n{\n    size_t cur_token;\n    char * addr_spec;\n    int r;\n    int res;\n    size_t begin;\n    size_t end;\n    int final;\n    size_t count;\n    const char * src;\n    char * dest;\n    size_t i;\n    \n    cur_token = * indx;\n    \n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n        res = r;\n        goto err;\n    }\n    \n    end = cur_token;\n    if (end >= length) {\n        res = MAILIMF_ERROR_PARSE;\n        goto err;\n    }\n    \n    begin = cur_token;\n    \n    final = FALSE;\n    while (1) {\n        switch (message[end]) {\n            case '>':\n            case '\\r':\n            case '\\n':\n                final = TRUE;\n                break;\n        }\n        \n        if (final)\n            break;\n        \n        end ++;\n        if (end >= length)\n            break;\n    }\n    \n    if (end == begin) {\n        res = MAILIMF_ERROR_PARSE;\n        goto err;\n    }\n    \n    addr_spec = malloc(end - cur_token + 1);\n    if (addr_spec == NULL) {\n        res = MAILIMF_ERROR_MEMORY;\n        goto err;\n    }\n    \n    count = end - cur_token;\n    src = message + cur_token;\n    dest = addr_spec;\n    for(i = 0 ; i < count ; i ++) {\n        if ((* src != ' ') && (* src != '\\t')) {\n            * dest = * src;\n            dest ++;\n        }\n        src ++;\n    }\n    * dest = '\\0';\n    \n    cur_token = end;\n    \n    * result = addr_spec;\n    * indx = cur_token;\n    \n    return MAILIMF_NO_ERROR;\n    \nerr:\n    return res;\n}\n\n/*\nlocal-part      =       dot-atom / quoted-string / obs-local-part\n*/\n\n#if 0\nstatic int mailimf_local_part_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx,\n\t\t\t\t    char ** result)\n{\n  int r;\n\n  r = mailimf_dot_atom_parse(message, length, indx, result);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    return r;\n  case MAILIMF_ERROR_PARSE:\n    break;\n  default:\n    return r;\n  }\n\n  r = mailimf_quoted_string_parse(message, length, indx, result);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\ndomain          =       dot-atom / domain-literal / obs-domain\n*/\n\n#if 0\nstatic int mailimf_domain_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx,\n\t\t\t\tchar ** result)\n{\n  int r;\n\n  r = mailimf_dot_atom_parse(message, length, indx, result);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    return r;\n  case MAILIMF_ERROR_PARSE:\n    break;\n  default:\n    return r;\n  }\n\n  r = mailimf_domain_literal_parse(message, length, indx, result);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\n[FWS] dcontent\n*/\n\n#if 0\nstatic int\nmailimf_domain_literal_fws_dcontent_parse(const char * message, size_t length,\n\t\t\t\t\t  size_t * indx)\n{\n  size_t cur_token;\n  char ch;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n  \n  r = mailimf_dcontent_parse(message, length, &cur_token, &ch);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\ndomain-literal  =       [CFWS] \"[\" *([FWS] dcontent) [FWS] \"]\" [CFWS]\n*/\n\n#if 0\nstatic int mailimf_domain_literal_parse(const char * message, size_t length,\n\t\t\t\t\tsize_t * indx, char ** result)\n{\n  size_t cur_token;\n  int len;\n  int begin;\n  char * domain_literal;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  begin = cur_token;\n  r = mailimf_obracket_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  while (1) {\n    r = mailimf_domain_literal_fws_dcontent_parse(message, length,\n\t\t\t\t\t\t  &cur_token);\n    if (r == MAILIMF_NO_ERROR) {\n      /* do nothing */\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else\n      return r;\n  }\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_cbracket_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  len = cur_token - begin;\n\n  domain_literal = malloc(len + 1);\n  if (domain_literal == NULL)\n    return MAILIMF_ERROR_MEMORY;\n  strncpy(domain_literal, message + begin, len);\n  domain_literal[len] = '\\0';\n\n  * result = domain_literal;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\ndcontent        =       dtext / quoted-pair\n*/\n\n#if 0\nstatic int mailimf_dcontent_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, char * result)\n{\n  size_t cur_token;\n  char ch;\n  int r;\n  \n  cur_token = * indx;\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_dtext(message[cur_token])) {\n    ch = message[cur_token];\n    cur_token ++;\n  }\n  else {\n    r = mailimf_quoted_pair_parse(message, length, &cur_token, &ch);\n    \n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n    \n  * indx = cur_token;\n  * result = ch;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n\n/*\ndtext           =       NO-WS-CTL /     ; Non white space controls\n\n                        %d33-90 /       ; The rest of the US-ASCII\n                        %d94-126        ;  characters not including \"[\",\n                                        ;  \"]\", or \"\\\"\n*/\n\nstatic inline int is_dtext(char ch)\n{\n  unsigned char uch = (unsigned char) ch;\n\n  if (is_no_ws_ctl(ch))\n    return TRUE;\n\n  if (uch < 33)\n    return FALSE;\n\n  if ((uch >= 91) && (uch <= 93))\n    return FALSE;\n\n  if (uch == 127)\n    return FALSE;\n\n  return TRUE;\n}\n\n/*\nmessage         =       (fields / obs-fields)\n                        [CRLF body]\n*/\n\nLIBETPAN_EXPORT\nint mailimf_message_parse(const char * message, size_t length,\n\t\t\t  size_t * indx,\n\t\t\t  struct mailimf_message ** result)\n{\n  struct mailimf_fields * fields;\n  struct mailimf_body * body;\n  struct mailimf_message * msg;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_fields_parse(message, length, &cur_token, &fields);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_crlf_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_body_parse(message, length, &cur_token, &body);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_fields;\n  }\n\n  msg = mailimf_message_new(fields, body);\n  if (msg == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_body;\n  }\n\n  * indx = cur_token;\n  * result = msg;\n\n  return MAILIMF_NO_ERROR;\n\n free_body:\n  mailimf_body_free(body);\n free_fields:\n  mailimf_fields_free(fields);\n err:\n  return res;\n}\n\n/*\nbody            =       *(*998text CRLF) *998text\n*/\n\nLIBETPAN_EXPORT\nint mailimf_body_parse(const char * message, size_t length,\n\t\t       size_t * indx,\n\t\t       struct mailimf_body ** result)\n{\n  size_t cur_token;\n  struct mailimf_body * body;\n\n  cur_token = * indx;\n\n  body = mailimf_body_new(message + cur_token, length - cur_token);\n  if (body == NULL)\n    return MAILIMF_ERROR_MEMORY;\n\n  cur_token = length;\n\n  * result = body;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nCHANGE TO THE RFC 2822\n\noriginal :\n\nfields          =       *(trace\n                          *(resent-date /\n                           resent-from /\n                           resent-sender /\n                           resent-to /\n                           resent-cc /\n                           resent-bcc /\n                           resent-msg-id))\n                        *(orig-date /\n                        from /\n                        sender /\n                        reply-to /\n                        to /\n                        cc /\n                        bcc /\n                        message-id /\n                        in-reply-to /\n                        references /\n                        subject /\n                        comments /\n                        keywords /\n                        optional-field)\n\nINTO THE FOLLOWING :\n*/\n\n/*\nresent-fields-list =      *(resent-date /\n                           resent-from /\n                           resent-sender /\n                           resent-to /\n                           resent-cc /\n                           resent-bcc /\n                           resent-msg-id))\n*/\n\n#if 0\nenum {\n  RESENT_HEADER_START,\n};\n\nstatic int guess_resent_header_type(char * message,\n\t\t\t\t    size_t length, size_t indx)\n{\n  int r;\n\n  r = mailimf_token_case_insensitive_parse(message,\n\t\t\t\t\t   length, &indx, \"Resent-\");\n  if (r != MAILIMF_NO_ERROR)\n    return MAILIMF_RESENT_FIELD_NONE;\n  \n  if (indx >= length)\n    return MAILIMF_RESENT_FIELD_NONE;\n\n  switch(toupper(message[indx])) {\n  case 'D':\n    return MAILIMF_RESENT_FIELD_DATE;\n  case 'F':\n    return MAILIMF_RESENT_FIELD_FROM;\n  case 'S':\n    return MAILIMF_RESENT_FIELD_SENDER;\n  case 'T':\n    return MAILIMF_RESENT_FIELD_TO;\n  case 'C':\n    return MAILIMF_RESENT_FIELD_CC;\n  case 'B':\n    return MAILIMF_RESENT_FIELD_BCC;\n  case 'M':\n    return MAILIMF_RESENT_FIELD_MSG_ID;\n  default:\n    return MAILIMF_RESENT_FIELD_NONE;\n  }\n}\n#endif\n\n#if 0\nstatic int\nmailimf_resent_field_parse(const char * message, size_t length,\n\t\t\t   size_t * indx,\n\t\t\t   struct mailimf_resent_field ** result)\n{\n  struct mailimf_orig_date * resent_date;\n  struct mailimf_from * resent_from;\n  struct mailimf_sender * resent_sender;\n  struct mailimf_to* resent_to;\n  struct mailimf_cc * resent_cc;\n  struct mailimf_bcc * resent_bcc;\n  struct mailimf_message_id * resent_msg_id;\n  size_t cur_token;\n  int type;\n  struct mailimf_resent_field * resent_field;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  resent_date = NULL;\n  resent_from = NULL;\n  resent_sender = NULL;\n  resent_to = NULL;\n  resent_cc = NULL;\n  resent_bcc = NULL;\n  resent_msg_id = NULL;\n\n  type = guess_resent_header_type(message, length, cur_token);\n\n  switch(type) {\n  case MAILIMF_RESENT_FIELD_DATE:\n    r = mailimf_resent_date_parse(message, length, &cur_token,\n\t\t\t\t  &resent_date);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_FROM:\n    r = mailimf_resent_from_parse(message, length, &cur_token,\n\t\t\t\t  &resent_from);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_SENDER:\n    r = mailimf_resent_sender_parse(message, length, &cur_token,\n\t\t\t\t    &resent_sender);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_TO:\n    r = mailimf_resent_to_parse(message, length, &cur_token,\n\t\t\t\t&resent_to);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_CC:\n    r= mailimf_resent_cc_parse(message, length, &cur_token,\n\t\t\t       &resent_cc);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_BCC:\n    r = mailimf_resent_bcc_parse(message, length, &cur_token,\n\t\t\t\t &resent_bcc);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_MSG_ID:\n    r = mailimf_resent_msg_id_parse(message, length, &cur_token,\n\t\t\t\t    &resent_msg_id);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  default:\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  resent_field = mailimf_resent_field_new(type, resent_date,\n\t\t\t\t\t  resent_from, resent_sender,\n\t\t\t\t\t  resent_to, resent_cc,\n\t\t\t\t\t  resent_bcc, resent_msg_id);\n  if (resent_field == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_resent;\n  }\n\n  * result = resent_field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_resent:\n  if (resent_msg_id != NULL)\n    mailimf_message_id_free(resent_msg_id);\n  if (resent_bcc != NULL)\n    mailimf_bcc_free(resent_bcc);\n  if (resent_cc != NULL)\n    mailimf_cc_free(resent_cc);\n  if (resent_to != NULL)\n    mailimf_to_free(resent_to);\n  if (resent_sender != NULL)\n    mailimf_sender_free(resent_sender);\n  if (resent_from != NULL)\n    mailimf_from_free(resent_from);\n  if (resent_date != NULL)\n    mailimf_orig_date_free(resent_date);\n err:\n  return res;\n}\n#endif\n\n#if 0\nstatic int\nmailimf_resent_fields_list_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx,\n\t\t\t\t struct mailimf_resent_fields_list ** result)\n{\n  clist * list;\n  size_t cur_token;\n  struct mailimf_resent_fields_list * resent_fields_list;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  list = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token, &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_resent_field_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_resent_field_free);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  resent_fields_list = mailimf_resent_fields_list_new(list);\n  if (resent_fields_list == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = resent_fields_list;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(list, (clist_func) mailimf_resent_field_free, NULL);\n  clist_free(list);\n err:\n  return res;\n}\n#endif\n\n/*\n ([trace]\n  [resent-fields-list])\n*/\n\n#if 0\nstatic int\nmailimf_trace_resent_fields_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_trace_resent_fields ** result)\n{\n  size_t cur_token;\n  struct mailimf_return * return_path;\n  struct mailimf_resent_fields_list * resent_fields;\n  struct mailimf_trace_resent_fields * trace_resent_fields;\n  int res;\n  int r;\n\n  cur_token = * indx;\n\n  return_path = NULL;\n  resent_fields = NULL;\n\n  r = mailimf_return_parse(message, length, &cur_token,\n\t\t\t   &return_path);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_resent_fields_list_parse(message, length, &cur_token,\n\t\t\t\t       &resent_fields);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  if ((return_path == NULL) && (resent_fields == NULL)) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  trace_resent_fields = mailimf_trace_resent_fields_new(return_path,\n\t\t\t\t\t\t\tresent_fields);\n  if (trace_resent_fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_resent_fields;\n  }\n\n  * result = trace_resent_fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_resent_fields:\n  if (resent_fields != NULL)\n    mailimf_resent_fields_list_free(resent_fields);\n  if (return_path != NULL)\n    mailimf_return_free(return_path);\n err:\n  return res;\n}\n#endif\n\n/*\ndelivering-info =       *([trace]\n                          [resent-fields-list])\n*/\n\n#if 0\nstatic int\nmailimf_delivering_info_parse(const char * message, size_t length,\n\t\t\t      size_t * indx,\n\t\t\t      struct mailimf_delivering_info ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_delivering_info * delivering_info;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_trace_resent_fields_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_trace_resent_fields_free);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  delivering_info = mailimf_delivering_info_new(list);\n  if (delivering_info == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = delivering_info;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(list, (clist_func) mailimf_trace_resent_fields_free, NULL);\n  clist_free(list);\n err:\n  return res;\n}\n#endif\n\n/*\nfield           =       delivering-info /\n                        orig-date /\n                        from /\n                        sender /\n                        reply-to /\n                        to /\n                        cc /\n                        bcc /\n                        message-id /\n                        in-reply-to /\n                        references /\n                        subject /\n                        comments /\n                        keywords /\n                        optional-field\n*/\n\nenum {\n  HEADER_START,\n  HEADER_C,\n  HEADER_R,\n  HEADER_RE,\n  HEADER_S,\n  HEADER_RES\n};\n\nstatic int guess_header_type(const char * message, size_t length, size_t indx)\n{\n  int state;\n  int r;\n\n  state = HEADER_START;\n  \n  while (1) {\n\n    if (indx >= length)\n      return MAILIMF_FIELD_NONE;\n\n    switch(state) {\n    case HEADER_START:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'B':\n\treturn MAILIMF_FIELD_BCC;\n      case 'C':\n\tstate = HEADER_C;\n\tbreak;\n      case 'D':\n\treturn MAILIMF_FIELD_ORIG_DATE;\n      case 'F':\n\treturn MAILIMF_FIELD_FROM;\n      case 'I':\n\treturn MAILIMF_FIELD_IN_REPLY_TO;\n      case 'K':\n\treturn MAILIMF_FIELD_KEYWORDS;\n      case 'M':\n\treturn MAILIMF_FIELD_MESSAGE_ID;\n      case 'R':\n\tstate = HEADER_R;\n\tbreak;\n      case 'T':\n\treturn MAILIMF_FIELD_TO;\n\tbreak;\n      case 'S':\n\tstate = HEADER_S;\n\tbreak;\n      default:\n\treturn MAILIMF_FIELD_NONE;\n      }\n      break;\n    case HEADER_C:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'O':\n\treturn MAILIMF_FIELD_COMMENTS;\n      case 'C':\n\treturn MAILIMF_FIELD_CC;\n      default:\n\treturn MAILIMF_FIELD_NONE;\n      }\n      break;\n    case HEADER_R:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'E':\n\tstate = HEADER_RE;\n\tbreak;\n      default:\n\treturn MAILIMF_FIELD_NONE;\n      }\n      break;\n    case HEADER_RE:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'F':\n\treturn MAILIMF_FIELD_REFERENCES;\n      case 'P':\n\treturn MAILIMF_FIELD_REPLY_TO;\n      case 'S':\n        state = HEADER_RES;\n        break;\n      case 'T':\n        return MAILIMF_FIELD_RETURN_PATH;\n      default:\n\treturn MAILIMF_FIELD_NONE;\n      }\n      break;\n    case HEADER_S:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'E':\n\treturn MAILIMF_FIELD_SENDER;\n      case 'U':\n\treturn MAILIMF_FIELD_SUBJECT;\n      default:\n\treturn MAILIMF_FIELD_NONE;\n      }\n      break;\n\n    case HEADER_RES:\n      r = mailimf_token_case_insensitive_parse(message,\n          length, &indx, \"ent-\");\n      if (r != MAILIMF_NO_ERROR)\n        return MAILIMF_FIELD_NONE;\n      \n      if (indx >= length)\n        return MAILIMF_FIELD_NONE;\n      \n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'D':\n        return MAILIMF_FIELD_RESENT_DATE;\n      case 'F':\n        return MAILIMF_FIELD_RESENT_FROM;\n      case 'S':\n        return MAILIMF_FIELD_RESENT_SENDER;\n      case 'T':\n        return MAILIMF_FIELD_RESENT_TO;\n      case 'C':\n        return MAILIMF_FIELD_RESENT_CC;\n      case 'B':\n        return MAILIMF_FIELD_RESENT_BCC;\n      case 'M':\n        return MAILIMF_FIELD_RESENT_MSG_ID;\n      default:\n        return MAILIMF_FIELD_NONE;\n      }\n      break;\n    }\n    indx ++;\n  }\n}\n\nstatic int mailimf_field_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_field ** result)\n{\n  size_t cur_token;\n  int type;\n  struct mailimf_return * return_path;\n  struct mailimf_orig_date * resent_date;\n  struct mailimf_from * resent_from;\n  struct mailimf_sender * resent_sender;\n  struct mailimf_to* resent_to;\n  struct mailimf_cc * resent_cc;\n  struct mailimf_bcc * resent_bcc;\n  struct mailimf_message_id * resent_msg_id;\n  struct mailimf_orig_date * orig_date;\n  struct mailimf_from * from;\n  struct mailimf_sender * sender;\n  struct mailimf_reply_to * reply_to;\n  struct mailimf_to * to;\n  struct mailimf_cc * cc;\n  struct mailimf_bcc * bcc;\n  struct mailimf_message_id * message_id;\n  struct mailimf_in_reply_to * in_reply_to;\n  struct mailimf_references * references;\n  struct mailimf_subject * subject;\n  struct mailimf_comments * comments;\n  struct mailimf_keywords * keywords;\n  struct mailimf_optional_field * optional_field;\n  struct mailimf_field * field;\n  int guessed_type;\n  int r;\n  int res;\n  \n  cur_token = * indx;\n\n  return_path = NULL;\n  resent_date = NULL;\n  resent_from = NULL;\n  resent_sender = NULL;\n  resent_to = NULL;\n  resent_cc = NULL;\n  resent_bcc = NULL;\n  resent_msg_id = NULL;\n  orig_date = NULL;\n  from = NULL;\n  sender = NULL;\n  reply_to = NULL;\n  to = NULL;\n  cc = NULL;\n  bcc = NULL;\n  message_id = NULL;\n  in_reply_to = NULL;\n  references = NULL;\n  subject = NULL;\n  comments = NULL;\n  keywords = NULL;\n  optional_field = NULL;\n\n  guessed_type = guess_header_type(message, length, cur_token);\n  type = MAILIMF_FIELD_NONE;\n\n  switch (guessed_type) {\n  case MAILIMF_FIELD_ORIG_DATE:\n    r = mailimf_orig_date_parse(message, length, &cur_token,\n\t\t\t\t&orig_date);\n    if (r == MAILIMF_NO_ERROR)\n      type = MAILIMF_FIELD_ORIG_DATE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_FROM:\n    r = mailimf_from_parse(message, length, &cur_token,\n\t\t\t   &from);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_SENDER:\n    r = mailimf_sender_parse(message, length, &cur_token,\n\t\t\t     &sender);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_REPLY_TO:\n    r = mailimf_reply_to_parse(message, length, &cur_token,\n\t\t\t       &reply_to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_TO:\n    r = mailimf_to_parse(message, length, &cur_token,\n\t\t\t &to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_CC:\n    r = mailimf_cc_parse(message, length, &cur_token,\n\t\t\t &cc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_BCC:\n    r = mailimf_bcc_parse(message, length, &cur_token,\n\t\t\t  &bcc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_MESSAGE_ID:\n    r = mailimf_message_id_parse(message, length, &cur_token,\n\t\t\t\t &message_id);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_IN_REPLY_TO:\n    r = mailimf_in_reply_to_parse(message, length, &cur_token,\n\t\t\t\t  &in_reply_to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_REFERENCES:\n    r = mailimf_references_parse(message, length, &cur_token,\n\t\t\t\t &references);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_SUBJECT:\n    r = mailimf_subject_parse(message, length, &cur_token,\n\t\t\t      &subject);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_COMMENTS:\n    r = mailimf_comments_parse(message, length, &cur_token,\n\t\t\t       &comments);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_KEYWORDS:\n    r = mailimf_keywords_parse(message, length, &cur_token,\n\t\t\t       &keywords);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RETURN_PATH:\n    r = mailimf_return_parse(message, length, &cur_token,\n        &return_path);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_DATE:\n    r = mailimf_resent_date_parse(message, length, &cur_token,\n\t\t\t\t  &resent_date);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_FROM:\n    r = mailimf_resent_from_parse(message, length, &cur_token,\n\t\t\t\t  &resent_from);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_SENDER:\n    r = mailimf_resent_sender_parse(message, length, &cur_token,\n\t\t\t\t    &resent_sender);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_TO:\n    r = mailimf_resent_to_parse(message, length, &cur_token,\n\t\t\t\t&resent_to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_CC:\n    r= mailimf_resent_cc_parse(message, length, &cur_token,\n\t\t\t       &resent_cc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_BCC:\n    r = mailimf_resent_bcc_parse(message, length, &cur_token,\n\t\t\t\t &resent_bcc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_MSG_ID:\n    r = mailimf_resent_msg_id_parse(message, length, &cur_token,\n\t\t\t\t    &resent_msg_id);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  }\n\n  if (type == MAILIMF_FIELD_NONE) {\n    r = mailimf_optional_field_parse(message, length, &cur_token,\n        &optional_field);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n\n    type = MAILIMF_FIELD_OPTIONAL_FIELD;\n  }\n\n  field = mailimf_field_new(type, return_path, resent_date,\n      resent_from, resent_sender, resent_to, resent_cc, resent_bcc,\n      resent_msg_id, orig_date, from, sender, reply_to, to,\n      cc, bcc, message_id, in_reply_to, references,\n      subject, comments, keywords, optional_field);\n  if (field == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_field;\n  }\n\n  * result = field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_field:\n  if (return_path != NULL)\n    mailimf_return_free(return_path);\n  if (resent_date != NULL)\n    mailimf_orig_date_free(resent_date);\n  if (resent_from != NULL)\n    mailimf_from_free(resent_from);\n  if (resent_sender != NULL)\n    mailimf_sender_free(resent_sender);\n  if (resent_to != NULL)\n    mailimf_to_free(resent_to);\n  if (resent_cc != NULL)\n    mailimf_cc_free(resent_cc);\n  if (resent_bcc != NULL)\n    mailimf_bcc_free(resent_bcc);\n  if (resent_msg_id != NULL)\n    mailimf_message_id_free(resent_msg_id);\n  if (orig_date != NULL)\n    mailimf_orig_date_free(orig_date);\n  if (from != NULL)\n    mailimf_from_free(from);\n  if (sender != NULL)\n    mailimf_sender_free(sender);\n  if (reply_to != NULL)\n    mailimf_reply_to_free(reply_to);\n  if (to != NULL)\n    mailimf_to_free(to);\n  if (cc != NULL)\n    mailimf_cc_free(cc);\n  if (bcc != NULL)\n    mailimf_bcc_free(bcc);\n  if (message_id != NULL)\n    mailimf_message_id_free(message_id);\n  if (in_reply_to != NULL)\n    mailimf_in_reply_to_free(in_reply_to);\n  if (references != NULL)\n    mailimf_references_free(references);\n  if (subject != NULL)\n    mailimf_subject_free(subject);\n  if (comments != NULL)\n    mailimf_comments_free(comments);\n  if (keywords != NULL)\n    mailimf_keywords_free(keywords);\n  if (optional_field != NULL)\n    mailimf_optional_field_free(optional_field);\n err:\n  return res;\n}\n\n\n/*\nfields          =       *(delivering-info /\n\t\t\torig-date /\n                        from /\n                        sender /\n                        reply-to /\n                        to /\n                        cc /\n                        bcc /\n                        message-id /\n                        in-reply-to /\n                        references /\n                        subject /\n                        comments /\n                        keywords /\n                        optional-field)\n*/\n\n#if 0\nint\nmailimf_unparsed_fields_parse(const char * message, size_t length,\n\t\t\t      size_t * indx,\n\t\t\t      struct mailimf_unparsed_fields ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_unparsed_fields * fields;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  list = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_optional_field_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_optional_field_free);\n  /*\n  if ((r = MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  */\n\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    /* do nothing */\n    break;\n\n  case MAILIMF_ERROR_PARSE:\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto err;\n    }\n    break;\n\n  default:\n    res = r;\n    goto err;\n  }\n\n  fields = mailimf_unparsed_fields_new(list);\n  if (fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_optional_field_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n#endif\n\nLIBETPAN_EXPORT\nint mailimf_fields_parse(const char * message, size_t length,\n\t\t\t size_t * indx,\n\t\t\t struct mailimf_fields ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_fields * fields;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  list = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_field_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_field_free);\n  /*\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  */\n\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    /* do nothing */\n    break;\n\n  case MAILIMF_ERROR_PARSE:\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto err;\n    }\n    break;\n\n  default:\n    res = r;\n    goto err;\n  }\n\n  fields = mailimf_fields_new(list);\n  if (fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_field_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n\n/*\norig-date       =       \"Date:\" date-time CRLF\n*/\n\n\nstatic int\nmailimf_orig_date_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_orig_date ** result)\n{\n  struct mailimf_date_time * date_time;\n  struct mailimf_orig_date * orig_date;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Date:\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_date_time_parse(message, length, &cur_token, &date_time);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_ignore_unstructured_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_date_time;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_date_time;\n  }\n\n  orig_date = mailimf_orig_date_new(date_time);\n  if (orig_date == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_date_time;\n  }\n\n  * result = orig_date;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_date_time:\n  mailimf_date_time_free(date_time);\n err:\n  return res;\n}\n\n/*\nfrom            =       \"From:\" mailbox-list CRLF\n*/\n\nstatic int\nmailimf_from_parse(const char * message, size_t length,\n\t\t   size_t * indx, struct mailimf_from ** result)\n{\n  struct mailimf_mailbox_list * mb_list;\n  struct mailimf_from * from;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token =  * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"From\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mb_list);\n\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mb_list;\n  }\n\n  from = mailimf_from_new(mb_list);\n  if (from == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mb_list;\n  }\n\n  * result = from;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_mb_list:\n  mailimf_mailbox_list_free(mb_list);\n err:\n  return res;\n}\n\n/*\nsender          =       \"Sender:\" mailbox CRLF\n*/\n\nstatic int\nmailimf_sender_parse(const char * message, size_t length,\n\t\t     size_t * indx, struct mailimf_sender ** result)\n{\n  struct mailimf_mailbox * mb;\n  struct mailimf_sender * sender;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Sender\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_mailbox_parse(message, length, &cur_token, &mb);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mb;\n  }\n\n  sender = mailimf_sender_new(mb);\n  if (sender == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mb;\n  }\n\n  * result = sender;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_mb:\n  mailimf_mailbox_free(mb);\n err:\n  return res;\n}\n\n/*\nreply-to        =       \"Reply-To:\" address-list CRLF\n*/\n\n\nstatic int\nmailimf_reply_to_parse(const char * message, size_t length,\n\t\t       size_t * indx, struct mailimf_reply_to ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_reply_to * reply_to;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Reply-To\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  reply_to = mailimf_reply_to_new(addr_list);\n  if (reply_to == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = reply_to;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\nto              =       \"To:\" address-list CRLF\n*/\n\nstatic int\nmailimf_to_parse(const char * message, size_t length,\n\t\t size_t * indx, struct mailimf_to ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_to * to;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"To\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  to = mailimf_to_new(addr_list);\n  if (to == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = to;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\ncc              =       \"Cc:\" address-list CRLF\n*/\n\n\nstatic int\nmailimf_cc_parse(const char * message, size_t length,\n\t\t size_t * indx, struct mailimf_cc ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_cc * cc;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Cc\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  cc = mailimf_cc_new(addr_list);\n  if (cc == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = cc;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\nbcc             =       \"Bcc:\" (address-list / [CFWS]) CRLF\n*/\n\n\nstatic int\nmailimf_bcc_parse(const char * message, size_t length,\n\t\t  size_t * indx, struct mailimf_bcc ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_bcc * bcc;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  addr_list = NULL;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Bcc\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    /* do nothing */\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto err;\n    }\n    break;\n  default:\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  bcc = mailimf_bcc_new(addr_list);\n  if (bcc == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  * result = bcc;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  if (addr_list != NULL)\n    mailimf_address_list_free(addr_list);\n  return res;\n}\n\n/*\nmessage-id      =       \"Message-ID:\" msg-id CRLF\n*/\n\nstatic int mailimf_message_id_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx,\n\t\t\t\t    struct mailimf_message_id ** result)\n{\n  char * value;\n  size_t cur_token;\n  struct mailimf_message_id * message_id;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Message-ID\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_msg_id_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_value;\n  }\n\n  message_id = mailimf_message_id_new(value);\n  if (message_id == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_value;\n  }\n\n  * result = message_id;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_value:\n  mailimf_msg_id_free(value);\n err:\n  return res;\n}\n\n/*\nin-reply-to     =       \"In-Reply-To:\" 1*msg-id CRLF\n*/\n\nLIBETPAN_EXPORT\nint mailimf_msg_id_list_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, clist ** result)\n{\n  return mailimf_struct_multiple_parse(message, length, indx,\n\t\t\t\t       result,\n\t\t\t\t       (mailimf_struct_parser *)\n\t\t\t\t       mailimf_unstrict_msg_id_parse,\n\t\t\t\t       (mailimf_struct_destructor *)\n\t\t\t\t       mailimf_msg_id_free);\n}\n\nstatic int mailimf_in_reply_to_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx,\n\t\t\t\t     struct mailimf_in_reply_to ** result)\n{\n  struct mailimf_in_reply_to * in_reply_to;\n  size_t cur_token;\n  clist * msg_id_list;\n  int res;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"In-Reply-To\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_msg_id_list_parse(message, length, &cur_token, &msg_id_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_list;\n  }\n\n  in_reply_to = mailimf_in_reply_to_new(msg_id_list);\n  if (in_reply_to == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = in_reply_to;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(msg_id_list, (clist_func) mailimf_msg_id_free, NULL);\n  clist_free(msg_id_list);\n err:\n  return res;\n}\n\n/*\nreferences      =       \"References:\" 1*msg-id CRLF\n*/\n\nLIBETPAN_EXPORT\nint mailimf_references_parse(const char * message, size_t length,\n\t\t\t     size_t * indx,\n\t\t\t     struct mailimf_references ** result)\n{\n  struct mailimf_references * references;\n  size_t cur_token;\n  clist * msg_id_list;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"References\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_msg_id_list_parse(message, length, &cur_token, &msg_id_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_list;\n  }\n\n  references = mailimf_references_new(msg_id_list);\n  if (references == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = references;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(msg_id_list, (clist_func) mailimf_msg_id_free, NULL);\n  clist_free(msg_id_list);\n err:\n  return res;\n}\n\n/*\nmsg-id          =       [CFWS] \"<\" id-left \"@\" id-right \">\" [CFWS]\n*/\n\nLIBETPAN_EXPORT\nint mailimf_msg_id_parse(const char * message, size_t length,\n\t\t\t size_t * indx,\n\t\t\t char ** result)\n{\n  size_t cur_token;\n#if 0\n  char * id_left;\n  char * id_right;\n#endif\n  char * msg_id;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_lower_parse(message, length, &cur_token);\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_addr_spec_msg_id_parse(message, length, &cur_token, &msg_id);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    \n    * result = msg_id;\n    * indx = cur_token;\n    \n    return MAILIMF_NO_ERROR;\n  }\n  else if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  // workaround for mbox mail\n  r = mailimf_lower_parse(message, length, &cur_token);\n  if (r == MAILIMF_NO_ERROR) {\n    // ok\n  }\n  else if (r == MAILIMF_ERROR_PARSE) {\n    // ok\n  }\n  else {\n    res = r;\n    goto err;\n  }\n  r = mailimf_addr_spec_msg_id_parse(message, length, &cur_token, &msg_id);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_greater_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    free(msg_id);\n    res = r;\n    goto err;\n  }\n  r = mailimf_greater_parse(message, length, &cur_token);\n  if (r == MAILIMF_NO_ERROR) {\n    // ok\n  }\n  else if (r == MAILIMF_ERROR_PARSE) {\n    // ok\n  }\n  else {\n    free(msg_id);\n    res = r;\n    goto err;\n  }\n  \n#if 0\n  r = mailimf_id_left_parse(message, length, &cur_token, &id_left);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_at_sign_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_id_left;\n  }\n\n  r = mailimf_id_right_parse(message, length, &cur_token, &id_right);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_id_left;\n  }\n\n  r = mailimf_greater_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_id_right;\n  }\n\n  msg_id = malloc(strlen(id_left) + strlen(id_right) + 2);\n  if (msg_id == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_id_right;\n  }\n  strcpy(msg_id, id_left);\n  strcat(msg_id, \"@\");\n  strcat(msg_id, id_right);\n\n  mailimf_id_left_free(id_left);\n  mailimf_id_right_free(id_right);\n#endif\n\n  * result = msg_id;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n#if 0\n free_id_right:\n  mailimf_id_right_free(id_right);\n free_id_left:\n  mailimf_id_left_free(id_left);\n#endif\n  /*\n free:\n  mailimf_atom_free(msg_id);\n  */\n err:\n  return res;\n}\n\nstatic int mailimf_parse_unwanted_msg_id(const char * message, size_t length,\n\t\t\t\t\t size_t * indx)\n{\n  size_t cur_token;\n  int r;\n  char * word;\n  int token_parsed;\n\n  cur_token = * indx;\n\n  token_parsed = TRUE;\n  while (token_parsed) {\n    token_parsed = FALSE;\n    r = mailimf_word_parse(message, length, &cur_token, &word);\n    if (r == MAILIMF_NO_ERROR) {\n      mailimf_word_free(word);\n      token_parsed = TRUE;\n    }\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_semi_colon_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_comma_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_plus_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_colon_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_point_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_at_sign_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n  }\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\nstatic int mailimf_unstrict_msg_id_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx,\n\t\t\t\t\t char ** result)\n{\n  char * msgid;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_parse_unwanted_msg_id(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_msg_id_parse(message, length, &cur_token, &msgid);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_parse_unwanted_msg_id(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    free(msgid);\n    return r;\n  }\n\n  * result = msgid;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nid-left         =       dot-atom-text / no-fold-quote / obs-id-left\n*/\n\n#if 0\nstatic int mailimf_id_left_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx, char ** result)\n{\n  int r;\n\n  r = mailimf_dot_atom_text_parse(message, length, indx, result);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    return MAILIMF_NO_ERROR;\n  case MAILIMF_ERROR_PARSE:\n    break;\n  default:\n    return r;\n  }\n  \n  r = mailimf_no_fold_quote_parse(message, length, indx, result);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\nid-right        =       dot-atom-text / no-fold-literal / obs-id-right\n*/\n\n#if 0\nstatic int mailimf_id_right_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, char ** result)\n{\n  int r;\n\n  r = mailimf_dot_atom_text_parse(message, length, indx, result);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    return MAILIMF_NO_ERROR;\n  case MAILIMF_ERROR_PARSE:\n    break;\n  default:\n    return r;\n  }\n\n  r = mailimf_no_fold_literal_parse(message, length, indx, result);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\nno-fold-quote   =       DQUOTE *(qtext / quoted-pair) DQUOTE\n*/\n\n#if 0\nstatic int mailimf_no_fold_quote_char_parse(const char * message, size_t length,\n\t\t\t\t\t    size_t * indx, char * result)\n{\n  char ch;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n#if 0\n  r = mailimf_qtext_parse(message, length, &cur_token, &ch);\n#endif\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_qtext(message[cur_token])) {\n    ch = message[cur_token];\n    cur_token ++;\n  }\n  else {\n    r = mailimf_quoted_pair_parse(message, length, &cur_token, &ch);\n    \n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n\n  * indx = cur_token;\n  * result = ch;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n#if 0\nstatic int mailimf_no_fold_quote_parse(const char * message, size_t length,\n\t\t\t\t       size_t * indx, char ** result)\n{\n  size_t cur_token;\n  size_t begin;\n  char ch;\n  char * no_fold_quote;\n  int r;\n  int res;\n\n  begin = cur_token;\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  while (1) {\n    r = mailimf_no_fold_quote_char_parse(message, length, &cur_token, &ch);\n    if (r == MAILIMF_NO_ERROR) {\n      /* do nothing */\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      res = r;\n      goto err;\n    }\n  }\n\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  /*  no_fold_quote = strndup(message + begin, cur_token - begin); */\n  no_fold_quote = malloc(cur_token - begin + 1);\n  if (no_fold_quote == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n  strncpy(no_fold_quote, message + begin, cur_token - begin);\n  no_fold_quote[cur_token - begin] = '\\0';\n\n  * result = no_fold_quote;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  return res;\n}\n#endif\n\n/*\nno-fold-literal =       \"[\" *(dtext / quoted-pair) \"]\"\n*/\n\n#if 0\nstatic inline int\nmailimf_no_fold_literal_char_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx, char * result)\n{\n  char ch;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n#if 0\n  r = mailimf_dtext_parse(message, length, &cur_token, &ch);\n#endif\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_dtext(message[cur_token])) {\n    ch = message[cur_token];\n    cur_token ++;\n  }\n  else {\n    r = mailimf_quoted_pair_parse(message, length, &cur_token, &ch);\n    \n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n\n  * indx = cur_token;\n  * result = ch;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n#if 0\nstatic int mailimf_no_fold_literal_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx, char ** result)\n{\n  size_t cur_token;\n  size_t begin;\n  char ch;\n  char * no_fold_literal;\n  int r;\n  int res;\n\n  begin = cur_token;\n  r = mailimf_obracket_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  while (1) {\n    r = mailimf_no_fold_literal_char_parse(message, length,\n\t\t\t\t\t   &cur_token, &ch);\n    if (r == MAILIMF_NO_ERROR) {\n      /* do nothing */\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      res = r;\n      goto err;\n    }\n  }\n\n  r = mailimf_cbracket_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  /*\n  no_fold_literal = strndup(message + begin, cur_token - begin);\n  */\n  no_fold_literal = malloc(cur_token - begin + 1);\n  if (no_fold_literal == NULL) {\n    res = MAILIMF_NO_ERROR;\n    goto err;\n  }\n  strncpy(no_fold_literal, message + begin, cur_token - begin);\n  no_fold_literal[cur_token - begin] = '\\0';\n\n  * result = no_fold_literal;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  return res;\n}\n#endif\n\n/*\nsubject         =       \"Subject:\" unstructured CRLF\n*/\n\nstatic int mailimf_subject_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx,\n\t\t\t\t struct mailimf_subject ** result)\n{\n  struct mailimf_subject * subject;\n  char * value;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Subject\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_unstructured_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_value;\n  }\n  \n  subject = mailimf_subject_new(value);\n  if (subject == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_value;\n  }\n\n  * result = subject;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_value:\n  mailimf_unstructured_free(value);\n err:\n  return res;\n}\n\n/*\ncomments        =       \"Comments:\" unstructured CRLF\n*/\n\nstatic int mailimf_comments_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_comments ** result)\n{\n  struct mailimf_comments * comments;\n  char * value;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Comments\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_unstructured_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_value;\n  }\n  \n  comments = mailimf_comments_new(value);\n  if (comments == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_value;\n  }\n\n  * result = comments;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_value:\n  mailimf_unstructured_free(value);\n err:\n  return res;\n}\n\n/*\nkeywords        =       \"Keywords:\" phrase *(\",\" phrase) CRLF\n*/\n\nstatic int mailimf_keywords_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_keywords ** result)\n{\n  struct mailimf_keywords * keywords;\n  clist * list;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Keywords\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_struct_list_parse(message, length, &cur_token,\n\t\t\t\t&list, ',',\n\t\t\t\t(mailimf_struct_parser *)\n\t\t\t\tmailimf_phrase_parse,\n\t\t\t\t(mailimf_struct_destructor *)\n\t\t\t\tmailimf_phrase_free);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_list;\n  }\n  \n  keywords = mailimf_keywords_new(list);\n  if (keywords == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = keywords;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(list, (clist_func) mailimf_phrase_free, NULL);\n  clist_free(list);\n err:\n  return res;\n}\n\n/*\nresent-date     =       \"Resent-Date:\" date-time CRLF\n*/\n\nstatic int\nmailimf_resent_date_parse(const char * message, size_t length,\n\t\t\t  size_t * indx, struct mailimf_orig_date ** result)\n{\n  struct mailimf_orig_date * orig_date;\n  struct mailimf_date_time * date_time;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-Date\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_date_time_parse(message, length, &cur_token, &date_time);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_date_time;\n  }\n\n  orig_date = mailimf_orig_date_new(date_time);\n  if (orig_date == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_date_time;\n  }\n\n  * result = orig_date;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_date_time:\n  mailimf_date_time_free(date_time);\n err:\n  return res;\n}\n\n/*\nresent-from     =       \"Resent-From:\" mailbox-list CRLF\n*/\n\nstatic int\nmailimf_resent_from_parse(const char * message, size_t length,\n\t\t\t  size_t * indx, struct mailimf_from ** result)\n{\n  struct mailimf_mailbox_list * mb_list;\n  struct mailimf_from * from;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token =  * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-From\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mb_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mb_list;\n  }\n\n  from = mailimf_from_new(mb_list);\n  if (from == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mb_list;\n  }\n\n  * result = from;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_mb_list:\n  mailimf_mailbox_list_free(mb_list);\n err:\n  return res;\n}\n\n/*\nresent-sender   =       \"Resent-Sender:\" mailbox CRLF\n*/\n\nstatic int\nmailimf_resent_sender_parse(const char * message, size_t length,\n\t\t\t    size_t * indx, struct mailimf_sender ** result)\n{\n  struct mailimf_mailbox * mb;\n  struct mailimf_sender * sender;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = length;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-Sender\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_mailbox_parse(message, length, &cur_token, &mb);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mb;\n  }\n\n  sender = mailimf_sender_new(mb);\n  if (sender == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mb;\n  }\n\n  * result = sender;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_mb:\n  mailimf_mailbox_free(mb);\n err:\n  return res;\n}\n\n/*\nresent-to       =       \"Resent-To:\" address-list CRLF\n*/\n\nstatic int\nmailimf_resent_to_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_to ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_to * to;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-To\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  to = mailimf_to_new(addr_list);\n  if (to == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = to;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\nresent-cc       =       \"Resent-Cc:\" address-list CRLF\n*/\n\nstatic int\nmailimf_resent_cc_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_cc ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_cc * cc;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-Cc\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  cc = mailimf_cc_new(addr_list);\n  if (cc == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = cc;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\nresent-bcc      =       \"Resent-Bcc:\" (address-list / [CFWS]) CRLF\n*/\n\nstatic int\nmailimf_resent_bcc_parse(const char * message, size_t length,\n\t\t\t size_t * indx, struct mailimf_bcc ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_bcc * bcc;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  bcc = NULL;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-Bcc\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  addr_list = NULL;\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  bcc = mailimf_bcc_new(addr_list);\n  if (bcc == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = bcc;\n  * indx = cur_token;\n\n  return TRUE;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\nresent-msg-id   =       \"Resent-Message-ID:\" msg-id CRLF\n*/\n\nstatic int\nmailimf_resent_msg_id_parse(const char * message, size_t length,\n\t\t\t    size_t * indx,\n\t\t\t    struct mailimf_message_id ** result)\n{\n  char * value;\n  size_t cur_token;\n  struct mailimf_message_id * message_id;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-Message-ID\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_msg_id_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_value;\n  }\n\n  message_id = mailimf_message_id_new(value);\n  if (message_id == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_value;\n  }\n\n  * result = message_id;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_value:\n  mailimf_msg_id_free(value);\n err:\n  return res;\n}\n\n/*\ntrace           =       [return]\n                        1*received\n*/\n\n#if 0\nstatic int mailimf_trace_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_trace ** result)\n{\n  size_t cur_token;\n  struct mailimf_return * return_path;\n  clist * received_list;\n  struct mailimf_trace * trace;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  return_path = NULL;\n  received_list = NULL;\n\n  r = mailimf_return_parse(message, length, &cur_token, &return_path);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &received_list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_received_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_received_free);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  if ((received_list == NULL) && (return_path == NULL)) {\n    res = MAILIMF_ERROR_PARSE;\n    goto free_return;\n  }\n\n  trace = mailimf_trace_new(return_path, received_list);\n  if (trace == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = trace;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(received_list, (clist_func) mailimf_received_free, NULL);\n  clist_free(received_list);\n free_return:\n  if (return_path != NULL)\n    mailimf_return_free(return_path);\n err:\n  return res;\n}\n#endif\n\n/*\nreturn          =       \"Return-Path:\" path CRLF\n*/\n\nstatic int mailimf_return_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx,\n\t\t\t\tstruct mailimf_return ** result)\n{\n  struct mailimf_path * path;\n  struct mailimf_return * return_path;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Return-Path\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  path = NULL;\n  r = mailimf_path_parse(message, length, &cur_token, &path);\n  if ( r!= MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_path;\n  }\n\n  return_path = mailimf_return_new(path);\n  if (return_path == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_path;\n  }\n\n  * result = return_path;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_path:\n  mailimf_path_free(path);\n err:\n  return res;\n}\n\n/*\npath            =       ([CFWS] \"<\" ([CFWS] / addr-spec) \">\" [CFWS]) /\n                        obs-path\n*/\n\nstatic int mailimf_path_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, struct mailimf_path ** result)\n{\n  size_t cur_token;\n  char * addr_spec;\n  struct mailimf_path * path;\n  int res;\n  int r;\n\n  cur_token = * indx;\n  addr_spec = NULL;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_lower_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_addr_spec_parse(message, length, &cur_token, &addr_spec);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto err;\n    }\n    break;\n  default:\n    return r;\n  }\n  \n  r = mailimf_greater_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  path = mailimf_path_new(addr_spec);\n  if (path == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_spec;\n  }\n\n  * indx = cur_token;\n  * result = path;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_spec:\n  if (addr_spec == NULL)\n    mailimf_addr_spec_free(addr_spec);\n err:\n  return res;\n}\n\n/*\nreceived        =       \"Received:\" name-val-list \";\" date-time CRLF\n*/\n\n#if 0\nstatic int mailimf_received_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_received ** result)\n{\n  size_t cur_token;\n  struct mailimf_received * received;\n  struct mailimf_name_val_list * name_val_list;\n  struct mailimf_date_time * date_time;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Received\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_name_val_list_parse(message, length,\n\t\t\t\t  &cur_token, &name_val_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_name_val_list;\n  }\n\n  r = mailimf_date_time_parse(message, length, &cur_token, &date_time);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_name_val_list;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_date_time;\n  }\n\n  received = mailimf_received_new(name_val_list, date_time);\n  if (received == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_date_time;\n  }\n\n  * indx = cur_token;\n  * result = received;\n\n  return MAILIMF_NO_ERROR;\n\n free_date_time:\n  mailimf_date_time_free(date_time);\n free_name_val_list:\n  mailimf_name_val_list_free(name_val_list);\n err:\n  return res;\n}\n#endif\n\n/*\nname-val-list   =       [CFWS] [name-val-pair *(CFWS name-val-pair)]\n*/\n\n#if 0\nstatic int\nmailimf_name_val_list_parse(const char * message, size_t length,\n\t\t\t    size_t * indx,\n\t\t\t    struct mailimf_name_val_list ** result)\n{\n  size_t cur_token;\n  struct mailimf_name_val_pair * pair;\n  struct mailimf_name_val_list * name_val_list;\n  clist* list;\n  int res;\n  int r;\n\n  cur_token = * indx;\n  list = NULL;\n\n  r = mailimf_name_val_pair_parse(message, length, &cur_token, &pair);\n\n  if (r == MAILIMF_NO_ERROR){\n    size_t final_token;\n\n    list = clist_new();\n    if (list == NULL) {\n      mailimf_name_val_pair_free(pair);\n      res = MAILIMF_ERROR_MEMORY;\n      goto err;\n    }\n\n    r = clist_append(list, pair);\n    if (r < 0) {\n      mailimf_name_val_pair_free(pair);\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_list;\n    }\n\n    final_token = cur_token;\n    \n    while (1) {\n      r = mailimf_cfws_parse(message, length, &cur_token);\n      if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n\tres = r;\n\tgoto free_list;\n      }\n\n      r = mailimf_name_val_pair_parse(message, length, &cur_token, &pair);\n      if (r == MAILIMF_NO_ERROR) {\n\t/* do nothing */\n      }\n      else if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else {\n\tres = r;\n\tgoto free_list;\n      }\n\n      r = clist_append(list, pair);\n      if (r < 0) {\n\tmailimf_name_val_pair_free(pair);\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free_list;\n      }\n\n      final_token = cur_token;\n    }\n    cur_token = final_token;\n  }\n\n  name_val_list = mailimf_name_val_list_new(list);\n  if (name_val_list == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * indx = cur_token;\n  * result = name_val_list;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_name_val_pair_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n#endif\n\n/*\nname-val-pair   =       item-name CFWS item-value\n*/\n\n#if 0\nstatic int\nmailimf_name_val_pair_parse(const char * message, size_t length,\n\t\t\t    size_t * indx,\n\t\t\t    struct mailimf_name_val_pair ** result)\n{\n  size_t cur_token;\n  char * item_name;\n  struct mailimf_item_value * item_value;\n  struct mailimf_name_val_pair * name_val_pair;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_item_name_parse(message, length, &cur_token, &item_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_item_name;\n  }\n\n  r = mailimf_item_value_parse(message, length, &cur_token, &item_value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_item_name;\n  }\n\n  name_val_pair = mailimf_name_val_pair_new(item_name, item_value);\n  if (name_val_pair == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_item_value;\n  }\n\n  * result = name_val_pair;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_item_value:\n  mailimf_item_value_free(item_value);\n free_item_name:\n  mailimf_item_name_free(item_name);\n err:\n  return res;\n}\n#endif\n\n/*\nitem-name       =       ALPHA *([\"-\"] (ALPHA / DIGIT))\n*/\n\n#if 0\nstatic int mailimf_item_name_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx, char ** result)\n{\n  size_t cur_token;\n  size_t begin;\n  char * item_name;\n  char ch;\n  int digit;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  begin = cur_token;\n\n  r = mailimf_alpha_parse(message, length, &cur_token, &ch);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  while (1) {\n    int minus_sign;\n\n    minus_sign = mailimf_minus_parse(message, length, &cur_token);\n\n    r = mailimf_alpha_parse(message, length, &cur_token, &ch);\n    if (r == MAILIMF_ERROR_PARSE)\n      r = mailimf_digit_parse(message, length, &cur_token, &digit);\n\n    if (r == MAILIMF_NO_ERROR) {\n      /* do nothing */\n    }\n    if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n  }\n\n  item_name = strndup(message + begin, cur_token - begin);\n  if (item_name == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  * indx = cur_token;\n  * result = item_name;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  return res;\n}\n#endif\n\n/*\nitem-value      =       1*angle-addr / addr-spec /\n                         atom / domain / msg-id\n*/\n\n#if 0\nstatic int is_item_value_atext(char ch)\n{\n  switch (ch) {\n  case '\\t':\n  case ' ':\n  case '\\r':\n  case '\\n':\n  case ';':\n    return FALSE;\n  default:\n    return TRUE;\n  }\n}\n\nstatic int mailimf_item_value_atom_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx, char ** result)\n{\n  char * atom;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_custom_string_parse(message, length, &cur_token,\n\t\t\t\t  &atom, is_item_value_atext);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  * indx = cur_token;\n  * result = atom;\n\n  return MAILIMF_NO_ERROR;\n}\n\nstatic int mailimf_item_value_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx,\n\t\t\t\t    struct mailimf_item_value ** result)\n{\n  size_t cur_token;\n  clist * angle_addr_list;\n  char * addr_spec;\n  char * atom;\n  char * domain;\n  char * msg_id;\n  int type;\n  struct mailimf_item_value * item_value;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  \n  angle_addr_list = NULL;\n  addr_spec = NULL;\n  atom = NULL;\n  domain = NULL;\n  msg_id = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &angle_addr_list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_angle_addr_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_angle_addr_free);\n  if (r == MAILIMF_NO_ERROR)\n    type = MAILIMF_ITEM_VALUE_ANGLE_ADDR_LIST;\n\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_addr_spec_parse(message, length, &cur_token,\n\t\t\t\t&addr_spec);\n    if (r == MAILIMF_NO_ERROR)\n      type = MAILIMF_ITEM_VALUE_ADDR_SPEC;\n  }\n\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_msg_id_parse(message, length, &cur_token,\n\t\t\t     &msg_id);\n    if (r == MAILIMF_NO_ERROR)\n      type = MAILIMF_ITEM_VALUE_MSG_ID;\n  }\n\n  /*\n  else if (mailimf_domain_parse(message, length, &cur_token,\n\t\t\t\t&domain))\n    type = MAILIMF_ITEM_VALUE_DOMAIN;\n  */\n  /*\n  else if (mailimf_atom_parse(message, length, &cur_token,\n\t\t\t      &atom))\n    type = MAILIMF_ITEM_VALUE_ATOM;\n  */\n\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_item_value_atom_parse(message, length, &cur_token,\n\t\t\t\t      &atom);\n    if (r == MAILIMF_NO_ERROR)\n      type = MAILIMF_ITEM_VALUE_ATOM;\n  }\n\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  item_value = mailimf_item_value_new(type, angle_addr_list, addr_spec,\n\t\t\t\t      atom, domain, msg_id);\n  if (item_value == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = item_value;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (angle_addr_list != NULL) {\n    clist_foreach(angle_addr_list, (clist_func) mailimf_angle_addr_free, NULL);\n    clist_free(angle_addr_list);\n  }\n  if (addr_spec != NULL)\n    mailimf_addr_spec_free(addr_spec);\n  if (atom != NULL)\n    mailimf_atom_free(atom);\n  if (domain != NULL)\n    mailimf_domain_free(domain);\n  if (msg_id != NULL)\n    mailimf_msg_id_free(msg_id);\n err:\n  return res;\n}\n#endif\n\n/*\noptional-field  =       field-name \":\" unstructured CRLF\n*/\n\nstatic int\nmailimf_optional_field_parse(const char * message, size_t length,\n\t\t\t     size_t * indx,\n\t\t\t     struct mailimf_optional_field ** result)\n{\n  char * name;\n  char * value;\n  struct mailimf_optional_field * optional_field;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_field_name_parse(message, length, &cur_token, &name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_name;\n  }\n\n  r = mailimf_unstructured_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_name;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_value;\n  }\n\n  optional_field = mailimf_optional_field_new(name, value);\n  if (optional_field == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_value;\n  }\n\n  * result = optional_field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_value:\n  mailimf_unstructured_free(value);\n free_name:\n  mailimf_field_name_free(name);\n err:\n  return res;\n}\n     \n/*\nfield-name      =       1*ftext\n*/\n\nstatic inline int is_ftext(char ch);\n\nstatic int mailimf_field_name_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, char ** result)\n{\n  char * field_name;\n  size_t cur_token;\n  size_t end;\n  \n  cur_token = * indx;\n\n  end = cur_token;\n  if (end >= length) {\n    return MAILIMF_ERROR_PARSE;\n  }\n\n  while (is_ftext(message[end])) {\n    end ++;\n    if (end >= length)\n      break;\n  }\n  if (end == cur_token) {\n    return MAILIMF_ERROR_PARSE;\n  }\n\n  /*  field_name = strndup(message + cur_token, end - cur_token); */\n  field_name = malloc(end - cur_token + 1);\n  if (field_name == NULL) {\n    return MAILIMF_ERROR_MEMORY;\n  }\n  strncpy(field_name, message + cur_token, end - cur_token);\n  field_name[end - cur_token] = '\\0';\n\n  cur_token = end;\n  \n  * indx = cur_token;\n  * result = field_name;\n  \n  return MAILIMF_NO_ERROR;\n}\n\n/*\nftext           =       %d33-57 /               ; Any character except\n                        %d59-126                ;  controls, SP, and\n                                                ;  \":\".\n*/\n\nstatic inline int is_ftext(char ch)\n{\n  unsigned char uch = (unsigned char) ch;\n\n  if (uch < 33)\n    return FALSE;\n\n  if (uch == 58)\n    return FALSE;\n\n  return TRUE;\n}\n\n/*\nstatic int mailimf_ftext_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, gchar * result)\n{\n  return mailimf_typed_text_parse(message, length, indx, result, is_ftext);\n}\n*/\n\n\n\n\nstatic int mailimf_envelope_field_parse(const char * message, size_t length,\n\t\t\t\t\tsize_t * indx,\n\t\t\t\t\tstruct mailimf_field ** result)\n{\n  size_t cur_token;\n  int type;\n  struct mailimf_orig_date * orig_date;\n  struct mailimf_from * from;\n  struct mailimf_sender * sender;\n  struct mailimf_reply_to * reply_to;\n  struct mailimf_to * to;\n  struct mailimf_cc * cc;\n  struct mailimf_bcc * bcc;\n  struct mailimf_message_id * message_id;\n  struct mailimf_in_reply_to * in_reply_to;\n  struct mailimf_references * references;\n  struct mailimf_subject * subject;\n  struct mailimf_optional_field * optional_field;\n  struct mailimf_field * field;\n  int guessed_type;\n  int r;\n  int res;\n  \n  cur_token = * indx;\n\n  orig_date = NULL;\n  from = NULL;\n  sender = NULL;\n  reply_to = NULL;\n  to = NULL;\n  cc = NULL;\n  bcc = NULL;\n  message_id = NULL;\n  in_reply_to = NULL;\n  references = NULL;\n  subject = NULL;\n  optional_field = NULL;\n\n  guessed_type = guess_header_type(message, length, cur_token);\n  type = MAILIMF_FIELD_NONE;\n\n  switch (guessed_type) {\n  case MAILIMF_FIELD_ORIG_DATE:\n    r = mailimf_orig_date_parse(message, length, &cur_token,\n\t\t\t\t&orig_date);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_FROM:\n    r = mailimf_from_parse(message, length, &cur_token,\n\t\t\t   &from);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_SENDER:\n    r = mailimf_sender_parse(message, length, &cur_token,\n\t\t\t     &sender);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_REPLY_TO:\n    r = mailimf_reply_to_parse(message, length, &cur_token,\n\t\t\t       &reply_to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_TO:\n    r = mailimf_to_parse(message, length, &cur_token,\n\t\t\t &to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_CC:\n    r = mailimf_cc_parse(message, length, &cur_token,\n\t\t\t &cc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_BCC:\n    r = mailimf_bcc_parse(message, length, &cur_token,\n\t\t\t  &bcc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_MESSAGE_ID:\n    r = mailimf_message_id_parse(message, length, &cur_token,\n\t\t\t\t &message_id);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_IN_REPLY_TO:\n    r = mailimf_in_reply_to_parse(message, length, &cur_token,\n\t\t\t\t  &in_reply_to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_REFERENCES:\n    r = mailimf_references_parse(message, length, &cur_token,\n\t\t\t\t &references);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_SUBJECT:\n    r = mailimf_subject_parse(message, length, &cur_token,\n\t\t\t      &subject);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  }\n\n  if (type == MAILIMF_FIELD_NONE) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  field = mailimf_field_new(type, NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL,\n      orig_date, from, sender, reply_to, to,\n      cc, bcc, message_id, in_reply_to, references,\n      subject, NULL, NULL, optional_field);\n  if (field == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_field;\n  }\n  \n  * result = field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_field:\n  if (orig_date != NULL)\n    mailimf_orig_date_free(orig_date);\n  if (from != NULL)\n    mailimf_from_free(from);\n  if (sender != NULL)\n    mailimf_sender_free(sender);\n  if (reply_to != NULL)\n    mailimf_reply_to_free(reply_to);\n  if (to != NULL)\n    mailimf_to_free(to);\n  if (cc != NULL)\n    mailimf_cc_free(cc);\n  if (bcc != NULL)\n    mailimf_bcc_free(bcc);\n  if (message_id != NULL)\n    mailimf_message_id_free(message_id);\n  if (in_reply_to != NULL)\n    mailimf_in_reply_to_free(in_reply_to);\n  if (references != NULL)\n    mailimf_references_free(references);\n  if (subject != NULL)\n    mailimf_subject_free(subject);\n  if (optional_field != NULL)\n    mailimf_optional_field_free(optional_field);\n err:\n  return res;\n}\n\nLIBETPAN_EXPORT\nint mailimf_envelope_fields_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_fields ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_fields * fields;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  list = clist_new();\n  if (list == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  while (1) {\n    struct mailimf_field * elt;\n\n    r = mailimf_envelope_field_parse(message, length, &cur_token, &elt);\n    if (r == MAILIMF_NO_ERROR) {\n      r = clist_append(list, elt);\n      if (r < 0) {\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free;\n      }\n    }\n    else if (r == MAILIMF_ERROR_PARSE) {\n      r = mailimf_ignore_field_parse(message, length, &cur_token);\n      if (r == MAILIMF_NO_ERROR) {\n\t/* do nothing */\n      }\n      else if (r == MAILIMF_ERROR_PARSE) {\n\tbreak;\n      }\n      else {\n\tres = r;\n\tgoto free;\n      }\n    }\n    else {\n      res = r;\n      goto free;\n    }\n  }\n\n  fields = mailimf_fields_new(list);\n  if (fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_field_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n\n\nstatic int\nmailimf_envelope_or_optional_field_parse(const char * message,\n\t\t\t\t\t size_t length,\n\t\t\t\t\t size_t * indx,\n\t\t\t\t\t struct mailimf_field ** result)\n{\n  int r;\n  size_t cur_token;\n  struct mailimf_optional_field * optional_field;\n  struct mailimf_field * field;\n\n  r = mailimf_envelope_field_parse(message, length, indx, result);\n  if (r == MAILIMF_NO_ERROR)\n    return MAILIMF_NO_ERROR;\n\n  cur_token = * indx;\n\n  r = mailimf_optional_field_parse(message, length, &cur_token,\n\t\t\t\t   &optional_field);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  field = mailimf_field_new(MAILIMF_FIELD_OPTIONAL_FIELD, NULL,\n      NULL, NULL, NULL,\n      NULL, NULL, NULL,\n      NULL, NULL, NULL,\n      NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, optional_field);\n  if (field == NULL) {\n    mailimf_optional_field_free(optional_field);\n    return MAILIMF_ERROR_MEMORY;\n  }\n\n  * result = field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\nLIBETPAN_EXPORT\nint\nmailimf_envelope_and_optional_fields_parse(const char * message, size_t length,\n\t\t\t\t\t   size_t * indx,\n\t\t\t\t\t   struct mailimf_fields ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_fields * fields;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  list = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_envelope_or_optional_field_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_field_free);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    /* do nothing */\n    break;\n\n  case MAILIMF_ERROR_PARSE:\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto err;\n    }\n    break;\n\n  default:\n    res = r;\n    goto err;\n  }\n\n  fields = mailimf_fields_new(list);\n  if (fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_field_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n\n\n\nstatic int\nmailimf_only_optional_field_parse(const char * message,\n\t\t\t\t  size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_field ** result)\n{\n  int r;\n  size_t cur_token;\n  struct mailimf_optional_field * optional_field;\n  struct mailimf_field * field;\n\n  cur_token = * indx;\n\n  r = mailimf_optional_field_parse(message, length, &cur_token,\n\t\t\t\t   &optional_field);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  field = mailimf_field_new(MAILIMF_FIELD_OPTIONAL_FIELD, NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, optional_field);\n  if (field == NULL) {\n    mailimf_optional_field_free(optional_field);\n    return MAILIMF_ERROR_MEMORY;\n  }\n\n  * result = field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\nLIBETPAN_EXPORT\nint\nmailimf_optional_fields_parse(const char * message, size_t length,\n\t\t\t      size_t * indx,\n\t\t\t      struct mailimf_fields ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_fields * fields;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  list = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_only_optional_field_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_field_free);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    /* do nothing */\n    break;\n\n  case MAILIMF_ERROR_PARSE:\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto err;\n    }\n    break;\n\n  default:\n    res = r;\n    goto err;\n  }\n\n  fields = mailimf_fields_new(list);\n  if (fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_field_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n"], "fixing_code": ["/*\n * libEtPan! -- a mail stuff library\n *\n * Copyright (C) 2001, 2005 - DINH Viet Hoa\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the libEtPan! project nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * $Id: mailimf.c,v 1.50 2011/06/20 23:25:26 hoa Exp $\n */\n\n#ifdef HAVE_CONFIG_H\n#\tinclude <config.h>\n#endif\n\n#include \"mailimf.h\"\n\n/*\n  RFC 2822\n\n  RFC 2821 ... \n   A message-originating SMTP system SHOULD NOT send a message that\n   already contains a Return-path header.  SMTP servers performing a\n   relay function MUST NOT inspect the message data, and especially not\n   to the extent needed to determine if Return-path headers are present.\n   SMTP servers making final delivery MAY remove Return-path headers\n   before adding their own.\n*/\n\n#include <ctype.h>\n#include \"mmapstring.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"mailmime_decode.h\"\n\n#ifndef TRUE\n#define TRUE 1\n#endif\n\n#ifndef FALSE\n#define FALSE 0\n#endif\n\n\n\n\n\n\n\nstatic inline int is_dtext(char ch);\n\nstatic int mailimf_quoted_pair_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx, char * result);\n\nstatic int mailimf_ccontent_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx);\n\nstatic int\nmailimf_comment_fws_ccontent_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx);\n\nstatic inline int mailimf_comment_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx);\n\nstatic int mailimf_qcontent_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, char * ch);\n\nstatic int mailimf_phrase_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, char ** result);\n\nstatic int mailimf_unstructured_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx, char ** result);\n\nstatic int mailimf_ignore_unstructured_parse(const char * message, size_t length,\n\t\t\t\t\t     size_t * indx);\n\nstatic int mailimf_day_of_week_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx, int * result);\n\nstatic int mailimf_day_name_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, int * result);\n\nstatic int mailimf_date_parse(const char * message, size_t length,\n\t\t\t      size_t * indx,\n\t\t\t      int * pday, int * pmonth, int * pyear);\n\nstatic int mailimf_broken_date_parse(const char * message, size_t length,\n                                     size_t * indx,\n                                     int * pday, int * pmonth, int * pyear);\n\nstatic int mailimf_year_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, int * result);\n\nstatic int mailimf_month_parse(const char * message, size_t length,\n\t\t\t       size_t * indx, int * result);\n\nstatic int mailimf_month_name_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, int * result);\n\nstatic int mailimf_day_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, int * result);\n\nstatic int mailimf_time_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, \n\t\t\t      int * phour, int * pmin,\n\t\t\t      int * psec,\n\t\t\t      int * zone);\nstatic int mailimf_time_of_day_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx,\n\t\t\t\t     int * phour, int * pmin,\n\t\t\t\t     int * psec);\n\nstatic int mailimf_hour_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, int * result);\n\nstatic int mailimf_minute_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, int * result);\n\nstatic int mailimf_second_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, int * result);\n\nstatic int mailimf_zone_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, int * result);\n\nstatic int mailimf_name_addr_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx,\n\t\t\t\t   char ** pdisplay_name,\n\t\t\t\t   char ** pangle_addr);\n\nstatic int mailimf_angle_addr_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, char ** result);\n\nstatic int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result);\n\nstatic int mailimf_display_name_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx, char ** result);\n\nstatic int mailimf_addr_spec_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx,\n\t\t\t\t   char ** address);\n\nstatic int\nmailimf_orig_date_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_orig_date ** result);\n\nstatic int\nmailimf_from_parse(const char * message, size_t length,\n\t\t   size_t * indx, struct mailimf_from ** result);\n\nstatic int\nmailimf_sender_parse(const char * message, size_t length,\n\t\t     size_t * indx, struct mailimf_sender ** result);\n\nstatic int\nmailimf_reply_to_parse(const char * message, size_t length,\n\t\t       size_t * indx, struct mailimf_reply_to ** result);\n\nstatic int\nmailimf_to_parse(const char * message, size_t length,\n\t\t size_t * indx, struct mailimf_to ** result);\n\nstatic int\nmailimf_cc_parse(const char * message, size_t length,\n\t\t size_t * indx, struct mailimf_cc ** result);\n\nstatic int\nmailimf_bcc_parse(const char * message, size_t length,\n\t\t  size_t * indx, struct mailimf_bcc ** result);\n\nstatic int mailimf_message_id_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx,\n\t\t\t\t    struct mailimf_message_id ** result);\n\nstatic int\nmailimf_in_reply_to_parse(const char * message, size_t length,\n\t\t\t  size_t * indx,\n\t\t\t  struct mailimf_in_reply_to ** result);\n\nstatic int mailimf_unstrict_msg_id_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx,\n\t\t\t\t\t char ** result);\n\nstatic int mailimf_subject_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx,\n\t\t\t\t struct mailimf_subject ** result);\n\nstatic int mailimf_comments_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_comments ** result);\n\nstatic int mailimf_keywords_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_keywords ** result);\n\nstatic int\nmailimf_resent_date_parse(const char * message, size_t length,\n\t\t\t  size_t * indx, struct mailimf_orig_date ** result);\n\nstatic int\nmailimf_resent_from_parse(const char * message, size_t length,\n\t\t\t  size_t * indx, struct mailimf_from ** result);\n\nstatic int\nmailimf_resent_sender_parse(const char * message, size_t length,\n\t\t\t    size_t * indx, struct mailimf_sender ** result);\n\nstatic int\nmailimf_resent_to_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_to ** result);\n\nstatic int\nmailimf_resent_cc_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_cc ** result);\n\nstatic int\nmailimf_resent_bcc_parse(const char * message, size_t length,\n\t\t\t size_t * indx, struct mailimf_bcc ** result);\n\nstatic int\nmailimf_resent_msg_id_parse(const char * message, size_t length,\n\t\t\t    size_t * indx,\n\t\t\t    struct mailimf_message_id ** result);\n\nstatic int mailimf_return_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx,\n\t\t\t\tstruct mailimf_return ** result);\n\nstatic int\nmailimf_path_parse(const char * message, size_t length,\n\t\t   size_t * indx, struct mailimf_path ** result);\n\nstatic int\nmailimf_optional_field_parse(const char * message, size_t length,\n\t\t\t     size_t * indx,\n\t\t\t     struct mailimf_optional_field ** result);\n\nstatic int mailimf_field_name_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, char ** result);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* *************************************************************** */\n\nstatic inline int is_digit(char ch)\n{\n  return (ch >= '0') && (ch <= '9');\n}\n\nstatic int mailimf_digit_parse(const char * message, size_t length,\n\t\t\t       size_t * indx, int * result)\n{\n  size_t cur_token;\n\n  cur_token = * indx;\n  \n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_digit(message[cur_token])) {\n    * result = message[cur_token] - '0';\n    cur_token ++;\n    * indx = cur_token;\n    return MAILIMF_NO_ERROR;\n  }\n  else\n    return MAILIMF_ERROR_PARSE;\n}\n\nLIBETPAN_EXPORT\nint\nmailimf_number_parse(const char * message, size_t length,\n\t\t     size_t * indx, uint32_t * result)\n{\n  size_t cur_token;\n  int digit;\n  uint32_t number;\n  int parsed;\n  int r;\n\n  cur_token = * indx;\n  parsed = FALSE;\n\n  number = 0;\n  while (1) {\n    r = mailimf_digit_parse(message, length, &cur_token, &digit);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else\n\treturn r;\n    }\n    number *= 10;\n    number += digit;\n    parsed = TRUE;\n  }\n\n  if (!parsed)\n    return MAILIMF_ERROR_PARSE;\n\n  * result = number;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\nLIBETPAN_EXPORT\nint mailimf_char_parse(const char * message, size_t length,\n\t\t       size_t * indx, char token)\n{\n  size_t cur_token;\n\n  cur_token = * indx;\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (message[cur_token] == token) {\n    cur_token ++;\n    * indx = cur_token;\n    return MAILIMF_NO_ERROR;\n  }\n  else\n    return MAILIMF_ERROR_PARSE;\n}\n\nLIBETPAN_EXPORT\nint mailimf_unstrict_char_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, char token)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_char_parse(message, length, &cur_token, token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n  \n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\nLIBETPAN_EXPORT\nint\nmailimf_token_case_insensitive_len_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx, char * token,\n\t\t\t\t\t size_t token_length)\n{\n  size_t cur_token;\n\n  cur_token = * indx;\n\n  if (cur_token + token_length - 1 >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (strncasecmp(message + cur_token, token, token_length) == 0) {\n    cur_token += token_length;\n    * indx = cur_token;\n    return MAILIMF_NO_ERROR;\n  }\n  else\n    return MAILIMF_ERROR_PARSE;\n}\n\nstatic int mailimf_oparenth_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx)\n{\n  return mailimf_char_parse(message, length, indx, '(');\n}\n\nstatic int mailimf_cparenth_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx)\n{\n  return mailimf_char_parse(message, length, indx, ')');\n}\n\nstatic int mailimf_comma_parse(const char * message, size_t length,\n\t\t\t       size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, ',');\n}\n\nstatic int mailimf_dquote_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx)\n{\n  return mailimf_char_parse(message, length, indx, '\\\"');\n}\n\nstatic int mailimf_colon_parse(const char * message, size_t length,\n\t\t\t       size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, ':');\n}\n\nstatic int mailimf_semi_colon_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, ';');\n}\n\nstatic int mailimf_plus_parse(const char * message, size_t length,\n\t\t\t      size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '+');\n}\n\nstatic int mailimf_minus_parse(const char * message, size_t length,\n\t\t\t       size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '-');\n}\n\nstatic int mailimf_lower_parse(const char * message, size_t length,\n\t\t\t       size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '<');\n}\n\nstatic int mailimf_greater_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '>');\n}\n\nstatic int mailimf_at_sign_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '@');\n}\n\nstatic int mailimf_point_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx)\n{\n  return mailimf_unstrict_char_parse(message, length, indx, '.');\n}\n\nLIBETPAN_EXPORT\nint\nmailimf_custom_string_parse(const char * message, size_t length,\n\t\t\t    size_t * indx, char ** result,\n\t\t\t    int (* is_custom_char)(char))\n{\n  size_t begin;\n  size_t end;\n  char * gstr;\n\n  begin = * indx;\n\n  end = begin;\n\n  if (end >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  while (is_custom_char(message[end])) {\n    end ++;\n    if (end >= length)\n      break;\n  }\n\n  if (end != begin) {\n    /*\n    gstr = strndup(message + begin, end - begin);\n    */\n    gstr = malloc(end - begin + 1);\n    if (gstr == NULL)\n      return MAILIMF_ERROR_MEMORY;\n    strncpy(gstr, message + begin, end - begin);\n    gstr[end - begin] = '\\0';\n\n    * indx = end;\n    * result = gstr;\n    return MAILIMF_NO_ERROR;\n  }\n  else\n    return MAILIMF_ERROR_PARSE;\n}\n\n\n\n\n\n\n\ntypedef int mailimf_struct_parser(const char * message, size_t length,\n\t\t\t\t  size_t * indx, void * result);\n\ntypedef int mailimf_struct_destructor(void * result);\n\n\nstatic int\nmailimf_struct_multiple_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, clist ** result,\n\t\t\t      mailimf_struct_parser * parser,\n\t\t\t      mailimf_struct_destructor * destructor)\n{\n  clist * struct_list;\n  size_t cur_token;\n  void * value;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = parser(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  struct_list = clist_new();\n  if (struct_list == NULL) {\n    destructor(value);\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  r = clist_append(struct_list, value);\n  if (r < 0) {\n    destructor(value);\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  while (1) {\n    r = parser(message, length, &cur_token, &value);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else {\n\tres = r;\n\tgoto free;\n      }\n    }\n    r = clist_append(struct_list, value);\n    if (r < 0) {\n      (* destructor)(value);\n      res = MAILIMF_ERROR_MEMORY;\n      goto free;\n    }\n  }\n\n  * result = struct_list;\n  * indx = cur_token;\n  \n  return MAILIMF_NO_ERROR;\n\n free:\n  clist_foreach(struct_list, (clist_func) destructor, NULL);\n  clist_free(struct_list);\n err:\n  return res;\n}\n\n\n\nstatic int\nmailimf_struct_list_parse(const char * message, size_t length,\n\t\t\t  size_t * indx, clist ** result,\n\t\t\t  char symbol,\n\t\t\t  mailimf_struct_parser * parser,\n\t\t\t  mailimf_struct_destructor * destructor)\n{\n  clist * struct_list;\n  size_t cur_token;\n  void * value;\n  size_t final_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = parser(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  struct_list = clist_new();\n  if (struct_list == NULL) {\n    destructor(value);\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  r = clist_append(struct_list, value);\n  if (r < 0) {\n    destructor(value);\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  final_token = cur_token;\n\n  while (1) {\n    r = mailimf_unstrict_char_parse(message, length, &cur_token, symbol);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else {\n\tres = r;\n\tgoto free;\n      }\n    }\n\n    r = parser(message, length, &cur_token, &value);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else {\n\tres = r;\n\tgoto free;\n      }\n    }\n\n    r = clist_append(struct_list, value);\n    if (r < 0) {\n      destructor(value);\n      res = MAILIMF_ERROR_MEMORY;\n      goto free;\n    }\n\n    final_token = cur_token;\n  }\n  \n  * result = struct_list;\n  * indx = final_token;\n  \n  return MAILIMF_NO_ERROR;\n  \n free:\n  clist_foreach(struct_list, (clist_func) destructor, NULL);\n  clist_free(struct_list);\n err:\n  return res;\n}\n\nstatic inline int mailimf_wsp_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx)\n{\n  size_t cur_token;\n\n  cur_token = * indx;\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if ((message[cur_token] != ' ') && (message[cur_token] != '\\t'))\n    return MAILIMF_ERROR_PARSE;\n\n  cur_token ++;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\nLIBETPAN_EXPORT\nint mailimf_crlf_parse(const char * message, size_t length, size_t * indx)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_char_parse(message, length, &cur_token, '\\r');\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_char_parse(message, length, &cur_token, '\\n');\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n  return MAILIMF_NO_ERROR;\n}\n\nstatic int mailimf_unstrict_crlf_parse(const char * message,\n\t\t\t\t       size_t length, size_t * indx)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  mailimf_cfws_parse(message, length, &cur_token);\n\n  r = mailimf_char_parse(message, length, &cur_token, '\\r');\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_char_parse(message, length, &cur_token, '\\n');\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n  return MAILIMF_NO_ERROR;\n}\n\n/* ************************************************************************ */\n\n\n\n/* RFC 2822 grammar */\n\n/*\nNO-WS-CTL       =       %d1-8 /         ; US-ASCII control characters\n                        %d11 /          ;  that do not include the\n                        %d12 /          ;  carriage return, line feed,\n                        %d14-31 /       ;  and white space characters\n                        %d127\n*/\n\nstatic inline int is_no_ws_ctl(char ch)\n{\n  if ((ch == 9) || (ch == 10) || (ch == 13))\n    return FALSE;\n\n  if (ch == 127)\n     return TRUE;\n\n  return (ch >= 1) && (ch <= 31);\n}\n\n/*\ntext            =       %d1-9 /         ; Characters excluding CR and LF\n                        %d11 /\n                        %d12 /\n                        %d14-127 /\n                        obs-text\n*/\n\n/*\nspecials        =       \"(\" / \")\" /     ; Special characters used in\n                        \"<\" / \">\" /     ;  other parts of the syntax\n                        \"[\" / \"]\" /\n                        \":\" / \";\" /\n                        \"@\" / \"\\\" /\n                        \",\" / \".\" /\n                        DQUOTE\n*/\n\n/*\nquoted-pair     =       (\"\\\" text) / obs-qp\n*/\n\nstatic inline int mailimf_quoted_pair_parse(const char * message, size_t length,\n\t\t\t\t\t    size_t * indx, char * result)\n{\n  size_t cur_token;\n\n  cur_token = * indx;\n  \n  if (cur_token + 1 >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (message[cur_token] != '\\\\')\n    return MAILIMF_ERROR_PARSE;\n\n  cur_token ++;\n  * result = message[cur_token];\n  cur_token ++;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nFWS             =       ([*WSP CRLF] 1*WSP) /   ; Folding white space\n                        obs-FWS\n*/\n\nLIBETPAN_EXPORT\nint mailimf_fws_parse(const char * message, size_t length, size_t * indx)\n{\n  size_t cur_token;\n  size_t final_token;\n  int fws_1;\n  int fws_2;\n  int fws_3;\n  int r;\n  \n  cur_token = * indx;\n\n  fws_1 = FALSE;\n  while (1) {\n    r = mailimf_wsp_parse(message, length, &cur_token);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else\n\treturn r;\n    }\n    fws_1 = TRUE;\n  }\n  final_token = cur_token;\n\n  r = mailimf_crlf_parse(message, length, &cur_token);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    fws_2 = TRUE;\n    break;\n  case MAILIMF_ERROR_PARSE:\n    fws_2 = FALSE;\n    break;\n  default:\n      return r;\n  }\n  \n  fws_3 = FALSE;\n  if (fws_2) {\n    while (1) {\n      r = mailimf_wsp_parse(message, length, &cur_token);\n      if (r != MAILIMF_NO_ERROR) {\n\tif (r == MAILIMF_ERROR_PARSE)\n\t  break;\n\telse\n\t  return r;\n      }\n      fws_3 = TRUE;\n    }\n  }\n\n  if ((!fws_1) && (!fws_3))\n    return MAILIMF_ERROR_PARSE;\n\n  if (!fws_3)\n    cur_token = final_token;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\n/*\nctext           =       NO-WS-CTL /     ; Non white space controls\n\n                        %d33-39 /       ; The rest of the US-ASCII\n                        %d42-91 /       ;  characters not including \"(\",\n                        %d93-126        ;  \")\", or \"\\\"\n*/\n\nstatic inline int is_ctext(char ch)\n{\n  unsigned char uch = (unsigned char) ch;\n\n  if (is_no_ws_ctl(ch))\n    return TRUE;\n\n  if (uch < 33)\n    return FALSE;\n\n  if ((uch == 40) || (uch == 41))\n    return FALSE;\n  \n  if (uch == 92)\n    return FALSE;\n\n  if (uch == 127)\n    return FALSE;\n\n  return TRUE;\n}\n\n/*\nccontent        =       ctext / quoted-pair / comment\n*/\n\nstatic inline int mailimf_ccontent_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx)\n{\n  size_t cur_token;\n  char ch;\n  int r;\n  \n  cur_token = * indx;\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_ctext(message[cur_token])) {\n    cur_token ++;\n  }\n  else {\n    r = mailimf_quoted_pair_parse(message, length, &cur_token, &ch);\n    \n    if (r == MAILIMF_ERROR_PARSE)\n      r = mailimf_comment_parse(message, length, &cur_token);\n    \n    if (r == MAILIMF_ERROR_PARSE)\n      return r;\n  }\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\n[FWS] ccontent\n*/\n\nstatic inline int\nmailimf_comment_fws_ccontent_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_ccontent_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\ncomment         =       \"(\" *([FWS] ccontent) [FWS] \")\"\n*/\n\nstatic inline int mailimf_comment_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_oparenth_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  while (1) {\n    r = mailimf_comment_fws_ccontent_parse(message, length, &cur_token);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else\n\treturn r;\n    }\n  }\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_cparenth_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\n[FWS] comment\n*/\n\nstatic inline int mailimf_cfws_fws_comment_parse(const char * message, size_t length,\n\t\t\t\t\t\t size_t * indx)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_comment_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nCFWS            =       *([FWS] comment) (([FWS] comment) / FWS)\n*/\n\nLIBETPAN_EXPORT\nint mailimf_cfws_parse(const char * message, size_t length,\n\t\t       size_t * indx)\n{\n  size_t cur_token;\n  int has_comment;\n  int r;\n\n  cur_token = * indx;\n\n  has_comment = FALSE;\n  while (1) {\n    r = mailimf_cfws_fws_comment_parse(message, length, &cur_token);\n    if (r != MAILIMF_NO_ERROR) {\n      if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else\n\treturn r;\n    }\n    has_comment = TRUE;\n  }\n\n  if (!has_comment) {\n    r = mailimf_fws_parse(message, length, &cur_token);\n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\natext           =       ALPHA / DIGIT / ; Any character except controls,\n                        \"!\" / \"#\" /     ;  SP, and specials.\n                        \"$\" / \"%\" /     ;  Used for atoms\n                        \"&\" / \"'\" /\n                        \"*\" / \"+\" /\n                        \"-\" / \"/\" /\n                        \"=\" / \"?\" /\n                        \"^\" / \"_\" /\n                        \"`\" / \"{\" /\n                        \"|\" / \"}\" /\n                        \"~\"\n*/\n\nstatic inline int is_atext(char ch)\n{\n  switch (ch) {\n  case ' ':\n  case '\\t':\n  case '\\n':\n  case '\\r':\n#if 0\n  case '(':\n  case ')':\n#endif\n  case '<':\n  case '>':\n#if 0\n  case '@':\n#endif\n  case ',':\n  case '\"':\n  case ':':\n  case ';':\n    return FALSE;\n  default:\n    return TRUE;\n  }\n}\n\n/*\natom            =       [CFWS] 1*atext [CFWS]\n*/\n\nLIBETPAN_EXPORT\nint mailimf_atom_parse(const char * message, size_t length,\n\t\t       size_t * indx, char ** result)\n{\n  size_t cur_token;\n  int r;\n  int res;\n  char * atom;\n  size_t end;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  \n  end = cur_token;\n  if (end >= length) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  while (is_atext(message[end])) {\n    end ++;\n    if (end >= length)\n      break;\n  }\n  if (end == cur_token) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  atom = malloc(end - cur_token + 1);\n  if (atom == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n  strncpy(atom, message + cur_token, end - cur_token);\n  atom[end - cur_token] = '\\0';\n\n  cur_token = end;\n\n  * indx = cur_token;\n  * result = atom;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  return res;\n}\n\nLIBETPAN_EXPORT\nstatic int mailimf_fws_atom_for_word_parse(const char * message, size_t length,\n                                           size_t * indx, char ** result, int * p_missing_closing_quote)\n{\n  size_t end;\n  size_t cur_token;\n  int r;\n  int res;\n  struct mailmime_encoded_word * word;\n  int has_fwd;\n  int missing_closing_quote;\n  char * atom;\n  \n  cur_token = * indx;\n  missing_closing_quote = 0;\n  \n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  \n  end = cur_token;\n  \n  r = mailmime_encoded_word_parse(message, length, &cur_token, &word, &has_fwd, &missing_closing_quote);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  \n  if (r == MAILIMF_ERROR_PARSE) {\n    return mailimf_fws_atom_parse(message, length, indx, result);\n  }\n  \n  mailmime_encoded_word_free(word);\n  \n  atom = malloc(cur_token - end + 1);\n  if (atom == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n  strncpy(atom, message + end, cur_token - end);\n  atom[cur_token - end] = '\\0';\n  \n  * result = atom;\n  * indx = cur_token;\n  * p_missing_closing_quote = missing_closing_quote;\n  \n  return MAILIMF_NO_ERROR;\n  \nerr:\n  return res;\n}\n\nLIBETPAN_EXPORT\nint mailimf_fws_atom_parse(const char * message, size_t length,\n\t\t\t   size_t * indx, char ** result)\n{\n  size_t cur_token;\n  int r;\n  int res;\n  char * atom;\n  size_t end;\n\n  cur_token = * indx;\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  end = cur_token;\n  if (end >= length) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  while (is_atext(message[end])) {\n    end ++;\n    if (end >= length)\n      break;\n  }\n  if (end == cur_token) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  atom = malloc(end - cur_token + 1);\n  if (atom == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n  strncpy(atom, message + cur_token, end - cur_token);\n  atom[end - cur_token] = '\\0';\n\n  cur_token = end;\n\n  * indx = cur_token;\n  * result = atom;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  return res;\n}\n\n/*\ndot-atom        =       [CFWS] dot-atom-text [CFWS]\n*/\n\n#if 0\nstatic int mailimf_dot_atom_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, char ** result)\n{\n  return mailimf_atom_parse(message, length, indx, result);\n}\n#endif\n\n/*\ndot-atom-text   =       1*atext *(\".\" 1*atext)\n*/\n\n#if 0\nstatic int\nmailimf_dot_atom_text_parse(const char * message, size_t length,\n\t\t\t    size_t * indx, char ** result)\n{\n  return mailimf_atom_parse(message, length, indx, result);\n}\n#endif\n\n/*\nqtext           =       NO-WS-CTL /     ; Non white space controls\n\n                        %d33 /          ; The rest of the US-ASCII\n                        %d35-91 /       ;  characters not including \"\\\"\n                        %d93-126        ;  or the quote character\n*/\n\nstatic inline int is_qtext(char ch)\n{\n  unsigned char uch = (unsigned char) ch;\n\n  if (is_no_ws_ctl(ch))\n    return TRUE;\n\n  if (uch < 33)\n    return FALSE;\n\n  if (uch == 34)\n    return FALSE;\n\n  if (uch == 92)\n    return FALSE;\n\n  if (uch == 127)\n    return FALSE;\n\n  return TRUE;\n}\n\n/*\nqcontent        =       qtext / quoted-pair\n*/\n\nstatic int mailimf_qcontent_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, char * result)\n{\n  size_t cur_token;\n  char ch;\n  int r;\n\n  cur_token = * indx;\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_qtext(message[cur_token])) {\n    ch = message[cur_token];\n    cur_token ++;\n  }\n  else {\n    r = mailimf_quoted_pair_parse(message, length, &cur_token, &ch);\n    \n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n  \n  * result = ch;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nquoted-string   =       [CFWS]\n                        DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                        [CFWS]\n*/\n\nLIBETPAN_EXPORT\nint mailimf_quoted_string_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, char ** result)\n{\n  size_t cur_token;\n  MMAPString * gstr;\n  char ch;\n  char * str;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  gstr = mmap_string_new(\"\");\n  if (gstr == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n#if 0\n  if (mmap_string_append_c(gstr, '\\\"') == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n#endif\n\n  while (1) {\n    r = mailimf_fws_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR) {\n      if (mmap_string_append_c(gstr, ' ') == NULL) {\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free_gstr;\n      }\n    }\n    else if (r != MAILIMF_ERROR_PARSE) {\n      res = r;\n      goto free_gstr;\n    }\n\n    r = mailimf_qcontent_parse(message, length, &cur_token, &ch);\n    if (r == MAILIMF_NO_ERROR) {\n      if (mmap_string_append_c(gstr, ch) == NULL) {\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free_gstr;\n      }\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      res = r;\n      goto free_gstr;\n    }\n  }\n\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_gstr;\n  }\n\n#if 0\n  if (mmap_string_append_c(gstr, '\\\"') == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n#endif\n\n  str = strdup(gstr->str);\n  if (str == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n  mmap_string_free(gstr);\n\n  * indx = cur_token;\n  * result = str;\n\n  return MAILIMF_NO_ERROR;\n\n free_gstr:\n  mmap_string_free(gstr);\n err:\n  return res;\n}\n\nLIBETPAN_EXPORT\nint mailimf_fws_quoted_string_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, char ** result)\n{\n  size_t cur_token;\n  MMAPString * gstr;\n  char ch;\n  char * str;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  gstr = mmap_string_new(\"\");\n  if (gstr == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n#if 0\n  if (mmap_string_append_c(gstr, '\\\"') == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n#endif\n\n  while (1) {\n    r = mailimf_fws_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR) {\n      if (mmap_string_append_c(gstr, ' ') == NULL) {\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free_gstr;\n      }\n    }\n    else if (r != MAILIMF_ERROR_PARSE) {\n      res = r;\n      goto free_gstr;\n    }\n\n    r = mailimf_qcontent_parse(message, length, &cur_token, &ch);\n    if (r == MAILIMF_NO_ERROR) {\n      if (mmap_string_append_c(gstr, ch) == NULL) {\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free_gstr;\n      }\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      res = r;\n      goto free_gstr;\n    }\n  }\n\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_gstr;\n  }\n\n#if 0\n  if (mmap_string_append_c(gstr, '\\\"') == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n#endif\n\n  str = strdup(gstr->str);\n  if (str == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_gstr;\n  }\n  mmap_string_free(gstr);\n\n  * indx = cur_token;\n  * result = str;\n\n  return MAILIMF_NO_ERROR;\n\n free_gstr:\n  mmap_string_free(gstr);\n err:\n  return res;\n}\n\n/*\nword            =       atom / quoted-string\n*/\n\nLIBETPAN_EXPORT\nint mailimf_word_parse(const char * message, size_t length,\n\t\t       size_t * indx, char ** result)\n{\n  size_t cur_token;\n  char * word;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_atom_parse(message, length, &cur_token, &word);\n\n  if (r == MAILIMF_ERROR_PARSE)\n    r = mailimf_quoted_string_parse(message, length, &cur_token, &word);\n\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = word;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\nLIBETPAN_EXPORT\nint mailimf_fws_word_parse(const char * message, size_t length,\n\t\t\t   size_t * indx, char ** result, int * p_missing_closing_quote)\n{\n  size_t cur_token;\n  char * word;\n  int r;\n  int missing_closing_quote;\n\n  cur_token = * indx;\n  missing_closing_quote = 0;\n\n  r = mailimf_fws_atom_for_word_parse(message, length, &cur_token, &word, &missing_closing_quote);\n\n  if (r == MAILIMF_ERROR_PARSE)\n    r = mailimf_fws_quoted_string_parse(message, length, &cur_token, &word);\n\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = word;\n  * indx = cur_token;\n  * p_missing_closing_quote = missing_closing_quote;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nphrase          =       1*word / obs-phrase\n*/\n\nstatic int mailimf_phrase_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, char ** result)\n{\n  MMAPString * gphrase;\n  char * word;\n  int first;\n  size_t cur_token;\n  int r;\n  int res;\n  char * str;\n  int has_missing_closing_quote;\n\n  cur_token = * indx;\n  has_missing_closing_quote = 0;\n\n  gphrase = mmap_string_new(\"\");\n  if (gphrase == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  first = TRUE;\n\n  while (1) {\n    int missing_quote = 0;\n    r = mailimf_fws_word_parse(message, length, &cur_token, &word, &missing_quote);\n    if (missing_quote) {\n      has_missing_closing_quote = 1;\n    }\n    if (r == MAILIMF_NO_ERROR) {\n      if (!first) {\n\tif (mmap_string_append_c(gphrase, ' ') == NULL) {\n\t  mailimf_word_free(word);\n\t  res = MAILIMF_ERROR_MEMORY;\n\t  goto free;\n\t}\n      }\n      if (mmap_string_append(gphrase, word) == NULL) {\n\tmailimf_word_free(word);\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free;\n      }\n      mailimf_word_free(word);\n      first = FALSE;\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      res = r;\n      goto free;\n    }\n  }\n\n  if (first) {\n    res = MAILIMF_ERROR_PARSE;\n    goto free;\n  }\n\n  if (has_missing_closing_quote) {\n    r = mailimf_char_parse(message, length, &cur_token, '\\\"');\n  }\n\n  str = strdup(gphrase->str);\n  if (str == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n  mmap_string_free(gphrase);\n\n  * result = str;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  mmap_string_free(gphrase);\n err:\n  return res;\n}\n\n/*\nutext           =       NO-WS-CTL /     ; Non white space controls\n                        %d33-126 /      ; The rest of US-ASCII\n                        obs-utext\n\nadded : WSP\n*/\n\nenum {\n  UNSTRUCTURED_START,\n  UNSTRUCTURED_CR,\n  UNSTRUCTURED_LF,\n  UNSTRUCTURED_WSP,\n  UNSTRUCTURED_OUT\n};\n\nstatic int mailimf_unstructured_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx, char ** result)\n{\n  size_t cur_token;\n  int state;\n  size_t begin;\n  size_t terminal;\n  char * str;\n\n  cur_token = * indx;\n\n\n  while (1) {\n    int r;\n\n    r = mailimf_wsp_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR) {\n      /* do nothing */\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      return r;\n    }\n  }\n\n  state = UNSTRUCTURED_START;\n  begin = cur_token;\n  terminal = cur_token;\n\n  while (state != UNSTRUCTURED_OUT) {\n\n    switch(state) {\n    case UNSTRUCTURED_START:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      terminal = cur_token;\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_CR:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      switch(message[cur_token]) {\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n\n    case UNSTRUCTURED_LF:\n      if (cur_token >= length) {\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n\n      switch(message[cur_token]) {\n      case '\\t':\n      case ' ':\n\tstate = UNSTRUCTURED_WSP;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_WSP:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    }\n\n    cur_token ++;\n  }\n\n  str = malloc(terminal - begin + 1);\n  if (str == NULL)\n    return MAILIMF_ERROR_MEMORY;\n  strncpy(str, message + begin,  terminal - begin);\n  str[terminal - begin] = '\\0';\n\n  * indx = terminal;\n  * result = str;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\nstatic int mailimf_ignore_unstructured_parse(const char * message, size_t length,\n\t\t\t\t\t     size_t * indx)\n{\n  size_t cur_token;\n  int state;\n  size_t terminal;\n\n  cur_token = * indx;\n\n  state = UNSTRUCTURED_START;\n  terminal = cur_token;\n\n  while (state != UNSTRUCTURED_OUT) {\n\n    switch(state) {\n    case UNSTRUCTURED_START:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n      terminal = cur_token;\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_CR:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n      switch(message[cur_token]) {\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_LF:\n      if (cur_token >= length) {\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n      switch(message[cur_token]) {\n      case '\\t':\n      case ' ':\n\tstate = UNSTRUCTURED_WSP;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_WSP:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    }\n\n    cur_token ++;\n  }\n\n  * indx = terminal;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\nLIBETPAN_EXPORT\nint mailimf_ignore_field_parse(const char * message, size_t length,\n\t\t\t       size_t * indx)\n{\n  int has_field;\n  size_t cur_token;\n  int state;\n  size_t terminal;\n\n  has_field = FALSE;\n  cur_token = * indx;\n\n  terminal = cur_token;\n  state = UNSTRUCTURED_START;\n\n  /* check if this is not a beginning CRLF */\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  switch (message[cur_token]) {\n  case '\\r':\n    return MAILIMF_ERROR_PARSE;\n  case '\\n':\n    return MAILIMF_ERROR_PARSE;\n  }\n\n  while (state != UNSTRUCTURED_OUT) {\n\n    switch(state) {\n    case UNSTRUCTURED_START:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      case ':':\n\thas_field = TRUE;\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_CR:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      switch(message[cur_token]) {\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      case ':':\n\thas_field = TRUE;\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_LF:\n      if (cur_token >= length) {\n\tterminal = cur_token;\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n\n      switch(message[cur_token]) {\n      case '\\t':\n      case ' ':\n\tstate = UNSTRUCTURED_WSP;\n\tbreak;\n      default:\n\tterminal = cur_token;\n\tstate = UNSTRUCTURED_OUT;\n\tbreak;\n      }\n      break;\n    case UNSTRUCTURED_WSP:\n      if (cur_token >= length)\n\treturn MAILIMF_ERROR_PARSE;\n\n      switch(message[cur_token]) {\n      case '\\r':\n\tstate = UNSTRUCTURED_CR;\n\tbreak;\n      case '\\n':\n\tstate = UNSTRUCTURED_LF;\n\tbreak;\n      case ':':\n\thas_field = TRUE;\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      default:\n\tstate = UNSTRUCTURED_START;\n\tbreak;\n      }\n      break;\n    }\n\n    cur_token ++;\n  }\n\n  if (!has_field)\n    return MAILIMF_ERROR_PARSE;\n\n  * indx = terminal;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\n/*\ndate-time       =       [ day-of-week \",\" ] date FWS time [CFWS]\n*/\n\nLIBETPAN_EXPORT\nint mailimf_date_time_parse(const char * message, size_t length,\n\t\t\t    size_t * indx,\n\t\t\t    struct mailimf_date_time ** result)\n{\n  size_t cur_token;\n  int day_of_week;\n  struct mailimf_date_time * date_time;\n  int day;\n  int month;\n  int year;\n  int hour;\n  int min;\n  int sec;\n  int zone;\n  int r;\n\n  cur_token = * indx;\n\n  day_of_week = -1;\n  r = mailimf_day_of_week_parse(message, length, &cur_token, &day_of_week);\n  if (r == MAILIMF_NO_ERROR) {\n    r = mailimf_comma_parse(message, length, &cur_token);\n    if (r == MAILIMF_ERROR_PARSE) {\n      // ignore parse error.\n    }\n    else if (r != MAILIMF_NO_ERROR) {\n      return r;\n    }\n  }\n  else if (r != MAILIMF_ERROR_PARSE)\n    return r;\n\n  day = 0;\n  month = 0;\n  year = 0;\n  r = mailimf_date_parse(message, length, &cur_token, &day, &month, &year);\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_broken_date_parse(message, length, &cur_token, &day, &month, &year);\n  }\n  else if (r != MAILIMF_NO_ERROR) {\n    return r;\n  }\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n  \n  hour = 0;\n  min = 0;\n  sec = 0;\n  zone = 0;\n  r = mailimf_time_parse(message, length, &cur_token,\n\t\t\t &hour, &min, &sec, &zone);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  date_time = mailimf_date_time_new(day, month, year, hour, min, sec, zone);\n  if (date_time == NULL)\n    return MAILIMF_ERROR_MEMORY;\n\n  * indx = cur_token;\n  * result = date_time;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nday-of-week     =       ([FWS] day-name) / obs-day-of-week\n*/\n\nstatic int mailimf_day_of_week_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx, int * result)\n{\n  size_t cur_token;\n  int day_of_week;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_day_name_parse(message, length, &cur_token, &day_of_week);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n  * result = day_of_week;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nday-name        =       \"Mon\" / \"Tue\" / \"Wed\" / \"Thu\" /\n                        \"Fri\" / \"Sat\" / \"Sun\"\n*/\n\nstruct mailimf_token_value {\n  int value;\n  char * str;\n};\n\nstatic struct mailimf_token_value day_names[] = {\n  {1, \"Mon\"},\n  {2, \"Tue\"},\n  {3, \"Wed\"},\n  {4, \"Thu\"},\n  {5, \"Fri\"},\n  {6, \"Sat\"},\n  {7, \"Sun\"},\n};\n\nenum {\n  DAY_NAME_START,\n  DAY_NAME_T,\n  DAY_NAME_S\n};\n\nstatic int guess_day_name(const char * message, size_t length, size_t indx)\n{\n  int state;\n\n  state = DAY_NAME_START;\n\n  while (1) {\n\n    if (indx >= length)\n      return -1;\n\n    switch(state) {\n    case DAY_NAME_START:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'M': /* Mon */\n\treturn 1;\n\tbreak;\n      case 'T': /* Tue Thu */\n\tstate = DAY_NAME_T;\n\tbreak;\n      case 'W': /* Wed */\n\treturn 3;\n      case 'F':\n\treturn 5;\n      case 'S': /* Sat Sun */\n\tstate = DAY_NAME_S;\n\tbreak;\n      default:\n\treturn -1;\n      }\n      break;\n    case DAY_NAME_T:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'U':\n\treturn 2;\n      case 'H':\n\treturn 4;\n      default:\n\treturn -1;\n      }\n      break;\n    case DAY_NAME_S:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'A':\n\treturn 6;\n      case 'U':\n\treturn 7;\n      default:\n\treturn -1;\n      }\n      break;\n    }\n\n    indx ++;\n  }\n}\n\nstatic int mailimf_day_name_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, int * result)\n{\n  size_t cur_token;\n  int day_of_week;\n  int guessed_day;\n  int r;\n\n  cur_token = * indx;\n\n  guessed_day = guess_day_name(message, length, cur_token);\n  if (guessed_day == -1)\n    return MAILIMF_ERROR_PARSE;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token,\n\t\t\t\t\t   day_names[guessed_day - 1].str);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  day_of_week = guessed_day;\n\n  * result = day_of_week;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\ndate            =       day month year\n*/\n\nstatic int mailimf_date_parse(const char * message, size_t length,\n\t\t\t      size_t * indx,\n\t\t\t      int * pday, int * pmonth, int * pyear)\n{\n  size_t cur_token;\n  int day;\n  int month;\n  int year;\n  int r;\n\n  cur_token = * indx;\n\n  day = 1;\n  r = mailimf_day_parse(message, length, &cur_token, &day);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  month = 1;\n  r = mailimf_month_parse(message, length, &cur_token, &month);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  year = 2001;\n  r = mailimf_year_parse(message, length, &cur_token, &year);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * pday = day;\n  * pmonth = month;\n  * pyear = year;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\nstatic int mailimf_broken_date_parse(const char * message, size_t length,\n                                     size_t * indx,\n                                     int * pday, int * pmonth, int * pyear)\n{\n  size_t cur_token;\n  int day;\n  int month;\n  int year;\n  int r;\n\n  cur_token = * indx;\n\n  month = 1;\n  r = mailimf_month_parse(message, length, &cur_token, &month);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  day = 1;\n  r = mailimf_day_parse(message, length, &cur_token, &day);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  year = 2001;\n  r = mailimf_year_parse(message, length, &cur_token, &year);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * pday = day;\n  * pmonth = month;\n  * pyear = year;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nyear            =       4*DIGIT / obs-year\n*/\n\nstatic int mailimf_year_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, int * result)\n{\n  uint32_t number;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_number_parse(message, length, &cur_token, &number);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n  * result = number;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nmonth           =       (FWS month-name FWS) / obs-month\n*/\n\nstatic int mailimf_month_parse(const char * message, size_t length,\n\t\t\t       size_t * indx, int * result)\n{\n  size_t cur_token;\n  int month;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_month_name_parse(message, length, &cur_token, &month);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = month;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nmonth-name      =       \"Jan\" / \"Feb\" / \"Mar\" / \"Apr\" /\n                        \"May\" / \"Jun\" / \"Jul\" / \"Aug\" /\n                        \"Sep\" / \"Oct\" / \"Nov\" / \"Dec\"\n*/\n\nstatic struct mailimf_token_value month_names[] = {\n  {1, \"Jan\"},\n  {2, \"Feb\"},\n  {3, \"Mar\"},\n  {4, \"Apr\"},\n  {5, \"May\"},\n  {6, \"Jun\"},\n  {7, \"Jul\"},\n  {8, \"Aug\"},\n  {9, \"Sep\"},\n  {10, \"Oct\"},\n  {11, \"Nov\"},\n  {12, \"Dec\"},\n};\n\nenum {\n  MONTH_START,\n  MONTH_J,\n  MONTH_JU,\n  MONTH_M,\n  MONTH_MA,\n  MONTH_A\n};\n\nstatic int guess_month(const char * message, size_t length, size_t indx)\n{\n  int state;\n\n  state = MONTH_START;\n\n  while (1) {\n\n    if (indx >= length)\n      return -1;\n\n    switch(state) {\n    case MONTH_START:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'J': /* Jan Jun Jul */\n\tstate = MONTH_J;\n\tbreak;\n      case 'F': /* Feb */\n\treturn 2;\n      case 'M': /* Mar May */\n\tstate = MONTH_M;\n\tbreak;\n      case 'A': /* Apr Aug */\n\tstate = MONTH_A;\n\tbreak;\n      case 'S': /* Sep */\n\treturn 9;\n      case 'O': /* Oct */\n\treturn 10;\n      case 'N': /* Nov */\n\treturn 11;\n      case 'D': /* Dec */\n\treturn 12;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_J:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'A':\n\treturn 1;\n      case 'U':\n\tstate = MONTH_JU;\n\tbreak;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_JU:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'N':\n\treturn 6;\n      case 'L':\n\treturn 7;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_M:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'A':\n\tstate = MONTH_MA;\n\tbreak;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_MA:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'Y':\n\treturn 5;\n      case 'R':\n\treturn 3;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_A:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'P':\n\treturn 4;\n      case 'U':\n\treturn 8;\n      default:\n\treturn -1;\n      }\n      break;\n    }\n\n    indx ++;\n  }\n}\n\nstatic int mailimf_month_name_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, int * result)\n{\n  size_t cur_token;\n  int month;\n  int guessed_month;\n  int r;\n\n  cur_token = * indx;\n\n  guessed_month = guess_month(message, length, cur_token);\n  if (guessed_month == -1)\n    return MAILIMF_ERROR_PARSE;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token,\n\t\t\t\t\t   month_names[guessed_month - 1].str);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  month = guessed_month;\n\n  * result = month;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nday             =       ([FWS] 1*2DIGIT) / obs-day\n*/\n\nstatic int mailimf_day_parse(const char * message, size_t length,\n\t\t\t     size_t * indx, int * result)\n{\n  size_t cur_token;\n  uint32_t day;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_number_parse(message, length, &cur_token, &day);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = day;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\ntime            =       time-of-day FWS zone\n*/\n\nstatic int mailimf_time_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, \n\t\t\t      int * phour, int * pmin,\n\t\t\t      int * psec,\n\t\t\t      int * pzone)\n{\n  size_t cur_token;\n  int hour;\n  int min;\n  int sec;\n  int zone;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_time_of_day_parse(message, length, &cur_token,\n\t\t\t\t&hour, &min, &sec);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_zone_parse(message, length, &cur_token, &zone);\n  if (r == MAILIMF_NO_ERROR) {\n    /* do nothing */\n  }\n  else if (r == MAILIMF_ERROR_PARSE) {\n    zone = 0;\n  }\n  else {\n    return r;\n  }\n\n  * phour = hour;\n  * pmin = min;\n  * psec = sec;\n  * pzone = zone;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\ntime-of-day     =       hour \":\" minute [ \":\" second ]\n*/\n\nstatic int mailimf_time_of_day_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx,\n\t\t\t\t     int * phour, int * pmin,\n\t\t\t\t     int * psec)\n{\n  int hour;\n  int min;\n  int sec;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_hour_parse(message, length, &cur_token, &hour);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_minute_parse(message, length, &cur_token, &min);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r == MAILIMF_NO_ERROR) {\n    r = mailimf_second_parse(message, length, &cur_token, &sec);\n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n  else if (r == MAILIMF_ERROR_PARSE)\n    sec = 0;\n  else\n    return r;\n\n  * phour = hour;\n  * pmin = min;\n  * psec = sec;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nhour            =       2DIGIT / obs-hour\n*/\n\nstatic int mailimf_hour_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, int * result)\n{\n  uint32_t hour;\n  int r;\n\n  r = mailimf_number_parse(message, length, indx, &hour);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = hour;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nminute          =       2DIGIT / obs-minute\n*/\n\nstatic int mailimf_minute_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, int * result)\n{\n  uint32_t minute;\n  int r;\n\n  r = mailimf_number_parse(message, length, indx, &minute);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = minute;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nsecond          =       2DIGIT / obs-second\n*/\n\nstatic int mailimf_second_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, int * result)\n{\n  uint32_t second;\n  int r;\n\n  r = mailimf_number_parse(message, length, indx, &second);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = second;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nzone            =       (( \"+\" / \"-\" ) 4DIGIT) / obs-zone\n*/\n\n/*\nobs-zone        =       \"UT\" / \"GMT\" /          ; Universal Time\n                                                ; North American UT\n                                                ; offsets\n                        \"EST\" / \"EDT\" /         ; Eastern:  - 5/ - 4\n                        \"CST\" / \"CDT\" /         ; Central:  - 6/ - 5\n                        \"MST\" / \"MDT\" /         ; Mountain: - 7/ - 6\n                        \"PST\" / \"PDT\" /         ; Pacific:  - 8/ - 7\n\n                        %d65-73 /               ; Military zones - \"A\"\n                        %d75-90 /               ; through \"I\" and \"K\"\n                        %d97-105 /              ; through \"Z\", both\n                        %d107-122               ; upper and lower case\n*/\n\nenum {\n  STATE_ZONE_1 = 0,\n  STATE_ZONE_2 = 1,\n  STATE_ZONE_3 = 2,\n  STATE_ZONE_OK  = 3,\n  STATE_ZONE_ERR = 4,\n  STATE_ZONE_CONT = 5\n};\n\nstatic int mailimf_zone_parse(const char * message, size_t length,\n                              size_t * indx, int * result)\n{\n  int zone;\n  int sign;\n  size_t cur_token;\n  int r;\n  uint32_t value;\n\n  cur_token = * indx;\n\n  if (cur_token + 1 < length) {\n    if ((message[cur_token] == 'U') && (message[cur_token + 1] == 'T')) {\n      * result = TRUE;\n      * indx = cur_token + 2;\n\n      return MAILIMF_NO_ERROR;\n    }\n  }\n\n  zone = 0;\n  if (cur_token + 2 < length) {\n    int state;\n\n    state = STATE_ZONE_1;\n\n    while (state <= 2) {\n      switch (state) {\n        case STATE_ZONE_1:\n          switch (message[cur_token]) {\n            case 'G':\n              if (message[cur_token + 1] == 'M' && message[cur_token + 2] == 'T') {\n                if ((cur_token + 3 < length) && ((message[cur_token + 3] == '+') || (message[cur_token + 3] == '-'))) {\n                  cur_token += 3;\n                  state = STATE_ZONE_CONT;\n                }\n                else {\n                  zone = 0;\n                  state = STATE_ZONE_OK;\n                }\n              }\n              else {\n                state = STATE_ZONE_ERR;\n              }\n              break;\n            case 'E':\n              zone = -5;\n              state = STATE_ZONE_2;\n              break;\n            case 'C':\n              zone = -6;\n              state = STATE_ZONE_2;\n              break;\n            case 'M':\n              zone = -7;\n              state = STATE_ZONE_2;\n              break;\n            case 'P':\n              zone = -8;\n              state = STATE_ZONE_2;\n              break;\n            default:\n              state = STATE_ZONE_CONT;\n              break;\n          }\n          break;\n        case STATE_ZONE_2:\n          switch (message[cur_token + 1]) {\n            case 'S':\n              state = STATE_ZONE_3;\n              break;\n            case 'D':\n              zone ++;\n              state = STATE_ZONE_3;\n              break;\n            default:\n              state = STATE_ZONE_ERR;\n              break;\n          }\n          break;\n        case STATE_ZONE_3:\n          if (message[cur_token + 2] == 'T') {\n            zone *= 100;\n            state = STATE_ZONE_OK;\n          }\n          else\n            state = STATE_ZONE_ERR;\n          break;\n      }\n    }\n\n    switch (state) {\n      case STATE_ZONE_OK:\n        * result = zone;\n        * indx = cur_token + 3;\n        return MAILIMF_NO_ERROR;\n\n      case STATE_ZONE_ERR:\n        return MAILIMF_ERROR_PARSE;\n    }\n  }\n\n  sign = 1;\n  r = mailimf_plus_parse(message, length, &cur_token);\n  if (r == MAILIMF_NO_ERROR)\n    sign = 1;\n\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_minus_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      sign = -1;\n  }\n\n  if (r == MAILIMF_NO_ERROR) {\n    /* do nothing */\n  }\n  else if (r == MAILIMF_ERROR_PARSE)\n    sign = 1;\n  else\n    return r;\n\n  r = mailimf_number_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  zone = value * sign;\n\n  * indx = cur_token;\n  * result = zone;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\naddress         =       mailbox / group\n*/\n\nLIBETPAN_EXPORT\nint mailimf_address_parse(const char * message, size_t length,\n\t\t\t  size_t * indx,\n\t\t\t  struct mailimf_address ** result)\n{\n  int type;\n  size_t cur_token;\n  struct mailimf_mailbox * mailbox;\n  struct mailimf_group * group;\n  struct mailimf_address * address;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  mailbox = NULL;\n  group = NULL;\n\n  type = MAILIMF_ADDRESS_ERROR; /* XXX - removes a gcc warning */\n  r = mailimf_group_parse(message, length, &cur_token, &group);\n  if (r == MAILIMF_NO_ERROR)\n    type = MAILIMF_ADDRESS_GROUP;\n  \n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_mailbox_parse(message, length, &cur_token, &mailbox);\n    if (r == MAILIMF_NO_ERROR)\n      type = MAILIMF_ADDRESS_MAILBOX;\n  }\n\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  address = mailimf_address_new(type, mailbox, group);\n  if (address == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = address;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n  \n free:\n  if (mailbox != NULL)\n    mailimf_mailbox_free(mailbox);\n  if (group != NULL)\n    mailimf_group_free(group);\n err:\n  return res;\n}\n\n\n/*\nmailbox         =       name-addr / addr-spec\n*/\n\n\nLIBETPAN_EXPORT\nint mailimf_mailbox_parse(const char * message, size_t length,\n\t\t\t  size_t * indx,\n\t\t\t  struct mailimf_mailbox ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox * mailbox;\n  char * addr_spec;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  display_name = NULL;\n  addr_spec = NULL;\n\n  r = mailimf_name_addr_parse(message, length, &cur_token,\n\t\t\t      &display_name, &addr_spec);\n  if (r == MAILIMF_ERROR_PARSE)\n    r = mailimf_addr_spec_parse(message, length, &cur_token, &addr_spec);\n\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  mailbox = mailimf_mailbox_new(display_name, addr_spec);\n  if (mailbox == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = mailbox;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (display_name != NULL)\n    mailimf_display_name_free(display_name);\n  if (addr_spec != NULL)\n    mailimf_addr_spec_free(addr_spec);\n err:\n  return res;\n}\n\n/*\nname-addr       =       [display-name] angle-addr\n*/\n\nstatic int mailimf_name_addr_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx,\n\t\t\t\t   char ** pdisplay_name,\n\t\t\t\t   char ** pangle_addr)\n{\n  char * display_name;\n  char * angle_addr;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  display_name = NULL;\n  angle_addr = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_angle_addr_parse(message, length, &cur_token, &angle_addr);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  * pdisplay_name = display_name;\n  * pangle_addr = angle_addr;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_display_name:\n  if (display_name != NULL)\n    mailimf_display_name_free(display_name);\n err:\n  return res;\n}\n\n/*\nangle-addr      =       [CFWS] \"<\" addr-spec \">\" [CFWS] / obs-angle-addr\n*/\n\nstatic int mailimf_angle_addr_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, char ** result)\n{\n  size_t cur_token;\n  char * addr_spec;\n  int r;\n  \n  cur_token = * indx;\n  \n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n  \n  r = mailimf_lower_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n  \n  r = mailimf_addr_spec_parse(message, length, &cur_token, &addr_spec);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n  \n  r = mailimf_greater_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    free(addr_spec);\n    return r;\n  }\n\n  * result = addr_spec;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\ngroup           =       display-name \":\" [mailbox-list / CFWS] \";\"\n                        [CFWS]\n*/\n\nstatic int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n  struct mailimf_group * group;\n  int r;\n  int res;\n  clist * list;\n\n  cur_token = * indx;\n\n  mailbox_list = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto free_display_name;\n    }\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_display_name;\n    }\n    mailbox_list = mailimf_mailbox_list_new(list);\n    if (mailbox_list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      clist_free(list);\n      goto free_display_name;\n    }\n    break;\n  default:\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n\n  * indx = cur_token;\n  * result = group;\n\n  return MAILIMF_NO_ERROR;\n\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}\n\n/*\ndisplay-name    =       phrase\n*/\n\nstatic int mailimf_display_name_parse(const char * message, size_t length,\n\t\t\t\t      size_t * indx, char ** result)\n{\n  return mailimf_phrase_parse(message, length, indx, result);\n}\n\n/*\nmailbox-list    =       (mailbox *(\",\" mailbox)) / obs-mbox-list\n*/\n\nLIBETPAN_EXPORT\nint\nmailimf_mailbox_list_parse(const char * message, size_t length,\n\t\t\t   size_t * indx,\n\t\t\t   struct mailimf_mailbox_list ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_mailbox_list * mailbox_list;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_struct_list_parse(message, length, \n\t\t\t\t&cur_token, &list, ',',\n\t\t\t\t(mailimf_struct_parser *)\n\t\t\t\tmailimf_mailbox_parse,\n\t\t\t\t(mailimf_struct_destructor *)\n\t\t\t\tmailimf_mailbox_free);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  mailbox_list = mailimf_mailbox_list_new(list);\n  if (mailbox_list == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = mailbox_list;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(list, (clist_func) mailimf_mailbox_free, NULL);\n  clist_free(list);\n err:\n  return res;\n}\t\t\t\t   \n\n/*\naddress-list    =       (address *(\",\" address)) / obs-addr-list\n*/\n\n\nLIBETPAN_EXPORT\nint\nmailimf_address_list_parse(const char * message, size_t length,\n\t\t\t   size_t * indx,\n\t\t\t   struct mailimf_address_list ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_address_list * address_list;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_struct_list_parse(message, length,\n\t\t\t\t&cur_token, &list, ',',\n\t\t\t\t(mailimf_struct_parser *)\n\t\t\t\tmailimf_address_parse,\n\t\t\t\t(mailimf_struct_destructor *)\n\t\t\t\tmailimf_address_free);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  address_list = mailimf_address_list_new(list);\n  if (address_list == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = address_list;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(list, (clist_func) mailimf_address_free, NULL);\n  clist_free(list);\n err:\n  return res;\n}\t\t\t\t   \n\n/*\naddr-spec       =       local-part \"@\" domain\n*/\n\n\nstatic int mailimf_addr_spec_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx,\n\t\t\t\t   char ** result)\n{\n  size_t cur_token;\n#if 0\n  char * local_part;\n  char * domain;\n#endif\n  char * addr_spec;\n  int r;\n  int res;\n  size_t begin;\n  size_t end;\n  int final;\n  size_t count;\n  const char * src;\n  char * dest;\n  size_t i;\n  \n  cur_token = * indx;\n  \n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  end = cur_token;\n  if (end >= length) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  begin = cur_token;\n\n  final = FALSE;\n  while (1) {\n    switch (message[end]) {\n    case '>':\n    case ',':\n    case '\\r':\n    case '\\n':\n    case '(':\n    case ')':\n    case ':':\n    case ';':\n      final = TRUE;\n      break;\n    }\n\n    if (final)\n      break;\n\n    end ++;\n    if (end >= length)\n      break;\n  }\n\n  if (end == begin) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n  \n  addr_spec = malloc(end - cur_token + 1);\n  if (addr_spec == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n  \n  count = end - cur_token;\n  src = message + cur_token;\n  dest = addr_spec;\n  for(i = 0 ; i < count ; i ++) {\n    if ((* src != ' ') && (* src != '\\t')) {\n      * dest = * src;\n      dest ++;\n    }\n    src ++;\n  }\n  * dest = '\\0';\n  \n#if 0\n  strncpy(addr_spec, message + cur_token, end - cur_token);\n  addr_spec[end - cur_token] = '\\0';\n#endif\n\n  cur_token = end;\n\n#if 0\n  r = mailimf_local_part_parse(message, length, &cur_token, &local_part);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_at_sign_parse(message, length, &cur_token);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    r = mailimf_domain_parse(message, length, &cur_token, &domain);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto free_local_part;\n    }\n    break;\n\n  case MAILIMF_ERROR_PARSE:\n    domain = NULL;\n    break;\n\n  default:\n    res = r;\n    goto free_local_part;\n  }\n\n  if (domain) {\n    addr_spec = malloc(strlen(local_part) + strlen(domain) + 2);\n    if (addr_spec == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_domain;\n    }\n    \n    strcpy(addr_spec, local_part);\n    strcat(addr_spec, \"@\");\n    strcat(addr_spec, domain);\n\n    mailimf_domain_free(domain);\n    mailimf_local_part_free(local_part);\n  }\n  else {\n    addr_spec = local_part;\n  }\n#endif\n\n  * result = addr_spec;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n#if 0\n free_domain:\n  mailimf_domain_free(domain);\n free_local_part:\n  mailimf_local_part_free(local_part);\n#endif\n err:\n  return res;\n}\n\n\n/*\n for msg id\n addr-spec       =       local-part \"@\" domain\n */\n\nstatic int mailimf_addr_spec_msg_id_parse(const char * message, size_t length,\n                                          size_t * indx,\n                                          char ** result)\n{\n    size_t cur_token;\n    char * addr_spec;\n    int r;\n    int res;\n    size_t begin;\n    size_t end;\n    int final;\n    size_t count;\n    const char * src;\n    char * dest;\n    size_t i;\n    \n    cur_token = * indx;\n    \n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n        res = r;\n        goto err;\n    }\n    \n    end = cur_token;\n    if (end >= length) {\n        res = MAILIMF_ERROR_PARSE;\n        goto err;\n    }\n    \n    begin = cur_token;\n    \n    final = FALSE;\n    while (1) {\n        switch (message[end]) {\n            case '>':\n            case '\\r':\n            case '\\n':\n                final = TRUE;\n                break;\n        }\n        \n        if (final)\n            break;\n        \n        end ++;\n        if (end >= length)\n            break;\n    }\n    \n    if (end == begin) {\n        res = MAILIMF_ERROR_PARSE;\n        goto err;\n    }\n    \n    addr_spec = malloc(end - cur_token + 1);\n    if (addr_spec == NULL) {\n        res = MAILIMF_ERROR_MEMORY;\n        goto err;\n    }\n    \n    count = end - cur_token;\n    src = message + cur_token;\n    dest = addr_spec;\n    for(i = 0 ; i < count ; i ++) {\n        if ((* src != ' ') && (* src != '\\t')) {\n            * dest = * src;\n            dest ++;\n        }\n        src ++;\n    }\n    * dest = '\\0';\n    \n    cur_token = end;\n    \n    * result = addr_spec;\n    * indx = cur_token;\n    \n    return MAILIMF_NO_ERROR;\n    \nerr:\n    return res;\n}\n\n/*\nlocal-part      =       dot-atom / quoted-string / obs-local-part\n*/\n\n#if 0\nstatic int mailimf_local_part_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx,\n\t\t\t\t    char ** result)\n{\n  int r;\n\n  r = mailimf_dot_atom_parse(message, length, indx, result);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    return r;\n  case MAILIMF_ERROR_PARSE:\n    break;\n  default:\n    return r;\n  }\n\n  r = mailimf_quoted_string_parse(message, length, indx, result);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\ndomain          =       dot-atom / domain-literal / obs-domain\n*/\n\n#if 0\nstatic int mailimf_domain_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx,\n\t\t\t\tchar ** result)\n{\n  int r;\n\n  r = mailimf_dot_atom_parse(message, length, indx, result);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    return r;\n  case MAILIMF_ERROR_PARSE:\n    break;\n  default:\n    return r;\n  }\n\n  r = mailimf_domain_literal_parse(message, length, indx, result);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\n[FWS] dcontent\n*/\n\n#if 0\nstatic int\nmailimf_domain_literal_fws_dcontent_parse(const char * message, size_t length,\n\t\t\t\t\t  size_t * indx)\n{\n  size_t cur_token;\n  char ch;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n  \n  r = mailimf_dcontent_parse(message, length, &cur_token, &ch);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\ndomain-literal  =       [CFWS] \"[\" *([FWS] dcontent) [FWS] \"]\" [CFWS]\n*/\n\n#if 0\nstatic int mailimf_domain_literal_parse(const char * message, size_t length,\n\t\t\t\t\tsize_t * indx, char ** result)\n{\n  size_t cur_token;\n  int len;\n  int begin;\n  char * domain_literal;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  begin = cur_token;\n  r = mailimf_obracket_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  while (1) {\n    r = mailimf_domain_literal_fws_dcontent_parse(message, length,\n\t\t\t\t\t\t  &cur_token);\n    if (r == MAILIMF_NO_ERROR) {\n      /* do nothing */\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else\n      return r;\n  }\n\n  r = mailimf_fws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_cbracket_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  len = cur_token - begin;\n\n  domain_literal = malloc(len + 1);\n  if (domain_literal == NULL)\n    return MAILIMF_ERROR_MEMORY;\n  strncpy(domain_literal, message + begin, len);\n  domain_literal[len] = '\\0';\n\n  * result = domain_literal;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\ndcontent        =       dtext / quoted-pair\n*/\n\n#if 0\nstatic int mailimf_dcontent_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, char * result)\n{\n  size_t cur_token;\n  char ch;\n  int r;\n  \n  cur_token = * indx;\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_dtext(message[cur_token])) {\n    ch = message[cur_token];\n    cur_token ++;\n  }\n  else {\n    r = mailimf_quoted_pair_parse(message, length, &cur_token, &ch);\n    \n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n    \n  * indx = cur_token;\n  * result = ch;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n\n/*\ndtext           =       NO-WS-CTL /     ; Non white space controls\n\n                        %d33-90 /       ; The rest of the US-ASCII\n                        %d94-126        ;  characters not including \"[\",\n                                        ;  \"]\", or \"\\\"\n*/\n\nstatic inline int is_dtext(char ch)\n{\n  unsigned char uch = (unsigned char) ch;\n\n  if (is_no_ws_ctl(ch))\n    return TRUE;\n\n  if (uch < 33)\n    return FALSE;\n\n  if ((uch >= 91) && (uch <= 93))\n    return FALSE;\n\n  if (uch == 127)\n    return FALSE;\n\n  return TRUE;\n}\n\n/*\nmessage         =       (fields / obs-fields)\n                        [CRLF body]\n*/\n\nLIBETPAN_EXPORT\nint mailimf_message_parse(const char * message, size_t length,\n\t\t\t  size_t * indx,\n\t\t\t  struct mailimf_message ** result)\n{\n  struct mailimf_fields * fields;\n  struct mailimf_body * body;\n  struct mailimf_message * msg;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_fields_parse(message, length, &cur_token, &fields);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_crlf_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_body_parse(message, length, &cur_token, &body);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_fields;\n  }\n\n  msg = mailimf_message_new(fields, body);\n  if (msg == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_body;\n  }\n\n  * indx = cur_token;\n  * result = msg;\n\n  return MAILIMF_NO_ERROR;\n\n free_body:\n  mailimf_body_free(body);\n free_fields:\n  mailimf_fields_free(fields);\n err:\n  return res;\n}\n\n/*\nbody            =       *(*998text CRLF) *998text\n*/\n\nLIBETPAN_EXPORT\nint mailimf_body_parse(const char * message, size_t length,\n\t\t       size_t * indx,\n\t\t       struct mailimf_body ** result)\n{\n  size_t cur_token;\n  struct mailimf_body * body;\n\n  cur_token = * indx;\n\n  body = mailimf_body_new(message + cur_token, length - cur_token);\n  if (body == NULL)\n    return MAILIMF_ERROR_MEMORY;\n\n  cur_token = length;\n\n  * result = body;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nCHANGE TO THE RFC 2822\n\noriginal :\n\nfields          =       *(trace\n                          *(resent-date /\n                           resent-from /\n                           resent-sender /\n                           resent-to /\n                           resent-cc /\n                           resent-bcc /\n                           resent-msg-id))\n                        *(orig-date /\n                        from /\n                        sender /\n                        reply-to /\n                        to /\n                        cc /\n                        bcc /\n                        message-id /\n                        in-reply-to /\n                        references /\n                        subject /\n                        comments /\n                        keywords /\n                        optional-field)\n\nINTO THE FOLLOWING :\n*/\n\n/*\nresent-fields-list =      *(resent-date /\n                           resent-from /\n                           resent-sender /\n                           resent-to /\n                           resent-cc /\n                           resent-bcc /\n                           resent-msg-id))\n*/\n\n#if 0\nenum {\n  RESENT_HEADER_START,\n};\n\nstatic int guess_resent_header_type(char * message,\n\t\t\t\t    size_t length, size_t indx)\n{\n  int r;\n\n  r = mailimf_token_case_insensitive_parse(message,\n\t\t\t\t\t   length, &indx, \"Resent-\");\n  if (r != MAILIMF_NO_ERROR)\n    return MAILIMF_RESENT_FIELD_NONE;\n  \n  if (indx >= length)\n    return MAILIMF_RESENT_FIELD_NONE;\n\n  switch(toupper(message[indx])) {\n  case 'D':\n    return MAILIMF_RESENT_FIELD_DATE;\n  case 'F':\n    return MAILIMF_RESENT_FIELD_FROM;\n  case 'S':\n    return MAILIMF_RESENT_FIELD_SENDER;\n  case 'T':\n    return MAILIMF_RESENT_FIELD_TO;\n  case 'C':\n    return MAILIMF_RESENT_FIELD_CC;\n  case 'B':\n    return MAILIMF_RESENT_FIELD_BCC;\n  case 'M':\n    return MAILIMF_RESENT_FIELD_MSG_ID;\n  default:\n    return MAILIMF_RESENT_FIELD_NONE;\n  }\n}\n#endif\n\n#if 0\nstatic int\nmailimf_resent_field_parse(const char * message, size_t length,\n\t\t\t   size_t * indx,\n\t\t\t   struct mailimf_resent_field ** result)\n{\n  struct mailimf_orig_date * resent_date;\n  struct mailimf_from * resent_from;\n  struct mailimf_sender * resent_sender;\n  struct mailimf_to* resent_to;\n  struct mailimf_cc * resent_cc;\n  struct mailimf_bcc * resent_bcc;\n  struct mailimf_message_id * resent_msg_id;\n  size_t cur_token;\n  int type;\n  struct mailimf_resent_field * resent_field;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  resent_date = NULL;\n  resent_from = NULL;\n  resent_sender = NULL;\n  resent_to = NULL;\n  resent_cc = NULL;\n  resent_bcc = NULL;\n  resent_msg_id = NULL;\n\n  type = guess_resent_header_type(message, length, cur_token);\n\n  switch(type) {\n  case MAILIMF_RESENT_FIELD_DATE:\n    r = mailimf_resent_date_parse(message, length, &cur_token,\n\t\t\t\t  &resent_date);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_FROM:\n    r = mailimf_resent_from_parse(message, length, &cur_token,\n\t\t\t\t  &resent_from);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_SENDER:\n    r = mailimf_resent_sender_parse(message, length, &cur_token,\n\t\t\t\t    &resent_sender);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_TO:\n    r = mailimf_resent_to_parse(message, length, &cur_token,\n\t\t\t\t&resent_to);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_CC:\n    r= mailimf_resent_cc_parse(message, length, &cur_token,\n\t\t\t       &resent_cc);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_BCC:\n    r = mailimf_resent_bcc_parse(message, length, &cur_token,\n\t\t\t\t &resent_bcc);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_RESENT_FIELD_MSG_ID:\n    r = mailimf_resent_msg_id_parse(message, length, &cur_token,\n\t\t\t\t    &resent_msg_id);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    break;\n  default:\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  resent_field = mailimf_resent_field_new(type, resent_date,\n\t\t\t\t\t  resent_from, resent_sender,\n\t\t\t\t\t  resent_to, resent_cc,\n\t\t\t\t\t  resent_bcc, resent_msg_id);\n  if (resent_field == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_resent;\n  }\n\n  * result = resent_field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_resent:\n  if (resent_msg_id != NULL)\n    mailimf_message_id_free(resent_msg_id);\n  if (resent_bcc != NULL)\n    mailimf_bcc_free(resent_bcc);\n  if (resent_cc != NULL)\n    mailimf_cc_free(resent_cc);\n  if (resent_to != NULL)\n    mailimf_to_free(resent_to);\n  if (resent_sender != NULL)\n    mailimf_sender_free(resent_sender);\n  if (resent_from != NULL)\n    mailimf_from_free(resent_from);\n  if (resent_date != NULL)\n    mailimf_orig_date_free(resent_date);\n err:\n  return res;\n}\n#endif\n\n#if 0\nstatic int\nmailimf_resent_fields_list_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx,\n\t\t\t\t struct mailimf_resent_fields_list ** result)\n{\n  clist * list;\n  size_t cur_token;\n  struct mailimf_resent_fields_list * resent_fields_list;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  list = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token, &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_resent_field_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_resent_field_free);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  resent_fields_list = mailimf_resent_fields_list_new(list);\n  if (resent_fields_list == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = resent_fields_list;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(list, (clist_func) mailimf_resent_field_free, NULL);\n  clist_free(list);\n err:\n  return res;\n}\n#endif\n\n/*\n ([trace]\n  [resent-fields-list])\n*/\n\n#if 0\nstatic int\nmailimf_trace_resent_fields_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_trace_resent_fields ** result)\n{\n  size_t cur_token;\n  struct mailimf_return * return_path;\n  struct mailimf_resent_fields_list * resent_fields;\n  struct mailimf_trace_resent_fields * trace_resent_fields;\n  int res;\n  int r;\n\n  cur_token = * indx;\n\n  return_path = NULL;\n  resent_fields = NULL;\n\n  r = mailimf_return_parse(message, length, &cur_token,\n\t\t\t   &return_path);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_resent_fields_list_parse(message, length, &cur_token,\n\t\t\t\t       &resent_fields);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  if ((return_path == NULL) && (resent_fields == NULL)) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  trace_resent_fields = mailimf_trace_resent_fields_new(return_path,\n\t\t\t\t\t\t\tresent_fields);\n  if (trace_resent_fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_resent_fields;\n  }\n\n  * result = trace_resent_fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_resent_fields:\n  if (resent_fields != NULL)\n    mailimf_resent_fields_list_free(resent_fields);\n  if (return_path != NULL)\n    mailimf_return_free(return_path);\n err:\n  return res;\n}\n#endif\n\n/*\ndelivering-info =       *([trace]\n                          [resent-fields-list])\n*/\n\n#if 0\nstatic int\nmailimf_delivering_info_parse(const char * message, size_t length,\n\t\t\t      size_t * indx,\n\t\t\t      struct mailimf_delivering_info ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_delivering_info * delivering_info;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_trace_resent_fields_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_trace_resent_fields_free);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  delivering_info = mailimf_delivering_info_new(list);\n  if (delivering_info == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = delivering_info;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(list, (clist_func) mailimf_trace_resent_fields_free, NULL);\n  clist_free(list);\n err:\n  return res;\n}\n#endif\n\n/*\nfield           =       delivering-info /\n                        orig-date /\n                        from /\n                        sender /\n                        reply-to /\n                        to /\n                        cc /\n                        bcc /\n                        message-id /\n                        in-reply-to /\n                        references /\n                        subject /\n                        comments /\n                        keywords /\n                        optional-field\n*/\n\nenum {\n  HEADER_START,\n  HEADER_C,\n  HEADER_R,\n  HEADER_RE,\n  HEADER_S,\n  HEADER_RES\n};\n\nstatic int guess_header_type(const char * message, size_t length, size_t indx)\n{\n  int state;\n  int r;\n\n  state = HEADER_START;\n  \n  while (1) {\n\n    if (indx >= length)\n      return MAILIMF_FIELD_NONE;\n\n    switch(state) {\n    case HEADER_START:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'B':\n\treturn MAILIMF_FIELD_BCC;\n      case 'C':\n\tstate = HEADER_C;\n\tbreak;\n      case 'D':\n\treturn MAILIMF_FIELD_ORIG_DATE;\n      case 'F':\n\treturn MAILIMF_FIELD_FROM;\n      case 'I':\n\treturn MAILIMF_FIELD_IN_REPLY_TO;\n      case 'K':\n\treturn MAILIMF_FIELD_KEYWORDS;\n      case 'M':\n\treturn MAILIMF_FIELD_MESSAGE_ID;\n      case 'R':\n\tstate = HEADER_R;\n\tbreak;\n      case 'T':\n\treturn MAILIMF_FIELD_TO;\n\tbreak;\n      case 'S':\n\tstate = HEADER_S;\n\tbreak;\n      default:\n\treturn MAILIMF_FIELD_NONE;\n      }\n      break;\n    case HEADER_C:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'O':\n\treturn MAILIMF_FIELD_COMMENTS;\n      case 'C':\n\treturn MAILIMF_FIELD_CC;\n      default:\n\treturn MAILIMF_FIELD_NONE;\n      }\n      break;\n    case HEADER_R:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'E':\n\tstate = HEADER_RE;\n\tbreak;\n      default:\n\treturn MAILIMF_FIELD_NONE;\n      }\n      break;\n    case HEADER_RE:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'F':\n\treturn MAILIMF_FIELD_REFERENCES;\n      case 'P':\n\treturn MAILIMF_FIELD_REPLY_TO;\n      case 'S':\n        state = HEADER_RES;\n        break;\n      case 'T':\n        return MAILIMF_FIELD_RETURN_PATH;\n      default:\n\treturn MAILIMF_FIELD_NONE;\n      }\n      break;\n    case HEADER_S:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'E':\n\treturn MAILIMF_FIELD_SENDER;\n      case 'U':\n\treturn MAILIMF_FIELD_SUBJECT;\n      default:\n\treturn MAILIMF_FIELD_NONE;\n      }\n      break;\n\n    case HEADER_RES:\n      r = mailimf_token_case_insensitive_parse(message,\n          length, &indx, \"ent-\");\n      if (r != MAILIMF_NO_ERROR)\n        return MAILIMF_FIELD_NONE;\n      \n      if (indx >= length)\n        return MAILIMF_FIELD_NONE;\n      \n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'D':\n        return MAILIMF_FIELD_RESENT_DATE;\n      case 'F':\n        return MAILIMF_FIELD_RESENT_FROM;\n      case 'S':\n        return MAILIMF_FIELD_RESENT_SENDER;\n      case 'T':\n        return MAILIMF_FIELD_RESENT_TO;\n      case 'C':\n        return MAILIMF_FIELD_RESENT_CC;\n      case 'B':\n        return MAILIMF_FIELD_RESENT_BCC;\n      case 'M':\n        return MAILIMF_FIELD_RESENT_MSG_ID;\n      default:\n        return MAILIMF_FIELD_NONE;\n      }\n      break;\n    }\n    indx ++;\n  }\n}\n\nstatic int mailimf_field_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_field ** result)\n{\n  size_t cur_token;\n  int type;\n  struct mailimf_return * return_path;\n  struct mailimf_orig_date * resent_date;\n  struct mailimf_from * resent_from;\n  struct mailimf_sender * resent_sender;\n  struct mailimf_to* resent_to;\n  struct mailimf_cc * resent_cc;\n  struct mailimf_bcc * resent_bcc;\n  struct mailimf_message_id * resent_msg_id;\n  struct mailimf_orig_date * orig_date;\n  struct mailimf_from * from;\n  struct mailimf_sender * sender;\n  struct mailimf_reply_to * reply_to;\n  struct mailimf_to * to;\n  struct mailimf_cc * cc;\n  struct mailimf_bcc * bcc;\n  struct mailimf_message_id * message_id;\n  struct mailimf_in_reply_to * in_reply_to;\n  struct mailimf_references * references;\n  struct mailimf_subject * subject;\n  struct mailimf_comments * comments;\n  struct mailimf_keywords * keywords;\n  struct mailimf_optional_field * optional_field;\n  struct mailimf_field * field;\n  int guessed_type;\n  int r;\n  int res;\n  \n  cur_token = * indx;\n\n  return_path = NULL;\n  resent_date = NULL;\n  resent_from = NULL;\n  resent_sender = NULL;\n  resent_to = NULL;\n  resent_cc = NULL;\n  resent_bcc = NULL;\n  resent_msg_id = NULL;\n  orig_date = NULL;\n  from = NULL;\n  sender = NULL;\n  reply_to = NULL;\n  to = NULL;\n  cc = NULL;\n  bcc = NULL;\n  message_id = NULL;\n  in_reply_to = NULL;\n  references = NULL;\n  subject = NULL;\n  comments = NULL;\n  keywords = NULL;\n  optional_field = NULL;\n\n  guessed_type = guess_header_type(message, length, cur_token);\n  type = MAILIMF_FIELD_NONE;\n\n  switch (guessed_type) {\n  case MAILIMF_FIELD_ORIG_DATE:\n    r = mailimf_orig_date_parse(message, length, &cur_token,\n\t\t\t\t&orig_date);\n    if (r == MAILIMF_NO_ERROR)\n      type = MAILIMF_FIELD_ORIG_DATE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_FROM:\n    r = mailimf_from_parse(message, length, &cur_token,\n\t\t\t   &from);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_SENDER:\n    r = mailimf_sender_parse(message, length, &cur_token,\n\t\t\t     &sender);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_REPLY_TO:\n    r = mailimf_reply_to_parse(message, length, &cur_token,\n\t\t\t       &reply_to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_TO:\n    r = mailimf_to_parse(message, length, &cur_token,\n\t\t\t &to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_CC:\n    r = mailimf_cc_parse(message, length, &cur_token,\n\t\t\t &cc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_BCC:\n    r = mailimf_bcc_parse(message, length, &cur_token,\n\t\t\t  &bcc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_MESSAGE_ID:\n    r = mailimf_message_id_parse(message, length, &cur_token,\n\t\t\t\t &message_id);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_IN_REPLY_TO:\n    r = mailimf_in_reply_to_parse(message, length, &cur_token,\n\t\t\t\t  &in_reply_to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_REFERENCES:\n    r = mailimf_references_parse(message, length, &cur_token,\n\t\t\t\t &references);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_SUBJECT:\n    r = mailimf_subject_parse(message, length, &cur_token,\n\t\t\t      &subject);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_COMMENTS:\n    r = mailimf_comments_parse(message, length, &cur_token,\n\t\t\t       &comments);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_KEYWORDS:\n    r = mailimf_keywords_parse(message, length, &cur_token,\n\t\t\t       &keywords);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RETURN_PATH:\n    r = mailimf_return_parse(message, length, &cur_token,\n        &return_path);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_DATE:\n    r = mailimf_resent_date_parse(message, length, &cur_token,\n\t\t\t\t  &resent_date);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_FROM:\n    r = mailimf_resent_from_parse(message, length, &cur_token,\n\t\t\t\t  &resent_from);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_SENDER:\n    r = mailimf_resent_sender_parse(message, length, &cur_token,\n\t\t\t\t    &resent_sender);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_TO:\n    r = mailimf_resent_to_parse(message, length, &cur_token,\n\t\t\t\t&resent_to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_CC:\n    r= mailimf_resent_cc_parse(message, length, &cur_token,\n\t\t\t       &resent_cc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_BCC:\n    r = mailimf_resent_bcc_parse(message, length, &cur_token,\n\t\t\t\t &resent_bcc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_RESENT_MSG_ID:\n    r = mailimf_resent_msg_id_parse(message, length, &cur_token,\n\t\t\t\t    &resent_msg_id);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  }\n\n  if (type == MAILIMF_FIELD_NONE) {\n    r = mailimf_optional_field_parse(message, length, &cur_token,\n        &optional_field);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n\n    type = MAILIMF_FIELD_OPTIONAL_FIELD;\n  }\n\n  field = mailimf_field_new(type, return_path, resent_date,\n      resent_from, resent_sender, resent_to, resent_cc, resent_bcc,\n      resent_msg_id, orig_date, from, sender, reply_to, to,\n      cc, bcc, message_id, in_reply_to, references,\n      subject, comments, keywords, optional_field);\n  if (field == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_field;\n  }\n\n  * result = field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_field:\n  if (return_path != NULL)\n    mailimf_return_free(return_path);\n  if (resent_date != NULL)\n    mailimf_orig_date_free(resent_date);\n  if (resent_from != NULL)\n    mailimf_from_free(resent_from);\n  if (resent_sender != NULL)\n    mailimf_sender_free(resent_sender);\n  if (resent_to != NULL)\n    mailimf_to_free(resent_to);\n  if (resent_cc != NULL)\n    mailimf_cc_free(resent_cc);\n  if (resent_bcc != NULL)\n    mailimf_bcc_free(resent_bcc);\n  if (resent_msg_id != NULL)\n    mailimf_message_id_free(resent_msg_id);\n  if (orig_date != NULL)\n    mailimf_orig_date_free(orig_date);\n  if (from != NULL)\n    mailimf_from_free(from);\n  if (sender != NULL)\n    mailimf_sender_free(sender);\n  if (reply_to != NULL)\n    mailimf_reply_to_free(reply_to);\n  if (to != NULL)\n    mailimf_to_free(to);\n  if (cc != NULL)\n    mailimf_cc_free(cc);\n  if (bcc != NULL)\n    mailimf_bcc_free(bcc);\n  if (message_id != NULL)\n    mailimf_message_id_free(message_id);\n  if (in_reply_to != NULL)\n    mailimf_in_reply_to_free(in_reply_to);\n  if (references != NULL)\n    mailimf_references_free(references);\n  if (subject != NULL)\n    mailimf_subject_free(subject);\n  if (comments != NULL)\n    mailimf_comments_free(comments);\n  if (keywords != NULL)\n    mailimf_keywords_free(keywords);\n  if (optional_field != NULL)\n    mailimf_optional_field_free(optional_field);\n err:\n  return res;\n}\n\n\n/*\nfields          =       *(delivering-info /\n\t\t\torig-date /\n                        from /\n                        sender /\n                        reply-to /\n                        to /\n                        cc /\n                        bcc /\n                        message-id /\n                        in-reply-to /\n                        references /\n                        subject /\n                        comments /\n                        keywords /\n                        optional-field)\n*/\n\n#if 0\nint\nmailimf_unparsed_fields_parse(const char * message, size_t length,\n\t\t\t      size_t * indx,\n\t\t\t      struct mailimf_unparsed_fields ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_unparsed_fields * fields;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  list = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_optional_field_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_optional_field_free);\n  /*\n  if ((r = MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  */\n\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    /* do nothing */\n    break;\n\n  case MAILIMF_ERROR_PARSE:\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto err;\n    }\n    break;\n\n  default:\n    res = r;\n    goto err;\n  }\n\n  fields = mailimf_unparsed_fields_new(list);\n  if (fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_optional_field_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n#endif\n\nLIBETPAN_EXPORT\nint mailimf_fields_parse(const char * message, size_t length,\n\t\t\t size_t * indx,\n\t\t\t struct mailimf_fields ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_fields * fields;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  list = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_field_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_field_free);\n  /*\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  */\n\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    /* do nothing */\n    break;\n\n  case MAILIMF_ERROR_PARSE:\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto err;\n    }\n    break;\n\n  default:\n    res = r;\n    goto err;\n  }\n\n  fields = mailimf_fields_new(list);\n  if (fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_field_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n\n/*\norig-date       =       \"Date:\" date-time CRLF\n*/\n\n\nstatic int\nmailimf_orig_date_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_orig_date ** result)\n{\n  struct mailimf_date_time * date_time;\n  struct mailimf_orig_date * orig_date;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Date:\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_date_time_parse(message, length, &cur_token, &date_time);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_ignore_unstructured_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_date_time;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_date_time;\n  }\n\n  orig_date = mailimf_orig_date_new(date_time);\n  if (orig_date == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_date_time;\n  }\n\n  * result = orig_date;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_date_time:\n  mailimf_date_time_free(date_time);\n err:\n  return res;\n}\n\n/*\nfrom            =       \"From:\" mailbox-list CRLF\n*/\n\nstatic int\nmailimf_from_parse(const char * message, size_t length,\n\t\t   size_t * indx, struct mailimf_from ** result)\n{\n  struct mailimf_mailbox_list * mb_list;\n  struct mailimf_from * from;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token =  * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"From\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mb_list);\n\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mb_list;\n  }\n\n  from = mailimf_from_new(mb_list);\n  if (from == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mb_list;\n  }\n\n  * result = from;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_mb_list:\n  mailimf_mailbox_list_free(mb_list);\n err:\n  return res;\n}\n\n/*\nsender          =       \"Sender:\" mailbox CRLF\n*/\n\nstatic int\nmailimf_sender_parse(const char * message, size_t length,\n\t\t     size_t * indx, struct mailimf_sender ** result)\n{\n  struct mailimf_mailbox * mb;\n  struct mailimf_sender * sender;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Sender\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_mailbox_parse(message, length, &cur_token, &mb);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mb;\n  }\n\n  sender = mailimf_sender_new(mb);\n  if (sender == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mb;\n  }\n\n  * result = sender;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_mb:\n  mailimf_mailbox_free(mb);\n err:\n  return res;\n}\n\n/*\nreply-to        =       \"Reply-To:\" address-list CRLF\n*/\n\n\nstatic int\nmailimf_reply_to_parse(const char * message, size_t length,\n\t\t       size_t * indx, struct mailimf_reply_to ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_reply_to * reply_to;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Reply-To\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  reply_to = mailimf_reply_to_new(addr_list);\n  if (reply_to == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = reply_to;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\nto              =       \"To:\" address-list CRLF\n*/\n\nstatic int\nmailimf_to_parse(const char * message, size_t length,\n\t\t size_t * indx, struct mailimf_to ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_to * to;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"To\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  to = mailimf_to_new(addr_list);\n  if (to == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = to;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\ncc              =       \"Cc:\" address-list CRLF\n*/\n\n\nstatic int\nmailimf_cc_parse(const char * message, size_t length,\n\t\t size_t * indx, struct mailimf_cc ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_cc * cc;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Cc\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  cc = mailimf_cc_new(addr_list);\n  if (cc == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = cc;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\nbcc             =       \"Bcc:\" (address-list / [CFWS]) CRLF\n*/\n\n\nstatic int\nmailimf_bcc_parse(const char * message, size_t length,\n\t\t  size_t * indx, struct mailimf_bcc ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_bcc * bcc;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  addr_list = NULL;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Bcc\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    /* do nothing */\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto err;\n    }\n    break;\n  default:\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  bcc = mailimf_bcc_new(addr_list);\n  if (bcc == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  * result = bcc;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  if (addr_list != NULL)\n    mailimf_address_list_free(addr_list);\n  return res;\n}\n\n/*\nmessage-id      =       \"Message-ID:\" msg-id CRLF\n*/\n\nstatic int mailimf_message_id_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx,\n\t\t\t\t    struct mailimf_message_id ** result)\n{\n  char * value;\n  size_t cur_token;\n  struct mailimf_message_id * message_id;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Message-ID\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_msg_id_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_value;\n  }\n\n  message_id = mailimf_message_id_new(value);\n  if (message_id == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_value;\n  }\n\n  * result = message_id;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_value:\n  mailimf_msg_id_free(value);\n err:\n  return res;\n}\n\n/*\nin-reply-to     =       \"In-Reply-To:\" 1*msg-id CRLF\n*/\n\nLIBETPAN_EXPORT\nint mailimf_msg_id_list_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, clist ** result)\n{\n  return mailimf_struct_multiple_parse(message, length, indx,\n\t\t\t\t       result,\n\t\t\t\t       (mailimf_struct_parser *)\n\t\t\t\t       mailimf_unstrict_msg_id_parse,\n\t\t\t\t       (mailimf_struct_destructor *)\n\t\t\t\t       mailimf_msg_id_free);\n}\n\nstatic int mailimf_in_reply_to_parse(const char * message, size_t length,\n\t\t\t\t     size_t * indx,\n\t\t\t\t     struct mailimf_in_reply_to ** result)\n{\n  struct mailimf_in_reply_to * in_reply_to;\n  size_t cur_token;\n  clist * msg_id_list;\n  int res;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"In-Reply-To\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_msg_id_list_parse(message, length, &cur_token, &msg_id_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_list;\n  }\n\n  in_reply_to = mailimf_in_reply_to_new(msg_id_list);\n  if (in_reply_to == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = in_reply_to;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(msg_id_list, (clist_func) mailimf_msg_id_free, NULL);\n  clist_free(msg_id_list);\n err:\n  return res;\n}\n\n/*\nreferences      =       \"References:\" 1*msg-id CRLF\n*/\n\nLIBETPAN_EXPORT\nint mailimf_references_parse(const char * message, size_t length,\n\t\t\t     size_t * indx,\n\t\t\t     struct mailimf_references ** result)\n{\n  struct mailimf_references * references;\n  size_t cur_token;\n  clist * msg_id_list;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"References\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_msg_id_list_parse(message, length, &cur_token, &msg_id_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_list;\n  }\n\n  references = mailimf_references_new(msg_id_list);\n  if (references == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = references;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(msg_id_list, (clist_func) mailimf_msg_id_free, NULL);\n  clist_free(msg_id_list);\n err:\n  return res;\n}\n\n/*\nmsg-id          =       [CFWS] \"<\" id-left \"@\" id-right \">\" [CFWS]\n*/\n\nLIBETPAN_EXPORT\nint mailimf_msg_id_parse(const char * message, size_t length,\n\t\t\t size_t * indx,\n\t\t\t char ** result)\n{\n  size_t cur_token;\n#if 0\n  char * id_left;\n  char * id_right;\n#endif\n  char * msg_id;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_lower_parse(message, length, &cur_token);\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_addr_spec_msg_id_parse(message, length, &cur_token, &msg_id);\n    if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n    \n    * result = msg_id;\n    * indx = cur_token;\n    \n    return MAILIMF_NO_ERROR;\n  }\n  else if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  // workaround for mbox mail\n  r = mailimf_lower_parse(message, length, &cur_token);\n  if (r == MAILIMF_NO_ERROR) {\n    // ok\n  }\n  else if (r == MAILIMF_ERROR_PARSE) {\n    // ok\n  }\n  else {\n    res = r;\n    goto err;\n  }\n  r = mailimf_addr_spec_msg_id_parse(message, length, &cur_token, &msg_id);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_greater_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    free(msg_id);\n    res = r;\n    goto err;\n  }\n  r = mailimf_greater_parse(message, length, &cur_token);\n  if (r == MAILIMF_NO_ERROR) {\n    // ok\n  }\n  else if (r == MAILIMF_ERROR_PARSE) {\n    // ok\n  }\n  else {\n    free(msg_id);\n    res = r;\n    goto err;\n  }\n  \n#if 0\n  r = mailimf_id_left_parse(message, length, &cur_token, &id_left);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_at_sign_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_id_left;\n  }\n\n  r = mailimf_id_right_parse(message, length, &cur_token, &id_right);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_id_left;\n  }\n\n  r = mailimf_greater_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_id_right;\n  }\n\n  msg_id = malloc(strlen(id_left) + strlen(id_right) + 2);\n  if (msg_id == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_id_right;\n  }\n  strcpy(msg_id, id_left);\n  strcat(msg_id, \"@\");\n  strcat(msg_id, id_right);\n\n  mailimf_id_left_free(id_left);\n  mailimf_id_right_free(id_right);\n#endif\n\n  * result = msg_id;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n#if 0\n free_id_right:\n  mailimf_id_right_free(id_right);\n free_id_left:\n  mailimf_id_left_free(id_left);\n#endif\n  /*\n free:\n  mailimf_atom_free(msg_id);\n  */\n err:\n  return res;\n}\n\nstatic int mailimf_parse_unwanted_msg_id(const char * message, size_t length,\n\t\t\t\t\t size_t * indx)\n{\n  size_t cur_token;\n  int r;\n  char * word;\n  int token_parsed;\n\n  cur_token = * indx;\n\n  token_parsed = TRUE;\n  while (token_parsed) {\n    token_parsed = FALSE;\n    r = mailimf_word_parse(message, length, &cur_token, &word);\n    if (r == MAILIMF_NO_ERROR) {\n      mailimf_word_free(word);\n      token_parsed = TRUE;\n    }\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_semi_colon_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_comma_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_plus_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_colon_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_point_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n    r = mailimf_at_sign_parse(message, length, &cur_token);\n    if (r == MAILIMF_NO_ERROR)\n      token_parsed = TRUE;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else\n      return r;\n  }\n\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\nstatic int mailimf_unstrict_msg_id_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx,\n\t\t\t\t\t char ** result)\n{\n  char * msgid;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_parse_unwanted_msg_id(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_msg_id_parse(message, length, &cur_token, &msgid);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_parse_unwanted_msg_id(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    free(msgid);\n    return r;\n  }\n\n  * result = msgid;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n/*\nid-left         =       dot-atom-text / no-fold-quote / obs-id-left\n*/\n\n#if 0\nstatic int mailimf_id_left_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx, char ** result)\n{\n  int r;\n\n  r = mailimf_dot_atom_text_parse(message, length, indx, result);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    return MAILIMF_NO_ERROR;\n  case MAILIMF_ERROR_PARSE:\n    break;\n  default:\n    return r;\n  }\n  \n  r = mailimf_no_fold_quote_parse(message, length, indx, result);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\nid-right        =       dot-atom-text / no-fold-literal / obs-id-right\n*/\n\n#if 0\nstatic int mailimf_id_right_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx, char ** result)\n{\n  int r;\n\n  r = mailimf_dot_atom_text_parse(message, length, indx, result);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    return MAILIMF_NO_ERROR;\n  case MAILIMF_ERROR_PARSE:\n    break;\n  default:\n    return r;\n  }\n\n  r = mailimf_no_fold_literal_parse(message, length, indx, result);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n/*\nno-fold-quote   =       DQUOTE *(qtext / quoted-pair) DQUOTE\n*/\n\n#if 0\nstatic int mailimf_no_fold_quote_char_parse(const char * message, size_t length,\n\t\t\t\t\t    size_t * indx, char * result)\n{\n  char ch;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n#if 0\n  r = mailimf_qtext_parse(message, length, &cur_token, &ch);\n#endif\n\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_qtext(message[cur_token])) {\n    ch = message[cur_token];\n    cur_token ++;\n  }\n  else {\n    r = mailimf_quoted_pair_parse(message, length, &cur_token, &ch);\n    \n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n\n  * indx = cur_token;\n  * result = ch;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n#if 0\nstatic int mailimf_no_fold_quote_parse(const char * message, size_t length,\n\t\t\t\t       size_t * indx, char ** result)\n{\n  size_t cur_token;\n  size_t begin;\n  char ch;\n  char * no_fold_quote;\n  int r;\n  int res;\n\n  begin = cur_token;\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  while (1) {\n    r = mailimf_no_fold_quote_char_parse(message, length, &cur_token, &ch);\n    if (r == MAILIMF_NO_ERROR) {\n      /* do nothing */\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      res = r;\n      goto err;\n    }\n  }\n\n  r = mailimf_dquote_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  /*  no_fold_quote = strndup(message + begin, cur_token - begin); */\n  no_fold_quote = malloc(cur_token - begin + 1);\n  if (no_fold_quote == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n  strncpy(no_fold_quote, message + begin, cur_token - begin);\n  no_fold_quote[cur_token - begin] = '\\0';\n\n  * result = no_fold_quote;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  return res;\n}\n#endif\n\n/*\nno-fold-literal =       \"[\" *(dtext / quoted-pair) \"]\"\n*/\n\n#if 0\nstatic inline int\nmailimf_no_fold_literal_char_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx, char * result)\n{\n  char ch;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n#if 0\n  r = mailimf_dtext_parse(message, length, &cur_token, &ch);\n#endif\n  if (cur_token >= length)\n    return MAILIMF_ERROR_PARSE;\n\n  if (is_dtext(message[cur_token])) {\n    ch = message[cur_token];\n    cur_token ++;\n  }\n  else {\n    r = mailimf_quoted_pair_parse(message, length, &cur_token, &ch);\n    \n    if (r != MAILIMF_NO_ERROR)\n      return r;\n  }\n\n  * indx = cur_token;\n  * result = ch;\n\n  return MAILIMF_NO_ERROR;\n}\n#endif\n\n#if 0\nstatic int mailimf_no_fold_literal_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx, char ** result)\n{\n  size_t cur_token;\n  size_t begin;\n  char ch;\n  char * no_fold_literal;\n  int r;\n  int res;\n\n  begin = cur_token;\n  r = mailimf_obracket_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  while (1) {\n    r = mailimf_no_fold_literal_char_parse(message, length,\n\t\t\t\t\t   &cur_token, &ch);\n    if (r == MAILIMF_NO_ERROR) {\n      /* do nothing */\n    }\n    else if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else {\n      res = r;\n      goto err;\n    }\n  }\n\n  r = mailimf_cbracket_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  /*\n  no_fold_literal = strndup(message + begin, cur_token - begin);\n  */\n  no_fold_literal = malloc(cur_token - begin + 1);\n  if (no_fold_literal == NULL) {\n    res = MAILIMF_NO_ERROR;\n    goto err;\n  }\n  strncpy(no_fold_literal, message + begin, cur_token - begin);\n  no_fold_literal[cur_token - begin] = '\\0';\n\n  * result = no_fold_literal;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  return res;\n}\n#endif\n\n/*\nsubject         =       \"Subject:\" unstructured CRLF\n*/\n\nstatic int mailimf_subject_parse(const char * message, size_t length,\n\t\t\t\t size_t * indx,\n\t\t\t\t struct mailimf_subject ** result)\n{\n  struct mailimf_subject * subject;\n  char * value;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Subject\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_unstructured_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_value;\n  }\n  \n  subject = mailimf_subject_new(value);\n  if (subject == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_value;\n  }\n\n  * result = subject;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_value:\n  mailimf_unstructured_free(value);\n err:\n  return res;\n}\n\n/*\ncomments        =       \"Comments:\" unstructured CRLF\n*/\n\nstatic int mailimf_comments_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_comments ** result)\n{\n  struct mailimf_comments * comments;\n  char * value;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Comments\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_unstructured_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_value;\n  }\n  \n  comments = mailimf_comments_new(value);\n  if (comments == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_value;\n  }\n\n  * result = comments;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_value:\n  mailimf_unstructured_free(value);\n err:\n  return res;\n}\n\n/*\nkeywords        =       \"Keywords:\" phrase *(\",\" phrase) CRLF\n*/\n\nstatic int mailimf_keywords_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_keywords ** result)\n{\n  struct mailimf_keywords * keywords;\n  clist * list;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Keywords\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_struct_list_parse(message, length, &cur_token,\n\t\t\t\t&list, ',',\n\t\t\t\t(mailimf_struct_parser *)\n\t\t\t\tmailimf_phrase_parse,\n\t\t\t\t(mailimf_struct_destructor *)\n\t\t\t\tmailimf_phrase_free);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_list;\n  }\n  \n  keywords = mailimf_keywords_new(list);\n  if (keywords == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = keywords;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(list, (clist_func) mailimf_phrase_free, NULL);\n  clist_free(list);\n err:\n  return res;\n}\n\n/*\nresent-date     =       \"Resent-Date:\" date-time CRLF\n*/\n\nstatic int\nmailimf_resent_date_parse(const char * message, size_t length,\n\t\t\t  size_t * indx, struct mailimf_orig_date ** result)\n{\n  struct mailimf_orig_date * orig_date;\n  struct mailimf_date_time * date_time;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-Date\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_date_time_parse(message, length, &cur_token, &date_time);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_date_time;\n  }\n\n  orig_date = mailimf_orig_date_new(date_time);\n  if (orig_date == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_date_time;\n  }\n\n  * result = orig_date;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_date_time:\n  mailimf_date_time_free(date_time);\n err:\n  return res;\n}\n\n/*\nresent-from     =       \"Resent-From:\" mailbox-list CRLF\n*/\n\nstatic int\nmailimf_resent_from_parse(const char * message, size_t length,\n\t\t\t  size_t * indx, struct mailimf_from ** result)\n{\n  struct mailimf_mailbox_list * mb_list;\n  struct mailimf_from * from;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token =  * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-From\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mb_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mb_list;\n  }\n\n  from = mailimf_from_new(mb_list);\n  if (from == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mb_list;\n  }\n\n  * result = from;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_mb_list:\n  mailimf_mailbox_list_free(mb_list);\n err:\n  return res;\n}\n\n/*\nresent-sender   =       \"Resent-Sender:\" mailbox CRLF\n*/\n\nstatic int\nmailimf_resent_sender_parse(const char * message, size_t length,\n\t\t\t    size_t * indx, struct mailimf_sender ** result)\n{\n  struct mailimf_mailbox * mb;\n  struct mailimf_sender * sender;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = length;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-Sender\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_mailbox_parse(message, length, &cur_token, &mb);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mb;\n  }\n\n  sender = mailimf_sender_new(mb);\n  if (sender == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mb;\n  }\n\n  * result = sender;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_mb:\n  mailimf_mailbox_free(mb);\n err:\n  return res;\n}\n\n/*\nresent-to       =       \"Resent-To:\" address-list CRLF\n*/\n\nstatic int\nmailimf_resent_to_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_to ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_to * to;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-To\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  to = mailimf_to_new(addr_list);\n  if (to == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = to;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\nresent-cc       =       \"Resent-Cc:\" address-list CRLF\n*/\n\nstatic int\nmailimf_resent_cc_parse(const char * message, size_t length,\n\t\t\tsize_t * indx, struct mailimf_cc ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_cc * cc;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-Cc\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  cc = mailimf_cc_new(addr_list);\n  if (cc == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = cc;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\nresent-bcc      =       \"Resent-Bcc:\" (address-list / [CFWS]) CRLF\n*/\n\nstatic int\nmailimf_resent_bcc_parse(const char * message, size_t length,\n\t\t\t size_t * indx, struct mailimf_bcc ** result)\n{\n  struct mailimf_address_list * addr_list;\n  struct mailimf_bcc * bcc;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  bcc = NULL;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-Bcc\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  addr_list = NULL;\n  r = mailimf_address_list_parse(message, length, &cur_token, &addr_list);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_addr_list;\n  }\n\n  bcc = mailimf_bcc_new(addr_list);\n  if (bcc == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_list;\n  }\n\n  * result = bcc;\n  * indx = cur_token;\n\n  return TRUE;\n\n free_addr_list:\n  mailimf_address_list_free(addr_list);\n err:\n  return res;\n}\n\n/*\nresent-msg-id   =       \"Resent-Message-ID:\" msg-id CRLF\n*/\n\nstatic int\nmailimf_resent_msg_id_parse(const char * message, size_t length,\n\t\t\t    size_t * indx,\n\t\t\t    struct mailimf_message_id ** result)\n{\n  char * value;\n  size_t cur_token;\n  struct mailimf_message_id * message_id;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Resent-Message-ID\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_msg_id_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_value;\n  }\n\n  message_id = mailimf_message_id_new(value);\n  if (message_id == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_value;\n  }\n\n  * result = message_id;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_value:\n  mailimf_msg_id_free(value);\n err:\n  return res;\n}\n\n/*\ntrace           =       [return]\n                        1*received\n*/\n\n#if 0\nstatic int mailimf_trace_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_trace ** result)\n{\n  size_t cur_token;\n  struct mailimf_return * return_path;\n  clist * received_list;\n  struct mailimf_trace * trace;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  return_path = NULL;\n  received_list = NULL;\n\n  r = mailimf_return_parse(message, length, &cur_token, &return_path);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &received_list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_received_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_received_free);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  if ((received_list == NULL) && (return_path == NULL)) {\n    res = MAILIMF_ERROR_PARSE;\n    goto free_return;\n  }\n\n  trace = mailimf_trace_new(return_path, received_list);\n  if (trace == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = trace;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(received_list, (clist_func) mailimf_received_free, NULL);\n  clist_free(received_list);\n free_return:\n  if (return_path != NULL)\n    mailimf_return_free(return_path);\n err:\n  return res;\n}\n#endif\n\n/*\nreturn          =       \"Return-Path:\" path CRLF\n*/\n\nstatic int mailimf_return_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx,\n\t\t\t\tstruct mailimf_return ** result)\n{\n  struct mailimf_path * path;\n  struct mailimf_return * return_path;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Return-Path\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  path = NULL;\n  r = mailimf_path_parse(message, length, &cur_token, &path);\n  if ( r!= MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_path;\n  }\n\n  return_path = mailimf_return_new(path);\n  if (return_path == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_path;\n  }\n\n  * result = return_path;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_path:\n  mailimf_path_free(path);\n err:\n  return res;\n}\n\n/*\npath            =       ([CFWS] \"<\" ([CFWS] / addr-spec) \">\" [CFWS]) /\n                        obs-path\n*/\n\nstatic int mailimf_path_parse(const char * message, size_t length,\n\t\t\t      size_t * indx, struct mailimf_path ** result)\n{\n  size_t cur_token;\n  char * addr_spec;\n  struct mailimf_path * path;\n  int res;\n  int r;\n\n  cur_token = * indx;\n  addr_spec = NULL;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_lower_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_addr_spec_parse(message, length, &cur_token, &addr_spec);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto err;\n    }\n    break;\n  default:\n    return r;\n  }\n  \n  r = mailimf_greater_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  path = mailimf_path_new(addr_spec);\n  if (path == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_addr_spec;\n  }\n\n  * indx = cur_token;\n  * result = path;\n\n  return MAILIMF_NO_ERROR;\n\n free_addr_spec:\n  if (addr_spec == NULL)\n    mailimf_addr_spec_free(addr_spec);\n err:\n  return res;\n}\n\n/*\nreceived        =       \"Received:\" name-val-list \";\" date-time CRLF\n*/\n\n#if 0\nstatic int mailimf_received_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_received ** result)\n{\n  size_t cur_token;\n  struct mailimf_received * received;\n  struct mailimf_name_val_list * name_val_list;\n  struct mailimf_date_time * date_time;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_token_case_insensitive_parse(message, length,\n\t\t\t\t\t   &cur_token, \"Received\");\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_name_val_list_parse(message, length,\n\t\t\t\t  &cur_token, &name_val_list);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_name_val_list;\n  }\n\n  r = mailimf_date_time_parse(message, length, &cur_token, &date_time);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_name_val_list;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_date_time;\n  }\n\n  received = mailimf_received_new(name_val_list, date_time);\n  if (received == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_date_time;\n  }\n\n  * indx = cur_token;\n  * result = received;\n\n  return MAILIMF_NO_ERROR;\n\n free_date_time:\n  mailimf_date_time_free(date_time);\n free_name_val_list:\n  mailimf_name_val_list_free(name_val_list);\n err:\n  return res;\n}\n#endif\n\n/*\nname-val-list   =       [CFWS] [name-val-pair *(CFWS name-val-pair)]\n*/\n\n#if 0\nstatic int\nmailimf_name_val_list_parse(const char * message, size_t length,\n\t\t\t    size_t * indx,\n\t\t\t    struct mailimf_name_val_list ** result)\n{\n  size_t cur_token;\n  struct mailimf_name_val_pair * pair;\n  struct mailimf_name_val_list * name_val_list;\n  clist* list;\n  int res;\n  int r;\n\n  cur_token = * indx;\n  list = NULL;\n\n  r = mailimf_name_val_pair_parse(message, length, &cur_token, &pair);\n\n  if (r == MAILIMF_NO_ERROR){\n    size_t final_token;\n\n    list = clist_new();\n    if (list == NULL) {\n      mailimf_name_val_pair_free(pair);\n      res = MAILIMF_ERROR_MEMORY;\n      goto err;\n    }\n\n    r = clist_append(list, pair);\n    if (r < 0) {\n      mailimf_name_val_pair_free(pair);\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_list;\n    }\n\n    final_token = cur_token;\n    \n    while (1) {\n      r = mailimf_cfws_parse(message, length, &cur_token);\n      if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n\tres = r;\n\tgoto free_list;\n      }\n\n      r = mailimf_name_val_pair_parse(message, length, &cur_token, &pair);\n      if (r == MAILIMF_NO_ERROR) {\n\t/* do nothing */\n      }\n      else if (r == MAILIMF_ERROR_PARSE)\n\tbreak;\n      else {\n\tres = r;\n\tgoto free_list;\n      }\n\n      r = clist_append(list, pair);\n      if (r < 0) {\n\tmailimf_name_val_pair_free(pair);\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free_list;\n      }\n\n      final_token = cur_token;\n    }\n    cur_token = final_token;\n  }\n\n  name_val_list = mailimf_name_val_list_new(list);\n  if (name_val_list == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * indx = cur_token;\n  * result = name_val_list;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_name_val_pair_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n#endif\n\n/*\nname-val-pair   =       item-name CFWS item-value\n*/\n\n#if 0\nstatic int\nmailimf_name_val_pair_parse(const char * message, size_t length,\n\t\t\t    size_t * indx,\n\t\t\t    struct mailimf_name_val_pair ** result)\n{\n  size_t cur_token;\n  char * item_name;\n  struct mailimf_item_value * item_value;\n  struct mailimf_name_val_pair * name_val_pair;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n  \n  r = mailimf_item_name_parse(message, length, &cur_token, &item_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_item_name;\n  }\n\n  r = mailimf_item_value_parse(message, length, &cur_token, &item_value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_item_name;\n  }\n\n  name_val_pair = mailimf_name_val_pair_new(item_name, item_value);\n  if (name_val_pair == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_item_value;\n  }\n\n  * result = name_val_pair;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_item_value:\n  mailimf_item_value_free(item_value);\n free_item_name:\n  mailimf_item_name_free(item_name);\n err:\n  return res;\n}\n#endif\n\n/*\nitem-name       =       ALPHA *([\"-\"] (ALPHA / DIGIT))\n*/\n\n#if 0\nstatic int mailimf_item_name_parse(const char * message, size_t length,\n\t\t\t\t   size_t * indx, char ** result)\n{\n  size_t cur_token;\n  size_t begin;\n  char * item_name;\n  char ch;\n  int digit;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  begin = cur_token;\n\n  r = mailimf_alpha_parse(message, length, &cur_token, &ch);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  while (1) {\n    int minus_sign;\n\n    minus_sign = mailimf_minus_parse(message, length, &cur_token);\n\n    r = mailimf_alpha_parse(message, length, &cur_token, &ch);\n    if (r == MAILIMF_ERROR_PARSE)\n      r = mailimf_digit_parse(message, length, &cur_token, &digit);\n\n    if (r == MAILIMF_NO_ERROR) {\n      /* do nothing */\n    }\n    if (r == MAILIMF_ERROR_PARSE)\n      break;\n    else if (r != MAILIMF_NO_ERROR) {\n      res = r;\n      goto err;\n    }\n  }\n\n  item_name = strndup(message + begin, cur_token - begin);\n  if (item_name == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  * indx = cur_token;\n  * result = item_name;\n\n  return MAILIMF_NO_ERROR;\n\n err:\n  return res;\n}\n#endif\n\n/*\nitem-value      =       1*angle-addr / addr-spec /\n                         atom / domain / msg-id\n*/\n\n#if 0\nstatic int is_item_value_atext(char ch)\n{\n  switch (ch) {\n  case '\\t':\n  case ' ':\n  case '\\r':\n  case '\\n':\n  case ';':\n    return FALSE;\n  default:\n    return TRUE;\n  }\n}\n\nstatic int mailimf_item_value_atom_parse(const char * message, size_t length,\n\t\t\t\t\t size_t * indx, char ** result)\n{\n  char * atom;\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_custom_string_parse(message, length, &cur_token,\n\t\t\t\t  &atom, is_item_value_atext);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  * indx = cur_token;\n  * result = atom;\n\n  return MAILIMF_NO_ERROR;\n}\n\nstatic int mailimf_item_value_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx,\n\t\t\t\t    struct mailimf_item_value ** result)\n{\n  size_t cur_token;\n  clist * angle_addr_list;\n  char * addr_spec;\n  char * atom;\n  char * domain;\n  char * msg_id;\n  int type;\n  struct mailimf_item_value * item_value;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  \n  angle_addr_list = NULL;\n  addr_spec = NULL;\n  atom = NULL;\n  domain = NULL;\n  msg_id = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &angle_addr_list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_angle_addr_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_angle_addr_free);\n  if (r == MAILIMF_NO_ERROR)\n    type = MAILIMF_ITEM_VALUE_ANGLE_ADDR_LIST;\n\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_addr_spec_parse(message, length, &cur_token,\n\t\t\t\t&addr_spec);\n    if (r == MAILIMF_NO_ERROR)\n      type = MAILIMF_ITEM_VALUE_ADDR_SPEC;\n  }\n\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_msg_id_parse(message, length, &cur_token,\n\t\t\t     &msg_id);\n    if (r == MAILIMF_NO_ERROR)\n      type = MAILIMF_ITEM_VALUE_MSG_ID;\n  }\n\n  /*\n  else if (mailimf_domain_parse(message, length, &cur_token,\n\t\t\t\t&domain))\n    type = MAILIMF_ITEM_VALUE_DOMAIN;\n  */\n  /*\n  else if (mailimf_atom_parse(message, length, &cur_token,\n\t\t\t      &atom))\n    type = MAILIMF_ITEM_VALUE_ATOM;\n  */\n\n  if (r == MAILIMF_ERROR_PARSE) {\n    r = mailimf_item_value_atom_parse(message, length, &cur_token,\n\t\t\t\t      &atom);\n    if (r == MAILIMF_NO_ERROR)\n      type = MAILIMF_ITEM_VALUE_ATOM;\n  }\n\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  item_value = mailimf_item_value_new(type, angle_addr_list, addr_spec,\n\t\t\t\t      atom, domain, msg_id);\n  if (item_value == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = item_value;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (angle_addr_list != NULL) {\n    clist_foreach(angle_addr_list, (clist_func) mailimf_angle_addr_free, NULL);\n    clist_free(angle_addr_list);\n  }\n  if (addr_spec != NULL)\n    mailimf_addr_spec_free(addr_spec);\n  if (atom != NULL)\n    mailimf_atom_free(atom);\n  if (domain != NULL)\n    mailimf_domain_free(domain);\n  if (msg_id != NULL)\n    mailimf_msg_id_free(msg_id);\n err:\n  return res;\n}\n#endif\n\n/*\noptional-field  =       field-name \":\" unstructured CRLF\n*/\n\nstatic int\nmailimf_optional_field_parse(const char * message, size_t length,\n\t\t\t     size_t * indx,\n\t\t\t     struct mailimf_optional_field ** result)\n{\n  char * name;\n  char * value;\n  struct mailimf_optional_field * optional_field;\n  size_t cur_token;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  r = mailimf_field_name_parse(message, length, &cur_token, &name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_name;\n  }\n\n  r = mailimf_unstructured_parse(message, length, &cur_token, &value);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_name;\n  }\n\n  r = mailimf_unstrict_crlf_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_value;\n  }\n\n  optional_field = mailimf_optional_field_new(name, value);\n  if (optional_field == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_value;\n  }\n\n  * result = optional_field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_value:\n  mailimf_unstructured_free(value);\n free_name:\n  mailimf_field_name_free(name);\n err:\n  return res;\n}\n     \n/*\nfield-name      =       1*ftext\n*/\n\nstatic inline int is_ftext(char ch);\n\nstatic int mailimf_field_name_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, char ** result)\n{\n  char * field_name;\n  size_t cur_token;\n  size_t end;\n  \n  cur_token = * indx;\n\n  end = cur_token;\n  if (end >= length) {\n    return MAILIMF_ERROR_PARSE;\n  }\n\n  while (is_ftext(message[end])) {\n    end ++;\n    if (end >= length)\n      break;\n  }\n  if (end == cur_token) {\n    return MAILIMF_ERROR_PARSE;\n  }\n\n  /*  field_name = strndup(message + cur_token, end - cur_token); */\n  field_name = malloc(end - cur_token + 1);\n  if (field_name == NULL) {\n    return MAILIMF_ERROR_MEMORY;\n  }\n  strncpy(field_name, message + cur_token, end - cur_token);\n  field_name[end - cur_token] = '\\0';\n\n  cur_token = end;\n  \n  * indx = cur_token;\n  * result = field_name;\n  \n  return MAILIMF_NO_ERROR;\n}\n\n/*\nftext           =       %d33-57 /               ; Any character except\n                        %d59-126                ;  controls, SP, and\n                                                ;  \":\".\n*/\n\nstatic inline int is_ftext(char ch)\n{\n  unsigned char uch = (unsigned char) ch;\n\n  if (uch < 33)\n    return FALSE;\n\n  if (uch == 58)\n    return FALSE;\n\n  return TRUE;\n}\n\n/*\nstatic int mailimf_ftext_parse(const char * message, size_t length,\n\t\t\t\t    size_t * indx, gchar * result)\n{\n  return mailimf_typed_text_parse(message, length, indx, result, is_ftext);\n}\n*/\n\n\n\n\nstatic int mailimf_envelope_field_parse(const char * message, size_t length,\n\t\t\t\t\tsize_t * indx,\n\t\t\t\t\tstruct mailimf_field ** result)\n{\n  size_t cur_token;\n  int type;\n  struct mailimf_orig_date * orig_date;\n  struct mailimf_from * from;\n  struct mailimf_sender * sender;\n  struct mailimf_reply_to * reply_to;\n  struct mailimf_to * to;\n  struct mailimf_cc * cc;\n  struct mailimf_bcc * bcc;\n  struct mailimf_message_id * message_id;\n  struct mailimf_in_reply_to * in_reply_to;\n  struct mailimf_references * references;\n  struct mailimf_subject * subject;\n  struct mailimf_optional_field * optional_field;\n  struct mailimf_field * field;\n  int guessed_type;\n  int r;\n  int res;\n  \n  cur_token = * indx;\n\n  orig_date = NULL;\n  from = NULL;\n  sender = NULL;\n  reply_to = NULL;\n  to = NULL;\n  cc = NULL;\n  bcc = NULL;\n  message_id = NULL;\n  in_reply_to = NULL;\n  references = NULL;\n  subject = NULL;\n  optional_field = NULL;\n\n  guessed_type = guess_header_type(message, length, cur_token);\n  type = MAILIMF_FIELD_NONE;\n\n  switch (guessed_type) {\n  case MAILIMF_FIELD_ORIG_DATE:\n    r = mailimf_orig_date_parse(message, length, &cur_token,\n\t\t\t\t&orig_date);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_FROM:\n    r = mailimf_from_parse(message, length, &cur_token,\n\t\t\t   &from);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_SENDER:\n    r = mailimf_sender_parse(message, length, &cur_token,\n\t\t\t     &sender);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_REPLY_TO:\n    r = mailimf_reply_to_parse(message, length, &cur_token,\n\t\t\t       &reply_to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_TO:\n    r = mailimf_to_parse(message, length, &cur_token,\n\t\t\t &to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_CC:\n    r = mailimf_cc_parse(message, length, &cur_token,\n\t\t\t &cc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_BCC:\n    r = mailimf_bcc_parse(message, length, &cur_token,\n\t\t\t  &bcc);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_MESSAGE_ID:\n    r = mailimf_message_id_parse(message, length, &cur_token,\n\t\t\t\t &message_id);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_IN_REPLY_TO:\n    r = mailimf_in_reply_to_parse(message, length, &cur_token,\n\t\t\t\t  &in_reply_to);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_REFERENCES:\n    r = mailimf_references_parse(message, length, &cur_token,\n\t\t\t\t &references);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  case MAILIMF_FIELD_SUBJECT:\n    r = mailimf_subject_parse(message, length, &cur_token,\n\t\t\t      &subject);\n    if (r == MAILIMF_NO_ERROR)\n      type = guessed_type;\n    else if (r == MAILIMF_ERROR_PARSE) {\n      /* do nothing */\n    }\n    else {\n      res = r;\n      goto err;\n    }\n    break;\n  }\n\n  if (type == MAILIMF_FIELD_NONE) {\n    res = MAILIMF_ERROR_PARSE;\n    goto err;\n  }\n\n  field = mailimf_field_new(type, NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL,\n      orig_date, from, sender, reply_to, to,\n      cc, bcc, message_id, in_reply_to, references,\n      subject, NULL, NULL, optional_field);\n  if (field == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_field;\n  }\n  \n  * result = field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_field:\n  if (orig_date != NULL)\n    mailimf_orig_date_free(orig_date);\n  if (from != NULL)\n    mailimf_from_free(from);\n  if (sender != NULL)\n    mailimf_sender_free(sender);\n  if (reply_to != NULL)\n    mailimf_reply_to_free(reply_to);\n  if (to != NULL)\n    mailimf_to_free(to);\n  if (cc != NULL)\n    mailimf_cc_free(cc);\n  if (bcc != NULL)\n    mailimf_bcc_free(bcc);\n  if (message_id != NULL)\n    mailimf_message_id_free(message_id);\n  if (in_reply_to != NULL)\n    mailimf_in_reply_to_free(in_reply_to);\n  if (references != NULL)\n    mailimf_references_free(references);\n  if (subject != NULL)\n    mailimf_subject_free(subject);\n  if (optional_field != NULL)\n    mailimf_optional_field_free(optional_field);\n err:\n  return res;\n}\n\nLIBETPAN_EXPORT\nint mailimf_envelope_fields_parse(const char * message, size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_fields ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_fields * fields;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  list = clist_new();\n  if (list == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto err;\n  }\n\n  while (1) {\n    struct mailimf_field * elt;\n\n    r = mailimf_envelope_field_parse(message, length, &cur_token, &elt);\n    if (r == MAILIMF_NO_ERROR) {\n      r = clist_append(list, elt);\n      if (r < 0) {\n\tres = MAILIMF_ERROR_MEMORY;\n\tgoto free;\n      }\n    }\n    else if (r == MAILIMF_ERROR_PARSE) {\n      r = mailimf_ignore_field_parse(message, length, &cur_token);\n      if (r == MAILIMF_NO_ERROR) {\n\t/* do nothing */\n      }\n      else if (r == MAILIMF_ERROR_PARSE) {\n\tbreak;\n      }\n      else {\n\tres = r;\n\tgoto free;\n      }\n    }\n    else {\n      res = r;\n      goto free;\n    }\n  }\n\n  fields = mailimf_fields_new(list);\n  if (fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_field_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n\n\nstatic int\nmailimf_envelope_or_optional_field_parse(const char * message,\n\t\t\t\t\t size_t length,\n\t\t\t\t\t size_t * indx,\n\t\t\t\t\t struct mailimf_field ** result)\n{\n  int r;\n  size_t cur_token;\n  struct mailimf_optional_field * optional_field;\n  struct mailimf_field * field;\n\n  r = mailimf_envelope_field_parse(message, length, indx, result);\n  if (r == MAILIMF_NO_ERROR)\n    return MAILIMF_NO_ERROR;\n\n  cur_token = * indx;\n\n  r = mailimf_optional_field_parse(message, length, &cur_token,\n\t\t\t\t   &optional_field);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  field = mailimf_field_new(MAILIMF_FIELD_OPTIONAL_FIELD, NULL,\n      NULL, NULL, NULL,\n      NULL, NULL, NULL,\n      NULL, NULL, NULL,\n      NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, optional_field);\n  if (field == NULL) {\n    mailimf_optional_field_free(optional_field);\n    return MAILIMF_ERROR_MEMORY;\n  }\n\n  * result = field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\nLIBETPAN_EXPORT\nint\nmailimf_envelope_and_optional_fields_parse(const char * message, size_t length,\n\t\t\t\t\t   size_t * indx,\n\t\t\t\t\t   struct mailimf_fields ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_fields * fields;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  list = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_envelope_or_optional_field_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_field_free);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    /* do nothing */\n    break;\n\n  case MAILIMF_ERROR_PARSE:\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto err;\n    }\n    break;\n\n  default:\n    res = r;\n    goto err;\n  }\n\n  fields = mailimf_fields_new(list);\n  if (fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_field_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n\n\n\nstatic int\nmailimf_only_optional_field_parse(const char * message,\n\t\t\t\t  size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_field ** result)\n{\n  int r;\n  size_t cur_token;\n  struct mailimf_optional_field * optional_field;\n  struct mailimf_field * field;\n\n  cur_token = * indx;\n\n  r = mailimf_optional_field_parse(message, length, &cur_token,\n\t\t\t\t   &optional_field);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  field = mailimf_field_new(MAILIMF_FIELD_OPTIONAL_FIELD, NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, optional_field);\n  if (field == NULL) {\n    mailimf_optional_field_free(optional_field);\n    return MAILIMF_ERROR_MEMORY;\n  }\n\n  * result = field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n\n\nLIBETPAN_EXPORT\nint\nmailimf_optional_fields_parse(const char * message, size_t length,\n\t\t\t      size_t * indx,\n\t\t\t      struct mailimf_fields ** result)\n{\n  size_t cur_token;\n  clist * list;\n  struct mailimf_fields * fields;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  list = NULL;\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_only_optional_field_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_field_free);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    /* do nothing */\n    break;\n\n  case MAILIMF_ERROR_PARSE:\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto err;\n    }\n    break;\n\n  default:\n    res = r;\n    goto err;\n  }\n\n  fields = mailimf_fields_new(list);\n  if (fields == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free;\n  }\n\n  * result = fields;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free:\n  if (list != NULL) {\n    clist_foreach(list, (clist_func) mailimf_field_free, NULL);\n    clist_free(list);\n  }\n err:\n  return res;\n}\n"], "filenames": ["src/low-level/imf/mailimf.c"], "buggy_code_start_loc": [3085], "buggy_code_end_loc": [3110], "fixing_code_start_loc": [3086], "fixing_code_end_loc": [3123], "type": "CWE-476", "message": "A null dereference vulnerability has been found in the MIME handling component of LibEtPan before 1.8, as used in MailCore and MailCore 2. A crash can occur in low-level/imf/mailimf.c during a failed parse of a Cc header containing multiple e-mail addresses.", "other": {"cve": {"id": "CVE-2017-8825", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-08T16:29:00.177", "lastModified": "2017-05-18T16:19:54.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A null dereference vulnerability has been found in the MIME handling component of LibEtPan before 1.8, as used in MailCore and MailCore 2. A crash can occur in low-level/imf/mailimf.c during a failed parse of a Cc header containing multiple e-mail addresses."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad de desreferencia nula en el componente MIME de LibEtPan en versiones anteriores a la 1.8, como las utilizadas en MailCore y MailCore 2. Puede ocurrir un fallo en low-level/imf/mailimf.c durante una an\u00e1lisis fallido de una cabecera Cc que contiene m\u00faltiples direcciones de correo electr\u00f3nico."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libetpan_project:libetpan:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.7.2", "matchCriteriaId": "D7D0B05F-8691-4D8A-97C7-BF3246B5D749"}]}]}], "references": [{"url": "https://github.com/dinhviethoa/libetpan/commit/1fe8fbc032ccda1db9af66d93016b49c16c1f22d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dinhviethoa/libetpan/issues/274", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/dinhviethoa/libetpan/releases/tag/1.8", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dinhviethoa/libetpan/commit/1fe8fbc032ccda1db9af66d93016b49c16c1f22d"}}