{"buggy_code": ["package de.thm.ii.fbs.controller\n\nimport com.fasterxml.jackson.databind.JsonNode\nimport de.thm.ii.fbs.controller.exception.{ForbiddenException, UnauthorizedException}\nimport de.thm.ii.fbs.model.{GlobalRole, User}\nimport de.thm.ii.fbs.services.persistence.UserService\nimport de.thm.ii.fbs.services.security.{AuthService, LdapService, LocalLoginService}\nimport de.thm.ii.fbs.util.JsonWrapper.jsonNodeToWrapper\n\nimport javax.servlet.http.{Cookie, HttpServletRequest, HttpServletResponse}\nimport net.unicon.cas.client.configuration.{CasClientConfigurerAdapter, EnableCasClient}\nimport org.slf4j.LoggerFactory\nimport org.springframework.beans.factory.annotation.{Autowired, Value}\nimport org.springframework.web.bind.annotation._\n\n/**\n  * LoginController simply perform login request.\n  */\n@RestController\n@EnableCasClient\n@RequestMapping(path = Array(\"/api/v1/login\"))\nclass LoginController extends CasClientConfigurerAdapter {\n  @Autowired\n  private implicit val userService: UserService = null\n  @Autowired\n  private val authService: AuthService = null\n  @Autowired\n  private val loginService: LocalLoginService = null\n  @Autowired\n  private val ldapService: LdapService = null\n\n  @Value(\"${cas.client-host-url}\")\n  private val CLIENT_HOST_URL: String = null\n  @Value(\"${ldap.attributeNames.uid}\")\n  private val uidAttributeName: String = null\n  @Value(\"${ldap.attributeNames.sn}\")\n  private val snAttributeName: String = null\n  @Value(\"${ldap.attributeNames.name}\")\n  private val nameAttributeName: String = null\n  @Value(\"${ldap.attributeNames.mail}\")\n  private val mailAttributeName: String = null\n  @Value(\"${ldap.allowLogin}\")\n  private val allowLdapLogin: Boolean = false\n\n  private val logger = LoggerFactory.getLogger(this.getClass)\n  /**\n    * Authentication starts here. here we using CAS\n    *\n    *\n    * This Webservice sends user to CAS to perform a login. CAS redirects to this point and\n    * here a answer to a connected Application (i.e. Angular) will be sent\n    *\n    * @author Benjamin Manns\n    * @param route requested route by user, has to be forwarded to the Angular App\n    * @param request Http request gives access to the http request information.\n    * @param response HTTP Answer (contains also cookies)\n    * @return Java Map\n    */\n  @RequestMapping(value = Array(\"/cas\"), method = Array(RequestMethod.GET))\n  def userLogin(@RequestParam(value = \"route\", required = false) route: String, request: HttpServletRequest,\n                response: HttpServletResponse): Unit = {\n    try {\n      val casUser = request.getUserPrincipal\n\n      var name: String = null\n      if (casUser == null) {\n        logger.warn(\"HELP WE GOT NO ANSWER FOM CAS\")\n      } else {\n        name = casUser.getName\n      }\n      userService.find(name)\n        .orElse(loadUserFromLdap(name).map(u => userService.create(u, null)))\n        .foreach(u => {\n          val token = authService.createToken(u)\n          val co = new Cookie(\"jwt\", token)\n          co.setPath(\"/\")\n          co.setHttpOnly(false)\n          co.setMaxAge(30)\n          response.addCookie(co)\n          val cr = new Cookie(\"JSESSIONID\", \"\")\n          cr.setPath(\"/\")\n          cr.setHttpOnly(true)\n          cr.setSecure(true)\n          cr.setMaxAge(0)\n          response.addCookie(cr)\n        })\n\n      response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY)\n      response.setHeader(\"Location\", CLIENT_HOST_URL + \"/courses\")\n    } catch {\n      case e: Throwable => {\n        logger.error(\"Error: \", e)\n        response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY)\n        response.setHeader(\"Location\", CLIENT_HOST_URL + \"/\")\n      }\n    }}\n\n  private def loadUserFromLdap(uid: String): Option[User] =\n    ldapService.getEntryByUid(uid)\n      .map(entry => new User(\n      entry.getAttribute(nameAttributeName).getStringValue,\n      entry.getAttribute(snAttributeName).getStringValue,\n      entry.getAttribute(mailAttributeName).getStringValue,\n      entry.getAttribute(uidAttributeName).getStringValue,\n      GlobalRole.USER))\n\n  /**\n    * Login via LDAP\n    * @param request Http request gives access to the http request information.\n    * @param response HTTP Answer (contains also cookies)\n    * @param jsonNode Request Body of User login\n    */\n  @RequestMapping(value = Array(\"/ldap\"), method = Array(RequestMethod.POST))\n  def userLDAPLogin(request: HttpServletRequest, response: HttpServletResponse, @RequestBody jsonNode: JsonNode): Unit = {\n    if (allowLdapLogin) {\n      val login = for {\n        username <- jsonNode.retrive(\"username\").asText()\n        password <- jsonNode.retrive(\"password\").asText()\n        ldapUser <- ldapService.login(username, password)\n        user <- loadUserFromLdap(ldapUser.getAttribute(\"uid\").getStringValue)\n      } yield (user, password)\n\n      login match {\n        case Some((user, password)) =>\n          val localUser = userService.find(user.username).getOrElse(userService.create(user, password))\n          authService.renewAuthentication(localUser, response)\n        case None => throw new UnauthorizedException()\n      }\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n\n  /**\n    * Login via local database.\n    *\n    * @param request  Http request gives access to the http request information.\n    * @param response HTTP Answer (contains also cookies)\n    * @param jsonNode Request Body of User login\n    */\n  @RequestMapping(value = Array(\"/local\"), method = Array(RequestMethod.POST))\n  def userLocalLogin(request: HttpServletRequest, response: HttpServletResponse, @RequestBody jsonNode: JsonNode): Unit = {\n    val login = for {\n      username <- jsonNode.retrive(\"username\").asText()\n      password <- jsonNode.retrive(\"password\").asText()\n      user <- loginService.login(username, password)\n    } yield user\n\n    login match {\n      case Some(user) => authService.renewAuthentication(user, response)\n      case None => throw new UnauthorizedException()\n    }\n  }\n\n  /**\n    * Login via local database or ldap.\n    * @param request Http request gives access to the http request information.\n    * @param response HTTP Answer (contains also cookies)\n    * @param jsonNode Request Body of User login\n    */\n  @RequestMapping(value = Array(\"/unified\"), method = Array(RequestMethod.POST))\n  def userUnifiedLogin(request: HttpServletRequest, response: HttpServletResponse, @RequestBody jsonNode: JsonNode): Unit = {\n    val credentials = for {\n      username <- jsonNode.retrive(\"username\").asText()\n      password <- jsonNode.retrive(\"password\").asText()\n    } yield (username, password)\n\n    val user = credentials.flatMap(creds =>\n        loginService.login(creds._1, creds._2).orElse(if (allowLdapLogin) {for {\n            ldapLogin <- ldapService.login(creds._1, creds._2)\n            ldapUser <- loadUserFromLdap(ldapLogin.getAttribute(uidAttributeName).getStringValue)\n              .map(user => userService.find(user.username).getOrElse(userService.create(user, null)))\n          } yield ldapUser} else {None})\n    )\n\n    user match {\n      case Some(user) => authService.renewAuthentication(user, response)\n      case None => throw new UnauthorizedException()\n    }\n  }\n\n  /**\n    * Renews the token of the user\n    * @param req Http Request\n    * @param res Http Response\n    */\n  @RequestMapping(value = Array(\"/token\"), method = Array(RequestMethod.GET))\n  def renew(req: HttpServletRequest, res: HttpServletResponse): Unit = {\n    authService.authorize(req, res);\n  }\n}\n"], "fixing_code": ["package de.thm.ii.fbs.controller\n\nimport com.fasterxml.jackson.databind.JsonNode\nimport de.thm.ii.fbs.controller.exception.{ForbiddenException, UnauthorizedException}\nimport de.thm.ii.fbs.model.{GlobalRole, User}\nimport de.thm.ii.fbs.services.persistence.UserService\nimport de.thm.ii.fbs.services.security.{AuthService, LdapService, LocalLoginService}\nimport de.thm.ii.fbs.util.JsonWrapper.jsonNodeToWrapper\n\nimport javax.servlet.http.{Cookie, HttpServletRequest, HttpServletResponse}\nimport net.unicon.cas.client.configuration.{CasClientConfigurerAdapter, EnableCasClient}\nimport org.slf4j.LoggerFactory\nimport org.springframework.beans.factory.annotation.{Autowired, Value}\nimport org.springframework.web.bind.annotation._\n\n/**\n  * LoginController simply perform login request.\n  */\n@RestController\n@EnableCasClient\n@RequestMapping(path = Array(\"/api/v1/login\"))\nclass LoginController extends CasClientConfigurerAdapter {\n  @Autowired\n  private implicit val userService: UserService = null\n  @Autowired\n  private val authService: AuthService = null\n  @Autowired\n  private val loginService: LocalLoginService = null\n  @Autowired\n  private val ldapService: LdapService = null\n\n  @Value(\"${cas.client-host-url}\")\n  private val CLIENT_HOST_URL: String = null\n  @Value(\"${ldap.attributeNames.uid}\")\n  private val uidAttributeName: String = null\n  @Value(\"${ldap.attributeNames.sn}\")\n  private val snAttributeName: String = null\n  @Value(\"${ldap.attributeNames.name}\")\n  private val nameAttributeName: String = null\n  @Value(\"${ldap.attributeNames.mail}\")\n  private val mailAttributeName: String = null\n  @Value(\"${ldap.allowLogin}\")\n  private val allowLdapLogin: Boolean = false\n\n  private val logger = LoggerFactory.getLogger(this.getClass)\n  /**\n    * Authentication starts here. here we using CAS\n    *\n    *\n    * This Webservice sends user to CAS to perform a login. CAS redirects to this point and\n    * here a answer to a connected Application (i.e. Angular) will be sent\n    *\n    * @author Benjamin Manns\n    * @param route requested route by user, has to be forwarded to the Angular App\n    * @param request Http request gives access to the http request information.\n    * @param response HTTP Answer (contains also cookies)\n    * @return Java Map\n    */\n  @RequestMapping(value = Array(\"/cas\"), method = Array(RequestMethod.GET))\n  def userLogin(@RequestParam(value = \"route\", required = false) route: String, request: HttpServletRequest,\n                response: HttpServletResponse): Unit = {\n    try {\n      val casUser = request.getUserPrincipal\n\n      var name: String = null\n      if (casUser == null) {\n        logger.warn(\"HELP WE GOT NO ANSWER FOM CAS\")\n      } else {\n        name = casUser.getName\n      }\n      userService.find(name)\n        .orElse(loadUserFromLdap(name).map(u => userService.create(u, null)))\n        .foreach(u => {\n          val token = authService.createToken(u)\n          val co = new Cookie(\"jwt\", token)\n          co.setPath(\"/\")\n          co.setHttpOnly(false)\n          co.setMaxAge(30)\n          response.addCookie(co)\n          val cr = new Cookie(\"JSESSIONID\", \"\")\n          cr.setPath(\"/\")\n          cr.setHttpOnly(true)\n          cr.setSecure(true)\n          cr.setMaxAge(0)\n          response.addCookie(cr)\n        })\n\n      response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY)\n      response.setHeader(\"Location\", CLIENT_HOST_URL + \"/courses\")\n    } catch {\n      case e: Throwable => {\n        logger.error(\"Error: \", e)\n        response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY)\n        response.setHeader(\"Location\", CLIENT_HOST_URL + \"/\")\n      }\n    }}\n\n  private def loadUserFromLdap(uid: String): Option[User] =\n    ldapService.getEntryByUid(uid)\n      .map(entry => new User(\n      entry.getAttribute(nameAttributeName).getStringValue,\n      entry.getAttribute(snAttributeName).getStringValue,\n      entry.getAttribute(mailAttributeName).getStringValue,\n      entry.getAttribute(uidAttributeName).getStringValue,\n      GlobalRole.USER))\n\n  /**\n    * Login via LDAP\n    * @param request Http request gives access to the http request information.\n    * @param response HTTP Answer (contains also cookies)\n    * @param jsonNode Request Body of User login\n    */\n  @RequestMapping(value = Array(\"/ldap\"), method = Array(RequestMethod.POST))\n  def userLDAPLogin(request: HttpServletRequest, response: HttpServletResponse, @RequestBody jsonNode: JsonNode): Unit = {\n    if (allowLdapLogin) {\n      val login = for {\n        username <- jsonNode.retrive(\"username\").asText()\n        password <- jsonNode.retrive(\"password\").asText()\n        ldapUser <- ldapService.login(username, password)\n        user <- loadUserFromLdap(ldapUser.getAttribute(\"uid\").getStringValue)\n      } yield user\n\n      login match {\n        case Some((user)) =>\n          val localUser = userService.find(user.username).getOrElse(userService.create(user, null))\n          authService.renewAuthentication(localUser, response)\n        case None => throw new UnauthorizedException()\n      }\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n\n  /**\n    * Login via local database.\n    *\n    * @param request  Http request gives access to the http request information.\n    * @param response HTTP Answer (contains also cookies)\n    * @param jsonNode Request Body of User login\n    */\n  @RequestMapping(value = Array(\"/local\"), method = Array(RequestMethod.POST))\n  def userLocalLogin(request: HttpServletRequest, response: HttpServletResponse, @RequestBody jsonNode: JsonNode): Unit = {\n    val login = for {\n      username <- jsonNode.retrive(\"username\").asText()\n      password <- jsonNode.retrive(\"password\").asText()\n      user <- loginService.login(username, password)\n    } yield user\n\n    login match {\n      case Some(user) => authService.renewAuthentication(user, response)\n      case None => throw new UnauthorizedException()\n    }\n  }\n\n  /**\n    * Login via local database or ldap.\n    * @param request Http request gives access to the http request information.\n    * @param response HTTP Answer (contains also cookies)\n    * @param jsonNode Request Body of User login\n    */\n  @RequestMapping(value = Array(\"/unified\"), method = Array(RequestMethod.POST))\n  def userUnifiedLogin(request: HttpServletRequest, response: HttpServletResponse, @RequestBody jsonNode: JsonNode): Unit = {\n    val credentials = for {\n      username <- jsonNode.retrive(\"username\").asText()\n      password <- jsonNode.retrive(\"password\").asText()\n    } yield (username, password)\n\n    val user = credentials.flatMap(creds =>\n        loginService.login(creds._1, creds._2).orElse(if (allowLdapLogin) {for {\n            ldapLogin <- ldapService.login(creds._1, creds._2)\n            ldapUser <- loadUserFromLdap(ldapLogin.getAttribute(uidAttributeName).getStringValue)\n              .map(user => userService.find(user.username).getOrElse(userService.create(user, null)))\n          } yield ldapUser} else {None})\n    )\n\n    user match {\n      case Some(user) => authService.renewAuthentication(user, response)\n      case None => throw new UnauthorizedException()\n    }\n  }\n\n  /**\n    * Renews the token of the user\n    * @param req Http Request\n    * @param res Http Response\n    */\n  @RequestMapping(value = Array(\"/token\"), method = Array(RequestMethod.GET))\n  def renew(req: HttpServletRequest, res: HttpServletResponse): Unit = {\n    authService.authorize(req, res);\n  }\n}\n"], "filenames": ["modules/fbs-core/api/src/main/scala/de/thm/ii/fbs/controller/LoginController.scala"], "buggy_code_start_loc": [121], "buggy_code_end_loc": [126], "fixing_code_start_loc": [121], "fixing_code_end_loc": [126], "type": "CWE-312", "message": "Feedbacksystem is a personalized feedback system for students using artificial intelligence. Passwords of users using LDAP login are stored in clear text in the database. The LDAP users password is passed unencrypted in the LoginController.scala and stored in the database when logging in for the first time. Users using only local login or the cas login are not affected. This issue has been patched in version 1.19.2.\n\n", "other": {"cve": {"id": "CVE-2023-37468", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-13T21:15:09.253", "lastModified": "2023-07-25T18:35:42.230", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Feedbacksystem is a personalized feedback system for students using artificial intelligence. Passwords of users using LDAP login are stored in clear text in the database. The LDAP users password is passed unencrypted in the LoginController.scala and stored in the database when logging in for the first time. Users using only local login or the cas login are not affected. This issue has been patched in version 1.19.2.\n\n"}, {"lang": "es", "value": "Feedbacksystem es un sistema de feedback personalizado para estudiantes que utiliza inteligencia artificial. Las contrase\u00f1as de los usuarios que utilizan el login LDAP se almacenan en texto claro en la base de datos. La contrase\u00f1a de los usuarios LDAP se pasa sin cifrar en el \"LoginController.scala\" y se almacena en la base de datos cuando se inicia sesi\u00f3n por primera vez. Los usuarios que utilizan s\u00f3lo el inicio de sesi\u00f3n local o el inicio de sesi\u00f3n cas no se ven afectados. Este problema ha sido corregido en la versi\u00f3n 1.19.2. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.5, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-312"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:thm:feedbacksystem:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.5.0", "versionEndExcluding": "1.9.2", "matchCriteriaId": "CC3297F4-C7E7-407D-9099-5FC637CE8E14"}]}]}], "references": [{"url": "https://github.com/thm-mni-ii/feedbacksystem/commit/8d896125263e1efb1b70990987c7704426325bcf", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/thm-mni-ii/feedbacksystem/releases/tag/v1.9.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/thm-mni-ii/feedbacksystem/security/advisories/GHSA-g28r-8wg3-7349", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/thm-mni-ii/feedbacksystem/commit/8d896125263e1efb1b70990987c7704426325bcf"}}