{"buggy_code": ["/* $Id: file.c,v 1.266 2012/05/22 09:45:56 inu Exp $ */\n#include \"fm.h\"\n#include <sys/types.h>\n#include \"myctype.h\"\n#include <signal.h>\n#include <setjmp.h>\n#if defined(HAVE_WAITPID) || defined(HAVE_WAIT3)\n#include <sys/wait.h>\n#endif\n#include <stdio.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <utime.h>\n/* foo */\n\n#include \"html.h\"\n#include \"parsetagx.h\"\n#include \"local.h\"\n#include \"regex.h\"\n\n#ifndef max\n#define max(a,b)        ((a) > (b) ? (a) : (b))\n#endif\t\t\t\t/* not max */\n#ifndef min\n#define min(a,b)        ((a) > (b) ? (b) : (a))\n#endif\t\t\t\t/* not min */\n\n#define MAX_INPUT_SIZE 80 /* TODO - max should be screen line length */\n\nstatic int frame_source = 0;\n\nstatic char *guess_filename(char *file);\nstatic int _MoveFile(char *path1, char *path2);\nstatic void uncompress_stream(URLFile *uf, char **src);\nstatic FILE *lessopen_stream(char *path);\nstatic Buffer *loadcmdout(char *cmd,\n\t\t\t  Buffer *(*loadproc) (URLFile *, Buffer *),\n\t\t\t  Buffer *defaultbuf);\n#ifndef USE_ANSI_COLOR\n#define addnewline(a,b,c,d,e,f,g) _addnewline(a,b,c,e,f,g)\n#endif\nstatic void addnewline(Buffer *buf, char *line, Lineprop *prop,\n\t\t       Linecolor *color, int pos, int width, int nlines);\nstatic void addLink(Buffer *buf, struct parsed_tag *tag);\n\nstatic JMP_BUF AbortLoading;\n\nstatic struct table *tables[MAX_TABLE];\nstatic struct table_mode table_mode[MAX_TABLE];\n\n#if defined(USE_M17N) || defined(USE_IMAGE)\nstatic ParsedURL *cur_baseURL = NULL;\n#endif\n#ifdef USE_M17N\nstatic wc_ces cur_document_charset = 0;\n#endif\n\nstatic Str cur_title;\nstatic Str cur_select;\nstatic Str select_str;\nstatic int select_is_multiple;\nstatic int n_selectitem;\nstatic Str cur_option;\nstatic Str cur_option_value;\nstatic Str cur_option_label;\nstatic int cur_option_selected;\nstatic int cur_status;\n#ifdef MENU_SELECT\n/* menu based <select>  */\nFormSelectOption *select_option;\nint max_select = MAX_SELECT;\nstatic int n_select;\nstatic int cur_option_maxwidth;\n#endif\t\t\t\t/* MENU_SELECT */\n\nstatic Str cur_textarea;\nStr *textarea_str;\nstatic int cur_textarea_size;\nstatic int cur_textarea_rows;\nstatic int cur_textarea_readonly;\nstatic int n_textarea;\nstatic int ignore_nl_textarea;\nint max_textarea = MAX_TEXTAREA;\n\nstatic int http_response_code;\n\n#ifdef USE_M17N\nstatic wc_ces content_charset = 0;\nstatic wc_ces meta_charset = 0;\nstatic char *check_charset(char *p);\nstatic char *check_accept_charset(char *p);\n#endif\n\n#define set_prevchar(x,y,n) Strcopy_charp_n((x),(y),(n))\n#define set_space_to_prevchar(x) Strcopy_charp_n((x),\" \",1)\n\nstruct link_stack {\n    int cmd;\n    short offset;\n    short pos;\n    struct link_stack *next;\n};\n\nstatic struct link_stack *link_stack = NULL;\n\n#define FORMSTACK_SIZE 10\n#define FRAMESTACK_SIZE 10\n\n#ifdef USE_NNTP\n#define Str_news_endline(s) ((s)->ptr[0]=='.'&&((s)->ptr[1]=='\\n'||(s)->ptr[1]=='\\r'||(s)->ptr[1]=='\\0'))\n#endif\t\t\t\t/* USE_NNTP */\n\n#define INITIAL_FORM_SIZE 10\nstatic FormList **forms;\nstatic int *form_stack;\nstatic int form_max = -1;\nstatic int forms_size = 0;\n#define cur_form_id ((form_sp >= 0)? form_stack[form_sp] : -1)\nstatic int form_sp = 0;\n\nstatic clen_t current_content_length;\n\nstatic int cur_hseq;\n#ifdef USE_IMAGE\nstatic int cur_iseq;\n#endif\n\n#define MAX_UL_LEVEL\t9\n#define UL_SYMBOL(x)\t(N_GRAPH_SYMBOL + (x))\n#define UL_SYMBOL_DISC\t\tUL_SYMBOL(9)\n#define UL_SYMBOL_CIRCLE\tUL_SYMBOL(10)\n#define UL_SYMBOL_SQUARE\tUL_SYMBOL(11)\n#define IMG_SYMBOL\t\tUL_SYMBOL(12)\n#define HR_SYMBOL\t26\n\n#ifdef USE_COOKIE\n/* This array should be somewhere else */\n/* FIXME: gettextize? */\nchar *violations[COO_EMAX] = {\n    \"internal error\",\n    \"tail match failed\",\n    \"wrong number of dots\",\n    \"RFC 2109 4.3.2 rule 1\",\n    \"RFC 2109 4.3.2 rule 2.1\",\n    \"RFC 2109 4.3.2 rule 2.2\",\n    \"RFC 2109 4.3.2 rule 3\",\n    \"RFC 2109 4.3.2 rule 4\",\n    \"RFC XXXX 4.3.2 rule 5\"\n};\n#endif\n\n/* *INDENT-OFF* */\nstatic struct compression_decoder {\n    int type;\n    char *ext;\n    char *mime_type;\n    int auxbin_p;\n    char *cmd;\n    char *name;\n    char *encoding;\n    char *encodings[4];\n} compression_decoders[] = {\n    { CMP_COMPRESS, \".gz\", \"application/x-gzip\",\n      0, GUNZIP_CMDNAME, GUNZIP_NAME, \"gzip\", \n      {\"gzip\", \"x-gzip\", NULL} }, \n    { CMP_COMPRESS, \".Z\", \"application/x-compress\",\n      0, GUNZIP_CMDNAME, GUNZIP_NAME, \"compress\",\n      {\"compress\", \"x-compress\", NULL} }, \n    { CMP_BZIP2, \".bz2\", \"application/x-bzip\",\n      0, BUNZIP2_CMDNAME, BUNZIP2_NAME, \"bzip, bzip2\",\n      {\"x-bzip\", \"bzip\", \"bzip2\", NULL} }, \n    { CMP_DEFLATE, \".deflate\", \"application/x-deflate\",\n      1, INFLATE_CMDNAME, INFLATE_NAME, \"deflate\",\n      {\"deflate\", \"x-deflate\", NULL} }, \n    { CMP_NOCOMPRESS, NULL, NULL, 0, NULL, NULL, NULL, {NULL}},\n};\n/* *INDENT-ON* */\n\n#define SAVE_BUF_SIZE 1536\n\nstatic MySignalHandler\nKeyAbort(SIGNAL_ARG)\n{\n    LONGJMP(AbortLoading, 1);\n    SIGNAL_RETURN;\n}\n\nstatic void\nUFhalfclose(URLFile *f)\n{\n    switch (f->scheme) {\n    case SCM_FTP:\n\tcloseFTP();\n\tbreak;\n#ifdef USE_NNTP\n    case SCM_NEWS:\n    case SCM_NNTP:\n\tcloseNews();\n\tbreak;\n#endif\n    default:\n\tUFclose(f);\n\tbreak;\n    }\n}\n\nint\ncurrentLn(Buffer *buf)\n{\n    if (buf->currentLine)\n\t/*     return buf->currentLine->real_linenumber + 1;      */\n\treturn buf->currentLine->linenumber + 1;\n    else\n\treturn 1;\n}\n\nstatic Buffer *\nloadSomething(URLFile *f,\n\t      Buffer *(*loadproc) (URLFile *, Buffer *), Buffer *defaultbuf)\n{\n    Buffer *buf;\n\n    if ((buf = loadproc(f, defaultbuf)) == NULL)\n\treturn NULL;\n\n    if (buf->buffername == NULL || buf->buffername[0] == '\\0') {\n\tbuf->buffername = checkHeader(buf, \"Subject:\");\n\tif (buf->buffername == NULL && buf->filename != NULL)\n\t    buf->buffername = conv_from_system(lastFileName(buf->filename));\n    }\n    if (buf->currentURL.scheme == SCM_UNKNOWN)\n\tbuf->currentURL.scheme = f->scheme;\n    if (f->scheme == SCM_LOCAL && buf->sourcefile == NULL)\n\tbuf->sourcefile = buf->filename;\n    if (loadproc == loadHTMLBuffer\n#ifdef USE_IMAGE\n\t|| loadproc == loadImageBuffer\n#endif\n       )\n\tbuf->type = \"text/html\";\n    else\n\tbuf->type = \"text/plain\";\n    return buf;\n}\n\nint\ndir_exist(char *path)\n{\n    struct stat stbuf;\n\n    if (path == NULL || *path == '\\0')\n\treturn 0;\n    if (stat(path, &stbuf) == -1)\n\treturn 0;\n    return IS_DIRECTORY(stbuf.st_mode);\n}\n\nstatic int\nis_dump_text_type(char *type)\n{\n    struct mailcap *mcap;\n    return (type && (mcap = searchExtViewer(type)) &&\n\t    (mcap->flags & (MAILCAP_HTMLOUTPUT | MAILCAP_COPIOUSOUTPUT)));\n}\n\nstatic int\nis_text_type(char *type)\n{\n    return (type == NULL || type[0] == '\\0' ||\n\t    strncasecmp(type, \"text/\", 5) == 0 ||\n\t    (strncasecmp(type, \"application/\", 12) == 0 &&\n\t\tstrstr(type, \"xhtml\") != NULL) ||\n\t    strncasecmp(type, \"message/\", sizeof(\"message/\") - 1) == 0);\n}\n\nstatic int\nis_plain_text_type(char *type)\n{\n    return ((type && strcasecmp(type, \"text/plain\") == 0) ||\n\t    (is_text_type(type) && !is_dump_text_type(type)));\n}\n\nint\nis_html_type(char *type)\n{\n    return (type && (strcasecmp(type, \"text/html\") == 0 ||\n\t\t     strcasecmp(type, \"application/xhtml+xml\") == 0));\n}\n\nstatic void\ncheck_compression(char *path, URLFile *uf)\n{\n    int len;\n    struct compression_decoder *d;\n\n    if (path == NULL)\n\treturn;\n\n    len = strlen(path);\n    uf->compression = CMP_NOCOMPRESS;\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tint elen;\n\tif (d->ext == NULL)\n\t    continue;\n\telen = strlen(d->ext);\n\tif (len > elen && strcasecmp(&path[len - elen], d->ext) == 0) {\n\t    uf->compression = d->type;\n\t    uf->guess_type = d->mime_type;\n\t    break;\n\t}\n    }\n}\n\nstatic char *\ncompress_application_type(int compression)\n{\n    struct compression_decoder *d;\n\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tif (d->type == compression)\n\t    return d->mime_type;\n    }\n    return NULL;\n}\n\nstatic char *\nuncompressed_file_type(char *path, char **ext)\n{\n    int len, slen;\n    Str fn;\n    char *t0;\n    struct compression_decoder *d;\n\n    if (path == NULL)\n\treturn NULL;\n\n    slen = 0;\n    len = strlen(path);\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tif (d->ext == NULL)\n\t    continue;\n\tslen = strlen(d->ext);\n\tif (len > slen && strcasecmp(&path[len - slen], d->ext) == 0)\n\t    break;\n    }\n    if (d->type == CMP_NOCOMPRESS)\n\treturn NULL;\n\n    fn = Strnew_charp(path);\n    Strshrink(fn, slen);\n    if (ext)\n\t*ext = filename_extension(fn->ptr, 0);\n    t0 = guessContentType(fn->ptr);\n    if (t0 == NULL)\n\tt0 = \"text/plain\";\n    return t0;\n}\n\nstatic int\nsetModtime(char *path, time_t modtime)\n{\n    struct utimbuf t;\n    struct stat st;\n\n    if (stat(path, &st) == 0)\n\tt.actime = st.st_atime;\n    else\n\tt.actime = time(NULL);\n    t.modtime = modtime;\n    return utime(path, &t);\n}\n\nvoid\nexamineFile(char *path, URLFile *uf)\n{\n    struct stat stbuf;\n\n    uf->guess_type = NULL;\n    if (path == NULL || *path == '\\0' ||\n\tstat(path, &stbuf) == -1 || NOT_REGULAR(stbuf.st_mode)) {\n\tuf->stream = NULL;\n\treturn;\n    }\n    uf->stream = openIS(path);\n    if (!do_download) {\n\tif (use_lessopen && getenv(\"LESSOPEN\") != NULL) {\n\t    FILE *fp;\n\t    uf->guess_type = guessContentType(path);\n\t    if (uf->guess_type == NULL)\n\t\tuf->guess_type = \"text/plain\";\n\t    if (is_html_type(uf->guess_type))\n\t\treturn;\n\t    if ((fp = lessopen_stream(path))) {\n\t\tUFclose(uf);\n\t\tuf->stream = newFileStream(fp, (void (*)())pclose);\n\t\tuf->guess_type = \"text/plain\";\n\t\treturn;\n\t    }\n\t}\n\tcheck_compression(path, uf);\n\tif (uf->compression != CMP_NOCOMPRESS) {\n\t    char *ext = uf->ext;\n\t    char *t0 = uncompressed_file_type(path, &ext);\n\t    uf->guess_type = t0;\n\t    uf->ext = ext;\n\t    uncompress_stream(uf, NULL);\n\t    return;\n\t}\n    }\n}\n\n#define S_IXANY\t(S_IXUSR|S_IXGRP|S_IXOTH)\n\nint\ncheck_command(char *cmd, int auxbin_p)\n{\n    static char *path = NULL;\n    Str dirs;\n    char *p, *np;\n    Str pathname;\n    struct stat st;\n\n    if (path == NULL)\n\tpath = getenv(\"PATH\");\n    if (auxbin_p)\n\tdirs = Strnew_charp(w3m_auxbin_dir());\n    else\n\tdirs = Strnew_charp(path);\n    for (p = dirs->ptr; p != NULL; p = np) {\n\tnp = strchr(p, PATH_SEPARATOR);\n\tif (np)\n\t    *np++ = '\\0';\n\tpathname = Strnew();\n\tStrcat_charp(pathname, p);\n\tStrcat_char(pathname, '/');\n\tStrcat_charp(pathname, cmd);\n\tif (stat(pathname->ptr, &st) == 0 && S_ISREG(st.st_mode)\n\t    && (st.st_mode & S_IXANY) != 0)\n\t    return 1;\n    }\n    return 0;\n}\n\nchar *\nacceptableEncoding()\n{\n    static Str encodings = NULL;\n    struct compression_decoder *d;\n    TextList *l;\n    char *p;\n\n    if (encodings != NULL)\n\treturn encodings->ptr;\n    l = newTextList();\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tif (check_command(d->cmd, d->auxbin_p)) {\n\t    pushText(l, d->encoding);\n\t}\n    }\n    encodings = Strnew();\n    while ((p = popText(l)) != NULL) {\n\tif (encodings->length)\n\t    Strcat_charp(encodings, \", \");\n\tStrcat_charp(encodings, p);\n    }\n    return encodings->ptr;\n}\n\n/* \n * convert line\n */\n#ifdef USE_M17N\nStr\nconvertLine(URLFile *uf, Str line, int mode, wc_ces * charset,\n\t    wc_ces doc_charset)\n#else\nStr\nconvertLine0(URLFile *uf, Str line, int mode)\n#endif\n{\n#ifdef USE_M17N\n    line = wc_Str_conv_with_detect(line, charset, doc_charset, InnerCharset);\n#endif\n    if (mode != RAW_MODE)\n\tcleanup_line(line, mode);\n#ifdef USE_NNTP\n    if (uf && uf->scheme == SCM_NEWS)\n\tStrchop(line);\n#endif\t\t\t\t/* USE_NNTP */\n    return line;\n}\n\nint\nmatchattr(char *p, char *attr, int len, Str *value)\n{\n    int quoted;\n    char *q = NULL;\n\n    if (strncasecmp(p, attr, len) == 0) {\n\tp += len;\n\tSKIP_BLANKS(p);\n\tif (value) {\n\t    *value = Strnew();\n\t    if (*p == '=') {\n\t\tp++;\n\t\tSKIP_BLANKS(p);\n\t\tquoted = 0;\n\t\twhile (!IS_ENDL(*p) && (quoted || *p != ';')) {\n\t\t    if (!IS_SPACE(*p))\n\t\t\tq = p;\n\t\t    if (*p == '\"')\n\t\t\tquoted = (quoted) ? 0 : 1;\n\t\t    else\n\t\t\tStrcat_char(*value, *p);\n\t\t    p++;\n\t\t}\n\t\tif (q)\n\t\t    Strshrink(*value, p - q - 1);\n\t    }\n\t    return 1;\n\t}\n\telse {\n\t    if (IS_ENDT(*p)) {\n\t\treturn 1;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n#ifdef USE_IMAGE\n#ifdef USE_XFACE\nstatic char *\nxface2xpm(char *xface)\n{\n    Image image;\n    ImageCache *cache;\n    FILE *f;\n    struct stat st;\n\n    SKIP_BLANKS(xface);\n    image.url = xface;\n    image.ext = \".xpm\";\n    image.width = 48;\n    image.height = 48;\n    image.cache = NULL;\n    cache = getImage(&image, NULL, IMG_FLAG_AUTO);\n    if (cache->loaded & IMG_FLAG_LOADED && !stat(cache->file, &st))\n\treturn cache->file;\n    cache->loaded = IMG_FLAG_ERROR;\n\n    f = popen(Sprintf(\"%s > %s\", shell_quote(auxbinFile(XFACE2XPM)),\n\t\t      shell_quote(cache->file))->ptr, \"w\");\n    if (!f)\n\treturn NULL;\n    fputs(xface, f);\n    pclose(f);\n    if (stat(cache->file, &st) || !st.st_size)\n\treturn NULL;\n    cache->loaded = IMG_FLAG_LOADED | IMG_FLAG_DONT_REMOVE;\n    cache->index = 0;\n    return cache->file;\n}\n#endif\n#endif\n\nvoid\nreadHeader(URLFile *uf, Buffer *newBuf, int thru, ParsedURL *pu)\n{\n    char *p, *q;\n#ifdef USE_COOKIE\n    char *emsg;\n#endif\n    char c;\n    Str lineBuf2 = NULL;\n    Str tmp;\n    TextList *headerlist;\n#ifdef USE_M17N\n    wc_ces charset = WC_CES_US_ASCII, mime_charset;\n#endif\n    char *tmpf;\n    FILE *src = NULL;\n    Lineprop *propBuffer;\n\n    headerlist = newBuf->document_header = newTextList();\n    if (uf->scheme == SCM_HTTP\n#ifdef USE_SSL\n\t|| uf->scheme == SCM_HTTPS\n#endif\t\t\t\t/* USE_SSL */\n\t)\n\thttp_response_code = -1;\n    else\n\thttp_response_code = 0;\n\n    if (thru && !newBuf->header_source\n#ifdef USE_IMAGE\n\t&& !image_source\n#endif\n\t) {\n\ttmpf = tmpfname(TMPF_DFL, NULL)->ptr;\n\tsrc = fopen(tmpf, \"w\");\n\tif (src)\n\t    newBuf->header_source = tmpf;\n    }\n    while ((tmp = StrmyUFgets(uf))->length) {\n#ifdef USE_NNTP\n\tif (uf->scheme == SCM_NEWS && tmp->ptr[0] == '.')\n\t    Strshrinkfirst(tmp, 1);\n#endif\n\tif(w3m_reqlog){\n\t    FILE *ff;\n\t    ff = fopen(w3m_reqlog, \"a\");\n\t    Strfputs(tmp, ff);\n\t    fclose(ff);\n\t}\n\tif (src)\n\t    Strfputs(tmp, src);\n\tcleanup_line(tmp, HEADER_MODE);\n\tif (tmp->ptr[0] == '\\n' || tmp->ptr[0] == '\\r' || tmp->ptr[0] == '\\0') {\n\t    if (!lineBuf2)\n\t\t/* there is no header */\n\t\tbreak;\n\t    /* last header */\n\t}\n\telse if (!(w3m_dump & DUMP_HEAD)) {\n\t    if (lineBuf2) {\n\t\tStrcat(lineBuf2, tmp);\n\t    }\n\t    else {\n\t\tlineBuf2 = tmp;\n\t    }\n\t    c = UFgetc(uf);\n\t    UFundogetc(uf);\n\t    if (c == ' ' || c == '\\t')\n\t\t/* header line is continued */\n\t\tcontinue;\n\t    lineBuf2 = decodeMIME(lineBuf2, &mime_charset);\n\t    lineBuf2 = convertLine(NULL, lineBuf2, RAW_MODE,\n\t\t\t\t   mime_charset ? &mime_charset : &charset,\n\t\t\t\t   mime_charset ? mime_charset\n\t\t\t\t   : DocumentCharset);\n\t    /* separated with line and stored */\n\t    tmp = Strnew_size(lineBuf2->length);\n\t    for (p = lineBuf2->ptr; *p; p = q) {\n\t\tfor (q = p; *q && *q != '\\r' && *q != '\\n'; q++) ;\n\t\tlineBuf2 = checkType(Strnew_charp_n(p, q - p), &propBuffer,\n\t\t\t\t     NULL);\n\t\tStrcat(tmp, lineBuf2);\n\t\tif (thru)\n\t\t    addnewline(newBuf, lineBuf2->ptr, propBuffer, NULL,\n\t\t\t       lineBuf2->length, FOLD_BUFFER_WIDTH, -1);\n\t\tfor (; *q && (*q == '\\r' || *q == '\\n'); q++) ;\n\t    }\n#ifdef USE_IMAGE\n\t    if (thru && activeImage && displayImage) {\n\t\tStr src = NULL;\n\t\tif (!strncasecmp(tmp->ptr, \"X-Image-URL:\", 12)) {\n\t\t    tmpf = &tmp->ptr[12];\n\t\t    SKIP_BLANKS(tmpf);\n\t\t    src = Strnew_m_charp(\"<img src=\\\"\", html_quote(tmpf),\n\t\t\t\t\t \"\\\" alt=\\\"X-Image-URL\\\">\", NULL);\n\t\t}\n#ifdef USE_XFACE\n\t\telse if (!strncasecmp(tmp->ptr, \"X-Face:\", 7)) {\n\t\t    tmpf = xface2xpm(&tmp->ptr[7]);\n\t\t    if (tmpf)\n\t\t\tsrc = Strnew_m_charp(\"<img src=\\\"file:\",\n\t\t\t\t\t     html_quote(tmpf),\n\t\t\t\t\t     \"\\\" alt=\\\"X-Face\\\"\",\n\t\t\t\t\t     \" width=48 height=48>\", NULL);\n\t\t}\n#endif\n\t\tif (src) {\n\t\t    URLFile f;\n\t\t    Line *l;\n#ifdef USE_M17N\n\t\t    wc_ces old_charset = newBuf->document_charset;\n#endif\n\t\t    init_stream(&f, SCM_LOCAL, newStrStream(src));\n\t\t    loadHTMLstream(&f, newBuf, NULL, TRUE);\n\t\t    UFclose(&f);\n\t\t    for (l = newBuf->lastLine; l && l->real_linenumber;\n\t\t\t l = l->prev)\n\t\t\tl->real_linenumber = 0;\n#ifdef USE_M17N\n\t\t    newBuf->document_charset = old_charset;\n#endif\n\t\t}\n\t    }\n#endif\n\t    lineBuf2 = tmp;\n\t}\n\telse {\n\t    lineBuf2 = tmp;\n\t}\n\tif ((uf->scheme == SCM_HTTP\n#ifdef USE_SSL\n\t     || uf->scheme == SCM_HTTPS\n#endif\t\t\t\t/* USE_SSL */\n\t    ) && http_response_code == -1) {\n\t    p = lineBuf2->ptr;\n\t    while (*p && !IS_SPACE(*p))\n\t\tp++;\n\t    while (*p && IS_SPACE(*p))\n\t\tp++;\n\t    http_response_code = atoi(p);\n\t    if (fmInitialized) {\n\t\tmessage(lineBuf2->ptr, 0, 0);\n\t\trefresh();\n\t    }\n\t}\n\tif (!strncasecmp(lineBuf2->ptr, \"content-transfer-encoding:\", 26)) {\n\t    p = lineBuf2->ptr + 26;\n\t    while (IS_SPACE(*p))\n\t\tp++;\n\t    if (!strncasecmp(p, \"base64\", 6))\n\t\tuf->encoding = ENC_BASE64;\n\t    else if (!strncasecmp(p, \"quoted-printable\", 16))\n\t\tuf->encoding = ENC_QUOTE;\n\t    else if (!strncasecmp(p, \"uuencode\", 8) ||\n\t\t     !strncasecmp(p, \"x-uuencode\", 10))\n\t\tuf->encoding = ENC_UUENCODE;\n\t    else\n\t\tuf->encoding = ENC_7BIT;\n\t}\n\telse if (!strncasecmp(lineBuf2->ptr, \"content-encoding:\", 17)) {\n\t    struct compression_decoder *d;\n\t    p = lineBuf2->ptr + 17;\n\t    while (IS_SPACE(*p))\n\t\tp++;\n\t    uf->compression = CMP_NOCOMPRESS;\n\t    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\t\tchar **e;\n\t\tfor (e = d->encodings; *e != NULL; e++) {\n\t\t    if (strncasecmp(p, *e, strlen(*e)) == 0) {\n\t\t\tuf->compression = d->type;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (uf->compression != CMP_NOCOMPRESS)\n\t\t    break;\n\t    }\n\t    uf->content_encoding = uf->compression;\n\t}\n#ifdef USE_COOKIE\n\telse if (use_cookie && accept_cookie &&\n\t\t pu && check_cookie_accept_domain(pu->host) &&\n\t\t (!strncasecmp(lineBuf2->ptr, \"Set-Cookie:\", 11) ||\n\t\t  !strncasecmp(lineBuf2->ptr, \"Set-Cookie2:\", 12))) {\n\t    Str name = Strnew(), value = Strnew(), domain = NULL, path = NULL,\n\t\tcomment = NULL, commentURL = NULL, port = NULL, tmp2;\n\t    int version, quoted, flag = 0;\n\t    time_t expires = (time_t) - 1;\n\n\t    q = NULL;\n\t    if (lineBuf2->ptr[10] == '2') {\n\t\tp = lineBuf2->ptr + 12;\n\t\tversion = 1;\n\t    }\n\t    else {\n\t\tp = lineBuf2->ptr + 11;\n\t\tversion = 0;\n\t    }\n#ifdef DEBUG\n\t    fprintf(stderr, \"Set-Cookie: [%s]\\n\", p);\n#endif\t\t\t\t/* DEBUG */\n\t    SKIP_BLANKS(p);\n\t    while (*p != '=' && !IS_ENDT(*p))\n\t\tStrcat_char(name, *(p++));\n\t    Strremovetrailingspaces(name);\n\t    if (*p == '=') {\n\t\tp++;\n\t\tSKIP_BLANKS(p);\n\t\tquoted = 0;\n\t\twhile (!IS_ENDL(*p) && (quoted || *p != ';')) {\n\t\t    if (!IS_SPACE(*p))\n\t\t\tq = p;\n\t\t    if (*p == '\"')\n\t\t\tquoted = (quoted) ? 0 : 1;\n\t\t    Strcat_char(value, *(p++));\n\t\t}\n\t\tif (q)\n\t\t    Strshrink(value, p - q - 1);\n\t    }\n\t    while (*p == ';') {\n\t\tp++;\n\t\tSKIP_BLANKS(p);\n\t\tif (matchattr(p, \"expires\", 7, &tmp2)) {\n\t\t    /* version 0 */\n\t\t    expires = mymktime(tmp2->ptr);\n\t\t}\n\t\telse if (matchattr(p, \"max-age\", 7, &tmp2)) {\n\t\t    /* XXX Is there any problem with max-age=0? (RFC 2109 ss. 4.2.1, 4.2.2 */\n\t\t    expires = time(NULL) + atol(tmp2->ptr);\n\t\t}\n\t\telse if (matchattr(p, \"domain\", 6, &tmp2)) {\n\t\t    domain = tmp2;\n\t\t}\n\t\telse if (matchattr(p, \"path\", 4, &tmp2)) {\n\t\t    path = tmp2;\n\t\t}\n\t\telse if (matchattr(p, \"secure\", 6, NULL)) {\n\t\t    flag |= COO_SECURE;\n\t\t}\n\t\telse if (matchattr(p, \"comment\", 7, &tmp2)) {\n\t\t    comment = tmp2;\n\t\t}\n\t\telse if (matchattr(p, \"version\", 7, &tmp2)) {\n\t\t    version = atoi(tmp2->ptr);\n\t\t}\n\t\telse if (matchattr(p, \"port\", 4, &tmp2)) {\n\t\t    /* version 1, Set-Cookie2 */\n\t\t    port = tmp2;\n\t\t}\n\t\telse if (matchattr(p, \"commentURL\", 10, &tmp2)) {\n\t\t    /* version 1, Set-Cookie2 */\n\t\t    commentURL = tmp2;\n\t\t}\n\t\telse if (matchattr(p, \"discard\", 7, NULL)) {\n\t\t    /* version 1, Set-Cookie2 */\n\t\t    flag |= COO_DISCARD;\n\t\t}\n\t\tquoted = 0;\n\t\twhile (!IS_ENDL(*p) && (quoted || *p != ';')) {\n\t\t    if (*p == '\"')\n\t\t\tquoted = (quoted) ? 0 : 1;\n\t\t    p++;\n\t\t}\n\t    }\n\t    if (pu && name->length > 0) {\n\t\tint err;\n\t\tif (show_cookie) {\n\t\t    if (flag & COO_SECURE)\n\t\t        disp_message_nsec(\"Received a secured cookie\", FALSE, 1,\n\t\t\t\t      TRUE, FALSE);\n\t\t    else\n\t\t        disp_message_nsec(Sprintf(\"Received cookie: %s=%s\",\n\t\t\t\t\t      name->ptr, value->ptr)->ptr,\n\t\t\t\t      FALSE, 1, TRUE, FALSE);\n\t\t}\n\t\terr =\n\t\t    add_cookie(pu, name, value, expires, domain, path, flag,\n\t\t\t       comment, version, port, commentURL);\n\t\tif (err) {\n\t\t    char *ans = (accept_bad_cookie == ACCEPT_BAD_COOKIE_ACCEPT)\n\t\t\t? \"y\" : NULL;\n\t\t    if (fmInitialized && (err & COO_OVERRIDE_OK) &&\n\t\t\taccept_bad_cookie == ACCEPT_BAD_COOKIE_ASK) {\n\t\t\tStr msg = Sprintf(\"Accept bad cookie from %s for %s?\",\n\t\t\t\t\t  pu->host,\n\t\t\t\t\t  ((domain && domain->ptr)\n\t\t\t\t\t   ? domain->ptr : \"<localdomain>\"));\n\t\t\tif (msg->length > COLS - 10)\n\t\t\t    Strshrink(msg, msg->length - (COLS - 10));\n\t\t\tStrcat_charp(msg, \" (y/n)\");\n\t\t\tans = inputAnswer(msg->ptr);\n\t\t    }\n\t\t    if (ans == NULL || TOLOWER(*ans) != 'y' ||\n\t\t\t(err =\n\t\t\t add_cookie(pu, name, value, expires, domain, path,\n\t\t\t\t    flag | COO_OVERRIDE, comment, version,\n\t\t\t\t    port, commentURL))) {\n\t\t\terr = (err & ~COO_OVERRIDE_OK) - 1;\n\t\t\tif (err >= 0 && err < COO_EMAX)\n\t\t\t    emsg = Sprintf(\"This cookie was rejected \"\n\t\t\t\t\t   \"to prevent security violation. [%s]\",\n\t\t\t\t\t   violations[err])->ptr;\n\t\t\telse\n\t\t\t    emsg =\n\t\t\t\t\"This cookie was rejected to prevent security violation.\";\n\t\t\trecord_err_message(emsg);\n\t\t\tif (show_cookie)\n\t\t\t    disp_message_nsec(emsg, FALSE, 1, TRUE, FALSE);\n\t\t    }\n\t\t    else\n\t\t\tif (show_cookie)\n\t\t\t    disp_message_nsec(Sprintf\n\t\t\t\t\t  (\"Accepting invalid cookie: %s=%s\",\n\t\t\t\t\t   name->ptr, value->ptr)->ptr, FALSE,\n\t\t\t\t\t  1, TRUE, FALSE);\n\t\t}\n\t    }\n\t}\n#endif\t\t\t\t/* USE_COOKIE */\n\telse if (!strncasecmp(lineBuf2->ptr, \"w3m-control:\", 12) &&\n\t\t uf->scheme == SCM_LOCAL_CGI) {\n\t    Str funcname = Strnew();\n\t    int f;\n\n\t    p = lineBuf2->ptr + 12;\n\t    SKIP_BLANKS(p);\n\t    while (*p && !IS_SPACE(*p))\n\t\tStrcat_char(funcname, *(p++));\n\t    SKIP_BLANKS(p);\n\t    f = getFuncList(funcname->ptr);\n\t    if (f >= 0) {\n\t\ttmp = Strnew_charp(p);\n\t\tStrchop(tmp);\n\t\tpushEvent(f, tmp->ptr);\n\t    }\n\t}\n\tif (headerlist)\n\t    pushText(headerlist, lineBuf2->ptr);\n\tStrfree(lineBuf2);\n\tlineBuf2 = NULL;\n    }\n    if (thru)\n\taddnewline(newBuf, \"\", propBuffer, NULL, 0, -1, -1);\n    if (src)\n\tfclose(src);\n}\n\nchar *\ncheckHeader(Buffer *buf, char *field)\n{\n    int len;\n    TextListItem *i;\n    char *p;\n\n    if (buf == NULL || field == NULL || buf->document_header == NULL)\n\treturn NULL;\n    len = strlen(field);\n    for (i = buf->document_header->first; i != NULL; i = i->next) {\n\tif (!strncasecmp(i->ptr, field, len)) {\n\t    p = i->ptr + len;\n\t    return remove_space(p);\n\t}\n    }\n    return NULL;\n}\n\nchar *\ncheckContentType(Buffer *buf)\n{\n    char *p;\n    Str r;\n    p = checkHeader(buf, \"Content-Type:\");\n    if (p == NULL)\n\treturn NULL;\n    r = Strnew();\n    while (*p && *p != ';' && !IS_SPACE(*p))\n\tStrcat_char(r, *p++);\n#ifdef USE_M17N\n    if ((p = strcasestr(p, \"charset\")) != NULL) {\n\tp += 7;\n\tSKIP_BLANKS(p);\n\tif (*p == '=') {\n\t    p++;\n\t    SKIP_BLANKS(p);\n\t    if (*p == '\"')\n\t\tp++;\n\t    content_charset = wc_guess_charset(p, 0);\n\t}\n    }\n#endif\n    return r->ptr;\n}\n\nstruct auth_param {\n    char *name;\n    Str val;\n};\n\nstruct http_auth {\n    int pri;\n    char *scheme;\n    struct auth_param *param;\n    Str (*cred) (struct http_auth * ha, Str uname, Str pw, ParsedURL *pu,\n\t\t HRequest *hr, FormList *request);\n};\n\nenum {\n    AUTHCHR_NUL,\n    AUTHCHR_SEP,\n    AUTHCHR_TOKEN,\n};\n\nstatic int\nskip_auth_token(char **pp)\n{\n    char *p;\n    int first = AUTHCHR_NUL, typ;\n\n    for (p = *pp ;; ++p) {\n\tswitch (*p) {\n\tcase '\\0':\n\t    goto endoftoken;\n\tdefault:\n\t    if ((unsigned char)*p > 037) {\n\t\ttyp = AUTHCHR_TOKEN;\n\t\tbreak;\n\t    }\n\t    /* thru */\n\tcase '\\177':\n\tcase '[':\n\tcase ']':\n\tcase '(':\n\tcase ')':\n\tcase '<':\n\tcase '>':\n\tcase '@':\n\tcase ';':\n\tcase ':':\n\tcase '\\\\':\n\tcase '\"':\n\tcase '/':\n\tcase '?':\n\tcase '=':\n\tcase ' ':\n\tcase '\\t':\n\tcase ',':\n\t    typ = AUTHCHR_SEP;\n\t    break;\n\t}\n\n\tif (!first)\n\t    first = typ;\n\telse if (first != typ)\n\t    break;\n    }\nendoftoken:\n    *pp = p;\n    return first;\n}\n\nstatic Str\nextract_auth_val(char **q)\n{\n    unsigned char *qq = *(unsigned char **)q;\n    int quoted = 0;\n    Str val = Strnew();\n\n    SKIP_BLANKS(qq);\n    if (*qq == '\"') {\n\tquoted = TRUE;\n\tStrcat_char(val, *qq++);\n    }\n    while (*qq != '\\0') {\n\tif (quoted && *qq == '\"') {\n\t    Strcat_char(val, *qq++);\n\t    break;\n\t}\n\tif (!quoted) {\n\t    switch (*qq) {\n\t    case '[':\n\t    case ']':\n\t    case '(':\n\t    case ')':\n\t    case '<':\n\t    case '>':\n\t    case '@':\n\t    case ';':\n\t    case ':':\n\t    case '\\\\':\n\t    case '\"':\n\t    case '/':\n\t    case '?':\n\t    case '=':\n\t    case ' ':\n\t    case '\\t':\n\t\tqq++;\n\t    case ',':\n\t\tgoto end_token;\n\t    default:\n\t\tif (*qq <= 037 || *qq == 0177) {\n\t\t    qq++;\n\t\t    goto end_token;\n\t\t}\n\t    }\n\t}\n\telse if (quoted && *qq == '\\\\')\n\t    Strcat_char(val, *qq++);\n\tStrcat_char(val, *qq++);\n    }\n  end_token:\n    *q = (char *)qq;\n    return val;\n}\n\nstatic Str\nqstr_unquote(Str s)\n{\n    char *p;\n\n    if (s == NULL)\n\treturn NULL;\n    p = s->ptr;\n    if (*p == '\"') {\n\tStr tmp = Strnew();\n\tfor (p++; *p != '\\0'; p++) {\n\t    if (*p == '\\\\')\n\t\tp++;\n\t    Strcat_char(tmp, *p);\n\t}\n\tif (Strlastchar(tmp) == '\"')\n\t    Strshrink(tmp, 1);\n\treturn tmp;\n    }\n    else\n\treturn s;\n}\n\nstatic char *\nextract_auth_param(char *q, struct auth_param *auth)\n{\n    struct auth_param *ap;\n    char *p;\n\n    for (ap = auth; ap->name != NULL; ap++) {\n\tap->val = NULL;\n    }\n\n    while (*q != '\\0') {\n\tSKIP_BLANKS(q);\n\tfor (ap = auth; ap->name != NULL; ap++) {\n\t    size_t len;\n\n\t    len = strlen(ap->name);\n\t    if (strncasecmp(q, ap->name, len) == 0 &&\n\t\t(IS_SPACE(q[len]) || q[len] == '=')) {\n\t\tp = q + len;\n\t\tSKIP_BLANKS(p);\n\t\tif (*p != '=')\n\t\t    return q;\n\t\tq = p + 1;\n\t\tap->val = extract_auth_val(&q);\n\t\tbreak;\n\t    }\n\t}\n\tif (ap->name == NULL) {\n\t    /* skip unknown param */\n\t    int token_type;\n\t    p = q;\n\t    if ((token_type = skip_auth_token(&q)) == AUTHCHR_TOKEN &&\n\t\t(IS_SPACE(*q) || *q == '=')) {\n\t\tSKIP_BLANKS(q);\n\t\tif (*q != '=')\n\t\t    return p;\n\t\tq++;\n\t\textract_auth_val(&q);\n\t    }\n\t    else\n\t\treturn p;\n\t}\n\tif (*q != '\\0') {\n\t    SKIP_BLANKS(q);\n\t    if (*q == ',')\n\t\tq++;\n\t    else\n\t\tbreak;\n\t}\n    }\n    return q;\n}\n\nstatic Str\nget_auth_param(struct auth_param *auth, char *name)\n{\n    struct auth_param *ap;\n    for (ap = auth; ap->name != NULL; ap++) {\n\tif (strcasecmp(name, ap->name) == 0)\n\t    return ap->val;\n    }\n    return NULL;\n}\n\nstatic Str\nAuthBasicCred(struct http_auth *ha, Str uname, Str pw, ParsedURL *pu,\n\t      HRequest *hr, FormList *request)\n{\n    Str s = Strdup(uname);\n    Strcat_char(s, ':');\n    Strcat(s, pw);\n    return Strnew_m_charp(\"Basic \", encodeB(s->ptr)->ptr, NULL);\n}\n\n#ifdef USE_DIGEST_AUTH\n#include <openssl/md5.h>\n\n/* RFC2617: 3.2.2 The Authorization Request Header\n * \n * credentials      = \"Digest\" digest-response\n * digest-response  = 1#( username | realm | nonce | digest-uri\n *                    | response | [ algorithm ] | [cnonce] |\n *                     [opaque] | [message-qop] |\n *                         [nonce-count]  | [auth-param] )\n *\n * username         = \"username\" \"=\" username-value\n * username-value   = quoted-string\n * digest-uri       = \"uri\" \"=\" digest-uri-value\n * digest-uri-value = request-uri   ; As specified by HTTP/1.1\n * message-qop      = \"qop\" \"=\" qop-value\n * cnonce           = \"cnonce\" \"=\" cnonce-value\n * cnonce-value     = nonce-value\n * nonce-count      = \"nc\" \"=\" nc-value\n * nc-value         = 8LHEX\n * response         = \"response\" \"=\" request-digest\n * request-digest = <\"> 32LHEX <\">\n * LHEX             =  \"0\" | \"1\" | \"2\" | \"3\" |\n *                     \"4\" | \"5\" | \"6\" | \"7\" |\n *                     \"8\" | \"9\" | \"a\" | \"b\" |\n *                     \"c\" | \"d\" | \"e\" | \"f\"\n */\n\nstatic Str\ndigest_hex(unsigned char *p)\n{\n    char *h = \"0123456789abcdef\";\n    Str tmp = Strnew_size(MD5_DIGEST_LENGTH * 2 + 1);\n    int i;\n    for (i = 0; i < MD5_DIGEST_LENGTH; i++, p++) {\n\tStrcat_char(tmp, h[(*p >> 4) & 0x0f]);\n\tStrcat_char(tmp, h[*p & 0x0f]);\n    }\n    return tmp;\n}\n\nenum {\n    QOP_NONE,\n    QOP_AUTH,\n    QOP_AUTH_INT,\n};\n\nstatic Str\nAuthDigestCred(struct http_auth *ha, Str uname, Str pw, ParsedURL *pu,\n\t       HRequest *hr, FormList *request)\n{\n    Str tmp, a1buf, a2buf, rd, s;\n    unsigned char md5[MD5_DIGEST_LENGTH + 1];\n    Str uri = HTTPrequestURI(pu, hr);\n    char nc[] = \"00000001\";\n    FILE *fp;\n\n    Str algorithm = qstr_unquote(get_auth_param(ha->param, \"algorithm\"));\n    Str nonce = qstr_unquote(get_auth_param(ha->param, \"nonce\"));\n    Str cnonce /* = qstr_unquote(get_auth_param(ha->param, \"cnonce\")) */;\n    /* cnonce is what client should generate. */\n    Str qop = qstr_unquote(get_auth_param(ha->param, \"qop\"));\n\n    static union {\n\tint r[4];\n\tunsigned char s[sizeof(int) * 4];\n    } cnonce_seed;\n    int qop_i = QOP_NONE;\n\n    cnonce_seed.r[0] = rand();\n    cnonce_seed.r[1] = rand();\n    cnonce_seed.r[2] = rand();\n    MD5(cnonce_seed.s, sizeof(cnonce_seed.s), md5);\n    cnonce = digest_hex(md5);\n    cnonce_seed.r[3]++;\n\n    if (qop) {\n\tchar *p;\n\tsize_t i;\n\n\tp = qop->ptr;\n\tSKIP_BLANKS(p);\n\n\tfor (;;) {\n\t    if ((i = strcspn(p, \" \\t,\")) > 0) {\n\t\tif (i == sizeof(\"auth-int\") - sizeof(\"\") && !strncasecmp(p, \"auth-int\", i)) {\n\t\t    if (qop_i < QOP_AUTH_INT)\n\t\t\tqop_i = QOP_AUTH_INT;\n\t\t}\n\t\telse if (i == sizeof(\"auth\") - sizeof(\"\") && !strncasecmp(p, \"auth\", i)) {\n\t\t    if (qop_i < QOP_AUTH)\n\t\t\tqop_i = QOP_AUTH;\n\t\t}\n\t    }\n\n\t    if (p[i]) {\n\t\tp += i + 1;\n\t\tSKIP_BLANKS(p);\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n\n    /* A1 = unq(username-value) \":\" unq(realm-value) \":\" passwd */\n    tmp = Strnew_m_charp(uname->ptr, \":\",\n\t\t\t qstr_unquote(get_auth_param(ha->param, \"realm\"))->ptr,\n\t\t\t \":\", pw->ptr, NULL);\n    MD5(tmp->ptr, strlen(tmp->ptr), md5);\n    a1buf = digest_hex(md5);\n\n    if (algorithm) {\n\tif (strcasecmp(algorithm->ptr, \"MD5-sess\") == 0) {\n\t    /* A1 = H(unq(username-value) \":\" unq(realm-value) \":\" passwd)\n\t     *      \":\" unq(nonce-value) \":\" unq(cnonce-value)\n\t     */\n\t    if (nonce == NULL)\n\t\treturn NULL;\n\t    tmp = Strnew_m_charp(a1buf->ptr, \":\",\n\t\t\t\t qstr_unquote(nonce)->ptr,\n\t\t\t\t \":\", qstr_unquote(cnonce)->ptr, NULL);\n\t    MD5(tmp->ptr, strlen(tmp->ptr), md5);\n\t    a1buf = digest_hex(md5);\n\t}\n\telse if (strcasecmp(algorithm->ptr, \"MD5\") == 0)\n\t    /* ok default */\n\t    ;\n\telse\n\t    /* unknown algorithm */\n\t    return NULL;\n    }\n\n    /* A2 = Method \":\" digest-uri-value */\n    tmp = Strnew_m_charp(HTTPrequestMethod(hr)->ptr, \":\", uri->ptr, NULL);\n    if (qop_i == QOP_AUTH_INT) {\n\t/*  A2 = Method \":\" digest-uri-value \":\" H(entity-body) */\n\tif (request && request->body) {\n\t    if (request->method == FORM_METHOD_POST && request->enctype == FORM_ENCTYPE_MULTIPART) {\n\t\tfp = fopen(request->body, \"r\");\n\t\tif (fp != NULL) {\n\t\t    Str ebody;\n\t\t    ebody = Strfgetall(fp);\n\t\t    fclose(fp);\n\t\t    MD5(ebody->ptr, strlen(ebody->ptr), md5);\n\t\t}\n\t\telse {\n\t\t    MD5(\"\", 0, md5);\n\t\t}\n\t    }\n\t    else {\n\t\tMD5(request->body, request->length, md5);\n\t    }\n\t}\n\telse {\n\t    MD5(\"\", 0, md5);\n\t}\n\tStrcat_char(tmp, ':');\n\tStrcat(tmp, digest_hex(md5));\n    }\n    MD5(tmp->ptr, strlen(tmp->ptr), md5);\n    a2buf = digest_hex(md5);\n\n    if (qop_i >= QOP_AUTH) {\n\t/* request-digest  = <\"> < KD ( H(A1),     unq(nonce-value)\n\t *                      \":\" nc-value\n\t *                      \":\" unq(cnonce-value)\n\t *                      \":\" unq(qop-value)\n\t *                      \":\" H(A2)\n\t *                      ) <\">\n\t */\n\tif (nonce == NULL)\n\t    return NULL;\n\ttmp = Strnew_m_charp(a1buf->ptr, \":\", qstr_unquote(nonce)->ptr,\n\t\t\t     \":\", nc,\n\t\t\t     \":\", qstr_unquote(cnonce)->ptr,\n\t\t\t     \":\", qop_i == QOP_AUTH ? \"auth\" : \"auth-int\",\n\t\t\t     \":\", a2buf->ptr, NULL);\n\tMD5(tmp->ptr, strlen(tmp->ptr), md5);\n\trd = digest_hex(md5);\n    }\n    else {\n\t/* compatibility with RFC 2069\n\t * request_digest = KD(H(A1),  unq(nonce), H(A2))\n\t */\n\ttmp = Strnew_m_charp(a1buf->ptr, \":\",\n\t\t\t     qstr_unquote(get_auth_param(ha->param, \"nonce\"))->\n\t\t\t     ptr, \":\", a2buf->ptr, NULL);\n\tMD5(tmp->ptr, strlen(tmp->ptr), md5);\n\trd = digest_hex(md5);\n    }\n\n    /*\n     * digest-response  = 1#( username | realm | nonce | digest-uri\n     *                          | response | [ algorithm ] | [cnonce] |\n     *                          [opaque] | [message-qop] |\n     *                          [nonce-count]  | [auth-param] )\n     */\n\n    tmp = Strnew_m_charp(\"Digest username=\\\"\", uname->ptr, \"\\\"\", NULL);\n    Strcat_m_charp(tmp, \", realm=\",\n\t\t   get_auth_param(ha->param, \"realm\")->ptr, NULL);\n    Strcat_m_charp(tmp, \", nonce=\",\n\t\t   get_auth_param(ha->param, \"nonce\")->ptr, NULL);\n    Strcat_m_charp(tmp, \", uri=\\\"\", uri->ptr, \"\\\"\", NULL);\n    Strcat_m_charp(tmp, \", response=\\\"\", rd->ptr, \"\\\"\", NULL);\n\n    if (algorithm)\n\tStrcat_m_charp(tmp, \", algorithm=\",\n\t\t       get_auth_param(ha->param, \"algorithm\")->ptr, NULL);\n\n    if (cnonce)\n\tStrcat_m_charp(tmp, \", cnonce=\\\"\", cnonce->ptr, \"\\\"\", NULL);\n\n    if ((s = get_auth_param(ha->param, \"opaque\")) != NULL)\n\tStrcat_m_charp(tmp, \", opaque=\", s->ptr, NULL);\n\n    if (qop_i >= QOP_AUTH) {\n\tStrcat_m_charp(tmp, \", qop=\",\n\t\t       qop_i == QOP_AUTH ? \"auth\" : \"auth-int\",\n\t\t       NULL);\n\t/* XXX how to count? */\n\t/* Since nonce is unique up to each *-Authenticate and w3m does not re-use *-Authenticate: headers,\n\t   nonce-count should be always \"00000001\". */\n\tStrcat_m_charp(tmp, \", nc=\", nc, NULL);\n    }\n\n    return tmp;\n}\n#endif\n\n/* *INDENT-OFF* */\nstruct auth_param none_auth_param[] = {\n    {NULL, NULL}\n};\n\nstruct auth_param basic_auth_param[] = {\n    {\"realm\", NULL},\n    {NULL, NULL}\n};\n\n#ifdef USE_DIGEST_AUTH\n/* RFC2617: 3.2.1 The WWW-Authenticate Response Header\n * challenge        =  \"Digest\" digest-challenge\n * \n * digest-challenge  = 1#( realm | [ domain ] | nonce |\n *                       [ opaque ] |[ stale ] | [ algorithm ] |\n *                        [ qop-options ] | [auth-param] )\n *\n * domain            = \"domain\" \"=\" <\"> URI ( 1*SP URI ) <\">\n * URI               = absoluteURI | abs_path\n * nonce             = \"nonce\" \"=\" nonce-value\n * nonce-value       = quoted-string\n * opaque            = \"opaque\" \"=\" quoted-string\n * stale             = \"stale\" \"=\" ( \"true\" | \"false\" )\n * algorithm         = \"algorithm\" \"=\" ( \"MD5\" | \"MD5-sess\" |\n *                        token )\n * qop-options       = \"qop\" \"=\" <\"> 1#qop-value <\">\n * qop-value         = \"auth\" | \"auth-int\" | token\n */\nstruct auth_param digest_auth_param[] = {\n    {\"realm\", NULL},\n    {\"domain\", NULL},\n    {\"nonce\", NULL},\n    {\"opaque\", NULL},\n    {\"stale\", NULL},\n    {\"algorithm\", NULL},\n    {\"qop\", NULL},\n    {NULL, NULL}\n};\n#endif\n/* for RFC2617: HTTP Authentication */\nstruct http_auth www_auth[] = {\n    { 1, \"Basic \", basic_auth_param, AuthBasicCred },\n#ifdef USE_DIGEST_AUTH\n    { 10, \"Digest \", digest_auth_param, AuthDigestCred },\n#endif\n    { 0, NULL, NULL, NULL,}\n};\n/* *INDENT-ON* */\n\nstatic struct http_auth *\nfindAuthentication(struct http_auth *hauth, Buffer *buf, char *auth_field)\n{\n    struct http_auth *ha;\n    int len = strlen(auth_field), slen;\n    TextListItem *i;\n    char *p0, *p;\n\n    bzero(hauth, sizeof(struct http_auth));\n    for (i = buf->document_header->first; i != NULL; i = i->next) {\n\tif (strncasecmp(i->ptr, auth_field, len) == 0) {\n\t    for (p = i->ptr + len; p != NULL && *p != '\\0';) {\n\t\tSKIP_BLANKS(p);\n\t\tp0 = p;\n\t\tfor (ha = &www_auth[0]; ha->scheme != NULL; ha++) {\n\t\t    slen = strlen(ha->scheme);\n\t\t    if (strncasecmp(p, ha->scheme, slen) == 0) {\n\t\t\tp += slen;\n\t\t\tSKIP_BLANKS(p);\n\t\t\tif (hauth->pri < ha->pri) {\n\t\t\t    *hauth = *ha;\n\t\t\t    p = extract_auth_param(p, hauth->param);\n\t\t\t    break;\n\t\t\t}\n\t\t\telse {\n\t\t\t    /* weak auth */\n\t\t\t    p = extract_auth_param(p, none_auth_param);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (p0 == p) {\n\t\t    /* all unknown auth failed */\n\t\t    int token_type;\n\t\t    if ((token_type = skip_auth_token(&p)) == AUTHCHR_TOKEN && IS_SPACE(*p)) {\n\t\t\tSKIP_BLANKS(p);\n\t\t\tp = extract_auth_param(p, none_auth_param);\n\t\t    }\n\t\t    else\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n    }\n    return hauth->scheme ? hauth : NULL;\n}\n\nstatic void\ngetAuthCookie(struct http_auth *hauth, char *auth_header,\n\t      TextList *extra_header, ParsedURL *pu, HRequest *hr,\n\t      FormList *request,\n\t      volatile Str *uname, volatile Str *pwd)\n{\n    Str ss = NULL;\n    Str tmp;\n    TextListItem *i;\n    int a_found;\n    int auth_header_len = strlen(auth_header);\n    char *realm = NULL;\n    int proxy;\n\n    if (hauth)\n\trealm = qstr_unquote(get_auth_param(hauth->param, \"realm\"))->ptr;\n\n    if (!realm)\n\treturn;\n\n    a_found = FALSE;\n    for (i = extra_header->first; i != NULL; i = i->next) {\n\tif (!strncasecmp(i->ptr, auth_header, auth_header_len)) {\n\t    a_found = TRUE;\n\t    break;\n\t}\n    }\n    proxy = !strncasecmp(\"Proxy-Authorization:\", auth_header,\n\t\t\t auth_header_len);\n    if (a_found) {\n\t/* This means that *-Authenticate: header is received after\n\t * Authorization: header is sent to the server. \n\t */\n\tif (fmInitialized) {\n\t    message(\"Wrong username or password\", 0, 0);\n\t    refresh();\n\t}\n\telse\n\t    fprintf(stderr, \"Wrong username or password\\n\");\n\tsleep(1);\n\t/* delete Authenticate: header from extra_header */\n\tdelText(extra_header, i);\n\tinvalidate_auth_user_passwd(pu, realm, *uname, *pwd, proxy);\n    }\n    *uname = NULL;\n    *pwd = NULL;\n\n    if (!a_found && find_auth_user_passwd(pu, realm, (Str*)uname, (Str*)pwd, \n\t\t\t\t\t  proxy)) {\n\t/* found username & password in passwd file */ ;\n    }\n    else {\n\tif (QuietMessage)\n\t    return;\n\t/* input username and password */\n\tsleep(2);\n\tif (fmInitialized) {\n\t    char *pp;\n\t    term_raw();\n\t    /* FIXME: gettextize? */\n\t    if ((pp = inputStr(Sprintf(\"Username for %s: \", realm)->ptr,\n\t\t\t       NULL)) == NULL)\n\t\treturn;\n\t    *uname = Str_conv_to_system(Strnew_charp(pp));\n\t    if ((pp = inputLine(Sprintf(\"Password for %s: \", realm)->ptr, NULL,\n\t\t\t\tIN_PASSWORD)) == NULL) {\n\t\t*uname = NULL;\n\t\treturn;\n\t    }\n\t    *pwd = Str_conv_to_system(Strnew_charp(pp));\n\t    term_cbreak();\n\t}\n\telse {\n\t    /*\n\t     * If post file is specified as '-', stdin is closed at this\n\t     * point.\n\t     * In this case, w3m cannot read username from stdin.\n\t     * So exit with error message.\n\t     * (This is same behavior as lwp-request.)\n\t     */\n\t    if (feof(stdin) || ferror(stdin)) {\n\t\t/* FIXME: gettextize? */\n\t\tfprintf(stderr, \"w3m: Authorization required for %s\\n\",\n\t\t\trealm);\n\t\texit(1);\n\t    }\n\t    \n\t    /* FIXME: gettextize? */\n\t    printf(proxy ? \"Proxy Username for %s: \" : \"Username for %s: \",\n\t\t   realm);\n\t    fflush(stdout);\n\t    *uname = Strfgets(stdin);\n\t    Strchop(*uname);\n#ifdef HAVE_GETPASSPHRASE\n\t    *pwd = Strnew_charp((char *)\n\t\t\t\tgetpassphrase(proxy ? \"Proxy Password: \" :\n\t\t\t\t\t      \"Password: \"));\n#else\n#ifndef __MINGW32_VERSION\n\t    *pwd = Strnew_charp((char *)\n\t\t\t\tgetpass(proxy ? \"Proxy Password: \" :\n\t\t\t\t\t\"Password: \"));\n#else\n\t    term_raw();\n\t    *pwd = Strnew_charp((char *)\n\t\t\t\tinputLine(proxy ? \"Proxy Password: \" :\n\t\t\t\t\t  \"Password: \", NULL, IN_PASSWORD));\n\t    term_cbreak();\n#endif /* __MINGW32_VERSION */\n#endif\n\t}\n    }\n    ss = hauth->cred(hauth, *uname, *pwd, pu, hr, request);\n    if (ss) {\n\ttmp = Strnew_charp(auth_header);\n\tStrcat_m_charp(tmp, \" \", ss->ptr, \"\\r\\n\", NULL);\n\tpushText(extra_header, tmp->ptr);\n    }\n    else {\n\t*uname = NULL;\n\t*pwd = NULL;\n    }\n    return;\n}\n\nstatic int\nsame_url_p(ParsedURL *pu1, ParsedURL *pu2)\n{\n    return (pu1->scheme == pu2->scheme && pu1->port == pu2->port &&\n\t    (pu1->host ? pu2->host ? !strcasecmp(pu1->host, pu2->host) : 0 : 1)\n\t    && (pu1->file ? pu2->\n\t\tfile ? !strcmp(pu1->file, pu2->file) : 0 : 1));\n}\n\nstatic int\ncheckRedirection(ParsedURL *pu)\n{\n    static ParsedURL *puv = NULL;\n    static int nredir = 0;\n    static int nredir_size = 0;\n    Str tmp;\n\n    if (pu == NULL) {\n\tnredir = 0;\n\tnredir_size = 0;\n\tpuv = NULL;\n\treturn TRUE;\n    }\n    if (nredir >= FollowRedirection) {\n\t/* FIXME: gettextize? */\n\ttmp = Sprintf(\"Number of redirections exceeded %d at %s\",\n\t\t      FollowRedirection, parsedURL2Str(pu)->ptr);\n\tdisp_err_message(tmp->ptr, FALSE);\n\treturn FALSE;\n    }\n    else if (nredir_size > 0 &&\n\t     (same_url_p(pu, &puv[(nredir - 1) % nredir_size]) ||\n\t      (!(nredir % 2)\n\t       && same_url_p(pu, &puv[(nredir / 2) % nredir_size])))) {\n\t/* FIXME: gettextize? */\n\ttmp = Sprintf(\"Redirection loop detected (%s)\",\n\t\t      parsedURL2Str(pu)->ptr);\n\tdisp_err_message(tmp->ptr, FALSE);\n\treturn FALSE;\n    }\n    if (!puv) {\n\tnredir_size = FollowRedirection / 2 + 1;\n\tpuv = New_N(ParsedURL, nredir_size);\n\tmemset(puv, 0, sizeof(ParsedURL) * nredir_size);\n    }\n    copyParsedURL(&puv[nredir % nredir_size], pu);\n    nredir++;\n    return TRUE;\n}\n\nStr\ngetLinkNumberStr(int correction)\n{\n    return Sprintf(\"[%d]\", cur_hseq + correction);\n}\n\n/* \n * loadGeneralFile: load file to buffer\n */\n#define DO_EXTERNAL ((Buffer *(*)(URLFile *, Buffer *))doExternal)\nBuffer *\nloadGeneralFile(char *path, ParsedURL *volatile current, char *referer,\n\t\tint flag, FormList *volatile request)\n{\n    URLFile f, *volatile of = NULL;\n    ParsedURL pu;\n    Buffer *b = NULL;\n    Buffer *(*volatile proc)(URLFile *, Buffer *) = loadBuffer;\n    char *volatile tpath;\n    char *volatile t = \"text/plain\", *p, *volatile real_type = NULL;\n    Buffer *volatile t_buf = NULL;\n    int volatile searchHeader = SearchHeader;\n    int volatile searchHeader_through = TRUE;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    TextList *extra_header = newTextList();\n    volatile Str uname = NULL;\n    volatile Str pwd = NULL;\n    volatile Str realm = NULL;\n    int volatile add_auth_cookie_flag;\n    unsigned char status = HTST_NORMAL;\n    URLOption url_option;\n    Str tmp;\n    Str volatile page = NULL;\n#ifdef USE_M17N\n    wc_ces charset = WC_CES_US_ASCII;\n#endif\n    HRequest hr;\n    ParsedURL *volatile auth_pu;\n\n    tpath = path;\n    prevtrap = NULL;\n    add_auth_cookie_flag = 0;\n\n    checkRedirection(NULL);\n\n  load_doc:\n    {\n\tconst char *sc_redirect;\n\tparseURL2(tpath, &pu, current);\n\tsc_redirect = query_SCONF_SUBSTITUTE_URL(&pu);\n\tif (sc_redirect && *sc_redirect && checkRedirection(&pu)) {\n\t    tpath = (char *)sc_redirect;\n\t    request = NULL;\n\t    add_auth_cookie_flag = 0;\n\t    current = New(ParsedURL);\n\t    *current = pu;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n    }\n    TRAP_OFF;\n    url_option.referer = referer;\n    url_option.flag = flag;\n    f = openURL(tpath, &pu, current, &url_option, request, extra_header, of,\n\t\t&hr, &status);\n    of = NULL;\n#ifdef USE_M17N\n    content_charset = 0;\n#endif\n    if (f.stream == NULL) {\n\tswitch (f.scheme) {\n\tcase SCM_LOCAL:\n\t    {\n\t\tstruct stat st;\n\t\tif (stat(pu.real_file, &st) < 0)\n\t\t    return NULL;\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t    if (UseExternalDirBuffer) {\n\t\t\tStr cmd = Sprintf(\"%s?dir=%s#current\",\n\t\t\t\t\t  DirBufferCommand, pu.file);\n\t\t\tb = loadGeneralFile(cmd->ptr, NULL, NO_REFERER, 0,\n\t\t\t\t\t    NULL);\n\t\t\tif (b != NULL && b != NO_BUFFER) {\n\t\t\t    copyParsedURL(&b->currentURL, &pu);\n\t\t\t    b->filename = b->currentURL.real_file;\n\t\t\t}\n\t\t\treturn b;\n\t\t    }\n\t\t    else {\n\t\t\tpage = loadLocalDir(pu.real_file);\n\t\t\tt = \"local:directory\";\n#ifdef USE_M17N\n\t\t\tcharset = SystemCharset;\n#endif\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase SCM_FTPDIR:\n\t    page = loadFTPDir(&pu, &charset);\n\t    t = \"ftp:directory\";\n\t    break;\n#ifdef USE_NNTP\n\tcase SCM_NEWS_GROUP:\n\t    page = loadNewsgroup(&pu, &charset);\n\t    t = \"news:group\";\n\t    break;\n#endif\n\tcase SCM_UNKNOWN:\n#ifdef USE_EXTERNAL_URI_LOADER\n\t    tmp = searchURIMethods(&pu);\n\t    if (tmp != NULL) {\n\t\tb = loadGeneralFile(tmp->ptr, current, referer, flag, request);\n\t\tif (b != NULL && b != NO_BUFFER)\n\t\t    copyParsedURL(&b->currentURL, &pu);\n\t\treturn b;\n\t    }\n#endif\n\t    /* FIXME: gettextize? */\n\t    disp_err_message(Sprintf(\"Unknown URI: %s\",\n\t\t\t\t     parsedURL2Str(&pu)->ptr)->ptr, FALSE);\n\t    break;\n\t}\n\tif (page && page->length > 0)\n\t    goto page_loaded;\n\treturn NULL;\n    }\n\n    if (status == HTST_MISSING) {\n\tTRAP_OFF;\n\tUFclose(&f);\n\treturn NULL;\n    }\n\n    /* openURL() succeeded */\n    if (SETJMP(AbortLoading) != 0) {\n\t/* transfer interrupted */\n\tTRAP_OFF;\n\tif (b)\n\t    discardBuffer(b);\n\tUFclose(&f);\n\treturn NULL;\n    }\n\n    b = NULL;\n    if (f.is_cgi) {\n\t/* local CGI */\n\tsearchHeader = TRUE;\n\tsearchHeader_through = FALSE;\n    }\n    if (header_string)\n\theader_string = NULL;\n    TRAP_ON;\n    if (pu.scheme == SCM_HTTP ||\n#ifdef USE_SSL\n\tpu.scheme == SCM_HTTPS ||\n#endif\t\t\t\t/* USE_SSL */\n\t((\n#ifdef USE_GOPHER\n\t     (pu.scheme == SCM_GOPHER && non_null(GOPHER_proxy)) ||\n#endif\t\t\t\t/* USE_GOPHER */\n\t     (pu.scheme == SCM_FTP && non_null(FTP_proxy))\n\t ) && !Do_not_use_proxy && !check_no_proxy(pu.host))) {\n\n\tif (fmInitialized) {\n\t    term_cbreak();\n\t    /* FIXME: gettextize? */\n\t    message(Sprintf(\"%s contacted. Waiting for reply...\", pu.host)->\n\t\t    ptr, 0, 0);\n\t    refresh();\n\t}\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n#if 0\t\t\t\t/* USE_SSL */\n\tif (IStype(f.stream) == IST_SSL) {\n\t    Str s = ssl_get_certificate(f.stream, pu.host);\n\t    if (s == NULL)\n\t\treturn NULL;\n\t    else\n\t\tt_buf->ssl_certificate = s->ptr;\n\t}\n#endif\n\treadHeader(&f, t_buf, FALSE, &pu);\n\tif (((http_response_code >= 301 && http_response_code <= 303)\n\t     || http_response_code == 307)\n\t    && (p = checkHeader(t_buf, \"Location:\")) != NULL\n\t    && checkRedirection(&pu)) {\n\t    /* document moved */\n\t    /* 301: Moved Permanently */\n\t    /* 302: Found */\n\t    /* 303: See Other */\n\t    /* 307: Temporary Redirect (HTTP/1.1) */\n\t    tpath = url_encode(p, NULL, 0);\n\t    request = NULL;\n\t    UFclose(&f);\n\t    current = New(ParsedURL);\n\t    copyParsedURL(current, &pu);\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    t_buf->bufferprop |= BP_REDIRECTED;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n\tt = checkContentType(t_buf);\n\tif (t == NULL && pu.file != NULL) {\n\t    if (!((http_response_code >= 400 && http_response_code <= 407) ||\n\t\t  (http_response_code >= 500 && http_response_code <= 505)))\n\t\tt = guessContentType(pu.file);\n\t}\n\tif (t == NULL)\n\t    t = \"text/plain\";\n\tif (add_auth_cookie_flag && realm && uname && pwd) {\n\t    /* If authorization is required and passed */\n\t    add_auth_user_passwd(&pu, qstr_unquote(realm)->ptr, uname, pwd, \n\t\t\t\t  0);\n\t    add_auth_cookie_flag = 0;\n\t}\n\tif ((p = checkHeader(t_buf, \"WWW-Authenticate:\")) != NULL &&\n\t    http_response_code == 401) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \"WWW-Authenticate:\") != NULL\n\t\t&& (realm = get_auth_param(hauth.param, \"realm\")) != NULL) {\n\t\tauth_pu = &pu;\n\t\tgetAuthCookie(&hauth, \"Authorization:\", extra_header,\n\t\t\t      auth_pu, &hr, request, &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tgoto load_doc;\n\t    }\n\t}\n\tif ((p = checkHeader(t_buf, \"Proxy-Authenticate:\")) != NULL &&\n\t    http_response_code == 407) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \"Proxy-Authenticate:\")\n\t\t!= NULL\n\t\t&& (realm = get_auth_param(hauth.param, \"realm\")) != NULL) {\n\t\tauth_pu = schemeToProxy(pu.scheme);\n\t\tgetAuthCookie(&hauth, \"Proxy-Authorization:\",\n\t\t\t      extra_header, auth_pu, &hr, request, \n\t\t\t      &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tadd_auth_user_passwd(auth_pu, qstr_unquote(realm)->ptr, uname, pwd, 1);\n\t\tgoto load_doc;\n\t    }\n\t}\n\t/* XXX: RFC2617 3.2.3 Authentication-Info: ? */\n\n\tif (status == HTST_CONNECT) {\n\t    of = &f;\n\t    goto load_doc;\n\t}\n\n\tf.modtime = mymktime(checkHeader(t_buf, \"Last-Modified:\"));\n    }\n#ifdef USE_NNTP\n    else if (pu.scheme == SCM_NEWS || pu.scheme == SCM_NNTP) {\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\treadHeader(&f, t_buf, TRUE, &pu);\n\tt = checkContentType(t_buf);\n\tif (t == NULL)\n\t    t = \"text/plain\";\n    }\n#endif\t\t\t\t/* USE_NNTP */\n#ifdef USE_GOPHER\n    else if (pu.scheme == SCM_GOPHER) {\n\tswitch (*pu.file) {\n\tcase '0':\n\t    t = \"text/plain\";\n\t    break;\n\tcase '1':\n\tcase 'm':\n\t    page = loadGopherDir(&f, &pu, &charset);\n\t    t = \"gopher:directory\";\n\t    TRAP_OFF;\n\t    goto page_loaded;\n\tcase 's':\n\t    t = \"audio/basic\";\n\t    break;\n\tcase 'g':\n\t    t = \"image/gif\";\n\t    break;\n\tcase 'h':\n\t    t = \"text/html\";\n\t    break;\n\t}\n    }\n#endif\t\t\t\t/* USE_GOPHER */\n    else if (pu.scheme == SCM_FTP) {\n\tcheck_compression(path, &f);\n\tif (f.compression != CMP_NOCOMPRESS) {\n\t    char *t1 = uncompressed_file_type(pu.file, NULL);\n\t    real_type = f.guess_type;\n#if 0\n\t    if (t1 && strncasecmp(t1, \"application/\", 12) == 0) {\n\t\tf.compression = CMP_NOCOMPRESS;\n\t\tt = real_type;\n\t    }\n\t    else\n#endif\n\t    if (t1)\n\t\tt = t1;\n\t    else\n\t\tt = real_type;\n\t}\n\telse {\n\t    real_type = guessContentType(pu.file);\n\t    if (real_type == NULL)\n\t\treal_type = \"text/plain\";\n\t    t = real_type;\n\t}\n#if 0\n\tif (!strncasecmp(t, \"application/\", 12)) {\n\t    char *tmpf = tmpfname(TMPF_DFL, NULL)->ptr;\n\t    current_content_length = 0;\n\t    if (save2tmp(f, tmpf) < 0)\n\t\tUFclose(&f);\n\t    else {\n\t\tUFclose(&f);\n\t\tTRAP_OFF;\n\t\tdoFileMove(tmpf, guess_save_name(t_buf, pu.file));\n\t    }\n\t    return NO_BUFFER;\n\t}\n#endif\n    }\n    else if (pu.scheme == SCM_DATA) {\n\tt = f.guess_type;\n    }\n    else if (searchHeader) {\n\tsearchHeader = SearchHeader = FALSE;\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\treadHeader(&f, t_buf, searchHeader_through, &pu);\n\tif (f.is_cgi && (p = checkHeader(t_buf, \"Location:\")) != NULL &&\n\t    checkRedirection(&pu)) {\n\t    /* document moved */\n\t    tpath = url_encode(remove_space(p), NULL, 0);\n\t    request = NULL;\n\t    UFclose(&f);\n\t    add_auth_cookie_flag = 0;\n\t    current = New(ParsedURL);\n\t    copyParsedURL(current, &pu);\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    t_buf->bufferprop |= BP_REDIRECTED;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n#ifdef AUTH_DEBUG\n\tif ((p = checkHeader(t_buf, \"WWW-Authenticate:\")) != NULL) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \"WWW-Authenticate:\") != NULL\n\t\t&& (realm = get_auth_param(hauth.param, \"realm\")) != NULL) {\n\t\tauth_pu = &pu;\n\t\tgetAuthCookie(&hauth, \"Authorization:\", extra_header,\n\t\t\t      auth_pu, &hr, request, &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tgoto load_doc;\n\t    }\n\t}\n#endif /* defined(AUTH_DEBUG) */\n\tt = checkContentType(t_buf);\n\tif (t == NULL)\n\t    t = \"text/plain\";\n    }\n    else if (DefaultType) {\n\tt = DefaultType;\n\tDefaultType = NULL;\n    }\n    else {\n\tt = guessContentType(pu.file);\n\tif (t == NULL)\n\t    t = \"text/plain\";\n\treal_type = t;\n\tif (f.guess_type)\n\t    t = f.guess_type;\n    }\n\n    /* XXX: can we use guess_type to give the type to loadHTMLstream\n     *      to support default utf8 encoding for XHTML here? */\n    f.guess_type = t;\n    \n  page_loaded:\n    if (page) {\n\tFILE *src;\n#ifdef USE_IMAGE\n\tif (image_source)\n\t    return NULL;\n#endif\n\ttmp = tmpfname(TMPF_SRC, \".html\");\n\tsrc = fopen(tmp->ptr, \"w\");\n\tif (src) {\n\t    Str s;\n\t    s = wc_Str_conv_strict(page, InnerCharset, charset);\n\t    Strfputs(s, src);\n\t    fclose(src);\n\t}\n\tif (do_download) {\n\t    char *file;\n\t    if (!src)\n\t\treturn NULL;\n\t    file = guess_filename(pu.file);\n#ifdef USE_GOPHER\n\t    if (f.scheme == SCM_GOPHER)\n\t\tfile = Sprintf(\"%s.html\", file)->ptr;\n#endif\n#ifdef USE_NNTP\n\t    if (f.scheme == SCM_NEWS_GROUP)\n\t\tfile = Sprintf(\"%s.html\", file)->ptr;\n#endif\n\t    doFileMove(tmp->ptr, file);\n\t    return NO_BUFFER;\n\t}\n\tb = loadHTMLString(page);\n\tif (b) {\n\t    copyParsedURL(&b->currentURL, &pu);\n\t    b->real_scheme = pu.scheme;\n\t    b->real_type = t;\n\t    if (src)\n\t\tb->sourcefile = tmp->ptr;\n#ifdef USE_M17N\n\t    b->document_charset = charset;\n#endif\n\t}\n\treturn b;\n    }\n\n    if (real_type == NULL)\n\treal_type = t;\n    proc = loadBuffer;\n\n    current_content_length = 0;\n    if ((p = checkHeader(t_buf, \"Content-Length:\")) != NULL)\n\tcurrent_content_length = strtoclen(p);\n    if (do_download) {\n\t/* download only */\n\tchar *file;\n\tTRAP_OFF;\n\tif (DecodeCTE && IStype(f.stream) != IST_ENCODED)\n\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\tif (pu.scheme == SCM_LOCAL) {\n\t    struct stat st;\n\t    if (PreserveTimestamp && !stat(pu.real_file, &st))\n\t\tf.modtime = st.st_mtime;\n\t    file = conv_from_system(guess_save_name(NULL, pu.real_file));\n\t}\n\telse\n\t    file = guess_save_name(t_buf, pu.file);\n\tif (doFileSave(f, file) == 0)\n\t    UFhalfclose(&f);\n\telse\n\t    UFclose(&f);\n\treturn NO_BUFFER;\n    }\n\n    if ((f.content_encoding != CMP_NOCOMPRESS) && AutoUncompress\n\t&& !(w3m_dump & DUMP_EXTRA)) {\n\tuncompress_stream(&f, &pu.real_file);\n    }\n    else if (f.compression != CMP_NOCOMPRESS) {\n\tif (!(w3m_dump & DUMP_SOURCE) &&\n\t    (w3m_dump & ~DUMP_FRAME || is_text_type(t)\n\t     || searchExtViewer(t))) {\n\t    if (t_buf == NULL)\n\t\tt_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    uncompress_stream(&f, &t_buf->sourcefile);\n\t    uncompressed_file_type(pu.file, &f.ext);\n\t}\n\telse {\n\t    t = compress_application_type(f.compression);\n\t    f.compression = CMP_NOCOMPRESS;\n\t}\n    }\n#ifdef USE_IMAGE\n    if (image_source) {\n\tBuffer *b = NULL;\n\tif (IStype(f.stream) != IST_ENCODED)\n\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\tif (save2tmp(f, image_source) == 0) {\n\t    b = newBuffer(INIT_BUFFER_WIDTH);\n\t    b->sourcefile = image_source;\n\t    b->real_type = t;\n\t}\n\tUFclose(&f);\n\tTRAP_OFF;\n\treturn b;\n    }\n#endif\n\n    if (is_html_type(t))\n\tproc = loadHTMLBuffer;\n    else if (is_plain_text_type(t))\n\tproc = loadBuffer;\n#ifdef USE_IMAGE\n    else if (activeImage && displayImage && !useExtImageViewer &&\n\t     !(w3m_dump & ~DUMP_FRAME) && !strncasecmp(t, \"image/\", 6))\n\tproc = loadImageBuffer;\n#endif\n    else if (w3m_backend) ;\n    else if (!(w3m_dump & ~DUMP_FRAME) || is_dump_text_type(t)) {\n\tif (!do_download && searchExtViewer(t) != NULL) {\n\t    proc = DO_EXTERNAL;\n\t}\n\telse {\n\t    TRAP_OFF;\n\t    if (pu.scheme == SCM_LOCAL) {\n\t\tUFclose(&f);\n\t\t_doFileCopy(pu.real_file,\n\t\t\t    conv_from_system(guess_save_name\n\t\t\t\t\t     (NULL, pu.real_file)), TRUE);\n\t    }\n\t    else {\n\t\tif (DecodeCTE && IStype(f.stream) != IST_ENCODED)\n\t\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\t\tif (doFileSave(f, guess_save_name(t_buf, pu.file)) == 0)\n\t\t    UFhalfclose(&f);\n\t\telse\n\t\t    UFclose(&f);\n\t    }\n\t    return NO_BUFFER;\n\t}\n    }\n    else if (w3m_dump & DUMP_FRAME)\n\treturn NULL;\n\n    if (t_buf == NULL)\n\tt_buf = newBuffer(INIT_BUFFER_WIDTH);\n    copyParsedURL(&t_buf->currentURL, &pu);\n    t_buf->filename = pu.real_file ? pu.real_file :\n\tpu.file ? conv_to_system(pu.file) : NULL;\n    if (flag & RG_FRAME) {\n\tt_buf->bufferprop |= BP_FRAME;\n    }\n#ifdef USE_SSL\n    t_buf->ssl_certificate = f.ssl_certificate;\n#endif\n    frame_source = flag & RG_FRAME_SRC;\n    if (proc == DO_EXTERNAL) {\n\tb = doExternal(f, t, t_buf);\n    } else {\n\tb = loadSomething(&f, proc, t_buf);\n    }\n    UFclose(&f);\n    frame_source = 0;\n    if (b && b != NO_BUFFER) {\n\tb->real_scheme = f.scheme;\n\tb->real_type = real_type;\n\tif (w3m_backend)\n\t    b->type = allocStr(t, -1);\n\tif (pu.label) {\n\t    if (proc == loadHTMLBuffer) {\n\t\tAnchor *a;\n\t\ta = searchURLLabel(b, pu.label);\n\t\tif (a != NULL) {\n\t\t    gotoLine(b, a->start.line);\n\t\t    if (label_topline)\n\t\t\tb->topLine = lineSkip(b, b->topLine,\n\t\t\t\t\t      b->currentLine->linenumber\n\t\t\t\t\t      - b->topLine->linenumber, FALSE);\n\t\t    b->pos = a->start.pos;\n\t\t    arrangeCursor(b);\n\t\t}\n\t    }\n\t    else {\t\t/* plain text */\n\t\tint l = atoi(pu.label);\n\t\tgotoRealLine(b, l);\n\t\tb->pos = 0;\n\t\tarrangeCursor(b);\n\t    }\n\t}\n    }\n    if (header_string)\n\theader_string = NULL;\n#ifdef USE_NNTP\n    if (b && b != NO_BUFFER && (f.scheme == SCM_NNTP || f.scheme == SCM_NEWS))\n\treAnchorNewsheader(b);\n#endif\n    if (b && b != NO_BUFFER)\n\tpreFormUpdateBuffer(b);\n    TRAP_OFF;\n    return b;\n}\n\n#define TAG_IS(s,tag,len)\\\n  (strncasecmp(s,tag,len)==0&&(s[len] == '>' || IS_SPACE((int)s[len])))\n\nstatic char *\nhas_hidden_link(struct readbuffer *obuf, int cmd)\n{\n    Str line = obuf->line;\n    struct link_stack *p;\n\n    if (Strlastchar(line) != '>')\n\treturn NULL;\n\n    for (p = link_stack; p; p = p->next)\n\tif (p->cmd == cmd)\n\t    break;\n    if (!p)\n\treturn NULL;\n\n    if (obuf->pos == p->pos)\n\treturn line->ptr + p->offset;\n\n    return NULL;\n}\n\nstatic void\npush_link(int cmd, int offset, int pos)\n{\n    struct link_stack *p;\n    p = New(struct link_stack);\n    p->cmd = cmd;\n    p->offset = offset;\n    p->pos = pos;\n    p->next = link_stack;\n    link_stack = p;\n}\n\nstatic int\nis_period_char(unsigned char *ch)\n{\n    switch (*ch) {\n    case ',':\n    case '.':\n    case ':':\n    case ';':\n    case '?':\n    case '!':\n    case ')':\n    case ']':\n    case '}':\n    case '>':\n\treturn 1;\n    default:\n\treturn 0;\n    }\n}\n\nstatic int\nis_beginning_char(unsigned char *ch)\n{\n    switch (*ch) {\n    case '(':\n    case '[':\n    case '{':\n    case '`':\n    case '<':\n\treturn 1;\n    default:\n\treturn 0;\n    }\n}\n\nstatic int\nis_word_char(unsigned char *ch)\n{\n    Lineprop ctype = get_mctype(ch);\n\n#ifdef USE_M17N\n    if (ctype & (PC_CTRL | PC_KANJI | PC_UNKNOWN))\n\treturn 0;\n    if (ctype & (PC_WCHAR1 | PC_WCHAR2))\n\treturn 1;\n#else\n    if (ctype == PC_CTRL)\n\treturn 0;\n#endif\n\n    if (IS_ALNUM(*ch))\n\treturn 1;\n\n    switch (*ch) {\n    case ',':\n    case '.':\n    case ':':\n    case '\\\"':\t\t\t/* \" */\n    case '\\'':\n    case '$':\n    case '%':\n    case '*':\n    case '+':\n    case '-':\n    case '@':\n    case '~':\n    case '_':\n\treturn 1;\n    }\n#ifdef USE_M17N\n    if (*ch == NBSP_CODE)\n\treturn 1;\n#else\n    if (*ch == TIMES_CODE || *ch == DIVIDE_CODE || *ch == ANSP_CODE)\n\treturn 0;\n    if (*ch >= AGRAVE_CODE || *ch == NBSP_CODE)\n\treturn 1;\n#endif\n    return 0;\n}\n\n#ifdef USE_M17N\nstatic int\nis_combining_char(unsigned char *ch)\n{\n    Lineprop ctype = get_mctype(ch);\n\n    if (ctype & PC_WCHAR2)\n\treturn 1;\n    return 0;\n}\n#endif\n\nint\nis_boundary(unsigned char *ch1, unsigned char *ch2)\n{\n    if (!*ch1 || !*ch2)\n\treturn 1;\n\n    if (*ch1 == ' ' && *ch2 == ' ')\n\treturn 0;\n\n    if (*ch1 != ' ' && is_period_char(ch2))\n\treturn 0;\n\n    if (*ch2 != ' ' && is_beginning_char(ch1))\n\treturn 0;\n\n#ifdef USE_M17N\n    if (is_combining_char(ch2))\n\treturn 0;\n#endif\n    if (is_word_char(ch1) && is_word_char(ch2))\n\treturn 0;\n\n    return 1;\n}\n\n\nstatic void\nset_breakpoint(struct readbuffer *obuf, int tag_length)\n{\n    obuf->bp.len = obuf->line->length;\n    obuf->bp.pos = obuf->pos;\n    obuf->bp.tlen = tag_length;\n    obuf->bp.flag = obuf->flag;\n#ifdef FORMAT_NICE\n    obuf->bp.flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n    obuf->bp.top_margin = obuf->top_margin;\n    obuf->bp.bottom_margin = obuf->bottom_margin;\n\n    if (!obuf->bp.init_flag)\n\treturn;\n\n    bcopy((void *)&obuf->anchor, (void *)&obuf->bp.anchor,\n\t  sizeof(obuf->anchor));\n    obuf->bp.img_alt = obuf->img_alt;\n    obuf->bp.input_alt = obuf->input_alt;\n    obuf->bp.in_bold = obuf->in_bold;\n    obuf->bp.in_italic = obuf->in_italic;\n    obuf->bp.in_under = obuf->in_under;\n    obuf->bp.in_strike = obuf->in_strike;\n    obuf->bp.in_ins = obuf->in_ins;\n    obuf->bp.nobr_level = obuf->nobr_level;\n    obuf->bp.prev_ctype = obuf->prev_ctype;\n    obuf->bp.init_flag = 0;\n}\n\nstatic void\nback_to_breakpoint(struct readbuffer *obuf)\n{\n    obuf->flag = obuf->bp.flag;\n    bcopy((void *)&obuf->bp.anchor, (void *)&obuf->anchor,\n\t  sizeof(obuf->anchor));\n    obuf->img_alt = obuf->bp.img_alt;\n    obuf->input_alt = obuf->bp.input_alt;\n    obuf->in_bold = obuf->bp.in_bold;\n    obuf->in_italic = obuf->bp.in_italic;\n    obuf->in_under = obuf->bp.in_under;\n    obuf->in_strike = obuf->bp.in_strike;\n    obuf->in_ins = obuf->bp.in_ins;\n    obuf->prev_ctype = obuf->bp.prev_ctype;\n    obuf->pos = obuf->bp.pos;\n    obuf->top_margin = obuf->bp.top_margin;\n    obuf->bottom_margin = obuf->bp.bottom_margin;\n    if (obuf->flag & RB_NOBR)\n\tobuf->nobr_level = obuf->bp.nobr_level;\n}\n\nstatic void\nappend_tags(struct readbuffer *obuf)\n{\n    int i;\n    int len = obuf->line->length;\n    int set_bp = 0;\n\n    for (i = 0; i < obuf->tag_sp; i++) {\n\tswitch (obuf->tag_stack[i]->cmd) {\n\tcase HTML_A:\n\tcase HTML_IMG_ALT:\n\tcase HTML_B:\n\tcase HTML_U:\n\tcase HTML_I:\n\tcase HTML_S:\n\t    push_link(obuf->tag_stack[i]->cmd, obuf->line->length, obuf->pos);\n\t    break;\n\t}\n\tStrcat_charp(obuf->line, obuf->tag_stack[i]->cmdname);\n\tswitch (obuf->tag_stack[i]->cmd) {\n\tcase HTML_NOBR:\n\t    if (obuf->nobr_level > 1)\n\t\tbreak;\n\tcase HTML_WBR:\n\t    set_bp = 1;\n\t    break;\n\t}\n    }\n    obuf->tag_sp = 0;\n    if (set_bp)\n\tset_breakpoint(obuf, obuf->line->length - len);\n}\n\nstatic void\npush_tag(struct readbuffer *obuf, char *cmdname, int cmd)\n{\n    obuf->tag_stack[obuf->tag_sp] = New(struct cmdtable);\n    obuf->tag_stack[obuf->tag_sp]->cmdname = allocStr(cmdname, -1);\n    obuf->tag_stack[obuf->tag_sp]->cmd = cmd;\n    obuf->tag_sp++;\n    if (obuf->tag_sp >= TAG_STACK_SIZE || obuf->flag & (RB_SPECIAL & ~RB_NOBR))\n\tappend_tags(obuf);\n}\n\nstatic void\npush_nchars(struct readbuffer *obuf, int width,\n\t    char *str, int len, Lineprop mode)\n{\n    append_tags(obuf);\n    Strcat_charp_n(obuf->line, str, len);\n    obuf->pos += width;\n    if (width > 0) {\n\tset_prevchar(obuf->prevchar, str, len);\n\tobuf->prev_ctype = mode;\n    }\n    obuf->flag |= RB_NFLUSHED;\n}\n\n#define push_charp(obuf, width, str, mode)\\\npush_nchars(obuf, width, str, strlen(str), mode)\n\n#define push_str(obuf, width, str, mode)\\\npush_nchars(obuf, width, str->ptr, str->length, mode)\n\nstatic void\ncheck_breakpoint(struct readbuffer *obuf, int pre_mode, char *ch)\n{\n    int tlen, len = obuf->line->length;\n\n    append_tags(obuf);\n    if (pre_mode)\n\treturn;\n    tlen = obuf->line->length - len;\n    if (tlen > 0\n\t|| is_boundary((unsigned char *)obuf->prevchar->ptr,\n\t\t       (unsigned char *)ch))\n\tset_breakpoint(obuf, tlen);\n}\n\nstatic void\npush_char(struct readbuffer *obuf, int pre_mode, char ch)\n{\n    check_breakpoint(obuf, pre_mode, &ch);\n    Strcat_char(obuf->line, ch);\n    obuf->pos++;\n    set_prevchar(obuf->prevchar, &ch, 1);\n    if (ch != ' ')\n\tobuf->prev_ctype = PC_ASCII;\n    obuf->flag |= RB_NFLUSHED;\n}\n\n#define PUSH(c) push_char(obuf, obuf->flag & RB_SPECIAL, c)\n\nstatic void\npush_spaces(struct readbuffer *obuf, int pre_mode, int width)\n{\n    int i;\n\n    if (width <= 0)\n\treturn;\n    check_breakpoint(obuf, pre_mode, \" \");\n    for (i = 0; i < width; i++)\n\tStrcat_char(obuf->line, ' ');\n    obuf->pos += width;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->flag |= RB_NFLUSHED;\n}\n\nstatic void\nproc_mchar(struct readbuffer *obuf, int pre_mode,\n\t   int width, char **str, Lineprop mode)\n{\n    check_breakpoint(obuf, pre_mode, *str);\n    obuf->pos += width;\n    Strcat_charp_n(obuf->line, *str, get_mclen(*str));\n    if (width > 0) {\n\tset_prevchar(obuf->prevchar, *str, 1);\n\tif (**str != ' ')\n\t    obuf->prev_ctype = mode;\n    }\n    (*str) += get_mclen(*str);\n    obuf->flag |= RB_NFLUSHED;\n}\n\nvoid\npush_render_image(Str str, int width, int limit,\n\t\t  struct html_feed_environ *h_env)\n{\n    struct readbuffer *obuf = h_env->obuf;\n    int indent = h_env->envs[h_env->envc].indent;\n\n    push_spaces(obuf, 1, (limit - width) / 2);\n    push_str(obuf, width, str, PC_ASCII);\n    push_spaces(obuf, 1, (limit - width + 1) / 2);\n    if (width > 0)\n\tflushline(h_env, obuf, indent, 0, h_env->limit);\n}\n\nstatic int\nsloppy_parse_line(char **str)\n{\n    if (**str == '<') {\n\twhile (**str && **str != '>')\n\t    (*str)++;\n\tif (**str == '>')\n\t    (*str)++;\n\treturn 1;\n    }\n    else {\n\twhile (**str && **str != '<')\n\t    (*str)++;\n\treturn 0;\n    }\n}\n\nstatic void\npassthrough(struct readbuffer *obuf, char *str, int back)\n{\n    int cmd;\n    Str tok = Strnew();\n    char *str_bak;\n\n    if (back) {\n\tStr str_save = Strnew_charp(str);\n\tStrshrink(obuf->line, obuf->line->ptr + obuf->line->length - str);\n\tstr = str_save->ptr;\n    }\n    while (*str) {\n\tstr_bak = str;\n\tif (sloppy_parse_line(&str)) {\n\t    char *q = str_bak;\n\t    cmd = gethtmlcmd(&q);\n\t    if (back) {\n\t\tstruct link_stack *p;\n\t\tfor (p = link_stack; p; p = p->next) {\n\t\t    if (p->cmd == cmd) {\n\t\t\tlink_stack = p->next;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tback = 0;\n\t    }\n\t    else {\n\t\tStrcat_charp_n(tok, str_bak, str - str_bak);\n\t\tpush_tag(obuf, tok->ptr, cmd);\n\t\tStrclear(tok);\n\t    }\n\t}\n\telse {\n\t    push_nchars(obuf, 0, str_bak, str - str_bak, obuf->prev_ctype);\n\t}\n    }\n}\n\n#if 0\nint\nis_blank_line(char *line, int indent)\n{\n    int i, is_blank = 0;\n\n    for (i = 0; i < indent; i++) {\n\tif (line[i] == '\\0') {\n\t    is_blank = 1;\n\t}\n\telse if (line[i] != ' ') {\n\t    break;\n\t}\n    }\n    if (i == indent && line[i] == '\\0')\n\tis_blank = 1;\n    return is_blank;\n}\n#endif\n\nvoid\nfillline(struct readbuffer *obuf, int indent)\n{\n    push_spaces(obuf, 1, indent - obuf->pos);\n    obuf->flag &= ~RB_NFLUSHED;\n}\n\nvoid\nflushline(struct html_feed_environ *h_env, struct readbuffer *obuf, int indent,\n\t  int force, int width)\n{\n    TextLineList *buf = h_env->buf;\n    FILE *f = h_env->f;\n    Str line = obuf->line, pass = NULL;\n    char *hidden_anchor = NULL, *hidden_img = NULL, *hidden_bold = NULL,\n\t*hidden_under = NULL, *hidden_italic = NULL, *hidden_strike = NULL,\n\t*hidden_ins = NULL, *hidden_input = NULL, *hidden = NULL;\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *df = fopen(\"zzzproc1\", \"a\");\n\tfprintf(df, \"flushline(%s,%d,%d,%d)\\n\", obuf->line->ptr, indent, force,\n\t\twidth);\n\tif (buf) {\n\t    TextLineListItem *p;\n\t    for (p = buf->first; p; p = p->next) {\n\t\tfprintf(df, \"buf=\\\"%s\\\"\\n\", p->ptr->line->ptr);\n\t    }\n\t}\n\tfclose(df);\n    }\n#endif\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && Strlastchar(line) == ' ') {\n\tStrshrink(line, 1);\n\tobuf->pos--;\n    }\n\n    append_tags(obuf);\n\n    if (obuf->anchor.url)\n\thidden = hidden_anchor = has_hidden_link(obuf, HTML_A);\n    if (obuf->img_alt) {\n\tif ((hidden_img = has_hidden_link(obuf, HTML_IMG_ALT)) != NULL) {\n\t    if (!hidden || hidden_img < hidden)\n\t\thidden = hidden_img;\n\t}\n    }\n    if (obuf->input_alt.in) {\n\tif ((hidden_input = has_hidden_link(obuf, HTML_INPUT_ALT)) != NULL) {\n\t    if (!hidden || hidden_input < hidden)\n\t\thidden = hidden_input;\n\t}\n    }\n    if (obuf->in_bold) {\n\tif ((hidden_bold = has_hidden_link(obuf, HTML_B)) != NULL) {\n\t    if (!hidden || hidden_bold < hidden)\n\t\thidden = hidden_bold;\n\t}\n    }\n    if (obuf->in_italic) {\n\tif ((hidden_italic = has_hidden_link(obuf, HTML_I)) != NULL) {\n\t    if (!hidden || hidden_italic < hidden)\n\t\thidden = hidden_italic;\n\t}\n    }\n    if (obuf->in_under) {\n\tif ((hidden_under = has_hidden_link(obuf, HTML_U)) != NULL) {\n\t    if (!hidden || hidden_under < hidden)\n\t\thidden = hidden_under;\n\t}\n    }\n    if (obuf->in_strike) {\n\tif ((hidden_strike = has_hidden_link(obuf, HTML_S)) != NULL) {\n\t    if (!hidden || hidden_strike < hidden)\n\t\thidden = hidden_strike;\n\t}\n    }\n    if (obuf->in_ins) {\n\tif ((hidden_ins = has_hidden_link(obuf, HTML_INS)) != NULL) {\n\t    if (!hidden || hidden_ins < hidden)\n\t\thidden = hidden_ins;\n\t}\n    }\n    if (hidden) {\n\tpass = Strnew_charp(hidden);\n\tStrshrink(line, line->ptr + line->length - hidden);\n    }\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && obuf->pos > width) {\n\tchar *tp = &line->ptr[obuf->bp.len - obuf->bp.tlen];\n\tchar *ep = &line->ptr[line->length];\n\n\tif (obuf->bp.pos == obuf->pos && tp <= ep &&\n\t    tp > line->ptr && tp[-1] == ' ') {\n\t    bcopy(tp, tp - 1, ep - tp + 1);\n\t    line->length--;\n\t    obuf->pos--;\n\t}\n    }\n\n    if (obuf->anchor.url && !hidden_anchor)\n\tStrcat_charp(line, \"</a>\");\n    if (obuf->img_alt && !hidden_img)\n\tStrcat_charp(line, \"</img_alt>\");\n    if (obuf->input_alt.in && !hidden_input)\n\tStrcat_charp(line, \"</input_alt>\");\n    if (obuf->in_bold && !hidden_bold)\n\tStrcat_charp(line, \"</b>\");\n    if (obuf->in_italic && !hidden_italic)\n\tStrcat_charp(line, \"</i>\");\n    if (obuf->in_under && !hidden_under)\n\tStrcat_charp(line, \"</u>\");\n    if (obuf->in_strike && !hidden_strike)\n\tStrcat_charp(line, \"</s>\");\n    if (obuf->in_ins && !hidden_ins)\n\tStrcat_charp(line, \"</ins>\");\n\n    if (obuf->top_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \"<pre_int>\");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \"</pre_int>\");\n\tfor (i = 0; i < obuf->top_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n\n    if (force == 1 || obuf->flag & RB_NFLUSHED) {\n\tTextLine *lbuf = newTextLine(line, obuf->pos);\n\tif (RB_GET_ALIGN(obuf) == RB_CENTER) {\n\t    align(lbuf, width, ALIGN_CENTER);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_RIGHT) {\n\t    align(lbuf, width, ALIGN_RIGHT);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_LEFT && obuf->flag & RB_INTABLE) {\n\t    align(lbuf, width, ALIGN_LEFT);\n\t}\n#ifdef FORMAT_NICE\n\telse if (obuf->flag & RB_FILL) {\n\t    char *p;\n\t    int rest, rrest;\n\t    int nspace, d, i;\n\n\t    rest = width - get_Str_strwidth(line);\n\t    if (rest > 1) {\n\t\tnspace = 0;\n\t\tfor (p = line->ptr + indent; *p; p++) {\n\t\t    if (*p == ' ')\n\t\t\tnspace++;\n\t\t}\n\t\tif (nspace > 0) {\n\t\t    int indent_here = 0;\n\t\t    d = rest / nspace;\n\t\t    p = line->ptr;\n\t\t    while (IS_SPACE(*p)) {\n\t\t\tp++;\n\t\t\tindent_here++;\n\t\t    }\n\t\t    rrest = rest - d * nspace;\n\t\t    line = Strnew_size(width + 1);\n\t\t    for (i = 0; i < indent_here; i++)\n\t\t\tStrcat_char(line, ' ');\n\t\t    for (; *p; p++) {\n\t\t\tStrcat_char(line, *p);\n\t\t\tif (*p == ' ') {\n\t\t\t    for (i = 0; i < d; i++)\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t    if (rrest > 0) {\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t\trrest--;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    lbuf = newTextLine(line, width);\n\t\t}\n\t    }\n\t}\n#endif\t\t\t\t/* FORMAT_NICE */\n#ifdef TABLE_DEBUG\n\tif (w3m_debug) {\n\t    FILE *f = fopen(\"zzzproc1\", \"a\");\n\t    fprintf(f, \"pos=%d,%d, maxlimit=%d\\n\",\n\t\t    visible_length(lbuf->line->ptr), lbuf->pos,\n\t\t    h_env->maxlimit);\n\t    fclose(f);\n\t}\n#endif\n\tif (lbuf->pos > h_env->maxlimit)\n\t    h_env->maxlimit = lbuf->pos;\n\tif (buf)\n\t    pushTextLine(buf, lbuf);\n\telse if (f) {\n\t    Strfputs(Str_conv_to_halfdump(lbuf->line), f);\n\t    fputc('\\n', f);\n\t}\n\tif (obuf->flag & RB_SPECIAL || obuf->flag & RB_NFLUSHED)\n\t    h_env->blank_lines = 0;\n\telse\n\t    h_env->blank_lines++;\n    }\n    else {\n\tchar *p = line->ptr, *q;\n\tStr tmp = Strnew(), tmp2 = Strnew();\n\n#define APPEND(str) \\\n\tif (buf) \\\n\t    appendTextLine(buf,(str),0); \\\n\telse if (f) \\\n\t    Strfputs((str),f)\n\n\twhile (*p) {\n\t    q = p;\n\t    if (sloppy_parse_line(&p)) {\n\t\tStrcat_charp_n(tmp, q, p - q);\n\t\tif (force == 2) {\n\t\t    APPEND(tmp);\n\t\t}\n\t\telse\n\t\t    Strcat(tmp2, tmp);\n\t\tStrclear(tmp);\n\t    }\n\t}\n\tif (force == 2) {\n\t    if (pass) {\n\t\tAPPEND(pass);\n\t    }\n\t    pass = NULL;\n\t}\n\telse {\n\t    if (pass)\n\t\tStrcat(tmp2, pass);\n\t    pass = tmp2;\n\t}\n    }\n\n    if (obuf->bottom_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \"<pre_int>\");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \"</pre_int>\");\n\tfor (i = 0; i < obuf->bottom_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n    if (obuf->top_margin < 0 || obuf->bottom_margin < 0)\n\treturn;\n\n    obuf->line = Strnew_size(256);\n    obuf->pos = 0;\n    obuf->top_margin = 0;\n    obuf->bottom_margin = 0;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->bp.init_flag = 1;\n    obuf->flag &= ~RB_NFLUSHED;\n    set_breakpoint(obuf, 0);\n    obuf->prev_ctype = PC_ASCII;\n    link_stack = NULL;\n    fillline(obuf, indent);\n    if (pass)\n\tpassthrough(obuf, pass->ptr, 0);\n    if (!hidden_anchor && obuf->anchor.url) {\n\tStr tmp;\n\tif (obuf->anchor.hseq > 0)\n\t    obuf->anchor.hseq = -obuf->anchor.hseq;\n\ttmp = Sprintf(\"<A HSEQ=\\\"%d\\\" HREF=\\\"\", obuf->anchor.hseq);\n\tStrcat_charp(tmp, html_quote(obuf->anchor.url));\n\tif (obuf->anchor.target) {\n\t    Strcat_charp(tmp, \"\\\" TARGET=\\\"\");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.target));\n\t}\n\tif (obuf->anchor.referer) {\n\t    Strcat_charp(tmp, \"\\\" REFERER=\\\"\");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.referer));\n\t}\n\tif (obuf->anchor.title) {\n\t    Strcat_charp(tmp, \"\\\" TITLE=\\\"\");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.title));\n\t}\n\tif (obuf->anchor.accesskey) {\n\t    char *c = html_quote_char(obuf->anchor.accesskey);\n\t    Strcat_charp(tmp, \"\\\" ACCESSKEY=\\\"\");\n\t    if (c)\n\t\tStrcat_charp(tmp, c);\n\t    else\n\t\tStrcat_char(tmp, obuf->anchor.accesskey);\n\t}\n\tStrcat_charp(tmp, \"\\\">\");\n\tpush_tag(obuf, tmp->ptr, HTML_A);\n    }\n    if (!hidden_img && obuf->img_alt) {\n\tStr tmp = Strnew_charp(\"<IMG_ALT SRC=\\\"\");\n\tStrcat_charp(tmp, html_quote(obuf->img_alt->ptr));\n\tStrcat_charp(tmp, \"\\\">\");\n\tpush_tag(obuf, tmp->ptr, HTML_IMG_ALT);\n    }\n    if (!hidden_input && obuf->input_alt.in) {\n\tStr tmp;\n\tif (obuf->input_alt.hseq > 0)\n\t    obuf->input_alt.hseq = - obuf->input_alt.hseq;\n\ttmp = Sprintf(\"<INPUT_ALT hseq=\\\"%d\\\" fid=\\\"%d\\\" name=\\\"%s\\\" type=\\\"%s\\\" value=\\\"%s\\\">\",\n\t\t     obuf->input_alt.hseq,\n\t\t     obuf->input_alt.fid,\n\t\t     obuf->input_alt.name ? obuf->input_alt.name->ptr : \"\",\n\t\t     obuf->input_alt.type ? obuf->input_alt.type->ptr : \"\",\n\t\t     obuf->input_alt.value ? obuf->input_alt.value->ptr : \"\");\n\tpush_tag(obuf, tmp->ptr, HTML_INPUT_ALT);\n    }\n    if (!hidden_bold && obuf->in_bold)\n\tpush_tag(obuf, \"<B>\", HTML_B);\n    if (!hidden_italic && obuf->in_italic)\n\tpush_tag(obuf, \"<I>\", HTML_I);\n    if (!hidden_under && obuf->in_under)\n\tpush_tag(obuf, \"<U>\", HTML_U);\n    if (!hidden_strike && obuf->in_strike)\n\tpush_tag(obuf, \"<S>\", HTML_S);\n    if (!hidden_ins && obuf->in_ins)\n\tpush_tag(obuf, \"<INS>\", HTML_INS);\n}\n\nvoid\ndo_blankline(struct html_feed_environ *h_env, struct readbuffer *obuf,\n\t     int indent, int indent_incr, int width)\n{\n    if (h_env->blank_lines == 0)\n\tflushline(h_env, obuf, indent, 1, width);\n}\n\nvoid\npurgeline(struct html_feed_environ *h_env)\n{\n    char *p, *q;\n    Str tmp;\n\n    if (h_env->buf == NULL || h_env->blank_lines == 0)\n\treturn;\n\n    p = rpopTextLine(h_env->buf)->line->ptr;\n    tmp = Strnew();\n    while (*p) {\n\tq = p;\n\tif (sloppy_parse_line(&p)) {\n\t    Strcat_charp_n(tmp, q, p - q);\n\t}\n    }\n    appendTextLine(h_env->buf, tmp, 0);\n    h_env->blank_lines--;\n}\n\nstatic int\nclose_effect0(struct readbuffer *obuf, int cmd)\n{\n    int i;\n    char *p;\n\n    for (i = obuf->tag_sp - 1; i >= 0; i--) {\n\tif (obuf->tag_stack[i]->cmd == cmd)\n\t    break;\n    }\n    if (i >= 0) {\n\tobuf->tag_sp--;\n\tbcopy(&obuf->tag_stack[i + 1], &obuf->tag_stack[i],\n\t      (obuf->tag_sp - i) * sizeof(struct cmdtable *));\n\treturn 1;\n    }\n    else if ((p = has_hidden_link(obuf, cmd)) != NULL) {\n\tpassthrough(obuf, p, 1);\n\treturn 1;\n    }\n    return 0;\n}\n\nstatic void\nclose_anchor(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    if (obuf->anchor.url) {\n\tint i;\n\tchar *p = NULL;\n\tint is_erased = 0;\n\n\tfor (i = obuf->tag_sp - 1; i >= 0; i--) {\n\t    if (obuf->tag_stack[i]->cmd == HTML_A)\n\t\tbreak;\n\t}\n\tif (i < 0 && obuf->anchor.hseq > 0 && Strlastchar(obuf->line) == ' ') {\n\t    Strshrink(obuf->line, 1);\n\t    obuf->pos--;\n\t    is_erased = 1;\n\t}\n\n\tif (i >= 0 || (p = has_hidden_link(obuf, HTML_A))) {\n\t    if (obuf->anchor.hseq > 0) {\n\t\tHTMLlineproc1(ANSP, h_env);\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t    }\n\t    else {\n\t\tif (i >= 0) {\n\t\t    obuf->tag_sp--;\n\t\t    bcopy(&obuf->tag_stack[i + 1], &obuf->tag_stack[i],\n\t\t\t  (obuf->tag_sp - i) * sizeof(struct cmdtable *));\n\t\t}\n\t\telse {\n\t\t    passthrough(obuf, p, 1);\n\t\t}\n\t\tbzero((void *)&obuf->anchor, sizeof(obuf->anchor));\n\t\treturn;\n\t    }\n\t    is_erased = 0;\n\t}\n\tif (is_erased) {\n\t    Strcat_char(obuf->line, ' ');\n\t    obuf->pos++;\n\t}\n\n\tpush_tag(obuf, \"</a>\", HTML_N_A);\n    }\n    bzero((void *)&obuf->anchor, sizeof(obuf->anchor));\n}\n\nvoid\nsave_fonteffect(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    if (obuf->fontstat_sp < FONT_STACK_SIZE)\n\tbcopy(obuf->fontstat, obuf->fontstat_stack[obuf->fontstat_sp],\n\t      FONTSTAT_SIZE);\n    obuf->fontstat_sp++;\n    if (obuf->in_bold)\n\tpush_tag(obuf, \"</b>\", HTML_N_B);\n    if (obuf->in_italic)\n\tpush_tag(obuf, \"</i>\", HTML_N_I);\n    if (obuf->in_under)\n\tpush_tag(obuf, \"</u>\", HTML_N_U);\n    if (obuf->in_strike)\n\tpush_tag(obuf, \"</s>\", HTML_N_S);\n    if (obuf->in_ins)\n\tpush_tag(obuf, \"</ins>\", HTML_N_INS);\n    bzero(obuf->fontstat, FONTSTAT_SIZE);\n}\n\nvoid\nrestore_fonteffect(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    if (obuf->fontstat_sp > 0)\n\tobuf->fontstat_sp--;\n    if (obuf->fontstat_sp < FONT_STACK_SIZE)\n\tbcopy(obuf->fontstat_stack[obuf->fontstat_sp], obuf->fontstat,\n\t      FONTSTAT_SIZE);\n    if (obuf->in_bold)\n\tpush_tag(obuf, \"<b>\", HTML_B);\n    if (obuf->in_italic)\n\tpush_tag(obuf, \"<i>\", HTML_I);\n    if (obuf->in_under)\n\tpush_tag(obuf, \"<u>\", HTML_U);\n    if (obuf->in_strike)\n\tpush_tag(obuf, \"<s>\", HTML_S);\n    if (obuf->in_ins)\n\tpush_tag(obuf, \"<ins>\", HTML_INS);\n}\n\nstatic Str\nprocess_title(struct parsed_tag *tag)\n{\n    cur_title = Strnew();\n    return NULL;\n}\n\nstatic Str\nprocess_n_title(struct parsed_tag *tag)\n{\n    Str tmp;\n\n    if (!cur_title)\n\treturn NULL;\n    Strremovefirstspaces(cur_title);\n    Strremovetrailingspaces(cur_title);\n    tmp = Strnew_m_charp(\"<title_alt title=\\\"\",\n\t\t\t html_quote(cur_title->ptr), \"\\\">\", NULL);\n    cur_title = NULL;\n    return tmp;\n}\n\nstatic void\nfeed_title(char *str)\n{\n    if (!cur_title)\n\treturn;\n    while (*str) {\n\tif (*str == '&')\n\t    Strcat_charp(cur_title, getescapecmd(&str));\n\telse if (*str == '\\n' || *str == '\\r') {\n\t    Strcat_char(cur_title, ' ');\n\t    str++;\n\t}\n\telse\n\t    Strcat_char(cur_title, *(str++));\n    }\n}\n\nStr\nprocess_img(struct parsed_tag *tag, int width)\n{\n    char *p, *q, *r, *r2 = NULL, *s, *t;\n#ifdef USE_IMAGE\n    int w, i, nw, ni = 1, n, w0 = -1, i0 = -1;\n    int align, xoffset, yoffset, top, bottom, ismap = 0;\n    int use_image = activeImage && displayImage;\n#else\n    int w, i, nw, n;\n#endif\n    int pre_int = FALSE, ext_pre_int = FALSE;\n    Str tmp = Strnew();\n\n    if (!parsedtag_get_value(tag, ATTR_SRC, &p))\n\treturn tmp;\n    p = url_encode(remove_space(p), cur_baseURL, cur_document_charset);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_ALT, &q);\n    if (!pseudoInlines && (q == NULL || (*q == '\\0' && ignore_null_img_alt)))\n\treturn tmp;\n    t = q;\n    parsedtag_get_value(tag, ATTR_TITLE, &t);\n    w = -1;\n    if (parsedtag_get_value(tag, ATTR_WIDTH, &w)) {\n\tif (w < 0) {\n\t    if (width > 0)\n\t\tw = (int)(-width * pixel_per_char * w / 100 + 0.5);\n\t    else\n\t\tw = -1;\n\t}\n#ifdef USE_IMAGE\n\tif (use_image) {\n\t    if (w > 0) {\n\t\tw = (int)(w * image_scale / 100 + 0.5);\n\t\tif (w == 0)\n\t\t    w = 1;\n\t\telse if (w > MAX_IMAGE_SIZE)\n\t\t    w = MAX_IMAGE_SIZE;\n\t    }\n\t}\n#endif\n    }\n#ifdef USE_IMAGE\n    if (use_image) {\n\ti = -1;\n\tif (parsedtag_get_value(tag, ATTR_HEIGHT, &i)) {\n\t    if (i > 0) {\n\t\ti = (int)(i * image_scale / 100 + 0.5);\n\t\tif (i == 0)\n\t\t    i = 1;\n\t\telse if (i > MAX_IMAGE_SIZE)\n\t\t    i = MAX_IMAGE_SIZE;\n\t    }\n\t    else {\n\t\ti = -1;\n\t    }\n\t}\n\talign = -1;\n\tparsedtag_get_value(tag, ATTR_ALIGN, &align);\n\tismap = 0;\n\tif (parsedtag_exists(tag, ATTR_ISMAP))\n\t    ismap = 1;\n    }\n    else\n#endif\n\tparsedtag_get_value(tag, ATTR_HEIGHT, &i);\n    r = NULL;\n    parsedtag_get_value(tag, ATTR_USEMAP, &r);\n    if (parsedtag_exists(tag, ATTR_PRE_INT))\n\text_pre_int = TRUE;\n\n    tmp = Strnew_size(128);\n#ifdef USE_IMAGE\n    if (use_image) {\n\tswitch (align) {\n\tcase ALIGN_LEFT:\n\t    Strcat_charp(tmp, \"<div_int align=left>\");\n\t    break;\n\tcase ALIGN_CENTER:\n\t    Strcat_charp(tmp, \"<div_int align=center>\");\n\t    break;\n\tcase ALIGN_RIGHT:\n\t    Strcat_charp(tmp, \"<div_int align=right>\");\n\t    break;\n\t}\n    }\n#endif\n    if (r) {\n\tStr tmp2;\n\tr2 = strchr(r, '#');\n\ts = \"<form_int method=internal action=map>\";\n\ttmp2 = process_form(parse_tag(&s, TRUE));\n\tif (tmp2)\n\t    Strcat(tmp, tmp2);\n\tStrcat(tmp, Sprintf(\"<input_alt fid=\\\"%d\\\" \"\n\t\t\t    \"type=hidden name=link value=\\\"\", cur_form_id));\n\tStrcat_charp(tmp, html_quote((r2) ? r2 + 1 : r));\n\tStrcat(tmp, Sprintf(\"\\\"><input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" \"\n\t\t\t    \"type=submit no_effect=true>\",\n\t\t\t    cur_hseq++, cur_form_id));\n    }\n#ifdef USE_IMAGE\n    if (use_image) {\n\tw0 = w;\n\ti0 = i;\n\tif (w < 0 || i < 0) {\n\t    Image image;\n\t    ParsedURL u;\n\n\t    parseURL2(p, &u, cur_baseURL);\n\t    image.url = parsedURL2Str(&u)->ptr;\n\t    if (!uncompressed_file_type(u.file, &image.ext))\n\t\timage.ext = filename_extension(u.file, TRUE);\n\t    image.cache = NULL;\n\t    image.width = w;\n\t    image.height = i;\n\n\t    image.cache = getImage(&image, cur_baseURL, IMG_FLAG_SKIP);\n\t    if (image.cache && image.cache->width > 0 &&\n\t\timage.cache->height > 0) {\n\t\tw = w0 = image.cache->width;\n\t\ti = i0 = image.cache->height;\n\t    }\n\t    if (w < 0)\n\t\tw = 8 * pixel_per_char;\n\t    if (i < 0)\n\t\ti = pixel_per_line;\n\t}\n\tif (enable_inline_image) {\n\t    nw = (w > 1) ? ((w - 1) / pixel_per_char_i + 1) : 1 ;\n\t    ni = (i > 1) ? ((i - 1) / pixel_per_line_i + 1) : 1 ;\n\t}\n\telse {\n\t    nw = (w > 3) ? (int)((w - 3) / pixel_per_char + 1) : 1;\n\t    ni = (i > 3) ? (int)((i - 3) / pixel_per_line + 1) : 1;\n\t}\n\tStrcat(tmp,\n\t       Sprintf(\"<pre_int><img_alt hseq=\\\"%d\\\" src=\\\"\", cur_iseq++));\n\tpre_int = TRUE;\n    }\n    else\n#endif\n    {\n\tif (w < 0)\n\t    w = 12 * pixel_per_char;\n\tnw = w ? (int)((w - 1) / pixel_per_char + 1) : 1;\n\tif (r) {\n\t    Strcat_charp(tmp, \"<pre_int>\");\n\t    pre_int = TRUE;\n\t}\n\tStrcat_charp(tmp, \"<img_alt src=\\\"\");\n    }\n    Strcat_charp(tmp, html_quote(p));\n    Strcat_charp(tmp, \"\\\"\");\n    if (t) {\n\tStrcat_charp(tmp, \" title=\\\"\");\n\tStrcat_charp(tmp, html_quote(t));\n\tStrcat_charp(tmp, \"\\\"\");\n    }\n#ifdef USE_IMAGE\n    if (use_image) {\n\tif (w0 >= 0)\n\t    Strcat(tmp, Sprintf(\" width=%d\", w0));\n\tif (i0 >= 0)\n\t    Strcat(tmp, Sprintf(\" height=%d\", i0));\n\tswitch (align) {\n\tcase ALIGN_MIDDLE:\n\t    if (!enable_inline_image) {\n\t\ttop = ni / 2;\n\t\tbottom = top;\n\t\tif (top * 2 == ni)\n\t\t    yoffset = (int)(((ni + 1) * pixel_per_line - i) / 2);\n\t\telse\n\t\t    yoffset = (int)((ni * pixel_per_line - i) / 2);\n\t\tbreak;\n\t    }\n\tcase ALIGN_TOP:\n\t    top = 0;\n\t    bottom = ni - 1;\n\t    yoffset = 0;\n\t    break;\n\tcase ALIGN_BOTTOM:\n\t    top = ni - 1;\n\t    bottom = 0;\n\t    yoffset = (int)(ni * pixel_per_line - i);\n\t    break;\n\tdefault:\n\t    top = ni - 1;\n\t    bottom = 0;\n\t    if (ni == 1 && ni * pixel_per_line > i)\n\t\tyoffset = 0;\n\t    else {\n\t\tyoffset = (int)(ni * pixel_per_line - i);\n\t\tif (yoffset <= -2)\n\t\t    yoffset++;\n\t    }\n\t    break;\n\t}\n\n\tif (enable_inline_image)\n\t    xoffset = 0;\n\telse\n\t    xoffset = (int)((nw * pixel_per_char - w) / 2);\n\n\tif (xoffset)\n\t    Strcat(tmp, Sprintf(\" xoffset=%d\", xoffset));\n\tif (yoffset)\n\t    Strcat(tmp, Sprintf(\" yoffset=%d\", yoffset));\n\tif (top)\n\t    Strcat(tmp, Sprintf(\" top_margin=%d\", top));\n\tif (bottom)\n\t    Strcat(tmp, Sprintf(\" bottom_margin=%d\", bottom));\n\tif (r) {\n\t    Strcat_charp(tmp, \" usemap=\\\"\");\n\t    Strcat_charp(tmp, html_quote((r2) ? r2 + 1 : r));\n\t    Strcat_charp(tmp, \"\\\"\");\n\t}\n\tif (ismap)\n\t    Strcat_charp(tmp, \" ismap\");\n    }\n#endif\n    Strcat_charp(tmp, \">\");\n    if (q != NULL && *q == '\\0' && ignore_null_img_alt)\n\tq = NULL;\n    if (q != NULL) {\n\tn = get_strwidth(q);\n#ifdef USE_IMAGE\n\tif (use_image) {\n\t    if (n > nw) {\n\t\tchar *r;\n\t\tfor (r = q, n = 0; r; r += get_mclen(r), n += get_mcwidth(r)) {\n\t\t    if (n + get_mcwidth(r) > nw)\n\t\t\tbreak;\n\t\t}\n\t\tStrcat_charp(tmp, html_quote(Strnew_charp_n(q, r - q)->ptr));\n\t    }\n\t    else\n\t\tStrcat_charp(tmp, html_quote(q));\n\t}\n\telse\n#endif\n\t    Strcat_charp(tmp, html_quote(q));\n\tgoto img_end;\n    }\n    if (w > 0 && i > 0) {\n\t/* guess what the image is! */\n\tif (w < 32 && i < 48) {\n\t    /* must be an icon or space */\n\t    n = 1;\n\t    if (strcasestr(p, \"space\") || strcasestr(p, \"blank\"))\n\t\tStrcat_charp(tmp, \"_\");\n\t    else {\n\t\tif (w * i < 8 * 16)\n\t\t    Strcat_charp(tmp, \"*\");\n\t\telse {\n\t\t    if (!pre_int) {\n\t\t\tStrcat_charp(tmp, \"<pre_int>\");\n\t\t\tpre_int = TRUE;\n\t\t    }\n\t\t    push_symbol(tmp, IMG_SYMBOL, symbol_width, 1);\n\t\t    n = symbol_width;\n\t\t}\n\t    }\n\t    goto img_end;\n\t}\n\tif (w > 200 && i < 13) {\n\t    /* must be a horizontal line */\n\t    if (!pre_int) {\n\t\tStrcat_charp(tmp, \"<pre_int>\");\n\t\tpre_int = TRUE;\n\t    }\n\t    w = w / pixel_per_char / symbol_width;\n\t    if (w <= 0)\n\t\tw = 1;\n\t    push_symbol(tmp, HR_SYMBOL, symbol_width, w);\n\t    n = w * symbol_width;\n\t    goto img_end;\n\t}\n    }\n    for (q = p; *q; q++) ;\n    while (q > p && *q != '/')\n\tq--;\n    if (*q == '/')\n\tq++;\n    Strcat_char(tmp, '[');\n    n = 1;\n    p = q;\n    for (; *q; q++) {\n\tif (!IS_ALNUM(*q) && *q != '_' && *q != '-') {\n\t    break;\n\t}\n\tStrcat_char(tmp, *q);\n\tn++;\n\tif (n + 1 >= nw)\n\t    break;\n    }\n    Strcat_char(tmp, ']');\n    n++;\n  img_end:\n#ifdef USE_IMAGE\n    if (use_image) {\n\tfor (; n < nw; n++)\n\t    Strcat_char(tmp, ' ');\n    }\n#endif\n    Strcat_charp(tmp, \"</img_alt>\");\n    if (pre_int && !ext_pre_int)\n\tStrcat_charp(tmp, \"</pre_int>\");\n    if (r) {\n\tStrcat_charp(tmp, \"</input_alt>\");\n\tprocess_n_form();\n    }\n#ifdef USE_IMAGE\n    if (use_image) {\n\tswitch (align) {\n\tcase ALIGN_RIGHT:\n\tcase ALIGN_CENTER:\n\tcase ALIGN_LEFT:\n\t    Strcat_charp(tmp, \"</div_int>\");\n\t    break;\n\t}\n    }\n#endif\n    return tmp;\n}\n\nStr\nprocess_anchor(struct parsed_tag *tag, char *tagbuf)\n{\n    if (parsedtag_need_reconstruct(tag)) {\n\tparsedtag_set_value(tag, ATTR_HSEQ, Sprintf(\"%d\", cur_hseq++)->ptr);\n\treturn parsedtag2str(tag);\n    }\n    else {\n\tStr tmp = Sprintf(\"<a hseq=\\\"%d\\\"\", cur_hseq++);\n\tStrcat_charp(tmp, tagbuf + 2);\n\treturn tmp;\n    }\n}\n\nStr\nprocess_input(struct parsed_tag *tag)\n{\n    int i = 20, v, x, y, z, iw, ih, size = 20;\n    char *q, *p, *r, *p2, *s;\n    Str tmp = NULL;\n    char *qq = \"\";\n    int qlen = 0;\n\n    if (cur_form_id < 0) {\n\tchar *s = \"<form_int method=internal action=none>\";\n\ttmp = process_form(parse_tag(&s, TRUE));\n    }\n    if (tmp == NULL)\n\ttmp = Strnew();\n\n    p = \"text\";\n    parsedtag_get_value(tag, ATTR_TYPE, &p);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_VALUE, &q);\n    r = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &r);\n    parsedtag_get_value(tag, ATTR_SIZE, &size);\n    if (size > MAX_INPUT_SIZE)\n\t    size = MAX_INPUT_SIZE;\n    parsedtag_get_value(tag, ATTR_MAXLENGTH, &i);\n    p2 = NULL;\n    parsedtag_get_value(tag, ATTR_ALT, &p2);\n    x = parsedtag_exists(tag, ATTR_CHECKED);\n    y = parsedtag_exists(tag, ATTR_ACCEPT);\n    z = parsedtag_exists(tag, ATTR_READONLY);\n\n    v = formtype(p);\n    if (v == FORM_UNKNOWN)\n\treturn NULL;\n\n    if (!q) {\n\tswitch (v) {\n\tcase FORM_INPUT_IMAGE:\n\tcase FORM_INPUT_SUBMIT:\n\tcase FORM_INPUT_BUTTON:\n\t    q = \"SUBMIT\";\n\t    break;\n\tcase FORM_INPUT_RESET:\n\t    q = \"RESET\";\n\t    break;\n\t    /* if no VALUE attribute is specified in \n\t     * <INPUT TYPE=CHECKBOX> tag, then the value \"on\" is used \n\t     * as a default value. It is not a part of HTML4.0 \n\t     * specification, but an imitation of Netscape behaviour. \n\t     */\n\tcase FORM_INPUT_CHECKBOX:\n\t    q = \"on\";\n\t}\n    }\n    /* VALUE attribute is not allowed in <INPUT TYPE=FILE> tag. */\n    if (v == FORM_INPUT_FILE)\n\tq = NULL;\n    if (q) {\n\tqq = html_quote(q);\n\tqlen = get_strwidth(q);\n    }\n\n    Strcat_charp(tmp, \"<pre_int>\");\n    switch (v) {\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_CHECKBOX:\n\tif (displayLinkNumber)\n\t    Strcat(tmp, getLinkNumberStr(0));\n\tStrcat_char(tmp, '[');\n\tbreak;\n    case FORM_INPUT_RADIO:\n\tif (displayLinkNumber)\n\t    Strcat(tmp, getLinkNumberStr(0));\n\tStrcat_char(tmp, '(');\n    }\n    Strcat(tmp, Sprintf(\"<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" type=\\\"%s\\\" \"\n\t\t\t\"name=\\\"%s\\\" width=%d maxlength=%d value=\\\"%s\\\"\",\n\t\t\tcur_hseq++, cur_form_id, html_quote(p),\n\t\t\thtml_quote(r), size, i, qq));\n    if (x)\n\tStrcat_charp(tmp, \" checked\");\n    if (y)\n\tStrcat_charp(tmp, \" accept\");\n    if (z)\n\tStrcat_charp(tmp, \" readonly\");\n    Strcat_char(tmp, '>');\n\n    if (v == FORM_INPUT_HIDDEN)\n\tStrcat_charp(tmp, \"</input_alt></pre_int>\");\n    else {\n\tswitch (v) {\n\tcase FORM_INPUT_PASSWORD:\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_FILE:\n\t    Strcat_charp(tmp, \"<u>\");\n\t    break;\n\tcase FORM_INPUT_IMAGE:\n\t    s = NULL;\n\t    parsedtag_get_value(tag, ATTR_SRC, &s);\n\t    if (s) {\n\t\tStrcat(tmp, Sprintf(\"<img src=\\\"%s\\\"\", html_quote(s)));\n\t\tif (p2)\n\t\t    Strcat(tmp, Sprintf(\" alt=\\\"%s\\\"\", html_quote(p2)));\n\t\tif (parsedtag_get_value(tag, ATTR_WIDTH, &iw))\n\t\t    Strcat(tmp, Sprintf(\" width=\\\"%d\\\"\", iw));\n\t\tif (parsedtag_get_value(tag, ATTR_HEIGHT, &ih))\n\t\t    Strcat(tmp, Sprintf(\" height=\\\"%d\\\"\", ih));\n\t\tStrcat_charp(tmp, \" pre_int>\");\n\t\tStrcat_charp(tmp, \"</input_alt></pre_int>\");\n\t\treturn tmp;\n\t    }\n\tcase FORM_INPUT_SUBMIT:\n\tcase FORM_INPUT_BUTTON:\n\tcase FORM_INPUT_RESET:\n\t    if (displayLinkNumber)\n\t\tStrcat(tmp, getLinkNumberStr(-1));\n\t    Strcat_charp(tmp, \"[\");\n\t    break;\n\t}\n\tswitch (v) {\n\tcase FORM_INPUT_PASSWORD:\n\t    i = 0;\n\t    if (q) {\n\t\tfor (; i < qlen && i < size; i++)\n\t\t    Strcat_char(tmp, '*');\n\t    }\n\t    for (; i < size; i++)\n\t\tStrcat_char(tmp, ' ');\n\t    break;\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_FILE:\n\t    if (q)\n\t\tStrcat(tmp, textfieldrep(Strnew_charp(q), size));\n\t    else {\n\t\tfor (i = 0; i < size; i++)\n\t\t    Strcat_char(tmp, ' ');\n\t    }\n\t    break;\n\tcase FORM_INPUT_SUBMIT:\n\tcase FORM_INPUT_BUTTON:\n\t    if (p2)\n\t\tStrcat_charp(tmp, html_quote(p2));\n\t    else\n\t\tStrcat_charp(tmp, qq);\n\t    break;\n\tcase FORM_INPUT_RESET:\n\t    Strcat_charp(tmp, qq);\n\t    break;\n\tcase FORM_INPUT_RADIO:\n\tcase FORM_INPUT_CHECKBOX:\n\t    if (x)\n\t\tStrcat_char(tmp, '*');\n\t    else\n\t\tStrcat_char(tmp, ' ');\n\t    break;\n\t}\n\tswitch (v) {\n\tcase FORM_INPUT_PASSWORD:\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_FILE:\n\t    Strcat_charp(tmp, \"</u>\");\n\t    break;\n\tcase FORM_INPUT_IMAGE:\n\tcase FORM_INPUT_SUBMIT:\n\tcase FORM_INPUT_BUTTON:\n\tcase FORM_INPUT_RESET:\n\t    Strcat_charp(tmp, \"]\");\n\t}\n\tStrcat_charp(tmp, \"</input_alt>\");\n\tswitch (v) {\n\tcase FORM_INPUT_PASSWORD:\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_FILE:\n\tcase FORM_INPUT_CHECKBOX:\n\t    Strcat_char(tmp, ']');\n\t    break;\n\tcase FORM_INPUT_RADIO:\n\t    Strcat_char(tmp, ')');\n\t}\n\tStrcat_charp(tmp, \"</pre_int>\");\n    }\n    return tmp;\n}\n\nStr\nprocess_button(struct parsed_tag *tag)\n{\n    Str tmp = NULL;\n    char *p, *q, *r, *qq = \"\";\n    int qlen, v;\n\n    if (cur_form_id < 0) {\n       char *s = \"<form_int method=internal action=none>\";\n       tmp = process_form(parse_tag(&s, TRUE));\n    }\n    if (tmp == NULL)\n       tmp = Strnew();\n\n    p = \"submit\";\n    parsedtag_get_value(tag, ATTR_TYPE, &p);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_VALUE, &q);\n    r = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &r);\n\n    v = formtype(p);\n    if (v == FORM_UNKNOWN)\n       return NULL;\n\n    switch (v) {\n    case FORM_INPUT_SUBMIT:\n    case FORM_INPUT_BUTTON:\n    case FORM_INPUT_RESET:\n\tbreak;\n    default:\n\tp = \"submit\";\n\tv = FORM_INPUT_SUBMIT;\n\tbreak;\n    }\n\n    if (!q) {\n       switch (v) {\n       case FORM_INPUT_SUBMIT:\n       case FORM_INPUT_BUTTON:\n           q = \"SUBMIT\";\n           break;\n       case FORM_INPUT_RESET:\n           q = \"RESET\";\n           break;\n       }\n    }\n    if (q) {\n       qq = html_quote(q);\n       qlen = strlen(q);\n    }\n\n    /*    Strcat_charp(tmp, \"<pre_int>\"); */\n    Strcat(tmp, Sprintf(\"<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" type=\\\"%s\\\" \"\n                       \"name=\\\"%s\\\" value=\\\"%s\\\">\",\n                       cur_hseq++, cur_form_id, html_quote(p),\n                       html_quote(r), qq));\n    return tmp;\n}\n\nStr\nprocess_n_button(void)\n{\n    Str tmp = Strnew();\n    Strcat_charp(tmp, \"</input_alt>\");\n    /*    Strcat_charp(tmp, \"</pre_int>\"); */\n    return tmp;\n}\n\nStr\nprocess_select(struct parsed_tag *tag)\n{\n    Str tmp = NULL;\n    char *p;\n\n    if (cur_form_id < 0) {\n\tchar *s = \"<form_int method=internal action=none>\";\n\ttmp = process_form(parse_tag(&s, TRUE));\n    }\n\n    p = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &p);\n    cur_select = Strnew_charp(p);\n    select_is_multiple = parsedtag_exists(tag, ATTR_MULTIPLE);\n\n#ifdef MENU_SELECT\n    if (!select_is_multiple) {\n\tselect_str = Strnew_charp(\"<pre_int>\");\n\tif (displayLinkNumber)\n\t    Strcat(select_str, getLinkNumberStr(0));\n\tStrcat(select_str, Sprintf(\"[<input_alt hseq=\\\"%d\\\" \"\n\t\t\t     \"fid=\\\"%d\\\" type=select name=\\\"%s\\\" selectnumber=%d\",\n\t\t\t     cur_hseq++, cur_form_id, html_quote(p), n_select));\n\tStrcat_charp(select_str, \">\");\n\tif (n_select == max_select) {\n\t    max_select *= 2;\n\t    select_option =\n\t\tNew_Reuse(FormSelectOption, select_option, max_select);\n\t}\n\tselect_option[n_select].first = NULL;\n\tselect_option[n_select].last = NULL;\n\tcur_option_maxwidth = 0;\n    }\n    else\n#endif\t\t\t\t/* MENU_SELECT */\n\tselect_str = Strnew();\n    cur_option = NULL;\n    cur_status = R_ST_NORMAL;\n    n_selectitem = 0;\n    return tmp;\n}\n\nStr\nprocess_n_select(void)\n{\n    if (cur_select == NULL)\n\treturn NULL;\n    process_option();\n#ifdef MENU_SELECT\n    if (!select_is_multiple) {\n\tif (select_option[n_select].first) {\n\t    FormItemList sitem;\n\t    chooseSelectOption(&sitem, select_option[n_select].first);\n\t    Strcat(select_str, textfieldrep(sitem.label, cur_option_maxwidth));\n\t}\n\tStrcat_charp(select_str, \"</input_alt>]</pre_int>\");\n\tn_select++;\n    }\n    else\n#endif\t\t\t\t/* MENU_SELECT */\n\tStrcat_charp(select_str, \"<br>\");\n    cur_select = NULL;\n    n_selectitem = 0;\n    return select_str;\n}\n\nvoid\nfeed_select(char *str)\n{\n    Str tmp = Strnew();\n    int prev_status = cur_status;\n    static int prev_spaces = -1;\n    char *p;\n\n    if (cur_select == NULL)\n\treturn;\n    while (read_token(tmp, &str, &cur_status, 0, 0)) {\n\tif (cur_status != R_ST_NORMAL || prev_status != R_ST_NORMAL)\n\t    continue;\n\tp = tmp->ptr;\n\tif (tmp->ptr[0] == '<' && Strlastchar(tmp) == '>') {\n\t    struct parsed_tag *tag;\n\t    char *q;\n\t    if (!(tag = parse_tag(&p, FALSE)))\n\t\tcontinue;\n\t    switch (tag->tagid) {\n\t    case HTML_OPTION:\n\t\tprocess_option();\n\t\tcur_option = Strnew();\n\t\tif (parsedtag_get_value(tag, ATTR_VALUE, &q))\n\t\t    cur_option_value = Strnew_charp(q);\n\t\telse\n\t\t    cur_option_value = NULL;\n\t\tif (parsedtag_get_value(tag, ATTR_LABEL, &q))\n\t\t    cur_option_label = Strnew_charp(q);\n\t\telse\n\t\t    cur_option_label = NULL;\n\t\tcur_option_selected = parsedtag_exists(tag, ATTR_SELECTED);\n\t\tprev_spaces = -1;\n\t\tbreak;\n\t    case HTML_N_OPTION:\n\t\t/* do nothing */\n\t\tbreak;\n\t    default:\n\t\t/* never happen */\n\t\tbreak;\n\t    }\n\t}\n\telse if (cur_option) {\n\t    while (*p) {\n\t\tif (IS_SPACE(*p) && prev_spaces != 0) {\n\t\t    p++;\n\t\t    if (prev_spaces > 0)\n\t\t\tprev_spaces++;\n\t\t}\n\t\telse {\n\t\t    if (IS_SPACE(*p))\n\t\t\tprev_spaces = 1;\n\t\t    else\n\t\t\tprev_spaces = 0;\n\t\t    if (*p == '&')\n\t\t\tStrcat_charp(cur_option, getescapecmd(&p));\n\t\t    else\n\t\t\tStrcat_char(cur_option, *(p++));\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid\nprocess_option(void)\n{\n    char begin_char = '[', end_char = ']';\n    int len;\n\n    if (cur_select == NULL || cur_option == NULL)\n\treturn;\n    while (cur_option->length > 0 && IS_SPACE(Strlastchar(cur_option)))\n\tStrshrink(cur_option, 1);\n    if (cur_option_value == NULL)\n\tcur_option_value = cur_option;\n    if (cur_option_label == NULL)\n\tcur_option_label = cur_option;\n#ifdef MENU_SELECT\n    if (!select_is_multiple) {\n\tlen = get_Str_strwidth(cur_option_label);\n\tif (len > cur_option_maxwidth)\n\t    cur_option_maxwidth = len;\n\taddSelectOption(&select_option[n_select],\n\t\t\tcur_option_value,\n\t\t\tcur_option_label, cur_option_selected);\n\treturn;\n    }\n#endif\t\t\t\t/* MENU_SELECT */\n    if (!select_is_multiple) {\n\tbegin_char = '(';\n\tend_char = ')';\n    }\n    Strcat(select_str, Sprintf(\"<br><pre_int>%c<input_alt hseq=\\\"%d\\\" \"\n\t\t\t       \"fid=\\\"%d\\\" type=%s name=\\\"%s\\\" value=\\\"%s\\\"\",\n\t\t\t       begin_char, cur_hseq++, cur_form_id,\n\t\t\t       select_is_multiple ? \"checkbox\" : \"radio\",\n\t\t\t       html_quote(cur_select->ptr),\n\t\t\t       html_quote(cur_option_value->ptr)));\n    if (cur_option_selected)\n\tStrcat_charp(select_str, \" checked>*</input_alt>\");\n    else\n\tStrcat_charp(select_str, \"> </input_alt>\");\n    Strcat_char(select_str, end_char);\n    Strcat_charp(select_str, html_quote(cur_option_label->ptr));\n    Strcat_charp(select_str, \"</pre_int>\");\n    n_selectitem++;\n}\n\nStr\nprocess_textarea(struct parsed_tag *tag, int width)\n{\n    Str tmp = NULL;\n    char *p;\n#define TEXTAREA_ATTR_COL_MAX 4096\n#define TEXTAREA_ATTR_ROWS_MAX 4096\n\n    if (cur_form_id < 0) {\n\tchar *s = \"<form_int method=internal action=none>\";\n\ttmp = process_form(parse_tag(&s, TRUE));\n    }\n\n    p = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &p);\n    cur_textarea = Strnew_charp(p);\n    cur_textarea_size = 20;\n    if (parsedtag_get_value(tag, ATTR_COLS, &p)) {\n\tcur_textarea_size = atoi(p);\n\tif (p[strlen(p) - 1] == '%')\n\t    cur_textarea_size = width * cur_textarea_size / 100 - 2;\n\tif (cur_textarea_size <= 0) {\n\t    cur_textarea_size = 20;\n\t} else if (cur_textarea_size > TEXTAREA_ATTR_COL_MAX) {\n\t    cur_textarea_size = TEXTAREA_ATTR_COL_MAX;\n\t}\n    }\n    cur_textarea_rows = 1;\n    if (parsedtag_get_value(tag, ATTR_ROWS, &p)) {\n\tcur_textarea_rows = atoi(p);\n\tif (cur_textarea_rows <= 0) {\n\t    cur_textarea_rows = 1;\n\t} else if (cur_textarea_rows > TEXTAREA_ATTR_ROWS_MAX) {\n\t    cur_textarea_rows = TEXTAREA_ATTR_ROWS_MAX;\n\t}\n    }\n    cur_textarea_readonly = parsedtag_exists(tag, ATTR_READONLY);\n    if (n_textarea >= max_textarea) {\n\tmax_textarea *= 2;\n\ttextarea_str = New_Reuse(Str, textarea_str, max_textarea);\n    }\n    textarea_str[n_textarea] = Strnew();\n    ignore_nl_textarea = TRUE;\n\n    return tmp;\n}\n\nStr\nprocess_n_textarea(void)\n{\n    Str tmp;\n    int i;\n\n    if (cur_textarea == NULL)\n\treturn NULL;\n\n    tmp = Strnew();\n    Strcat(tmp, Sprintf(\"<pre_int>[<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" \"\n\t\t\t\"type=textarea name=\\\"%s\\\" size=%d rows=%d \"\n\t\t\t\"top_margin=%d textareanumber=%d\",\n\t\t\tcur_hseq, cur_form_id,\n\t\t\thtml_quote(cur_textarea->ptr),\n\t\t\tcur_textarea_size, cur_textarea_rows,\n\t\t\tcur_textarea_rows - 1, n_textarea));\n    if (cur_textarea_readonly)\n\tStrcat_charp(tmp, \" readonly\");\n    Strcat_charp(tmp, \"><u>\");\n    for (i = 0; i < cur_textarea_size; i++)\n\tStrcat_char(tmp, ' ');\n    Strcat_charp(tmp, \"</u></input_alt>]</pre_int>\\n\");\n    cur_hseq++;\n    n_textarea++;\n    cur_textarea = NULL;\n\n    return tmp;\n}\n\nvoid\nfeed_textarea(char *str)\n{\n    if (cur_textarea == NULL)\n\treturn;\n    if (ignore_nl_textarea) {\n\tif (*str == '\\r')\n\t    str++;\n\tif (*str == '\\n')\n\t    str++;\n    }\n    ignore_nl_textarea = FALSE;\n    while (*str) {\n\tif (*str == '&')\n\t    Strcat_charp(textarea_str[n_textarea], getescapecmd(&str));\n\telse if (*str == '\\n') {\n\t    Strcat_charp(textarea_str[n_textarea], \"\\r\\n\");\n\t    str++;\n\t}\n\telse if (*str != '\\r')\n\t    Strcat_char(textarea_str[n_textarea], *(str++));\n    }\n}\n\nStr\nprocess_hr(struct parsed_tag *tag, int width, int indent_width)\n{\n    Str tmp = Strnew_charp(\"<nobr>\");\n    int w = 0;\n    int x = ALIGN_CENTER;\n#define HR_ATTR_WIDTH_MAX 65535\n\n    if (width > indent_width)\n\twidth -= indent_width;\n    if (parsedtag_get_value(tag, ATTR_WIDTH, &w)) {\n\tif (w > HR_ATTR_WIDTH_MAX) {\n\t    w = HR_ATTR_WIDTH_MAX;\n\t}\n\tw = REAL_WIDTH(w, width);\n    } else {\n\tw = width;\n    }\n\n    parsedtag_get_value(tag, ATTR_ALIGN, &x);\n    switch (x) {\n    case ALIGN_CENTER:\n\tStrcat_charp(tmp, \"<div_int align=center>\");\n\tbreak;\n    case ALIGN_RIGHT:\n\tStrcat_charp(tmp, \"<div_int align=right>\");\n\tbreak;\n    case ALIGN_LEFT:\n\tStrcat_charp(tmp, \"<div_int align=left>\");\n\tbreak;\n    }\n    w /= symbol_width;\n    if (w <= 0)\n\tw = 1;\n    push_symbol(tmp, HR_SYMBOL, symbol_width, w);\n    Strcat_charp(tmp, \"</div_int></nobr>\");\n    return tmp;\n}\n\n#ifdef USE_M17N\nstatic char *\ncheck_charset(char *p)\n{\n    return wc_guess_charset(p, 0) ? p : NULL;\n}\n\nstatic char *\ncheck_accept_charset(char *ac)\n{\n    char *s = ac, *e;\n\n    while (*s) {\n\twhile (*s && (IS_SPACE(*s) || *s == ','))\n\t    s++;\n\tif (!*s)\n\t    break;\n\te = s;\n\twhile (*e && !(IS_SPACE(*e) || *e == ','))\n\t    e++;\n\tif (wc_guess_charset(Strnew_charp_n(s, e - s)->ptr, 0))\n\t    return ac;\n\ts = e;\n    }\n    return NULL;\n}\n#endif\n\nstatic Str\nprocess_form_int(struct parsed_tag *tag, int fid)\n{\n    char *p, *q, *r, *s, *tg, *n;\n\n    p = \"get\";\n    parsedtag_get_value(tag, ATTR_METHOD, &p);\n    q = \"!CURRENT_URL!\";\n    parsedtag_get_value(tag, ATTR_ACTION, &q);\n    q = url_encode(remove_space(q), cur_baseURL, cur_document_charset);\n    r = NULL;\n#ifdef USE_M17N\n    if (parsedtag_get_value(tag, ATTR_ACCEPT_CHARSET, &r))\n\tr = check_accept_charset(r);\n    if (!r && parsedtag_get_value(tag, ATTR_CHARSET, &r))\n\tr = check_charset(r);\n#endif\n    s = NULL;\n    parsedtag_get_value(tag, ATTR_ENCTYPE, &s);\n    tg = NULL;\n    parsedtag_get_value(tag, ATTR_TARGET, &tg);\n    n = NULL;\n    parsedtag_get_value(tag, ATTR_NAME, &n);\n\n    if (fid < 0) {\n\tform_max++;\n\tform_sp++;\n\tfid = form_max;\n    }\n    else {\t\t\t/* <form_int> */\n\tif (form_max < fid)\n\t    form_max = fid;\n\tform_sp = fid;\n    }\n    if (forms_size == 0) {\n\tforms_size = INITIAL_FORM_SIZE;\n\tforms = New_N(FormList *, forms_size);\n\tform_stack = NewAtom_N(int, forms_size);\n    }\n    if (forms_size <= form_max) {\n\tforms_size += form_max;\n\tforms = New_Reuse(FormList *, forms, forms_size);\n\tform_stack = New_Reuse(int, form_stack, forms_size);\n    }\n    form_stack[form_sp] = fid;\n\n    if (w3m_halfdump) {\n\tStr tmp = Sprintf(\"<form_int fid=\\\"%d\\\" action=\\\"%s\\\" method=\\\"%s\\\"\",\n\t\t\t  fid, html_quote(q), html_quote(p));\n\tif (s)\n\t    Strcat(tmp, Sprintf(\" enctype=\\\"%s\\\"\", html_quote(s)));\n\tif (tg)\n\t    Strcat(tmp, Sprintf(\" target=\\\"%s\\\"\", html_quote(tg)));\n\tif (n)\n\t    Strcat(tmp, Sprintf(\" name=\\\"%s\\\"\", html_quote(n)));\n#ifdef USE_M17N\n\tif (r)\n\t    Strcat(tmp, Sprintf(\" accept-charset=\\\"%s\\\"\", html_quote(r)));\n#endif\n\tStrcat_charp(tmp, \">\");\n\treturn tmp;\n    }\n\n    forms[fid] = newFormList(q, p, r, s, tg, n, NULL);\n    return NULL;\n}\n\nStr\nprocess_form(struct parsed_tag *tag)\n{\n    return process_form_int(tag, -1);\n}\n\nStr\nprocess_n_form(void)\n{\n    if (form_sp >= 0)\n\tform_sp--;\n    return NULL;\n}\n\nstatic void\nclear_ignore_p_flag(int cmd, struct readbuffer *obuf)\n{\n    static int clear_flag_cmd[] = {\n\tHTML_HR, HTML_UNKNOWN\n    };\n    int i;\n\n    for (i = 0; clear_flag_cmd[i] != HTML_UNKNOWN; i++) {\n\tif (cmd == clear_flag_cmd[i]) {\n\t    obuf->flag &= ~RB_IGNORE_P;\n\t    return;\n\t}\n    }\n}\n\nstatic void\nset_alignment(struct readbuffer *obuf, struct parsed_tag *tag)\n{\n    long flag = -1;\n    int align;\n\n    if (parsedtag_get_value(tag, ATTR_ALIGN, &align)) {\n\tswitch (align) {\n\tcase ALIGN_CENTER:\n\t    flag = RB_CENTER;\n\t    break;\n\tcase ALIGN_RIGHT:\n\t    flag = RB_RIGHT;\n\t    break;\n\tcase ALIGN_LEFT:\n\t    flag = RB_LEFT;\n\t}\n    }\n    RB_SAVE_FLAG(obuf);\n    if (flag != -1) {\n\tRB_SET_ALIGN(obuf, flag);\n    }\n}\n\n#ifdef ID_EXT\nstatic void\nprocess_idattr(struct readbuffer *obuf, int cmd, struct parsed_tag *tag)\n{\n    char *id = NULL, *framename = NULL;\n    Str idtag = NULL;\n\n    /* \n     * HTML_TABLE is handled by the other process.\n     */\n    if (cmd == HTML_TABLE)\n\treturn;\n\n    parsedtag_get_value(tag, ATTR_ID, &id);\n    parsedtag_get_value(tag, ATTR_FRAMENAME, &framename);\n    if (id == NULL)\n\treturn;\n    if (framename)\n\tidtag = Sprintf(\"<_id id=\\\"%s\\\" framename=\\\"%s\\\">\",\n\t\t\thtml_quote(id), html_quote(framename));\n    else\n\tidtag = Sprintf(\"<_id id=\\\"%s\\\">\", html_quote(id));\n    push_tag(obuf, idtag->ptr, HTML_NOP);\n}\n#endif\t\t\t\t/* ID_EXT */\n\n#define CLOSE_P if (obuf->flag & RB_P) { \\\n      flushline(h_env, obuf, envs[h_env->envc].indent,0,h_env->limit);\\\n      RB_RESTORE_FLAG(obuf);\\\n      obuf->flag &= ~RB_P;\\\n    }\n\n#define CLOSE_A \\\n    CLOSE_P; \\\n    close_anchor(h_env, obuf);\n\n#define CLOSE_DT \\\n    if (obuf->flag & RB_IN_DT) { \\\n      obuf->flag &= ~RB_IN_DT; \\\n      HTMLlineproc1(\"</b>\", h_env); \\\n    }\n\n#define PUSH_ENV(cmd) \\\n    if (++h_env->envc_real < h_env->nenv) { \\\n      ++h_env->envc; \\\n      envs[h_env->envc].env = cmd; \\\n      envs[h_env->envc].count = 0; \\\n      if (h_env->envc <= MAX_INDENT_LEVEL) \\\n        envs[h_env->envc].indent = envs[h_env->envc - 1].indent + INDENT_INCR; \\\n      else \\\n        envs[h_env->envc].indent = envs[h_env->envc - 1].indent; \\\n    }\n\n#define POP_ENV \\\n    if (h_env->envc_real-- < h_env->nenv) \\\n      h_env->envc--;\n\nstatic int\nul_type(struct parsed_tag *tag, int default_type)\n{\n    char *p;\n    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\tif (!strcasecmp(p, \"disc\"))\n\t    return (int)'d';\n\telse if (!strcasecmp(p, \"circle\"))\n\t    return (int)'c';\n\telse if (!strcasecmp(p, \"square\"))\n\t    return (int)'s';\n    }\n    return default_type;\n}\n\nint\ngetMetaRefreshParam(char *q, Str *refresh_uri)\n{\n    int refresh_interval;\n    char *r;\n    Str s_tmp = NULL;\n\n    if (q == NULL || refresh_uri == NULL)\n\treturn 0;\n\n    refresh_interval = atoi(q);\n    if (refresh_interval < 0)\n\treturn 0;\n\n    while (*q) {\n\tif (!strncasecmp(q, \"url=\", 4)) {\n\t    q += 4;\n\t    if (*q == '\\\"' || *q == '\\'')\t/* \" or ' */\n\t\tq++;\n\t    r = q;\n\t    while (*r && !IS_SPACE(*r) && *r != ';')\n\t\tr++;\n\t    s_tmp = Strnew_charp_n(q, r - q);\n\n\t    if (s_tmp->ptr[s_tmp->length - 1] == '\\\"'          /* \" */\n\t       || s_tmp->ptr[s_tmp->length - 1] == '\\'') {     /* ' */\n\t\ts_tmp->length--;\n\t\ts_tmp->ptr[s_tmp->length] = '\\0';\n\t    }\n\t    q = r;\n\t}\n\twhile (*q && *q != ';')\n\t    q++;\n\tif (*q == ';')\n\t    q++;\n\twhile (*q && *q == ' ')\n\t    q++;\n    }\n    *refresh_uri = s_tmp;\n    return refresh_interval;\n}\n\nint\nHTMLtagproc1(struct parsed_tag *tag, struct html_feed_environ *h_env)\n{\n    char *p, *q, *r;\n    int i, w, x, y, z, count, width;\n    struct readbuffer *obuf = h_env->obuf;\n    struct environment *envs = h_env->envs;\n    Str tmp;\n    int hseq;\n    int cmd;\n#ifdef ID_EXT\n    char *id = NULL;\n#endif\t\t\t\t/* ID_EXT */\n\n    cmd = tag->tagid;\n\n    if (obuf->flag & RB_PRE) {\n\tswitch (cmd) {\n\tcase HTML_NOBR:\n\tcase HTML_N_NOBR:\n\tcase HTML_PRE_INT:\n\tcase HTML_N_PRE_INT:\n\t    return 1;\n\t}\n    }\n\n    switch (cmd) {\n    case HTML_B:\n\tobuf->in_bold++;\n\tif (obuf->in_bold > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_B:\n\tif (obuf->in_bold == 1 && close_effect0(obuf, HTML_B))\n\t    obuf->in_bold = 0;\n\tif (obuf->in_bold > 0) {\n\t    obuf->in_bold--;\n\t    if (obuf->in_bold == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_I:\n\tobuf->in_italic++;\n\tif (obuf->in_italic > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_I:\n\tif (obuf->in_italic == 1 && close_effect0(obuf, HTML_I))\n\t    obuf->in_italic = 0;\n\tif (obuf->in_italic > 0) {\n\t    obuf->in_italic--;\n\t    if (obuf->in_italic == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_U:\n\tobuf->in_under++;\n\tif (obuf->in_under > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_U:\n\tif (obuf->in_under == 1 && close_effect0(obuf, HTML_U))\n\t    obuf->in_under = 0;\n\tif (obuf->in_under > 0) {\n\t    obuf->in_under--;\n\t    if (obuf->in_under == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_EM:\n\tHTMLlineproc1(\"<i>\", h_env);\n\treturn 1;\n    case HTML_N_EM:\n\tHTMLlineproc1(\"</i>\", h_env);\n\treturn 1;\n    case HTML_STRONG:\n\tHTMLlineproc1(\"<b>\", h_env);\n\treturn 1;\n    case HTML_N_STRONG:\n\tHTMLlineproc1(\"</b>\", h_env);\n\treturn 1;\n    case HTML_Q:\n\tHTMLlineproc1(\"`\", h_env);\n\treturn 1;\n    case HTML_N_Q:\n\tHTMLlineproc1(\"'\", h_env);\n\treturn 1;\n    case HTML_P:\n    case HTML_N_P:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 1, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\tif (cmd == HTML_P) {\n\t    set_alignment(obuf, tag);\n\t    obuf->flag |= RB_P;\n\t}\n\treturn 1;\n    case HTML_BR:\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 1, h_env->limit);\n\th_env->blank_lines = 0;\n\treturn 1;\n    case HTML_H:\n\tif (!(obuf->flag & (RB_PREMODE | RB_IGNORE_P))) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tHTMLlineproc1(\"<b>\", h_env);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_H:\n\tHTMLlineproc1(\"</b>\", h_env);\n\tif (!(obuf->flag & RB_PREMODE)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t}\n\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\tclose_anchor(h_env, obuf);\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_UL:\n    case HTML_OL:\n    case HTML_BLQ:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!(obuf->flag & RB_PREMODE) &&\n\t\t(h_env->envc == 0 || cmd == HTML_BLQ))\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\tPUSH_ENV(cmd);\n\tif (cmd == HTML_UL || cmd == HTML_OL) {\n\t    if (parsedtag_get_value(tag, ATTR_START, &count)) {\n\t\tenvs[h_env->envc].count = count - 1;\n\t    }\n\t}\n\tif (cmd == HTML_OL) {\n\t    envs[h_env->envc].type = '1';\n\t    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\t\tenvs[h_env->envc].type = (int)*p;\n\t    }\n\t}\n\tif (cmd == HTML_UL)\n\t    envs[h_env->envc].type = ul_type(tag, 0);\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 1;\n    case HTML_N_UL:\n    case HTML_N_OL:\n    case HTML_N_DL:\n    case HTML_N_BLQ:\n\tCLOSE_DT;\n\tCLOSE_A;\n\tif (h_env->envc > 0) {\n\t    flushline(h_env, obuf, envs[h_env->envc - 1].indent, 0,\n\t\t      h_env->limit);\n\t    POP_ENV;\n\t    if (!(obuf->flag & RB_PREMODE) &&\n\t\t(h_env->envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ)) {\n\t\tdo_blankline(h_env, obuf,\n\t\t\t     envs[h_env->envc].indent,\n\t\t\t     INDENT_INCR, h_env->limit);\n\t\tobuf->flag |= RB_IGNORE_P;\n\t    }\n\t}\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_DL:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!(obuf->flag & RB_PREMODE))\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\tPUSH_ENV(cmd);\n\tif (parsedtag_exists(tag, ATTR_COMPACT))\n\t    envs[h_env->envc].env = HTML_DL_COMPACT;\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_LI:\n\tCLOSE_A;\n\tCLOSE_DT;\n\tif (h_env->envc > 0) {\n\t    Str num;\n\t    flushline(h_env, obuf,\n\t\t      envs[h_env->envc - 1].indent, 0, h_env->limit);\n\t    envs[h_env->envc].count++;\n\t    if (parsedtag_get_value(tag, ATTR_VALUE, &p)) {\n\t\tcount = atoi(p);\n\t\tif (count > 0)\n\t\t    envs[h_env->envc].count = count;\n\t\telse\n\t\t    envs[h_env->envc].count = 0;\n\t    }\n\t    switch (envs[h_env->envc].env) {\n\t    case HTML_UL:\n\t\tenvs[h_env->envc].type = ul_type(tag, envs[h_env->envc].type);\n\t\tfor (i = 0; i < INDENT_INCR - 3; i++)\n\t\t    push_charp(obuf, 1, NBSP, PC_ASCII);\n\t\ttmp = Strnew();\n\t\tswitch (envs[h_env->envc].type) {\n\t\tcase 'd':\n\t\t    push_symbol(tmp, UL_SYMBOL_DISC, symbol_width, 1);\n\t\t    break;\n\t\tcase 'c':\n\t\t    push_symbol(tmp, UL_SYMBOL_CIRCLE, symbol_width, 1);\n\t\t    break;\n\t\tcase 's':\n\t\t    push_symbol(tmp, UL_SYMBOL_SQUARE, symbol_width, 1);\n\t\t    break;\n\t\tdefault:\n\t\t    push_symbol(tmp,\n\t\t\t\tUL_SYMBOL((h_env->envc_real -\n\t\t\t\t\t   1) % MAX_UL_LEVEL), symbol_width,\n\t\t\t\t1);\n\t\t    break;\n\t\t}\n\t\tif (symbol_width == 1)\n\t\t    push_charp(obuf, 1, NBSP, PC_ASCII);\n\t\tpush_str(obuf, symbol_width, tmp, PC_ASCII);\n\t\tpush_charp(obuf, 1, NBSP, PC_ASCII);\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t\tbreak;\n\t    case HTML_OL:\n\t\tif (parsedtag_get_value(tag, ATTR_TYPE, &p))\n\t\t    envs[h_env->envc].type = (int)*p;\n\t\tswitch ((envs[h_env->envc].count > 0)? envs[h_env->envc].type: '1') {\n\t\tcase 'i':\n\t\t    num = romanNumeral(envs[h_env->envc].count);\n\t\t    break;\n\t\tcase 'I':\n\t\t    num = romanNumeral(envs[h_env->envc].count);\n\t\t    Strupper(num);\n\t\t    break;\n\t\tcase 'a':\n\t\t    num = romanAlphabet(envs[h_env->envc].count);\n\t\t    break;\n\t\tcase 'A':\n\t\t    num = romanAlphabet(envs[h_env->envc].count);\n\t\t    Strupper(num);\n\t\t    break;\n\t\tdefault:\n\t\t    num = Sprintf(\"%d\", envs[h_env->envc].count);\n\t\t    break;\n\t\t}\n\t\tif (INDENT_INCR >= 4)\n\t\t    Strcat_charp(num, \". \");\n\t\telse\n\t\t    Strcat_char(num, '.');\n\t\tpush_spaces(obuf, 1, INDENT_INCR - num->length);\n\t\tpush_str(obuf, num->length, num, PC_ASCII);\n\t\tif (INDENT_INCR >= 4)\n\t\t    set_space_to_prevchar(obuf->prevchar);\n\t\tbreak;\n\t    default:\n\t\tpush_spaces(obuf, 1, INDENT_INCR);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    flushline(h_env, obuf, 0, 0, h_env->limit);\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_DT:\n\tCLOSE_A;\n\tif (h_env->envc == 0 ||\n\t    (h_env->envc_real < h_env->nenv &&\n\t     envs[h_env->envc].env != HTML_DL &&\n\t     envs[h_env->envc].env != HTML_DL_COMPACT)) {\n\t    PUSH_ENV(HTML_DL);\n\t}\n\tif (h_env->envc > 0) {\n\t    flushline(h_env, obuf,\n\t\t      envs[h_env->envc - 1].indent, 0, h_env->limit);\n\t}\n\tif (!(obuf->flag & RB_IN_DT)) {\n\t    HTMLlineproc1(\"<b>\", h_env);\n\t    obuf->flag |= RB_IN_DT;\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_DD:\n\tCLOSE_A;\n\tCLOSE_DT;\n\tif (envs[h_env->envc].env == HTML_DL_COMPACT) {\n\t    if (obuf->pos > envs[h_env->envc].indent)\n\t\tflushline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t  h_env->limit);\n\t    else\n\t\tpush_spaces(obuf, 1, envs[h_env->envc].indent - obuf->pos);\n\t}\n\telse\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t/* obuf->flag |= RB_IGNORE_P; */\n\treturn 1;\n    case HTML_TITLE:\n\tclose_anchor(h_env, obuf);\n\tprocess_title(tag);\n\tobuf->flag |= RB_TITLE;\n\tobuf->end_tag = HTML_N_TITLE;\n\treturn 1;\n    case HTML_N_TITLE:\n\tif (!(obuf->flag & RB_TITLE))\n\t    return 1;\n\tobuf->flag &= ~RB_TITLE;\n\tobuf->end_tag = 0;\n\ttmp = process_n_title(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_TITLE_ALT:\n\tif (parsedtag_get_value(tag, ATTR_TITLE, &p))\n\t    h_env->title = html_unquote(p);\n\treturn 0;\n    case HTML_FRAMESET:\n\tPUSH_ENV(cmd);\n\tpush_charp(obuf, 9, \"--FRAME--\", PC_ASCII);\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 0;\n    case HTML_N_FRAMESET:\n\tif (h_env->envc > 0) {\n\t    POP_ENV;\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t}\n\treturn 0;\n    case HTML_NOFRAMES:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag |= (RB_NOFRAMES | RB_IGNORE_P);\n\t/* istr = str; */\n\treturn 1;\n    case HTML_N_NOFRAMES:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag &= ~RB_NOFRAMES;\n\treturn 1;\n    case HTML_FRAME:\n\tq = r = NULL;\n\tparsedtag_get_value(tag, ATTR_SRC, &q);\n\tparsedtag_get_value(tag, ATTR_NAME, &r);\n\tif (q) {\n\t    q = html_quote(q);\n\t    push_tag(obuf, Sprintf(\"<a hseq=\\\"%d\\\" href=\\\"%s\\\">\",\n\t\t\t\t   cur_hseq++, q)->ptr, HTML_A);\n\t    if (r)\n\t\tq = html_quote(r);\n\t    push_charp(obuf, get_strwidth(q), q, PC_ASCII);\n\t    push_tag(obuf, \"</a>\", HTML_N_A);\n\t}\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 0;\n    case HTML_HR:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_hr(tag, h_env->limit, envs[h_env->envc].indent);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\tset_space_to_prevchar(obuf->prevchar);\n\treturn 1;\n    case HTML_PRE:\n\tx = parsedtag_exists(tag, ATTR_FOR_TABLE);\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!x)\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\telse\n\t    fillline(obuf, envs[h_env->envc].indent);\n\tobuf->flag |= (RB_PRE | RB_IGNORE_P);\n\t/* istr = str; */\n\treturn 1;\n    case HTML_N_PRE:\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t    h_env->blank_lines++;\n\t}\n\tobuf->flag &= ~RB_PRE;\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_PRE_INT:\n\ti = obuf->line->length;\n\tappend_tags(obuf);\n\tif (!(obuf->flag & RB_SPECIAL)) {\n\t    set_breakpoint(obuf, obuf->line->length - i);\n\t}\n\tobuf->flag |= RB_PRE_INT;\n\treturn 0;\n    case HTML_N_PRE_INT:\n\tpush_tag(obuf, \"</pre_int>\", HTML_N_PRE_INT);\n\tobuf->flag &= ~RB_PRE_INT;\n\tif (!(obuf->flag & RB_SPECIAL) && obuf->pos > obuf->bp.pos) {\n\t    set_prevchar(obuf->prevchar, \"\", 0);\n\t    obuf->prev_ctype = PC_CTRL;\n\t}\n\treturn 1;\n    case HTML_NOBR:\n\tobuf->flag |= RB_NOBR;\n\tobuf->nobr_level++;\n\treturn 0;\n    case HTML_N_NOBR:\n\tif (obuf->nobr_level > 0)\n\t    obuf->nobr_level--;\n\tif (obuf->nobr_level == 0)\n\t    obuf->flag &= ~RB_NOBR;\n\treturn 0;\n    case HTML_PRE_PLAIN:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= (RB_PRE | RB_IGNORE_P);\n\treturn 1;\n    case HTML_N_PRE_PLAIN:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t}\n\tobuf->flag &= ~RB_PRE;\n\treturn 1;\n    case HTML_LISTING:\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= (RB_PLAIN | RB_IGNORE_P);\n\tswitch (cmd) {\n\tcase HTML_LISTING:\n\t    obuf->end_tag = HTML_N_LISTING;\n\t    break;\n\tcase HTML_XMP:\n\t    obuf->end_tag = HTML_N_XMP;\n\t    break;\n\tcase HTML_PLAINTEXT:\n\t    obuf->end_tag = MAX_HTMLTAG;\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_LISTING:\n    case HTML_N_XMP:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t}\n\tobuf->flag &= ~RB_PLAIN;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_SCRIPT:\n\tobuf->flag |= RB_SCRIPT;\n\tobuf->end_tag = HTML_N_SCRIPT;\n\treturn 1;\n    case HTML_STYLE:\n\tobuf->flag |= RB_STYLE;\n\tobuf->end_tag = HTML_N_STYLE;\n\treturn 1;\n    case HTML_N_SCRIPT:\n\tobuf->flag &= ~RB_SCRIPT;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_N_STYLE:\n\tobuf->flag &= ~RB_STYLE;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_A:\n\tif (obuf->anchor.url)\n\t    close_anchor(h_env, obuf);\n\n\thseq = 0;\n\n\tif (parsedtag_get_value(tag, ATTR_HREF, &p))\n\t    obuf->anchor.url = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_TARGET, &p))\n\t    obuf->anchor.target = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_REFERER, &p))\n\t    obuf->anchor.referer = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_TITLE, &p))\n\t    obuf->anchor.title = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_ACCESSKEY, &p))\n\t    obuf->anchor.accesskey = (unsigned char)*p;\n\tif (parsedtag_get_value(tag, ATTR_HSEQ, &hseq))\n\t    obuf->anchor.hseq = hseq;\n\n\tif (hseq == 0 && obuf->anchor.url) {\n\t    obuf->anchor.hseq = cur_hseq;\n\t    tmp = process_anchor(tag, h_env->tagbuf->ptr);\n\t    push_tag(obuf, tmp->ptr, HTML_A);\n\t    if (displayLinkNumber)\n\t\tHTMLlineproc1(getLinkNumberStr(-1)->ptr, h_env);\n\t    return 1;\n\t}\n\treturn 0;\n    case HTML_N_A:\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_IMG:\n\ttmp = process_img(tag, h_env->limit);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_IMG_ALT:\n\tif (parsedtag_get_value(tag, ATTR_SRC, &p))\n\t    obuf->img_alt = Strnew_charp(p);\n#ifdef USE_IMAGE\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_TOP_MARGIN, &i)) {\n\t    if (i > obuf->top_margin)\n\t\tobuf->top_margin = i;\n\t}\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &i)) {\n\t    if (i > obuf->bottom_margin)\n\t\tobuf->bottom_margin = i;\n\t}\n#endif\n\treturn 0;\n    case HTML_N_IMG_ALT:\n\tif (obuf->img_alt) {\n\t    if (!close_effect0(obuf, HTML_IMG_ALT))\n\t\tpush_tag(obuf, \"</img_alt>\", HTML_N_IMG_ALT);\n\t    obuf->img_alt = NULL;\n\t}\n\treturn 1;\n    case HTML_INPUT_ALT:\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_TOP_MARGIN, &i)) {\n\t    if (i > obuf->top_margin)\n\t\tobuf->top_margin = i;\n\t}\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &i)) {\n\t    if (i > obuf->bottom_margin)\n\t\tobuf->bottom_margin = i;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_HSEQ, &hseq)) {\n\t    obuf->input_alt.hseq = hseq;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_FID, &i)) {\n\t    obuf->input_alt.fid = i;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\t    obuf->input_alt.type = Strnew_charp(p);\n\t}\n\tif (parsedtag_get_value(tag, ATTR_VALUE, &p)) {\n\t    obuf->input_alt.value = Strnew_charp(p);\n\t}\n\tif (parsedtag_get_value(tag, ATTR_NAME, &p)) {\n\t    obuf->input_alt.name = Strnew_charp(p);\n\t}\n\tobuf->input_alt.in = 1;\n\treturn 0;\n    case HTML_N_INPUT_ALT:\n\tif (obuf->input_alt.in) {\n\t    if (!close_effect0(obuf, HTML_INPUT_ALT))\n\t\tpush_tag(obuf, \"</input_alt>\", HTML_N_INPUT_ALT);\n\t    obuf->input_alt.hseq = 0;\n\t    obuf->input_alt.fid = -1;\n\t    obuf->input_alt.in = 0;\n\t    obuf->input_alt.type = NULL;\n\t    obuf->input_alt.name = NULL;\n\t    obuf->input_alt.value = NULL;\n\t}\n\treturn 1;\n    case HTML_TABLE:\n\tclose_anchor(h_env, obuf);\n\tobuf->table_level++;\n\tif (obuf->table_level >= MAX_TABLE)\n\t    break;\n\tw = BORDER_NONE;\n\t/* x: cellspacing, y: cellpadding */\n\tx = 2;\n\ty = 1;\n\tz = 0;\n\twidth = 0;\n\tif (parsedtag_exists(tag, ATTR_BORDER)) {\n\t    if (parsedtag_get_value(tag, ATTR_BORDER, &w)) {\n\t\tif (w > 2)\n\t\t    w = BORDER_THICK;\n\t\telse if (w < 0) {\t/* weird */\n\t\t    w = BORDER_THIN;\n\t\t}\n\t    }\n\t    else\n\t\tw = BORDER_THIN;\n\t}\n\tif (DisplayBorders && w == BORDER_NONE)\n\t    w = BORDER_THIN;\n\tif (parsedtag_get_value(tag, ATTR_WIDTH, &i)) {\n\t    if (obuf->table_level == 0)\n\t\twidth = REAL_WIDTH(i, h_env->limit - envs[h_env->envc].indent);\n\t    else\n\t\twidth = RELATIVE_WIDTH(i);\n\t}\n\tif (parsedtag_exists(tag, ATTR_HBORDER))\n\t    w = BORDER_NOWIN;\n#define MAX_CELLSPACING 1000\n#define MAX_CELLPADDING 1000\n#define MAX_VSPACE 1000\n\tparsedtag_get_value(tag, ATTR_CELLSPACING, &x);\n\tparsedtag_get_value(tag, ATTR_CELLPADDING, &y);\n\tparsedtag_get_value(tag, ATTR_VSPACE, &z);\n\tif (x > MAX_CELLSPACING)\n\t    x = MAX_CELLSPACING;\n\tif (y > MAX_CELLPADDING)\n\t    y = MAX_CELLPADDING;\n\tif (z > MAX_VSPACE)\n\t    z = MAX_VSPACE;\n#ifdef ID_EXT\n\tparsedtag_get_value(tag, ATTR_ID, &id);\n#endif\t\t\t\t/* ID_EXT */\n\ttables[obuf->table_level] = begin_table(w, x, y, z);\n#ifdef ID_EXT\n\tif (id != NULL)\n\t    tables[obuf->table_level]->id = Strnew_charp(id);\n#endif\t\t\t\t/* ID_EXT */\n\ttable_mode[obuf->table_level].pre_mode = 0;\n\ttable_mode[obuf->table_level].indent_level = 0;\n\ttable_mode[obuf->table_level].nobr_level = 0;\n\ttable_mode[obuf->table_level].caption = 0;\n\ttable_mode[obuf->table_level].end_tag = 0;\t/* HTML_UNKNOWN */\n#ifndef TABLE_EXPAND\n\ttables[obuf->table_level]->total_width = width;\n#else\n\ttables[obuf->table_level]->real_width = width;\n\ttables[obuf->table_level]->total_width = 0;\n#endif\n\treturn 1;\n    case HTML_N_TABLE:\n\t/* should be processed in HTMLlineproc() */\n\treturn 1;\n    case HTML_CENTER:\n\tCLOSE_A;\n\tif (!(obuf->flag & (RB_PREMODE | RB_IGNORE_P)))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_SAVE_FLAG(obuf);\n\tRB_SET_ALIGN(obuf, RB_CENTER);\n\treturn 1;\n    case HTML_N_CENTER:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_PREMODE))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_DIV:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_DIV:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_DIV_INT:\n\tCLOSE_P;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_DIV_INT:\n\tCLOSE_P;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_FORM:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\ttmp = process_form(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_N_FORM:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag |= RB_IGNORE_P;\n\tprocess_n_form();\n\treturn 1;\n    case HTML_INPUT:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_input(tag);\n       if (tmp)\n           HTMLlineproc1(tmp->ptr, h_env);\n       return 1;\n    case HTML_BUTTON:\n       tmp = process_button(tag);\n       if (tmp)\n           HTMLlineproc1(tmp->ptr, h_env);\n       return 1;\n    case HTML_N_BUTTON:\n       tmp = process_n_button();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_SELECT:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_select(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\tobuf->flag |= RB_INSELECT;\n\tobuf->end_tag = HTML_N_SELECT;\n\treturn 1;\n    case HTML_N_SELECT:\n\tobuf->flag &= ~RB_INSELECT;\n\tobuf->end_tag = 0;\n\ttmp = process_n_select();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_OPTION:\n\t/* nothing */\n\treturn 1;\n    case HTML_TEXTAREA:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_textarea(tag, h_env->limit);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\tobuf->flag |= RB_INTXTA;\n\tobuf->end_tag = HTML_N_TEXTAREA;\n\treturn 1;\n    case HTML_N_TEXTAREA:\n\tobuf->flag &= ~RB_INTXTA;\n\tobuf->end_tag = 0;\n\ttmp = process_n_textarea();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_ISINDEX:\n\tp = \"\";\n\tq = \"!CURRENT_URL!\";\n\tparsedtag_get_value(tag, ATTR_PROMPT, &p);\n\tparsedtag_get_value(tag, ATTR_ACTION, &q);\n\ttmp = Strnew_m_charp(\"<form method=get action=\\\"\",\n\t\t\t     html_quote(q),\n\t\t\t     \"\\\">\",\n\t\t\t     html_quote(p),\n\t\t\t     \"<input type=text name=\\\"\\\" accept></form>\",\n\t\t\t     NULL);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_META:\n\tp = q = r = NULL;\n\tparsedtag_get_value(tag, ATTR_HTTP_EQUIV, &p);\n\tparsedtag_get_value(tag, ATTR_CONTENT, &q);\n#ifdef USE_M17N\n\tparsedtag_get_value(tag, ATTR_CHARSET, &r);\n\tif (r) {\n\t    /* <meta charset=\"\"> */\n\t    SKIP_BLANKS(r);\n\t    meta_charset = wc_guess_charset(r, 0);\n\t}\n\telse\n\tif (p && q && !strcasecmp(p, \"Content-Type\") &&\n\t    (q = strcasestr(q, \"charset\")) != NULL) {\n\t    q += 7;\n\t    SKIP_BLANKS(q);\n\t    if (*q == '=') {\n\t\tq++;\n\t\tSKIP_BLANKS(q);\n\t\tmeta_charset = wc_guess_charset(q, 0);\n\t    }\n\t}\n\telse\n#endif\n\tif (p && q && !strcasecmp(p, \"refresh\")) {\n\t    int refresh_interval;\n\t    tmp = NULL;\n\t    refresh_interval = getMetaRefreshParam(q, &tmp);\n\t    if (tmp) {\n\t\tq = html_quote(tmp->ptr);\n\t\ttmp = Sprintf(\"Refresh (%d sec) <a href=\\\"%s\\\">%s</a>\",\n\t\t\t      refresh_interval, q, q);\n\t    }\n\t    else if (refresh_interval > 0)\n\t\ttmp = Sprintf(\"Refresh (%d sec)\", refresh_interval);\n\t    if (tmp) {\n\t\tHTMLlineproc1(tmp->ptr, h_env);\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t\tif (!is_redisplay &&\n\t\t    !((obuf->flag & RB_NOFRAMES) && RenderFrame)) {\n\t\t    tag->need_reconstruct = TRUE;\n\t\t    return 0;\n\t\t}\n\t    }\n\t}\n\treturn 1;\n    case HTML_BASE:\n#if defined(USE_M17N) || defined(USE_IMAGE)\n\tp = NULL;\n\tif (parsedtag_get_value(tag, ATTR_HREF, &p)) {\n\t    cur_baseURL = New(ParsedURL);\n\t    parseURL(p, cur_baseURL, NULL);\n\t}\n#endif\n    case HTML_MAP:\n    case HTML_N_MAP:\n    case HTML_AREA:\n\treturn 0;\n    case HTML_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag |= RB_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>[DEL:</U>\", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_strike++;\n\t    if (obuf->in_strike == 1) {\n\t\tpush_tag(obuf, \"<s>\", HTML_S);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag &= ~RB_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>:DEL]</U>\", h_env);\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_strike == 0)\n\t\treturn 1;\n\t    if (obuf->in_strike == 1 && close_effect0(obuf, HTML_S))\n\t\tobuf->in_strike = 0;\n\t    if (obuf->in_strike > 0) {\n\t\tobuf->in_strike--;\n\t\tif (obuf->in_strike == 0) {\n\t\t    push_tag(obuf, \"</s>\", HTML_N_S);\n\t\t}\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag |= RB_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>[S:</U>\", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_strike++;\n\t    if (obuf->in_strike == 1) {\n\t\tpush_tag(obuf, \"<s>\", HTML_S);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag &= ~RB_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>:S]</U>\", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_strike == 0)\n\t\treturn 1;\n\t    if (obuf->in_strike == 1 && close_effect0(obuf, HTML_S))\n\t\tobuf->in_strike = 0;\n\t    if (obuf->in_strike > 0) {\n\t\tobuf->in_strike--;\n\t\tif (obuf->in_strike == 0) {\n\t\t    push_tag(obuf, \"</s>\", HTML_N_S);\n\t\t}\n\t    }\n\t}\n\treturn 1;\n    case HTML_INS:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>[INS:</U>\", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_ins++;\n\t    if (obuf->in_ins == 1) {\n\t\tpush_tag(obuf, \"<ins>\", HTML_INS);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_INS:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>:INS]</U>\", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_ins == 0)\n\t\treturn 1;\n\t    if (obuf->in_ins == 1 && close_effect0(obuf, HTML_INS))\n\t\tobuf->in_ins = 0;\n\t    if (obuf->in_ins > 0) {\n\t\tobuf->in_ins--;\n\t\tif (obuf->in_ins == 0) {\n\t\t    push_tag(obuf, \"</ins>\", HTML_N_INS);\n\t\t}\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_SUP:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\"^\", h_env);\n\treturn 1;\n    case HTML_N_SUP:\n\treturn 1;\n    case HTML_SUB:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\"[\", h_env);\n\treturn 1;\n    case HTML_N_SUB:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\"]\", h_env);\n\treturn 1;\n    case HTML_FONT:\n    case HTML_N_FONT:\n    case HTML_NOP:\n\treturn 1;\n    case HTML_BGSOUND:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\"<A HREF=\\\"%s\\\">bgsound(%s)</A>\", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_EMBED:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\"<A HREF=\\\"%s\\\">embed(%s)</A>\", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_APPLET:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_ARCHIVE, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\"<A HREF=\\\"%s\\\">applet archive(%s)</A>\", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_BODY:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_BACKGROUND, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\"<IMG SRC=\\\"%s\\\" ALT=\\\"bg image(%s)\\\"><BR>\", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n    case HTML_N_HEAD:\n\tif (obuf->flag & RB_TITLE)\n\t    HTMLlineproc1(\"</title>\", h_env);\n    case HTML_HEAD:\n    case HTML_N_BODY:\n\treturn 1;\n    default:\n\t/* obuf->prevchar = '\\0'; */\n\treturn 0;\n    }\n    /* not reached */\n    return 0;\n}\n\n#define PPUSH(p,c) {outp[pos]=(p);outc[pos]=(c);pos++;}\n#define PSIZE\t\\\n    if (out_size <= pos + 1) {\t\\\n\tout_size = pos * 3 / 2;\t\\\n\toutc = New_Reuse(char, outc, out_size);\t\\\n\toutp = New_Reuse(Lineprop, outp, out_size);\t\\\n    }\n\nstatic TextLineListItem *_tl_lp2;\n\nstatic Str\ntextlist_feed()\n{\n    TextLine *p;\n    if (_tl_lp2 != NULL) {\n\tp = _tl_lp2->ptr;\n\t_tl_lp2 = _tl_lp2->next;\n\treturn p->line;\n    }\n    return NULL;\n}\n\nstatic int\nex_efct(int ex)\n{\n    int effect = 0;\n\n    if (! ex)\n\treturn 0;\n\n    if (ex & PE_EX_ITALIC)\n\teffect |= PE_EX_ITALIC_E;\n\n    if (ex & PE_EX_INSERT)\n\teffect |= PE_EX_INSERT_E;\n\n    if (ex & PE_EX_STRIKE)\n\teffect |= PE_EX_STRIKE_E;\n\n    return effect;\n}\n\nstatic void\nHTMLlineproc2body(Buffer *buf, Str (*feed) (), int llimit)\n{\n    static char *outc = NULL;\n    static Lineprop *outp = NULL;\n    static int out_size = 0;\n    Anchor *a_href = NULL, *a_img = NULL, *a_form = NULL;\n    char *p, *q, *r, *s, *t, *str;\n    Lineprop mode, effect, ex_effect;\n    int pos;\n    int nlines;\n#ifdef DEBUG\n    FILE *debug = NULL;\n#endif\n    struct frameset *frameset_s[FRAMESTACK_SIZE];\n    int frameset_sp = -1;\n    union frameset_element *idFrame = NULL;\n    char *id = NULL;\n    int hseq, form_id;\n    Str line;\n    char *endp;\n    char symbol = '\\0';\n    int internal = 0;\n    Anchor **a_textarea = NULL;\n#ifdef MENU_SELECT\n    Anchor **a_select = NULL;\n#endif\n#if defined(USE_M17N) || defined(USE_IMAGE)\n    ParsedURL *base = baseURL(buf);\n#endif\n#ifdef USE_M17N\n    wc_ces name_charset = url_to_charset(NULL, &buf->currentURL,\n\t\t\t\t\t buf->document_charset);\n#endif\n\n    if (out_size == 0) {\n\tout_size = LINELEN;\n\toutc = NewAtom_N(char, out_size);\n\toutp = NewAtom_N(Lineprop, out_size);\n    }\n\n    n_textarea = -1;\n    if (!max_textarea) {\t/* halfload */\n\tmax_textarea = MAX_TEXTAREA;\n\ttextarea_str = New_N(Str, max_textarea);\n\ta_textarea = New_N(Anchor *, max_textarea);\n    }\n#ifdef MENU_SELECT\n    n_select = -1;\n    if (!max_select) {\t\t/* halfload */\n\tmax_select = MAX_SELECT;\n\tselect_option = New_N(FormSelectOption, max_select);\n\ta_select = New_N(Anchor *, max_select);\n    }\n#endif\n\n#ifdef DEBUG\n    if (w3m_debug)\n\tdebug = fopen(\"zzzerr\", \"a\");\n#endif\n\n    effect = 0;\n    ex_effect = 0;\n    nlines = 0;\n    while ((line = feed()) != NULL) {\n#ifdef DEBUG\n\tif (w3m_debug) {\n\t    Strfputs(line, debug);\n\t    fputc('\\n', debug);\n\t}\n#endif\n\tif (n_textarea >= 0 && *(line->ptr) != '<') {\t/* halfload */\n\t    Strcat(textarea_str[n_textarea], line);\n\t    continue;\n\t}\n      proc_again:\n\tif (++nlines == llimit)\n\t    break;\n\tpos = 0;\n#ifdef ENABLE_REMOVE_TRAILINGSPACES\n\tStrremovetrailingspaces(line);\n#endif\n\tstr = line->ptr;\n\tendp = str + line->length;\n\twhile (str < endp) {\n\t    PSIZE;\n\t    mode = get_mctype(str);\n\t    if ((effect | ex_efct(ex_effect)) & PC_SYMBOL && *str != '<') {\n#ifdef USE_M17N\n\t\tchar **buf = set_symbol(symbol_width0);\n\t\tint len;\n\n\t\tp = buf[(int)symbol];\n\t\tlen = get_mclen(p);\n\t\tmode = get_mctype(p);\n\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(p++));\n\t\tif (--len) {\n\t\t    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;\n\t\t    while (len--) {\n\t\t\tPSIZE;\n\t\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(p++));\n\t\t    }\n\t\t}\n#else\n\t\tPPUSH(PC_ASCII | effect | ex_efct(ex_effect), SYMBOL_BASE + symbol);\n#endif\n\t\tstr += symbol_width;\n\t    }\n#ifdef USE_M17N\n\t    else if (mode == PC_CTRL || mode == PC_UNDEF) {\n#else\n\t    else if (mode == PC_CTRL || IS_INTSPACE(*str)) {\n#endif\n\t\tPPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');\n\t\tstr++;\n\t    }\n#ifdef USE_M17N\n\t    else if (mode & PC_UNKNOWN) {\n\t\tPPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');\n\t\tstr += get_mclen(str);\n\t    }\n#endif\n\t    else if (*str != '<' && *str != '&') {\n#ifdef USE_M17N\n\t\tint len = get_mclen(str);\n#endif\n\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(str++));\n#ifdef USE_M17N\n\t\tif (--len) {\n\t\t    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;\n\t\t    while (len--) {\n\t\t\tPSIZE;\n\t\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(str++));\n\t\t    }\n\t\t}\n#endif\n\t    }\n\t    else if (*str == '&') {\n\t\t/* \n\t\t * & escape processing\n\t\t */\n\t\tp = getescapecmd(&str);\n\t\twhile (*p) {\n\t\t    PSIZE;\n\t\t    mode = get_mctype((unsigned char *)p);\n#ifdef USE_M17N\n\t\t    if (mode == PC_CTRL || mode == PC_UNDEF) {\n#else\n\t\t    if (mode == PC_CTRL || IS_INTSPACE(*str)) {\n#endif\n\t\t\tPPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');\n\t\t\tp++;\n\t\t    }\n#ifdef USE_M17N\n\t\t    else if (mode & PC_UNKNOWN) {\n\t\t\tPPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');\n\t\t\tp += get_mclen(p);\n\t\t    }\n#endif\n\t\t    else {\n#ifdef USE_M17N\n\t\t\tint len = get_mclen(p);\n#endif\n\t\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(p++));\n#ifdef USE_M17N\n\t\t\tif (--len) {\n\t\t\t    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;\n\t\t\t    while (len--) {\n\t\t\t\tPSIZE;\n\t\t\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(p++));\n\t\t\t    }\n\t\t\t}\n#endif\n\t\t    }\n\t\t}\n\t    }\n\t    else {\n\t\t/* tag processing */\n\t\tstruct parsed_tag *tag;\n\t\tif (!(tag = parse_tag(&str, TRUE)))\n\t\t    continue;\n\t\tswitch (tag->tagid) {\n\t\tcase HTML_B:\n\t\t    effect |= PE_BOLD;\n\t\t    break;\n\t\tcase HTML_N_B:\n\t\t    effect &= ~PE_BOLD;\n\t\t    break;\n\t\tcase HTML_I:\n\t\t    ex_effect |= PE_EX_ITALIC;\n\t\t    break;\n\t\tcase HTML_N_I:\n\t\t    ex_effect &= ~PE_EX_ITALIC;\n\t\t    break;\n\t\tcase HTML_INS:\n\t\t    ex_effect |= PE_EX_INSERT;\n\t\t    break;\n\t\tcase HTML_N_INS:\n\t\t    ex_effect &= ~PE_EX_INSERT;\n\t\t    break;\n\t\tcase HTML_U:\n\t\t    effect |= PE_UNDER;\n\t\t    break;\n\t\tcase HTML_N_U:\n\t\t    effect &= ~PE_UNDER;\n\t\t    break;\n\t\tcase HTML_S:\n\t\t    ex_effect |= PE_EX_STRIKE;\n\t\t    break;\n\t\tcase HTML_N_S:\n\t\t    ex_effect &= ~PE_EX_STRIKE;\n\t\t    break;\n\t\tcase HTML_A:\n\t\t    if (renderFrameSet &&\n\t\t\tparsedtag_get_value(tag, ATTR_FRAMENAME, &p)) {\n\t\t\tp = url_quote_conv(p, buf->document_charset);\n\t\t\tif (!idFrame || strcmp(idFrame->body->name, p)) {\n\t\t\t    idFrame = search_frame(renderFrameSet, p);\n\t\t\t    if (idFrame && idFrame->body->attr != F_BODY)\n\t\t\t\tidFrame = NULL;\n\t\t\t}\n\t\t    }\n\t\t    p = r = s = NULL;\n\t\t    q = buf->baseTarget;\n\t\t    t = \"\";\n\t\t    hseq = 0;\n\t\t    id = NULL;\n\t\t    if (parsedtag_get_value(tag, ATTR_NAME, &id)) {\n\t\t\tid = url_quote_conv(id, name_charset);\n\t\t\tregisterName(buf, id, currentLn(buf), pos);\n\t\t    }\n\t\t    if (parsedtag_get_value(tag, ATTR_HREF, &p))\n\t\t\tp = url_encode(remove_space(p), base,\n\t\t\t\t       buf->document_charset);\n\t\t    if (parsedtag_get_value(tag, ATTR_TARGET, &q))\n\t\t\tq = url_quote_conv(q, buf->document_charset);\n\t\t    if (parsedtag_get_value(tag, ATTR_REFERER, &r))\n\t\t\tr = url_encode(r, base,\n\t\t\t\t       buf->document_charset);\n\t\t    parsedtag_get_value(tag, ATTR_TITLE, &s);\n\t\t    parsedtag_get_value(tag, ATTR_ACCESSKEY, &t);\n\t\t    parsedtag_get_value(tag, ATTR_HSEQ, &hseq);\n\t\t    if (hseq > 0)\n\t\t\tbuf->hmarklist =\n\t\t\t    putHmarker(buf->hmarklist, currentLn(buf),\n\t\t\t\t       pos, hseq - 1);\n\t\t    else if (hseq < 0) {\n\t\t\tint h = -hseq - 1;\n\t\t\tif (buf->hmarklist &&\n\t\t\t    h < buf->hmarklist->nmark &&\n\t\t\t    buf->hmarklist->marks[h].invalid) {\n\t\t\t    buf->hmarklist->marks[h].pos = pos;\n\t\t\t    buf->hmarklist->marks[h].line = currentLn(buf);\n\t\t\t    buf->hmarklist->marks[h].invalid = 0;\n\t\t\t    hseq = -hseq;\n\t\t\t}\n\t\t    }\n\t\t    if (id && idFrame)\n\t\t\tidFrame->body->nameList =\n\t\t\t    putAnchor(idFrame->body->nameList, id, NULL,\n\t\t\t\t      (Anchor **)NULL, NULL, NULL, '\\0',\n\t\t\t\t      currentLn(buf), pos);\n\t\t    if (p) {\n\t\t\teffect |= PE_ANCHOR;\n\t\t\ta_href = registerHref(buf, p, q, r, s,\n\t\t\t\t\t      *t, currentLn(buf), pos);\n\t\t\ta_href->hseq = ((hseq > 0) ? hseq : -hseq) - 1;\n\t\t\ta_href->slave = (hseq > 0) ? FALSE : TRUE;\n\t\t    }\n\t\t    break;\n\t\tcase HTML_N_A:\n\t\t    effect &= ~PE_ANCHOR;\n\t\t    if (a_href) {\n\t\t\ta_href->end.line = currentLn(buf);\n\t\t\ta_href->end.pos = pos;\n\t\t\tif (a_href->start.line == a_href->end.line &&\n\t\t\t    a_href->start.pos == a_href->end.pos) {\n\t\t\t    if (buf->hmarklist &&\n\t\t\t\ta_href->hseq < buf->hmarklist->nmark)\n\t\t\t\tbuf->hmarklist->marks[a_href->hseq].invalid = 1;\n\t\t\t    a_href->hseq = -1;\n\t\t\t}\n\t\t\ta_href = NULL;\n\t\t    }\n\t\t    break;\n\n\t\tcase HTML_LINK:\n\t\t    addLink(buf, tag);\n\t\t    break;\n\n\t\tcase HTML_IMG_ALT:\n\t\t    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {\n#ifdef USE_IMAGE\n\t\t\tint w = -1, h = -1, iseq = 0, ismap = 0;\n\t\t\tint xoffset = 0, yoffset = 0, top = 0, bottom = 0;\n\t\t\tparsedtag_get_value(tag, ATTR_HSEQ, &iseq);\n\t\t\tparsedtag_get_value(tag, ATTR_WIDTH, &w);\n\t\t\tparsedtag_get_value(tag, ATTR_HEIGHT, &h);\n\t\t\tparsedtag_get_value(tag, ATTR_XOFFSET, &xoffset);\n\t\t\tparsedtag_get_value(tag, ATTR_YOFFSET, &yoffset);\n\t\t\tparsedtag_get_value(tag, ATTR_TOP_MARGIN, &top);\n\t\t\tparsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &bottom);\n\t\t\tif (parsedtag_exists(tag, ATTR_ISMAP))\n\t\t\t    ismap = 1;\n\t\t\tq = NULL;\n\t\t\tparsedtag_get_value(tag, ATTR_USEMAP, &q);\n\t\t\tif (iseq > 0) {\n\t\t\t    buf->imarklist = putHmarker(buf->imarklist,\n\t\t\t\t\t\t\tcurrentLn(buf), pos,\n\t\t\t\t\t\t\tiseq - 1);\n\t\t\t}\n#endif\n\t\t\ts = NULL;\n\t\t\tparsedtag_get_value(tag, ATTR_TITLE, &s);\n\t\t\tp = url_quote_conv(remove_space(p),\n\t\t\t\t\t   buf->document_charset);\n\t\t\ta_img = registerImg(buf, p, s, currentLn(buf), pos);\n#ifdef USE_IMAGE\n\t\t\ta_img->hseq = iseq;\n\t\t\ta_img->image = NULL;\n\t\t\tif (iseq > 0) {\n\t\t\t    ParsedURL u;\n\t\t\t    Image *image;\n\n\t\t\t    parseURL2(a_img->url, &u, base);\n\t\t\t    a_img->image = image = New(Image);\n\t\t\t    image->url = parsedURL2Str(&u)->ptr;\n\t\t\t    if (!uncompressed_file_type(u.file, &image->ext))\n\t\t\t\timage->ext = filename_extension(u.file, TRUE);\n\t\t\t    image->cache = NULL;\n\t\t\t    image->width =\n\t\t\t\t(w > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : w;\n\t\t\t    image->height =\n\t\t\t\t(h > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : h;\n\t\t\t    image->xoffset = xoffset;\n\t\t\t    image->yoffset = yoffset;\n\t\t\t    image->y = currentLn(buf) - top;\n\t\t\t    if (image->xoffset < 0 && pos == 0)\n\t\t\t\timage->xoffset = 0;\n\t\t\t    if (image->yoffset < 0 && image->y == 1)\n\t\t\t\timage->yoffset = 0;\n\t\t\t    image->rows = 1 + top + bottom;\n\t\t\t    image->map = q;\n\t\t\t    image->ismap = ismap;\n\t\t\t    image->touch = 0;\n\t\t\t    image->cache = getImage(image, base,\n\t\t\t\t\t\t    IMG_FLAG_SKIP);\n\t\t\t}\n\t\t\telse if (iseq < 0) {\n\t\t\t    BufferPoint *po = buf->imarklist->marks - iseq - 1;\n\t\t\t    Anchor *a = retrieveAnchor(buf->img,\n\t\t\t\t\t\t       po->line, po->pos);\n\t\t\t    if (a) {\n\t\t\t\ta_img->url = a->url;\n\t\t\t\ta_img->image = a->image;\n\t\t\t    }\n\t\t\t}\n#endif\n\t\t    }\n\t\t    effect |= PE_IMAGE;\n\t\t    break;\n\t\tcase HTML_N_IMG_ALT:\n\t\t    effect &= ~PE_IMAGE;\n\t\t    if (a_img) {\n\t\t\ta_img->end.line = currentLn(buf);\n\t\t\ta_img->end.pos = pos;\n\t\t    }\n\t\t    a_img = NULL;\n\t\t    break;\n\t\tcase HTML_INPUT_ALT:\n\t\t    {\n\t\t\tFormList *form;\n\t\t\tint top = 0, bottom = 0;\n\t\t\tint textareanumber = -1;\n#ifdef MENU_SELECT\n\t\t\tint selectnumber = -1;\n#endif\n\t\t\thseq = 0;\n\t\t\tform_id = -1;\n\n\t\t\tparsedtag_get_value(tag, ATTR_HSEQ, &hseq);\n\t\t\tparsedtag_get_value(tag, ATTR_FID, &form_id);\n\t\t\tparsedtag_get_value(tag, ATTR_TOP_MARGIN, &top);\n\t\t\tparsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &bottom);\n\t\t\tif (form_id < 0 || form_id > form_max || forms == NULL)\n\t\t\t    break;\t/* outside of <form>..</form> */\n\t\t\tform = forms[form_id];\n\t\t\tif (hseq > 0) {\n\t\t\t    int hpos = pos;\n\t\t\t    if (*str == '[')\n\t\t\t\thpos++;\n\t\t\t    buf->hmarklist =\n\t\t\t\tputHmarker(buf->hmarklist, currentLn(buf),\n\t\t\t\t\t   hpos, hseq - 1);\n\t\t\t}\n\t\t\telse if (hseq < 0) {\n\t\t\t    int h = -hseq - 1;\n\t\t\t    int hpos = pos;\n\t\t\t    if (*str == '[')\n\t\t\t\thpos++;\n\t\t\t    if (buf->hmarklist &&\n\t\t\t\th < buf->hmarklist->nmark &&\n\t\t\t\tbuf->hmarklist->marks[h].invalid) {\n\t\t\t\tbuf->hmarklist->marks[h].pos = hpos;\n\t\t\t\tbuf->hmarklist->marks[h].line = currentLn(buf);\n\t\t\t\tbuf->hmarklist->marks[h].invalid = 0;\n\t\t\t\thseq = -hseq;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (!form->target)\n\t\t\t    form->target = buf->baseTarget;\n\t\t\tif (a_textarea &&\n\t\t\t    parsedtag_get_value(tag, ATTR_TEXTAREANUMBER,\n\t\t\t\t\t\t&textareanumber)) {\n\t\t\t    if (textareanumber >= max_textarea) {\n\t\t\t\tmax_textarea = 2 * textareanumber;\n\t\t\t\ttextarea_str = New_Reuse(Str, textarea_str,\n\t\t\t\t\t\t\t max_textarea);\n\t\t\t\ta_textarea = New_Reuse(Anchor *, a_textarea,\n\t\t\t\t\t\t       max_textarea);\n\t\t\t    }\n\t\t\t}\n#ifdef MENU_SELECT\n\t\t\tif (a_select &&\n\t\t\t    parsedtag_get_value(tag, ATTR_SELECTNUMBER,\n\t\t\t\t\t\t&selectnumber)) {\n\t\t\t    if (selectnumber >= max_select) {\n\t\t\t\tmax_select = 2 * selectnumber;\n\t\t\t\tselect_option = New_Reuse(FormSelectOption,\n\t\t\t\t\t\t\t  select_option,\n\t\t\t\t\t\t\t  max_select);\n\t\t\t\ta_select = New_Reuse(Anchor *, a_select,\n\t\t\t\t\t\t     max_select);\n\t\t\t    }\n\t\t\t}\n#endif\n\t\t\ta_form =\n\t\t\t    registerForm(buf, form, tag, currentLn(buf), pos);\n\t\t\tif (a_textarea && textareanumber >= 0)\n\t\t\t    a_textarea[textareanumber] = a_form;\n#ifdef MENU_SELECT\n\t\t\tif (a_select && selectnumber >= 0)\n\t\t\t    a_select[selectnumber] = a_form;\n#endif\n\t\t\tif (a_form) {\n\t\t\t    a_form->hseq = hseq - 1;\n\t\t\t    a_form->y = currentLn(buf) - top;\n\t\t\t    a_form->rows = 1 + top + bottom;\n\t\t\t    if (!parsedtag_exists(tag, ATTR_NO_EFFECT))\n\t\t\t\teffect |= PE_FORM;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\tcase HTML_N_INPUT_ALT:\n\t\t    effect &= ~PE_FORM;\n\t\t    if (a_form) {\n\t\t\ta_form->end.line = currentLn(buf);\n\t\t\ta_form->end.pos = pos;\n\t\t\tif (a_form->start.line == a_form->end.line &&\n\t\t\t    a_form->start.pos == a_form->end.pos)\n\t\t\t    a_form->hseq = -1;\n\t\t    }\n\t\t    a_form = NULL;\n\t\t    break;\n\t\tcase HTML_MAP:\n\t\t    if (parsedtag_get_value(tag, ATTR_NAME, &p)) {\n\t\t\tMapList *m = New(MapList);\n\t\t\tm->name = Strnew_charp(p);\n\t\t\tm->area = newGeneralList();\n\t\t\tm->next = buf->maplist;\n\t\t\tbuf->maplist = m;\n\t\t    }\n\t\t    break;\n\t\tcase HTML_N_MAP:\n\t\t    /* nothing to do */\n\t\t    break;\n\t\tcase HTML_AREA:\n\t\t    if (buf->maplist == NULL)\t/* outside of <map>..</map> */\n\t\t\tbreak;\n\t\t    if (parsedtag_get_value(tag, ATTR_HREF, &p)) {\n\t\t\tMapArea *a;\n\t\t\tp = url_encode(remove_space(p), base,\n\t\t\t\t       buf->document_charset);\n\t\t\tt = NULL;\n\t\t\tparsedtag_get_value(tag, ATTR_TARGET, &t);\n\t\t\tq = \"\";\n\t\t\tparsedtag_get_value(tag, ATTR_ALT, &q);\n\t\t\tr = NULL;\n\t\t\ts = NULL;\n#ifdef USE_IMAGE\n\t\t\tparsedtag_get_value(tag, ATTR_SHAPE, &r);\n\t\t\tparsedtag_get_value(tag, ATTR_COORDS, &s);\n#endif\n\t\t\ta = newMapArea(p, t, q, r, s);\n\t\t\tpushValue(buf->maplist->area, (void *)a);\n\t\t    }\n\t\t    break;\n\t\tcase HTML_FRAMESET:\n\t\t    frameset_sp++;\n\t\t    if (frameset_sp >= FRAMESTACK_SIZE)\n\t\t\tbreak;\n\t\t    frameset_s[frameset_sp] = newFrameSet(tag);\n\t\t    if (frameset_s[frameset_sp] == NULL)\n\t\t\tbreak;\n\t\t    if (frameset_sp == 0) {\n\t\t\tif (buf->frameset == NULL) {\n\t\t\t    buf->frameset = frameset_s[frameset_sp];\n\t\t\t}\n\t\t\telse\n\t\t\t    pushFrameTree(&(buf->frameQ),\n\t\t\t\t\t  frameset_s[frameset_sp], NULL);\n\t\t    }\n\t\t    else\n\t\t\taddFrameSetElement(frameset_s[frameset_sp - 1],\n\t\t\t\t\t   *(union frameset_element *)\n\t\t\t\t\t   &frameset_s[frameset_sp]);\n\t\t    break;\n\t\tcase HTML_N_FRAMESET:\n\t\t    if (frameset_sp >= 0)\n\t\t\tframeset_sp--;\n\t\t    break;\n\t\tcase HTML_FRAME:\n\t\t    if (frameset_sp >= 0 && frameset_sp < FRAMESTACK_SIZE) {\n\t\t\tunion frameset_element element;\n\n\t\t\telement.body = newFrame(tag, buf);\n\t\t\taddFrameSetElement(frameset_s[frameset_sp], element);\n\t\t    }\n\t\t    break;\n\t\tcase HTML_BASE:\n\t\t    if (parsedtag_get_value(tag, ATTR_HREF, &p)) {\n\t\t\tp = url_encode(remove_space(p), NULL,\n\t\t\t\t       buf->document_charset);\n\t\t\tif (!buf->baseURL)\n\t\t\t    buf->baseURL = New(ParsedURL);\n\t\t\tparseURL(p, buf->baseURL, NULL);\n#if defined(USE_M17N) || defined(USE_IMAGE)\n\t\t\tbase = buf->baseURL;\n#endif\n\t\t    }\n\t\t    if (parsedtag_get_value(tag, ATTR_TARGET, &p))\n\t\t\tbuf->baseTarget =\n\t\t\t    url_quote_conv(p, buf->document_charset);\n\t\t    break;\n\t\tcase HTML_META:\n\t\t    p = q = NULL;\n\t\t    parsedtag_get_value(tag, ATTR_HTTP_EQUIV, &p);\n\t\t    parsedtag_get_value(tag, ATTR_CONTENT, &q);\n\t\t    if (p && q && !strcasecmp(p, \"refresh\") && MetaRefresh) {\n\t\t\tStr tmp = NULL;\n\t\t\tint refresh_interval = getMetaRefreshParam(q, &tmp);\n#ifdef USE_ALARM\n\t\t\tif (tmp) {\n\t\t\t    p = url_encode(remove_space(tmp->ptr), base,\n\t\t\t\t\t   buf->document_charset);\n\t\t\t    buf->event = setAlarmEvent(buf->event,\n\t\t\t\t\t\t       refresh_interval,\n\t\t\t\t\t\t       AL_IMPLICIT_ONCE,\n\t\t\t\t\t\t       FUNCNAME_gorURL, p);\n\t\t\t}\n\t\t\telse if (refresh_interval > 0)\n\t\t\t    buf->event = setAlarmEvent(buf->event,\n\t\t\t\t\t\t       refresh_interval,\n\t\t\t\t\t\t       AL_IMPLICIT,\n\t\t\t\t\t\t       FUNCNAME_reload, NULL);\n#else\n\t\t\tif (tmp && refresh_interval == 0) {\n\t\t\t    p = url_encode(remove_space(tmp->ptr), base,\n\t\t\t\t\t   buf->document_charset);\n\t\t\t    pushEvent(FUNCNAME_gorURL, p);\n\t\t\t}\n#endif\n\t\t    }\n\t\t    break;\n\t\tcase HTML_INTERNAL:\n\t\t    internal = HTML_INTERNAL;\n\t\t    break;\n\t\tcase HTML_N_INTERNAL:\n\t\t    internal = HTML_N_INTERNAL;\n\t\t    break;\n\t\tcase HTML_FORM_INT:\n\t\t    if (parsedtag_get_value(tag, ATTR_FID, &form_id))\n\t\t\tprocess_form_int(tag, form_id);\n\t\t    break;\n\t\tcase HTML_TEXTAREA_INT:\n\t\t    if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER,\n\t\t\t\t\t    &n_textarea)\n\t\t\t&& n_textarea >= 0 && n_textarea < max_textarea) {\n\t\t\ttextarea_str[n_textarea] = Strnew();\n\t\t    }\n\t\t    else\n\t\t\tn_textarea = -1;\n\t\t    break;\n\t\tcase HTML_N_TEXTAREA_INT:\n\t\t    if (n_textarea >= 0) {\n\t\t\tFormItemList *item =\n\t\t\t    (FormItemList *)a_textarea[n_textarea]->url;\n\t\t\titem->init_value = item->value =\n\t\t\t    textarea_str[n_textarea];\n\t\t    }\n\t\t    break;\n#ifdef MENU_SELECT\n\t\tcase HTML_SELECT_INT:\n\t\t    if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &n_select)\n\t\t\t&& n_select >= 0 && n_select < max_select) {\n\t\t\tselect_option[n_select].first = NULL;\n\t\t\tselect_option[n_select].last = NULL;\n\t\t    }\n\t\t    else\n\t\t\tn_select = -1;\n\t\t    break;\n\t\tcase HTML_N_SELECT_INT:\n\t\t    if (n_select >= 0) {\n\t\t\tFormItemList *item =\n\t\t\t    (FormItemList *)a_select[n_select]->url;\n\t\t\titem->select_option = select_option[n_select].first;\n\t\t\tchooseSelectOption(item, item->select_option);\n\t\t\titem->init_selected = item->selected;\n\t\t\titem->init_value = item->value;\n\t\t\titem->init_label = item->label;\n\t\t    }\n\t\t    break;\n\t\tcase HTML_OPTION_INT:\n\t\t    if (n_select >= 0) {\n\t\t\tint selected;\n\t\t\tq = \"\";\n\t\t\tparsedtag_get_value(tag, ATTR_LABEL, &q);\n\t\t\tp = q;\n\t\t\tparsedtag_get_value(tag, ATTR_VALUE, &p);\n\t\t\tselected = parsedtag_exists(tag, ATTR_SELECTED);\n\t\t\taddSelectOption(&select_option[n_select],\n\t\t\t\t\tStrnew_charp(p), Strnew_charp(q),\n\t\t\t\t\tselected);\n\t\t    }\n\t\t    break;\n#endif\n\t\tcase HTML_TITLE_ALT:\n\t\t    if (parsedtag_get_value(tag, ATTR_TITLE, &p))\n\t\t\tbuf->buffername = html_unquote(p);\n\t\t    break;\n\t\tcase HTML_SYMBOL:\n\t\t    effect |= PC_SYMBOL;\n\t\t    if (parsedtag_get_value(tag, ATTR_TYPE, &p))\n\t\t\tsymbol = (char)atoi(p);\n\t\t    break;\n\t\tcase HTML_N_SYMBOL:\n\t\t    effect &= ~PC_SYMBOL;\n\t\t    break;\n\t\t}\n#ifdef\tID_EXT\n\t\tid = NULL;\n\t\tif (parsedtag_get_value(tag, ATTR_ID, &id)) {\n\t\t    id = url_quote_conv(id, name_charset);\n\t\t    registerName(buf, id, currentLn(buf), pos);\n\t\t}\n\t\tif (renderFrameSet &&\n\t\t    parsedtag_get_value(tag, ATTR_FRAMENAME, &p)) {\n\t\t    p = url_quote_conv(p, buf->document_charset);\n\t\t    if (!idFrame || strcmp(idFrame->body->name, p)) {\n\t\t\tidFrame = search_frame(renderFrameSet, p);\n\t\t\tif (idFrame && idFrame->body->attr != F_BODY)\n\t\t\t    idFrame = NULL;\n\t\t    }\n\t\t}\n\t\tif (id && idFrame)\n\t\t    idFrame->body->nameList =\n\t\t\tputAnchor(idFrame->body->nameList, id, NULL,\n\t\t\t\t  (Anchor **)NULL, NULL, NULL, '\\0',\n\t\t\t\t  currentLn(buf), pos);\n#endif\t\t\t\t/* ID_EXT */\n\t    }\n\t}\n\t/* end of processing for one line */\n\tif (!internal)\n\t    addnewline(buf, outc, outp, NULL, pos, -1, nlines);\n\tif (internal == HTML_N_INTERNAL)\n\t    internal = 0;\n\tif (str != endp) {\n\t    line = Strsubstr(line, str - line->ptr, endp - str);\n\t    goto proc_again;\n\t}\n    }\n#ifdef DEBUG\n    if (w3m_debug)\n\tfclose(debug);\n#endif\n    for (form_id = 1; form_id <= form_max; form_id++)\n\tif (forms[form_id])\n\t    forms[form_id]->next = forms[form_id - 1];\n    buf->formlist = (form_max >= 0) ? forms[form_max] : NULL;\n    if (n_textarea)\n\taddMultirowsForm(buf, buf->formitem);\n#ifdef USE_IMAGE\n    addMultirowsImg(buf, buf->img);\n#endif\n}\n\nstatic void\naddLink(Buffer *buf, struct parsed_tag *tag)\n{\n    char *href = NULL, *title = NULL, *ctype = NULL, *rel = NULL, *rev = NULL;\n    char type = LINK_TYPE_NONE;\n    LinkList *l;\n\n    parsedtag_get_value(tag, ATTR_HREF, &href);\n    if (href)\n\thref = url_encode(remove_space(href), baseURL(buf),\n\t\t\t  buf->document_charset);\n    parsedtag_get_value(tag, ATTR_TITLE, &title);\n    parsedtag_get_value(tag, ATTR_TYPE, &ctype);\n    parsedtag_get_value(tag, ATTR_REL, &rel);\n    if (rel != NULL) {\n\t/* forward link type */\n\ttype = LINK_TYPE_REL;\n\tif (title == NULL)\n\t    title = rel;\n    }\n    parsedtag_get_value(tag, ATTR_REV, &rev);\n    if (rev != NULL) {\n\t/* reverse link type */\n\ttype = LINK_TYPE_REV;\n\tif (title == NULL)\n\t    title = rev;\n    }\n\n    l = New(LinkList);\n    l->url = href;\n    l->title = title;\n    l->ctype = ctype;\n    l->type = type;\n    l->next = NULL;\n    if (buf->linklist) {\n\tLinkList *i;\n\tfor (i = buf->linklist; i->next; i = i->next) ;\n\ti->next = l;\n    }\n    else\n\tbuf->linklist = l;\n}\n\nvoid\nHTMLlineproc2(Buffer *buf, TextLineList *tl)\n{\n    _tl_lp2 = tl->first;\n    HTMLlineproc2body(buf, textlist_feed, -1);\n}\n\nstatic InputStream _file_lp2;\n\nstatic Str\nfile_feed()\n{\n    Str s;\n    s = StrISgets(_file_lp2);\n    if (s->length == 0) {\n\tISclose(_file_lp2);\n\treturn NULL;\n    }\n    return s;\n}\n\nvoid\nHTMLlineproc3(Buffer *buf, InputStream stream)\n{\n    _file_lp2 = stream;\n    HTMLlineproc2body(buf, file_feed, -1);\n}\n\nstatic void\nproc_escape(struct readbuffer *obuf, char **str_return)\n{\n    char *str = *str_return, *estr;\n    int ech = getescapechar(str_return);\n    int width, n_add = *str_return - str;\n    Lineprop mode = PC_ASCII;\n\n    if (ech < 0) {\n\t*str_return = str;\n\tproc_mchar(obuf, obuf->flag & RB_SPECIAL, 1, str_return, PC_ASCII);\n\treturn;\n    }\n    mode = IS_CNTRL(ech) ? PC_CTRL : PC_ASCII;\n\n    estr = conv_entity(ech);\n    check_breakpoint(obuf, obuf->flag & RB_SPECIAL, estr);\n    width = get_strwidth(estr);\n    if (width == 1 && ech == (unsigned char)*estr &&\n\tech != '&' && ech != '<' && ech != '>') {\n\tif (IS_CNTRL(ech))\n\t    mode = PC_CTRL;\n\tpush_charp(obuf, width, estr, mode);\n    }\n    else\n\tpush_nchars(obuf, width, str, n_add, mode);\n    set_prevchar(obuf->prevchar, estr, strlen(estr));\n    obuf->prev_ctype = mode;\n}\n\n\nstatic int\nneed_flushline(struct html_feed_environ *h_env, struct readbuffer *obuf,\n\t       Lineprop mode)\n{\n    char ch;\n\n    if (obuf->flag & RB_PRE_INT) {\n\tif (obuf->pos > h_env->limit)\n\t    return 1;\n\telse\n\t    return 0;\n    }\n\n    ch = Strlastchar(obuf->line);\n    /* if (ch == ' ' && obuf->tag_sp > 0) */\n    if (ch == ' ')\n\treturn 0;\n\n    if (obuf->pos > h_env->limit)\n\treturn 1;\n\n    return 0;\n}\n\nstatic int\ntable_width(struct html_feed_environ *h_env, int table_level)\n{\n    int width;\n    if (table_level < 0)\n\treturn 0;\n    width = tables[table_level]->total_width;\n    if (table_level > 0 || width > 0)\n\treturn width;\n    return h_env->limit - h_env->envs[h_env->envc].indent;\n}\n\n/* HTML processing first pass */\nvoid\nHTMLlineproc0(char *line, struct html_feed_environ *h_env, int internal)\n{\n    Lineprop mode;\n    int cmd;\n    struct readbuffer *obuf = h_env->obuf;\n    int indent, delta;\n    struct parsed_tag *tag;\n    Str tokbuf;\n    struct table *tbl = NULL;\n    struct table_mode *tbl_mode = NULL;\n    int tbl_width = 0;\n#ifdef USE_M17N\n    int is_hangul, prev_is_hangul = 0;\n#endif\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *f = fopen(\"zzzproc1\", \"a\");\n\tfprintf(f, \"%c%c%c%c\",\n\t\t(obuf->flag & RB_PREMODE) ? 'P' : ' ',\n\t\t(obuf->table_level >= 0) ? 'T' : ' ',\n\t\t(obuf->flag & RB_INTXTA) ? 'X' : ' ',\n\t\t(obuf->flag & (RB_SCRIPT | RB_STYLE)) ? 'S' : ' ');\n\tfprintf(f, \"HTMLlineproc1(\\\"%s\\\",%d,%lx)\\n\", line, h_env->limit,\n\t\t(unsigned long)h_env);\n\tfclose(f);\n    }\n#endif\n\n    tokbuf = Strnew();\n\n  table_start:\n    if (obuf->table_level >= 0) {\n\tint level = min(obuf->table_level, MAX_TABLE - 1);\n\ttbl = tables[level];\n\ttbl_mode = &table_mode[level];\n\ttbl_width = table_width(h_env, level);\n    }\n\n    while (*line != '\\0') {\n\tchar *str, *p;\n\tint is_tag = FALSE;\n\tint pre_mode = (obuf->table_level >= 0) ? tbl_mode->pre_mode :\n\t    obuf->flag;\n\tint end_tag = (obuf->table_level >= 0) ? tbl_mode->end_tag :\n\t    obuf->end_tag;\n\n\tif (*line == '<' || obuf->status != R_ST_NORMAL) {\n\t    /* \n\t     * Tag processing\n\t     */\n\t    if (obuf->status == R_ST_EOL)\n\t\tobuf->status = R_ST_NORMAL;\n\t    else {\n\t\tread_token(h_env->tagbuf, &line, &obuf->status,\n\t\t\t   pre_mode & RB_PREMODE, obuf->status != R_ST_NORMAL);\n\t\tif (obuf->status != R_ST_NORMAL)\n\t\t    return;\n\t    }\n\t    if (h_env->tagbuf->length == 0)\n\t\tcontinue;\n\t    str = h_env->tagbuf->ptr;\n\t    if (*str == '<') {\n\t\tif (str[1] && REALLY_THE_BEGINNING_OF_A_TAG(str))\n\t\t    is_tag = TRUE;\n\t\telse if (!(pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT |\n\t\t\t\t       RB_SCRIPT | RB_STYLE | RB_TITLE))) {\n\t\t    line = Strnew_m_charp(str + 1, line, NULL)->ptr;\n\t\t    str = \"&lt;\";\n\t\t}\n\t    }\n\t}\n\telse {\n\t    read_token(tokbuf, &line, &obuf->status, pre_mode & RB_PREMODE, 0);\n\t    if (obuf->status != R_ST_NORMAL)\t/* R_ST_AMP ? */\n\t\tobuf->status = R_ST_NORMAL;\n\t    str = tokbuf->ptr;\n\t}\n\n\tif (pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT | RB_SCRIPT |\n\t\t\tRB_STYLE | RB_TITLE)) {\n\t    if (is_tag) {\n\t\tp = str;\n\t\tif ((tag = parse_tag(&p, internal))) {\n\t\t    if (tag->tagid == end_tag ||\n\t\t\t(pre_mode & RB_INSELECT && tag->tagid == HTML_N_FORM)\n\t\t\t|| (pre_mode & RB_TITLE\n\t\t\t    && (tag->tagid == HTML_N_HEAD\n\t\t\t\t|| tag->tagid == HTML_BODY)))\n\t\t\tgoto proc_normal;\n\t\t}\n\t    }\n\t    /* title */\n\t    if (pre_mode & RB_TITLE) {\n\t\tfeed_title(str);\n\t\tcontinue;\n\t    }\n\t    /* select */\n\t    if (pre_mode & RB_INSELECT) {\n\t\tif (obuf->table_level >= 0)\n\t\t    goto proc_normal;\n\t\tfeed_select(str);\n\t\tcontinue;\n\t    }\n\t    if (is_tag) {\n\t\tif (strncmp(str, \"<!--\", 4) && (p = strchr(str + 1, '<'))) {\n\t\t    str = Strnew_charp_n(str, p - str)->ptr;\n\t\t    line = Strnew_m_charp(p, line, NULL)->ptr;\n\t\t}\n\t\tis_tag = FALSE;\n\t    }\n\t    if (obuf->table_level >= 0)\n\t\tgoto proc_normal;\n\t    /* textarea */\n\t    if (pre_mode & RB_INTXTA) {\n\t\tfeed_textarea(str);\n\t\tcontinue;\n\t    }\n\t    /* script */\n\t    if (pre_mode & RB_SCRIPT)\n\t\tcontinue;\n\t    /* style */\n\t    if (pre_mode & RB_STYLE)\n\t\tcontinue;\n\t}\n\n      proc_normal:\n\tif (obuf->table_level >= 0) {\n\t    /* \n\t     * within table: in <table>..</table>, all input tokens\n\t     * are fed to the table renderer, and then the renderer\n\t     * makes HTML output.\n\t     */\n\t    switch (feed_table(tbl, str, tbl_mode, tbl_width, internal)) {\n\t    case 0:\n\t\t/* </table> tag */\n\t\tobuf->table_level--;\n\t\tif (obuf->table_level >= MAX_TABLE - 1)\n\t\t    continue;\n\t\tend_table(tbl);\n\t\tif (obuf->table_level >= 0) {\n\t\t    struct table *tbl0 = tables[obuf->table_level];\n\t\t    str = Sprintf(\"<table_alt tid=%d>\", tbl0->ntable)->ptr;\n\t\t    pushTable(tbl0, tbl);\n\t\t    tbl = tbl0;\n\t\t    tbl_mode = &table_mode[obuf->table_level];\n\t\t    tbl_width = table_width(h_env, obuf->table_level);\n\t\t    feed_table(tbl, str, tbl_mode, tbl_width, TRUE);\n\t\t    continue;\n\t\t    /* continue to the next */\n\t\t}\n\t\tif (obuf->flag & RB_DEL)\n\t\t    continue;\n\t\t/* all tables have been read */\n\t\tif (tbl->vspace > 0 && !(obuf->flag & RB_IGNORE_P)) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t}\n\t\tsave_fonteffect(h_env, obuf);\n\t\trenderTable(tbl, tbl_width, h_env);\n\t\trestore_fonteffect(h_env, obuf);\n\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\tif (tbl->vspace > 0) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    obuf->flag |= RB_IGNORE_P;\n\t\t}\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t\tcontinue;\n\t    case 1:\n\t\t/* <table> tag */\n\t\tbreak;\n\t    default:\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (is_tag) {\n/*** Beginning of a new tag ***/\n\t    if ((tag = parse_tag(&str, internal)))\n\t\tcmd = tag->tagid;\n\t    else\n\t\tcontinue;\n\t    /* process tags */\n\t    if (HTMLtagproc1(tag, h_env) == 0) {\n\t\t/* preserve the tag for second-stage processing */\n\t\tif (parsedtag_need_reconstruct(tag))\n\t\t    h_env->tagbuf = parsedtag2str(tag);\n\t\tpush_tag(obuf, h_env->tagbuf->ptr, cmd);\n\t    }\n#ifdef ID_EXT\n\t    else {\n\t\tprocess_idattr(obuf, cmd, tag);\n\t    }\n#endif\t\t\t\t/* ID_EXT */\n\t    obuf->bp.init_flag = 1;\n\t    clear_ignore_p_flag(cmd, obuf);\n\t    if (cmd == HTML_TABLE)\n\t\tgoto table_start;\n\t    else\n\t\tcontinue;\n\t}\n\n\tif (obuf->flag & (RB_DEL | RB_S))\n\t    continue;\n\twhile (*str) {\n\t    mode = get_mctype(str);\n\t    delta = get_mcwidth(str);\n\t    if (obuf->flag & (RB_SPECIAL & ~RB_NOBR)) {\n\t\tchar ch = *str;\n\t\tif (!(obuf->flag & RB_PLAIN) && (*str == '&')) {\n\t\t    char *p = str;\n\t\t    int ech = getescapechar(&p);\n\t\t    if (ech == '\\n' || ech == '\\r') {\n\t\t\tch = '\\n';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t    else if (ech == '\\t') {\n\t\t\tch = '\\t';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t}\n\t\tif (ch != '\\n')\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif (ch == '\\n') {\n\t\t    str++;\n\t\t    if (obuf->flag & RB_IGNORE_P) {\n\t\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (obuf->flag & RB_PRE_INT)\n\t\t\tPUSH(' ');\n\t\t    else\n\t\t\tflushline(h_env, obuf, h_env->envs[h_env->envc].indent,\n\t\t\t\t  1, h_env->limit);\n\t\t}\n\t\telse if (ch == '\\t') {\n\t\t    do {\n\t\t\tPUSH(' ');\n\t\t    } while ((h_env->envs[h_env->envc].indent + obuf->pos)\n\t\t\t     % Tabstop != 0);\n\t\t    str++;\n\t\t}\n\t\telse if (obuf->flag & RB_PLAIN) {\n\t\t    char *p = html_quote_char(*str);\n\t\t    if (p) {\n\t\t\tpush_charp(obuf, 1, p, PC_ASCII);\n\t\t\tstr++;\n\t\t    }\n\t\t    else {\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t}\n\t\tif (obuf->flag & (RB_SPECIAL & ~RB_PRE_INT))\n\t\t    continue;\n\t    }\n\t    else {\n\t\tif (!IS_SPACE(*str))\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif ((mode == PC_ASCII || mode == PC_CTRL) && IS_SPACE(*str)) {\n\t\t    if (*obuf->prevchar->ptr != ' ') {\n\t\t\tPUSH(' ');\n\t\t    }\n\t\t    str++;\n\t\t}\n\t\telse {\n#ifdef USE_M17N\n\t\t    if (mode == PC_KANJI1)\n\t\t\tis_hangul = wtf_is_hangul((wc_uchar *) str);\n\t\t    else\n\t\t\tis_hangul = 0;\n\t\t    if (!SimplePreserveSpace && mode == PC_KANJI1 &&\n\t\t\t!is_hangul && !prev_is_hangul &&\n\t\t\tobuf->pos > h_env->envs[h_env->envc].indent &&\n\t\t\tStrlastchar(obuf->line) == ' ') {\n\t\t\twhile (obuf->line->length >= 2 &&\n\t\t\t       !strncmp(obuf->line->ptr + obuf->line->length -\n\t\t\t\t\t2, \"  \", 2)\n\t\t\t       && obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t\tif (obuf->line->length >= 3 &&\n\t\t\t    obuf->prev_ctype == PC_KANJI1 &&\n\t\t\t    Strlastchar(obuf->line) == ' ' &&\n\t\t\t    obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t    }\n\t\t    prev_is_hangul = is_hangul;\n#endif\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, obuf->flag & RB_SPECIAL, delta, &str,\n\t\t\t\t   mode);\n\t\t}\n\t    }\n\t    if (need_flushline(h_env, obuf, mode)) {\n\t\tchar *bp = obuf->line->ptr + obuf->bp.len;\n\t\tchar *tp = bp - obuf->bp.tlen;\n\t\tint i = 0;\n\n\t\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t\t    i = 1;\n\n\t\tindent = h_env->envs[h_env->envc].indent;\n\t\tif (obuf->bp.pos - i > indent) {\n\t\t    Str line;\n\t\t    append_tags(obuf);\n\t\t    line = Strnew_charp(bp);\n\t\t    Strshrink(obuf->line, obuf->line->length - obuf->bp.len);\n#ifdef FORMAT_NICE\n\t\t    if (obuf->pos - i > h_env->limit)\n\t\t\tobuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    back_to_breakpoint(obuf);\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    HTMLlineproc1(line->ptr, h_env);\n\t\t}\n\t    }\n\t}\n    }\n    if (!(obuf->flag & (RB_SPECIAL | RB_INTXTA | RB_INSELECT))) {\n\tchar *tp;\n\tint i = 0;\n\n\tif (obuf->bp.pos == obuf->pos) {\n\t    tp = &obuf->line->ptr[obuf->bp.len - obuf->bp.tlen];\n\t}\n\telse {\n\t    tp = &obuf->line->ptr[obuf->line->length];\n\t}\n\n\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t    i = 1;\n\tindent = h_env->envs[h_env->envc].indent;\n\tif (obuf->pos - i > h_env->limit) {\n#ifdef FORMAT_NICE\n\t    obuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t}\n    }\n}\n\nextern char *NullLine;\nextern Lineprop NullProp[];\n\n#ifndef USE_ANSI_COLOR\n#define addnewline2(a,b,c,d,e,f) _addnewline2(a,b,c,e,f)\n#endif\nstatic void\naddnewline2(Buffer *buf, char *line, Lineprop *prop, Linecolor *color, int pos,\n\t    int nlines)\n{\n    Line *l;\n    l = New(Line);\n    l->next = NULL;\n    l->lineBuf = line;\n    l->propBuf = prop;\n#ifdef USE_ANSI_COLOR\n    l->colorBuf = color;\n#endif\n    l->len = pos;\n    l->width = -1;\n    l->size = pos;\n    l->bpos = 0;\n    l->bwidth = 0;\n    l->prev = buf->currentLine;\n    if (buf->currentLine) {\n\tl->next = buf->currentLine->next;\n\tbuf->currentLine->next = l;\n    }\n    else\n\tl->next = NULL;\n    if (buf->lastLine == NULL || buf->lastLine == buf->currentLine)\n\tbuf->lastLine = l;\n    buf->currentLine = l;\n    if (buf->firstLine == NULL)\n\tbuf->firstLine = l;\n    l->linenumber = ++buf->allLine;\n    if (nlines < 0) {\n\t/*     l->real_linenumber = l->linenumber;     */\n\tl->real_linenumber = 0;\n    }\n    else {\n\tl->real_linenumber = nlines;\n    }\n    l = NULL;\n}\n\nstatic void\naddnewline(Buffer *buf, char *line, Lineprop *prop, Linecolor *color, int pos,\n\t   int width, int nlines)\n{\n    char *s;\n    Lineprop *p;\n#ifdef USE_ANSI_COLOR\n    Linecolor *c;\n#endif\n    Line *l;\n    int i, bpos, bwidth;\n\n    if (pos > 0) {\n\ts = allocStr(line, pos);\n\tp = NewAtom_N(Lineprop, pos);\n\tbcopy((void *)prop, (void *)p, pos * sizeof(Lineprop));\n    }\n    else {\n\ts = NullLine;\n\tp = NullProp;\n    }\n#ifdef USE_ANSI_COLOR\n    if (pos > 0 && color) {\n\tc = NewAtom_N(Linecolor, pos);\n\tbcopy((void *)color, (void *)c, pos * sizeof(Linecolor));\n    }\n    else {\n\tc = NULL;\n    }\n#endif\n    addnewline2(buf, s, p, c, pos, nlines);\n    if (pos <= 0 || width <= 0)\n\treturn;\n    bpos = 0;\n    bwidth = 0;\n    while (1) {\n\tl = buf->currentLine;\n\tl->bpos = bpos;\n\tl->bwidth = bwidth;\n\ti = columnLen(l, width);\n\tif (i == 0) {\n\t    i++;\n#ifdef USE_M17N\n\t    while (i < l->len && p[i] & PC_WCHAR2)\n\t\ti++;\n#endif\n\t}\n\tl->len = i;\n\tl->width = COLPOS(l, l->len);\n\tif (pos <= i)\n\t    return;\n\tbpos += l->len;\n\tbwidth += l->width;\n\ts += i;\n\tp += i;\n#ifdef USE_ANSI_COLOR\n\tif (c)\n\t    c += i;\n#endif\n\tpos -= i;\n\taddnewline2(buf, s, p, c, pos, nlines);\n    }\n}\n\n/* \n * loadHTMLBuffer: read file and make new buffer\n */\nBuffer *\nloadHTMLBuffer(URLFile *f, Buffer *newBuf)\n{\n    FILE *src = NULL;\n    Str tmp;\n\n    if (newBuf == NULL)\n\tnewBuf = newBuffer(INIT_BUFFER_WIDTH);\n    if (newBuf->sourcefile == NULL &&\n\t(f->scheme != SCM_LOCAL || newBuf->mailcap)) {\n\ttmp = tmpfname(TMPF_SRC, \".html\");\n\tsrc = fopen(tmp->ptr, \"w\");\n\tif (src)\n\t    newBuf->sourcefile = tmp->ptr;\n    }\n\n    loadHTMLstream(f, newBuf, src, newBuf->bufferprop & BP_FRAME);\n\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    if (n_textarea)\n\tformResetBuffer(newBuf, newBuf->formitem);\n    if (src)\n\tfclose(src);\n\n    return newBuf;\n}\n\nstatic char *_size_unit[] = { \"b\", \"kb\", \"Mb\", \"Gb\", \"Tb\",\n    \"Pb\", \"Eb\", \"Zb\", \"Bb\", \"Yb\", NULL\n};\n\nchar *\nconvert_size(clen_t size, int usefloat)\n{\n    float csize;\n    int sizepos = 0;\n    char **sizes = _size_unit;\n\n    csize = (float)size;\n    while (csize >= 999.495 && sizes[sizepos + 1]) {\n\tcsize = csize / 1024.0;\n\tsizepos++;\n    }\n    return Sprintf(usefloat ? \"%.3g%s\" : \"%.0f%s\",\n\t\t   floor(csize * 100.0 + 0.5) / 100.0, sizes[sizepos])->ptr;\n}\n\nchar *\nconvert_size2(clen_t size1, clen_t size2, int usefloat)\n{\n    char **sizes = _size_unit;\n    float csize, factor = 1;\n    int sizepos = 0;\n\n    csize = (float)((size1 > size2) ? size1 : size2);\n    while (csize / factor >= 999.495 && sizes[sizepos + 1]) {\n\tfactor *= 1024.0;\n\tsizepos++;\n    }\n    return Sprintf(usefloat ? \"%.3g/%.3g%s\" : \"%.0f/%.0f%s\",\n\t\t   floor(size1 / factor * 100.0 + 0.5) / 100.0,\n\t\t   floor(size2 / factor * 100.0 + 0.5) / 100.0,\n\t\t   sizes[sizepos])->ptr;\n}\n\nvoid\nshowProgress(clen_t * linelen, clen_t * trbyte)\n{\n    int i, j, rate, duration, eta, pos;\n    static time_t last_time, start_time;\n    time_t cur_time;\n    Str messages;\n    char *fmtrbyte, *fmrate;\n\n    if (!fmInitialized)\n\treturn;\n\n    if (*linelen < 1024)\n\treturn;\n    if (current_content_length > 0) {\n\tdouble ratio;\n\tcur_time = time(0);\n\tif (*trbyte == 0) {\n\t    move(LASTLINE, 0);\n\t    clrtoeolx();\n\t    start_time = cur_time;\n\t}\n\t*trbyte += *linelen;\n\t*linelen = 0;\n\tif (cur_time == last_time)\n\t    return;\n\tlast_time = cur_time;\n\tmove(LASTLINE, 0);\n\tratio = 100.0 * (*trbyte) / current_content_length;\n\tfmtrbyte = convert_size2(*trbyte, current_content_length, 1);\n\tduration = cur_time - start_time;\n\tif (duration) {\n\t    rate = *trbyte / duration;\n\t    fmrate = convert_size(rate, 1);\n\t    eta = rate ? (current_content_length - *trbyte) / rate : -1;\n\t    messages = Sprintf(\"%11s %3.0f%% \"\n\t\t\t       \"%7s/s \"\n\t\t\t       \"eta %02d:%02d:%02d     \",\n\t\t\t       fmtrbyte, ratio,\n\t\t\t       fmrate,\n\t\t\t       eta / (60 * 60), (eta / 60) % 60, eta % 60);\n\t}\n\telse {\n\t    messages = Sprintf(\"%11s %3.0f%%                          \",\n\t\t\t       fmtrbyte, ratio);\n\t}\n\taddstr(messages->ptr);\n\tpos = 42;\n\ti = pos + (COLS - pos - 1) * (*trbyte) / current_content_length;\n\tmove(LASTLINE, pos);\n\tstandout();\n\taddch(' ');\n\tfor (j = pos + 1; j <= i; j++)\n\t    addch('|');\n\tstandend();\n\t/* no_clrtoeol(); */\n\trefresh();\n    }\n    else {\n\tcur_time = time(0);\n\tif (*trbyte == 0) {\n\t    move(LASTLINE, 0);\n\t    clrtoeolx();\n\t    start_time = cur_time;\n\t}\n\t*trbyte += *linelen;\n\t*linelen = 0;\n\tif (cur_time == last_time)\n\t    return;\n\tlast_time = cur_time;\n\tmove(LASTLINE, 0);\n\tfmtrbyte = convert_size(*trbyte, 1);\n\tduration = cur_time - start_time;\n\tif (duration) {\n\t    fmrate = convert_size(*trbyte / duration, 1);\n\t    messages = Sprintf(\"%7s loaded %7s/s\", fmtrbyte, fmrate);\n\t}\n\telse {\n\t    messages = Sprintf(\"%7s loaded\", fmtrbyte);\n\t}\n\tmessage(messages->ptr, 0, 0);\n\trefresh();\n    }\n}\n\nvoid\ninit_henv(struct html_feed_environ *h_env, struct readbuffer *obuf,\n\t  struct environment *envs, int nenv, TextLineList *buf,\n\t  int limit, int indent)\n{\n    envs[0].indent = indent;\n\n    obuf->line = Strnew();\n    obuf->cprop = 0;\n    obuf->pos = 0;\n    obuf->prevchar = Strnew_size(8);\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->flag = RB_IGNORE_P;\n    obuf->flag_sp = 0;\n    obuf->status = R_ST_NORMAL;\n    obuf->table_level = -1;\n    obuf->nobr_level = 0;\n    bzero((void *)&obuf->anchor, sizeof(obuf->anchor));\n    obuf->img_alt = 0;\n    obuf->input_alt.hseq = 0;\n    obuf->input_alt.fid = -1;\n    obuf->input_alt.in = 0;\n    obuf->input_alt.type = NULL;\n    obuf->input_alt.name = NULL;\n    obuf->input_alt.value = NULL;\n    obuf->in_bold = 0;\n    obuf->in_italic = 0;\n    obuf->in_under = 0;\n    obuf->in_strike = 0;\n    obuf->in_ins = 0;\n    obuf->prev_ctype = PC_ASCII;\n    obuf->tag_sp = 0;\n    obuf->fontstat_sp = 0;\n    obuf->top_margin = 0;\n    obuf->bottom_margin = 0;\n    obuf->bp.init_flag = 1;\n    set_breakpoint(obuf, 0);\n\n    h_env->buf = buf;\n    h_env->f = NULL;\n    h_env->obuf = obuf;\n    h_env->tagbuf = Strnew();\n    h_env->limit = limit;\n    h_env->maxlimit = 0;\n    h_env->envs = envs;\n    h_env->nenv = nenv;\n    h_env->envc = 0;\n    h_env->envc_real = 0;\n    h_env->title = NULL;\n    h_env->blank_lines = 0;\n}\n\nvoid\ncompleteHTMLstream(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    close_anchor(h_env, obuf);\n    if (obuf->img_alt) {\n\tpush_tag(obuf, \"</img_alt>\", HTML_N_IMG_ALT);\n\tobuf->img_alt = NULL;\n    }\n    if (obuf->input_alt.in) {\n\tpush_tag(obuf, \"</input_alt>\", HTML_N_INPUT_ALT);\n\tobuf->input_alt.hseq = 0;\n\tobuf->input_alt.fid = -1;\n\tobuf->input_alt.in = 0;\n\tobuf->input_alt.type = NULL;\n\tobuf->input_alt.name = NULL;\n\tobuf->input_alt.value = NULL;\n    }\n    if (obuf->in_bold) {\n\tpush_tag(obuf, \"</b>\", HTML_N_B);\n\tobuf->in_bold = 0;\n    }\n    if (obuf->in_italic) {\n\tpush_tag(obuf, \"</i>\", HTML_N_I);\n\tobuf->in_italic = 0;\n    }\n    if (obuf->in_under) {\n\tpush_tag(obuf, \"</u>\", HTML_N_U);\n\tobuf->in_under = 0;\n    }\n    if (obuf->in_strike) {\n\tpush_tag(obuf, \"</s>\", HTML_N_S);\n\tobuf->in_strike = 0;\n    }\n    if (obuf->in_ins) {\n\tpush_tag(obuf, \"</ins>\", HTML_N_INS);\n\tobuf->in_ins = 0;\n    }\n    if (obuf->flag & RB_INTXTA)\n\tHTMLlineproc1(\"</textarea>\", h_env);\n    /* for unbalanced select tag */\n    if (obuf->flag & RB_INSELECT)\n\tHTMLlineproc1(\"</select>\", h_env);\n    if (obuf->flag & RB_TITLE)\n\tHTMLlineproc1(\"</title>\", h_env);\n\n    /* for unbalanced table tag */\n    if (obuf->table_level >= MAX_TABLE)\n\tobuf->table_level = MAX_TABLE - 1;\n\n    while (obuf->table_level >= 0) {\n\ttable_mode[obuf->table_level].pre_mode\n\t    &= ~(TBLM_SCRIPT | TBLM_STYLE | TBLM_PLAIN);\n\tHTMLlineproc1(\"</table>\", h_env);\n    }\n}\n\nstatic void\nprint_internal_information(struct html_feed_environ *henv)\n{\n    int i;\n    Str s;\n    TextLineList *tl = newTextLineList();\n\n    s = Strnew_charp(\"<internal>\");\n    pushTextLine(tl, newTextLine(s, 0));\n    if (henv->title) {\n\ts = Strnew_m_charp(\"<title_alt title=\\\"\",\n\t\t\t   html_quote(henv->title), \"\\\">\", NULL);\n\tpushTextLine(tl, newTextLine(s, 0));\n    }\n#if 0\n    if (form_max >= 0) {\n\tFormList *fp;\n\tfor (i = 0; i <= form_max; i++) {\n\t    fp = forms[i];\n\t    s = Sprintf(\"<form_int fid=\\\"%d\\\" action=\\\"%s\\\" method=\\\"%s\\\"\",\n\t\t\ti, html_quote(fp->action->ptr),\n\t\t\t(fp->method == FORM_METHOD_POST) ? \"post\"\n\t\t\t: ((fp->method ==\n\t\t\t    FORM_METHOD_INTERNAL) ? \"internal\" : \"get\"));\n\t    if (fp->target)\n\t\tStrcat(s, Sprintf(\" target=\\\"%s\\\"\", html_quote(fp->target)));\n\t    if (fp->enctype == FORM_ENCTYPE_MULTIPART)\n\t\tStrcat_charp(s, \" enctype=\\\"multipart/form-data\\\"\");\n#ifdef USE_M17N\n\t    if (fp->charset)\n\t\tStrcat(s, Sprintf(\" accept-charset=\\\"%s\\\"\",\n\t\t\t\t  html_quote(fp->charset)));\n#endif\n\t    Strcat_charp(s, \">\");\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t}\n    }\n#endif\n#ifdef MENU_SELECT\n    if (n_select > 0) {\n\tFormSelectOptionItem *ip;\n\tfor (i = 0; i < n_select; i++) {\n\t    s = Sprintf(\"<select_int selectnumber=%d>\", i);\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t    for (ip = select_option[i].first; ip; ip = ip->next) {\n\t\ts = Sprintf(\"<option_int value=\\\"%s\\\" label=\\\"%s\\\"%s>\",\n\t\t\t    html_quote(ip->value ? ip->value->ptr :\n\t\t\t\t       ip->label->ptr),\n\t\t\t    html_quote(ip->label->ptr),\n\t\t\t    ip->checked ? \" selected\" : \"\");\n\t\tpushTextLine(tl, newTextLine(s, 0));\n\t    }\n\t    s = Strnew_charp(\"</select_int>\");\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t}\n    }\n#endif\t\t\t\t/* MENU_SELECT */\n    if (n_textarea > 0) {\n\tfor (i = 0; i < n_textarea; i++) {\n\t    s = Sprintf(\"<textarea_int textareanumber=%d>\", i);\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t    s = Strnew_charp(html_quote(textarea_str[i]->ptr));\n\t    Strcat_charp(s, \"</textarea_int>\");\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t}\n    }\n    s = Strnew_charp(\"</internal>\");\n    pushTextLine(tl, newTextLine(s, 0));\n\n    if (henv->buf)\n\tappendTextLineList(henv->buf, tl);\n    else if (henv->f) {\n\tTextLineListItem *p;\n\tfor (p = tl->first; p; p = p->next)\n\t    fprintf(henv->f, \"%s\\n\", Str_conv_to_halfdump(p->ptr->line)->ptr);\n    }\n}\n\nvoid\nloadHTMLstream(URLFile *f, Buffer *newBuf, FILE * src, int internal)\n{\n    struct environment envs[MAX_ENV_LEVEL];\n    clen_t linelen = 0;\n    clen_t trbyte = 0;\n    Str lineBuf2 = Strnew();\n#ifdef USE_M17N\n    wc_ces charset = WC_CES_US_ASCII;\n    wc_ces volatile doc_charset = DocumentCharset;\n#endif\n    struct html_feed_environ htmlenv1;\n    struct readbuffer obuf;\n#ifdef USE_IMAGE\n    int volatile image_flag;\n#endif\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n\n#ifdef USE_M17N\n    if (fmInitialized && graph_ok()) {\n\tsymbol_width = symbol_width0 = 1;\n    }\n    else {\n\tsymbol_width0 = 0;\n\tget_symbol(DisplayCharset, &symbol_width0);\n\tsymbol_width = WcOption.use_wide ? symbol_width0 : 1;\n    }\n#else\n    symbol_width = symbol_width0 = 1;\n#endif\n\n    cur_title = NULL;\n    n_textarea = 0;\n    cur_textarea = NULL;\n    max_textarea = MAX_TEXTAREA;\n    textarea_str = New_N(Str, max_textarea);\n#ifdef MENU_SELECT\n    n_select = 0;\n    max_select = MAX_SELECT;\n    select_option = New_N(FormSelectOption, max_select);\n#endif\t\t\t\t/* MENU_SELECT */\n    cur_select = NULL;\n    form_sp = -1;\n    form_max = -1;\n    forms_size = 0;\n    forms = NULL;\n    cur_hseq = 1;\n#ifdef USE_IMAGE\n    cur_iseq = 1;\n    if (newBuf->image_flag)\n\timage_flag = newBuf->image_flag;\n    else if (activeImage && displayImage && autoImage)\n\timage_flag = IMG_FLAG_AUTO;\n    else\n\timage_flag = IMG_FLAG_SKIP;\n#endif\n\n    if (w3m_halfload) {\n\tnewBuf->buffername = \"---\";\n#ifdef USE_M17N\n\tnewBuf->document_charset = InnerCharset;\n#endif\n\tmax_textarea = 0;\n#ifdef MENU_SELECT\n\tmax_select = 0;\n#endif\n\tHTMLlineproc3(newBuf, f->stream);\n\tw3m_halfload = FALSE;\n\treturn;\n    }\n\n    init_henv(&htmlenv1, &obuf, envs, MAX_ENV_LEVEL, NULL, newBuf->width, 0);\n\n    if (w3m_halfdump)\n\thtmlenv1.f = stdout;\n    else\n\thtmlenv1.buf = newTextLineList();\n#if defined(USE_M17N) || defined(USE_IMAGE)\n    cur_baseURL = baseURL(newBuf);\n#endif\n\n    if (SETJMP(AbortLoading) != 0) {\n\tHTMLlineproc1(\"<br>Transfer Interrupted!<br>\", &htmlenv1);\n\tgoto phase2;\n    }\n    TRAP_ON;\n\n#ifdef USE_M17N\n    if (newBuf != NULL) {\n\tif (newBuf->bufferprop & BP_FRAME)\n\t    charset = InnerCharset;\n\telse if (newBuf->document_charset)\n\t    charset = doc_charset = newBuf->document_charset;\n    }\n    if (content_charset && UseContentCharset)\n\tdoc_charset = content_charset;\n    else if (f->guess_type && !strcasecmp(f->guess_type, \"application/xhtml+xml\"))\n\tdoc_charset = WC_CES_UTF_8;\n    meta_charset = 0;\n#endif\n#if\t0\n    do_blankline(&htmlenv1, &obuf, 0, 0, htmlenv1.limit);\n    obuf.flag = RB_IGNORE_P;\n#endif\n    if (IStype(f->stream) != IST_ENCODED)\n\tf->stream = newEncodedStream(f->stream, f->encoding);\n    while ((lineBuf2 = StrmyUFgets(f))->length) {\n#ifdef USE_NNTP\n\tif (f->scheme == SCM_NEWS && lineBuf2->ptr[0] == '.') {\n\t    Strshrinkfirst(lineBuf2, 1);\n\t    if (lineBuf2->ptr[0] == '\\n' || lineBuf2->ptr[0] == '\\r' ||\n\t\tlineBuf2->ptr[0] == '\\0') {\n\t\t/*\n\t\t * iseos(f->stream) = TRUE;\n\t\t */\n\t\tbreak;\n\t    }\n\t}\n#endif\t\t\t\t/* USE_NNTP */\n\tif (src)\n\t    Strfputs(lineBuf2, src);\n\tlinelen += lineBuf2->length;\n\tif (w3m_dump & DUMP_EXTRA)\n\t    printf(\"W3m-in-progress: %s\\n\", convert_size2(linelen, current_content_length, TRUE));\n\tif (w3m_dump & DUMP_SOURCE)\n\t    continue;\n\tshowProgress(&linelen, &trbyte);\n\t/*\n\t * if (frame_source)\n\t * continue;\n\t */\n#ifdef USE_M17N\n\tif (meta_charset) {\t/* <META> */\n\t    if (content_charset == 0 && UseContentCharset) {\n\t\tdoc_charset = meta_charset;\n\t\tcharset = WC_CES_US_ASCII;\n\t    }\n\t    meta_charset = 0;\n\t}\n#endif\n\tlineBuf2 = convertLine(f, lineBuf2, HTML_MODE, &charset, doc_charset);\n#ifdef USE_M17N\n\tcur_document_charset = charset;\n#endif\n\tHTMLlineproc0(lineBuf2->ptr, &htmlenv1, internal);\n    }\n    if (obuf.status != R_ST_NORMAL) {\n\tHTMLlineproc0(\"\\n\", &htmlenv1, internal);\n    }\n    obuf.status = R_ST_NORMAL;\n    completeHTMLstream(&htmlenv1, &obuf);\n    flushline(&htmlenv1, &obuf, 0, 2, htmlenv1.limit);\n#if defined(USE_M17N) || defined(USE_IMAGE)\n    cur_baseURL = NULL;\n#endif\n#ifdef USE_M17N\n    cur_document_charset = 0;\n#endif\n    if (htmlenv1.title)\n\tnewBuf->buffername = htmlenv1.title;\n    if (w3m_halfdump) {\n\tTRAP_OFF;\n\tprint_internal_information(&htmlenv1);\n\treturn;\n    }\n    if (w3m_backend) {\n\tTRAP_OFF;\n\tprint_internal_information(&htmlenv1);\n\tbackend_halfdump_buf = htmlenv1.buf;\n\treturn;\n    }\n  phase2:\n    newBuf->trbyte = trbyte + linelen;\n    TRAP_OFF;\n#ifdef USE_M17N\n    if (!(newBuf->bufferprop & BP_FRAME))\n\tnewBuf->document_charset = charset;\n#endif\n#ifdef USE_IMAGE\n    newBuf->image_flag = image_flag;\n#endif\n    HTMLlineproc2(newBuf, htmlenv1.buf);\n}\n\n/* \n * loadHTMLString: read string and make new buffer\n */\nBuffer *\nloadHTMLString(Str page)\n{\n    URLFile f;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    Buffer *newBuf;\n\n    init_stream(&f, SCM_LOCAL, newStrStream(page));\n\n    newBuf = newBuffer(INIT_BUFFER_WIDTH);\n    if (SETJMP(AbortLoading) != 0) {\n\tTRAP_OFF;\n\tdiscardBuffer(newBuf);\n\tUFclose(&f);\n\treturn NULL;\n    }\n    TRAP_ON;\n\n#ifdef USE_M17N\n    newBuf->document_charset = InnerCharset;\n#endif\n    loadHTMLstream(&f, newBuf, NULL, TRUE);\n#ifdef USE_M17N\n    newBuf->document_charset = WC_CES_US_ASCII;\n#endif\n\n    TRAP_OFF;\n    UFclose(&f);\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    newBuf->type = \"text/html\";\n    newBuf->real_type = newBuf->type;\n    if (n_textarea)\n\tformResetBuffer(newBuf, newBuf->formitem);\n    return newBuf;\n}\n\n#ifdef USE_GOPHER\n\n/* \n * loadGopherDir: get gopher directory\n */\nStr\nloadGopherDir(URLFile *uf, ParsedURL *pu, wc_ces * charset)\n{\n    Str volatile tmp;\n    Str lbuf, name, file, host, port;\n    char *volatile p, *volatile q;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n#ifdef USE_M17N\n    wc_ces doc_charset = DocumentCharset;\n#endif\n\n    tmp = parsedURL2Str(pu);\n    p = html_quote(tmp->ptr);\n    tmp =\n\tconvertLine(NULL, Strnew_charp(file_unquote(tmp->ptr)), RAW_MODE,\n\t\t    charset, doc_charset);\n    q = html_quote(tmp->ptr);\n    tmp = Strnew_m_charp(\"<html>\\n<head>\\n<base href=\\\"\", p, \"\\\">\\n<title>\", q,\n\t\t\t \"</title>\\n</head>\\n<body>\\n<h1>Index of \", q,\n\t\t\t \"</h1>\\n<table>\\n\", NULL);\n\n    if (SETJMP(AbortLoading) != 0)\n\tgoto gopher_end;\n    TRAP_ON;\n\n    while (1) {\n\tif (lbuf = StrUFgets(uf), lbuf->length == 0)\n\t    break;\n\tif (lbuf->ptr[0] == '.' &&\n\t    (lbuf->ptr[1] == '\\n' || lbuf->ptr[1] == '\\r'))\n\t    break;\n\tlbuf = convertLine(uf, lbuf, HTML_MODE, charset, doc_charset);\n\tp = lbuf->ptr;\n\tfor (q = p; *q && *q != '\\t'; q++) ;\n\tname = Strnew_charp_n(p, q - p);\n\tif (!*q)\n\t    continue;\n\tp = q + 1;\n\tfor (q = p; *q && *q != '\\t'; q++) ;\n\tfile = Strnew_charp_n(p, q - p);\n\tif (!*q)\n\t    continue;\n\tp = q + 1;\n\tfor (q = p; *q && *q != '\\t'; q++) ;\n\thost = Strnew_charp_n(p, q - p);\n\tif (!*q)\n\t    continue;\n\tp = q + 1;\n\tfor (q = p; *q && *q != '\\t' && *q != '\\r' && *q != '\\n'; q++) ;\n\tport = Strnew_charp_n(p, q - p);\n\n\tswitch (name->ptr[0]) {\n\tcase '0':\n\t    p = \"[text file]\";\n\t    break;\n\tcase '1':\n\t    p = \"[directory]\";\n\t    break;\n\tcase 'm':\n\t    p = \"[message]\";\n\t    break;\n\tcase 's':\n\t    p = \"[sound]\";\n\t    break;\n\tcase 'g':\n\t    p = \"[gif]\";\n\t    break;\n\tcase 'h':\n\t    p = \"[HTML]\";\n\t    break;\n\tdefault:\n\t    p = \"[unsupported]\";\n\t    break;\n\t}\n\tq = Strnew_m_charp(\"gopher://\", host->ptr, \":\", port->ptr,\n\t\t\t   \"/\", file->ptr, NULL)->ptr;\n\tStrcat_m_charp(tmp, \"<a href=\\\"\",\n\t\t       html_quote(url_encode(q, NULL, *charset)),\n\t\t       \"\\\">\", p, html_quote(name->ptr + 1), \"</a>\\n\", NULL);\n    }\n\n  gopher_end:\n    TRAP_OFF;\n\n    Strcat_charp(tmp, \"</table>\\n</body>\\n</html>\\n\");\n    return tmp;\n}\n#endif\t\t\t\t/* USE_GOPHER */\n\n/* \n * loadBuffer: read file and make new buffer\n */\nBuffer *\nloadBuffer(URLFile *uf, Buffer *volatile newBuf)\n{\n    FILE *volatile src = NULL;\n#ifdef USE_M17N\n    wc_ces charset = WC_CES_US_ASCII;\n    wc_ces volatile doc_charset = DocumentCharset;\n#endif\n    Str lineBuf2;\n    volatile char pre_lbuf = '\\0';\n    int nlines;\n    Str tmpf;\n    clen_t linelen = 0, trbyte = 0;\n    Lineprop *propBuffer = NULL;\n#ifdef USE_ANSI_COLOR\n    Linecolor *colorBuffer = NULL;\n#endif\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n\n    if (newBuf == NULL)\n\tnewBuf = newBuffer(INIT_BUFFER_WIDTH);\n\n    if (SETJMP(AbortLoading) != 0) {\n\tgoto _end;\n    }\n    TRAP_ON;\n\n    if (newBuf->sourcefile == NULL &&\n\t(uf->scheme != SCM_LOCAL || newBuf->mailcap)) {\n\ttmpf = tmpfname(TMPF_SRC, NULL);\n\tsrc = fopen(tmpf->ptr, \"w\");\n\tif (src)\n\t    newBuf->sourcefile = tmpf->ptr;\n    }\n#ifdef USE_M17N\n    if (newBuf->document_charset)\n\tcharset = doc_charset = newBuf->document_charset;\n    if (content_charset && UseContentCharset)\n\tdoc_charset = content_charset;\n#endif\n\n    nlines = 0;\n    if (IStype(uf->stream) != IST_ENCODED)\n\tuf->stream = newEncodedStream(uf->stream, uf->encoding);\n    while ((lineBuf2 = StrmyISgets(uf->stream))->length) {\n#ifdef USE_NNTP\n\tif (uf->scheme == SCM_NEWS && lineBuf2->ptr[0] == '.') {\n\t    Strshrinkfirst(lineBuf2, 1);\n\t    if (lineBuf2->ptr[0] == '\\n' || lineBuf2->ptr[0] == '\\r' ||\n\t\tlineBuf2->ptr[0] == '\\0') {\n\t\t/*\n\t\t * iseos(uf->stream) = TRUE;\n\t\t */\n\t\tbreak;\n\t    }\n\t}\n#endif\t\t\t\t/* USE_NNTP */\n\tif (src)\n\t    Strfputs(lineBuf2, src);\n\tlinelen += lineBuf2->length;\n\tif (w3m_dump & DUMP_EXTRA)\n\t    printf(\"W3m-in-progress: %s\\n\", convert_size2(linelen, current_content_length, TRUE));\n\tif (w3m_dump & DUMP_SOURCE)\n\t    continue;\n\tshowProgress(&linelen, &trbyte);\n\tif (frame_source)\n\t    continue;\n\tlineBuf2 =\n\t    convertLine(uf, lineBuf2, PAGER_MODE, &charset, doc_charset);\n\tif (squeezeBlankLine) {\n\t    if (lineBuf2->ptr[0] == '\\n' && pre_lbuf == '\\n') {\n\t\t++nlines;\n\t\tcontinue;\n\t    }\n\t    pre_lbuf = lineBuf2->ptr[0];\n\t}\n\t++nlines;\n\tStrchop(lineBuf2);\n\tlineBuf2 = checkType(lineBuf2, &propBuffer, NULL);\n\taddnewline(newBuf, lineBuf2->ptr, propBuffer, colorBuffer,\n\t\t   lineBuf2->length, FOLD_BUFFER_WIDTH, nlines);\n    }\n  _end:\n    TRAP_OFF;\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    newBuf->trbyte = trbyte + linelen;\n#ifdef USE_M17N\n    newBuf->document_charset = charset;\n#endif\n    if (src)\n\tfclose(src);\n\n    return newBuf;\n}\n\n#ifdef USE_IMAGE\nBuffer *\nloadImageBuffer(URLFile *uf, Buffer *newBuf)\n{\n    Image image;\n    ImageCache *cache;\n    Str tmp, tmpf;\n    FILE *src = NULL;\n    URLFile f;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    struct stat st;\n    const ParsedURL *pu = newBuf ? &newBuf->currentURL : NULL;\n\n    loadImage(newBuf, IMG_FLAG_STOP);\n    image.url = uf->url;\n    image.ext = uf->ext;\n    image.width = -1;\n    image.height = -1;\n    image.cache = NULL;\n    cache = getImage(&image, (ParsedURL *)pu, IMG_FLAG_AUTO);\n    if (!(pu && pu->is_nocache) && cache->loaded & IMG_FLAG_LOADED &&\n\t!stat(cache->file, &st))\n\tgoto image_buffer;\n\n    if (IStype(uf->stream) != IST_ENCODED)\n\tuf->stream = newEncodedStream(uf->stream, uf->encoding);\n    TRAP_ON;\n    if (save2tmp(*uf, cache->file) < 0) {\n\tTRAP_OFF;\n\treturn NULL;\n    }\n    TRAP_OFF;\n\n    cache->loaded = IMG_FLAG_LOADED;\n    cache->index = 0;\n\n  image_buffer:\n    if (newBuf == NULL)\n\tnewBuf = newBuffer(INIT_BUFFER_WIDTH);\n    cache->loaded |= IMG_FLAG_DONT_REMOVE;\n    if (newBuf->sourcefile == NULL && uf->scheme != SCM_LOCAL)\n\tnewBuf->sourcefile = cache->file;\n\n    tmp = Sprintf(\"<img src=\\\"%s\\\"><br><br>\", html_quote(image.url));\n    tmpf = tmpfname(TMPF_SRC, \".html\");\n    src = fopen(tmpf->ptr, \"w\");\n    newBuf->mailcap_source = tmpf->ptr;\n\n    init_stream(&f, SCM_LOCAL, newStrStream(tmp));\n    loadHTMLstream(&f, newBuf, src, TRUE);\n    UFclose(&f);\n    if (src)\n\tfclose(src);\n\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    newBuf->image_flag = IMG_FLAG_AUTO;\n    return newBuf;\n}\n#endif\n\nstatic Str\nconv_symbol(Line *l)\n{\n    Str tmp = NULL;\n    char *p = l->lineBuf, *ep = p + l->len;\n    Lineprop *pr = l->propBuf;\n#ifdef USE_M17N\n    int w;\n    char **symbol = NULL;\n#else\n    char **symbol = get_symbol();\n#endif\n\n    for (; p < ep; p++, pr++) {\n\tif (*pr & PC_SYMBOL) {\n#ifdef USE_M17N\n\t    char c = ((char)wtf_get_code((wc_uchar *) p) & 0x7f) - SYMBOL_BASE;\n\t    int len = get_mclen(p);\n#else\n\t    char c = *p - SYMBOL_BASE;\n#endif\n\t    if (tmp == NULL) {\n\t\ttmp = Strnew_size(l->len);\n\t\tStrcopy_charp_n(tmp, l->lineBuf, p - l->lineBuf);\n#ifdef USE_M17N\n\t\tw = (*pr & PC_KANJI) ? 2 : 1;\n\t\tsymbol = get_symbol(DisplayCharset, &w);\n#endif\n\t    }\n\t    Strcat_charp(tmp, symbol[(int)c]);\n#ifdef USE_M17N\n\t    p += len - 1;\n\t    pr += len - 1;\n#endif\n\t}\n\telse if (tmp != NULL)\n\t    Strcat_char(tmp, *p);\n    }\n    if (tmp)\n\treturn tmp;\n    else\n\treturn Strnew_charp_n(l->lineBuf, l->len);\n}\n\n/* \n * saveBuffer: write buffer to file\n */\nstatic void\n_saveBuffer(Buffer *buf, Line *l, FILE * f, int cont)\n{\n    Str tmp;\n    int is_html = FALSE;\n#ifdef USE_M17N\n    int set_charset = !DisplayCharset;\n    wc_ces charset = DisplayCharset ? DisplayCharset : WC_CES_US_ASCII;\n#endif\n\n    is_html = is_html_type(buf->type);\n\n  pager_next:\n    for (; l != NULL; l = l->next) {\n\tif (is_html)\n\t    tmp = conv_symbol(l);\n\telse\n\t    tmp = Strnew_charp_n(l->lineBuf, l->len);\n\ttmp = wc_Str_conv(tmp, InnerCharset, charset);\n\tStrfputs(tmp, f);\n\tif (Strlastchar(tmp) != '\\n' && !(cont && l->next && l->next->bpos))\n\t    putc('\\n', f);\n    }\n    if (buf->pagerSource && !(buf->bufferprop & BP_CLOSE)) {\n\tl = getNextPage(buf, PagerMax);\n#ifdef USE_M17N\n\tif (set_charset)\n\t    charset = buf->document_charset;\n#endif\n\tgoto pager_next;\n    }\n}\n\nvoid\nsaveBuffer(Buffer *buf, FILE * f, int cont)\n{\n    _saveBuffer(buf, buf->firstLine, f, cont);\n}\n\nvoid\nsaveBufferBody(Buffer *buf, FILE * f, int cont)\n{\n    Line *l = buf->firstLine;\n\n    while (l != NULL && l->real_linenumber == 0)\n\tl = l->next;\n    _saveBuffer(buf, l, f, cont);\n}\n\nstatic Buffer *\nloadcmdout(char *cmd,\n\t   Buffer *(*loadproc) (URLFile *, Buffer *), Buffer *defaultbuf)\n{\n    FILE *f, *popen(const char *, const char *);\n    Buffer *buf;\n    URLFile uf;\n\n    if (cmd == NULL || *cmd == '\\0')\n\treturn NULL;\n    f = popen(cmd, \"r\");\n    if (f == NULL)\n\treturn NULL;\n    init_stream(&uf, SCM_UNKNOWN, newFileStream(f, (void (*)())pclose));\n    buf = loadproc(&uf, defaultbuf);\n    UFclose(&uf);\n    return buf;\n}\n\n/* \n * getshell: execute shell command and get the result into a buffer\n */\nBuffer *\ngetshell(char *cmd)\n{\n    Buffer *buf;\n\n    buf = loadcmdout(cmd, loadBuffer, NULL);\n    if (buf == NULL)\n\treturn NULL;\n    buf->filename = cmd;\n    buf->buffername = Sprintf(\"%s %s\", SHELLBUFFERNAME,\n\t\t\t      conv_from_system(cmd))->ptr;\n    return buf;\n}\n\n/* \n * getpipe: execute shell command and connect pipe to the buffer\n */\nBuffer *\ngetpipe(char *cmd)\n{\n    FILE *f, *popen(const char *, const char *);\n    Buffer *buf;\n\n    if (cmd == NULL || *cmd == '\\0')\n\treturn NULL;\n    f = popen(cmd, \"r\");\n    if (f == NULL)\n\treturn NULL;\n    buf = newBuffer(INIT_BUFFER_WIDTH);\n    buf->pagerSource = newFileStream(f, (void (*)())pclose);\n    buf->filename = cmd;\n    buf->buffername = Sprintf(\"%s %s\", PIPEBUFFERNAME,\n\t\t\t      conv_from_system(cmd))->ptr;\n    buf->bufferprop |= BP_PIPE;\n#ifdef USE_M17N\n    buf->document_charset = WC_CES_US_ASCII;\n#endif\n    return buf;\n}\n\n/* \n * Open pager buffer\n */\nBuffer *\nopenPagerBuffer(InputStream stream, Buffer *buf)\n{\n\n    if (buf == NULL)\n\tbuf = newBuffer(INIT_BUFFER_WIDTH);\n    buf->pagerSource = stream;\n    buf->buffername = getenv(\"MAN_PN\");\n    if (buf->buffername == NULL)\n\tbuf->buffername = PIPEBUFFERNAME;\n    else\n\tbuf->buffername = conv_from_system(buf->buffername);\n    buf->bufferprop |= BP_PIPE;\n#ifdef USE_M17N\n    if (content_charset && UseContentCharset)\n\tbuf->document_charset = content_charset;\n    else\n\tbuf->document_charset = WC_CES_US_ASCII;\n#endif\n    buf->currentLine = buf->firstLine;\n\n    return buf;\n}\n\nBuffer *\nopenGeneralPagerBuffer(InputStream stream)\n{\n    Buffer *buf;\n    char *t = \"text/plain\";\n    Buffer *t_buf = NULL;\n    URLFile uf;\n\n    init_stream(&uf, SCM_UNKNOWN, stream);\n\n#ifdef USE_M17N\n    content_charset = 0;\n#endif\n    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n    copyParsedURL(&t_buf->currentURL, NULL);\n    t_buf->currentURL.scheme = SCM_LOCAL;\n    t_buf->currentURL.file = \"-\";\n    if (SearchHeader) {\n\treadHeader(&uf, t_buf, TRUE, NULL);\n\tt = checkContentType(t_buf);\n\tif (t == NULL)\n\t    t = \"text/plain\";\n\tif (t_buf) {\n\t    t_buf->topLine = t_buf->firstLine;\n\t    t_buf->currentLine = t_buf->lastLine;\n\t}\n\tSearchHeader = FALSE;\n    }\n    else if (DefaultType) {\n\tt = DefaultType;\n\tDefaultType = NULL;\n    }\n    if (is_html_type(t)) {\n\tbuf = loadHTMLBuffer(&uf, t_buf);\n\tbuf->type = \"text/html\";\n    }\n    else if (is_plain_text_type(t)) {\n\tif (IStype(stream) != IST_ENCODED)\n\t    stream = newEncodedStream(stream, uf.encoding);\n\tbuf = openPagerBuffer(stream, t_buf);\n\tbuf->type = \"text/plain\";\n    }\n#ifdef USE_IMAGE\n    else if (activeImage && displayImage && !useExtImageViewer &&\n\t     !(w3m_dump & ~DUMP_FRAME) && !strncasecmp(t, \"image/\", 6)) {\n\tbuf = loadImageBuffer(&uf, t_buf);\n\tbuf->type = \"text/html\";\n    }\n#endif\n    else {\n\tif (searchExtViewer(t)) {\n\t    buf = doExternal(uf, t, t_buf);\n\t    UFclose(&uf);\n\t    if (buf == NULL || buf == NO_BUFFER)\n\t\treturn buf;\n\t}\n\telse {\t\t\t/* unknown type is regarded as text/plain */\n\t    if (IStype(stream) != IST_ENCODED)\n\t\tstream = newEncodedStream(stream, uf.encoding);\n\t    buf = openPagerBuffer(stream, t_buf);\n\t    buf->type = \"text/plain\";\n\t}\n    }\n    buf->real_type = t;\n    return buf;\n}\n\nLine *\ngetNextPage(Buffer *buf, int plen)\n{\n    Line *volatile top = buf->topLine, *volatile last = buf->lastLine,\n\t*volatile cur = buf->currentLine;\n    int i;\n    int volatile nlines = 0;\n    clen_t linelen = 0, trbyte = buf->trbyte;\n    Str lineBuf2;\n    char volatile pre_lbuf = '\\0';\n    URLFile uf;\n#ifdef USE_M17N\n    wc_ces charset;\n    wc_ces volatile doc_charset = DocumentCharset;\n    wc_uint8 old_auto_detect = WcOption.auto_detect;\n#endif\n    int volatile squeeze_flag = FALSE;\n    Lineprop *propBuffer = NULL;\n\n#ifdef USE_ANSI_COLOR\n    Linecolor *colorBuffer = NULL;\n#endif\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n\n    if (buf->pagerSource == NULL)\n\treturn NULL;\n\n    if (last != NULL) {\n\tnlines = last->real_linenumber;\n\tpre_lbuf = *(last->lineBuf);\n\tif (pre_lbuf == '\\0')\n\t    pre_lbuf = '\\n';\n\tbuf->currentLine = last;\n    }\n\n#ifdef USE_M17N\n    charset = buf->document_charset;\n    if (buf->document_charset != WC_CES_US_ASCII)\n\tdoc_charset = buf->document_charset;\n    else if (UseContentCharset) {\n\tcontent_charset = 0;\n\tcheckContentType(buf);\n\tif (content_charset)\n\t    doc_charset = content_charset;\n    }\n    WcOption.auto_detect = buf->auto_detect;\n#endif\n\n    if (SETJMP(AbortLoading) != 0) {\n\tgoto pager_end;\n    }\n    TRAP_ON;\n\n    init_stream(&uf, SCM_UNKNOWN, NULL);\n    for (i = 0; i < plen; i++) {\n\tlineBuf2 = StrmyISgets(buf->pagerSource);\n\tif (lineBuf2->length == 0) {\n\t    /* Assume that `cmd == buf->filename' */\n\t    if (buf->filename)\n\t\tbuf->buffername = Sprintf(\"%s %s\",\n\t\t\t\t\t  CPIPEBUFFERNAME,\n\t\t\t\t\t  conv_from_system(buf->filename))->\n\t\t    ptr;\n\t    else if (getenv(\"MAN_PN\") == NULL)\n\t\tbuf->buffername = CPIPEBUFFERNAME;\n\t    buf->bufferprop |= BP_CLOSE;\n\t    break;\n\t}\n\tlinelen += lineBuf2->length;\n\tshowProgress(&linelen, &trbyte);\n\tlineBuf2 =\n\t    convertLine(&uf, lineBuf2, PAGER_MODE, &charset, doc_charset);\n\tif (squeezeBlankLine) {\n\t    squeeze_flag = FALSE;\n\t    if (lineBuf2->ptr[0] == '\\n' && pre_lbuf == '\\n') {\n\t\t++nlines;\n\t\t--i;\n\t\tsqueeze_flag = TRUE;\n\t\tcontinue;\n\t    }\n\t    pre_lbuf = lineBuf2->ptr[0];\n\t}\n\t++nlines;\n\tStrchop(lineBuf2);\n\tlineBuf2 = checkType(lineBuf2, &propBuffer, &colorBuffer);\n\taddnewline(buf, lineBuf2->ptr, propBuffer, colorBuffer,\n\t\t   lineBuf2->length, FOLD_BUFFER_WIDTH, nlines);\n\tif (!top) {\n\t    top = buf->firstLine;\n\t    cur = top;\n\t}\n\tif (buf->lastLine->real_linenumber - buf->firstLine->real_linenumber\n\t    >= PagerMax) {\n\t    Line *l = buf->firstLine;\n\t    do {\n\t\tif (top == l)\n\t\t    top = l->next;\n\t\tif (cur == l)\n\t\t    cur = l->next;\n\t\tif (last == l)\n\t\t    last = NULL;\n\t\tl = l->next;\n\t    } while (l && l->bpos);\n\t    buf->firstLine = l;\n\t    buf->firstLine->prev = NULL;\n\t}\n    }\n  pager_end:\n    TRAP_OFF;\n\n    buf->trbyte = trbyte + linelen;\n#ifdef USE_M17N\n    buf->document_charset = charset;\n    WcOption.auto_detect = old_auto_detect;\n#endif\n    buf->topLine = top;\n    buf->currentLine = cur;\n    if (!last)\n\tlast = buf->firstLine;\n    else if (last && (last->next || !squeeze_flag))\n\tlast = last->next;\n    return last;\n}\n\nint\nsave2tmp(URLFile uf, char *tmpf)\n{\n    FILE *ff;\n    int check;\n    clen_t linelen = 0, trbyte = 0;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    static JMP_BUF env_bak;\n    volatile int retval = 0;\n    char *volatile buf = NULL;\n\n    ff = fopen(tmpf, \"wb\");\n    if (ff == NULL) {\n\t/* fclose(f); */\n\treturn -1;\n    }\n    bcopy(AbortLoading, env_bak, sizeof(JMP_BUF));\n    if (SETJMP(AbortLoading) != 0) {\n\tgoto _end;\n    }\n    TRAP_ON;\n    check = 0;\n#ifdef USE_NNTP\n    if (uf.scheme == SCM_NEWS) {\n\tchar c;\n\twhile (c = UFgetc(&uf), !iseos(uf.stream)) {\n\t    if (c == '\\n') {\n\t\tif (check == 0)\n\t\t    check++;\n\t\telse if (check == 3)\n\t\t    break;\n\t    }\n\t    else if (c == '.' && check == 1)\n\t\tcheck++;\n\t    else if (c == '\\r' && check == 2)\n\t\tcheck++;\n\t    else\n\t\tcheck = 0;\n\t    putc(c, ff);\n\t    linelen += sizeof(c);\n\t    showProgress(&linelen, &trbyte);\n\t}\n    }\n    else\n#endif\t\t\t\t/* USE_NNTP */\n    {\n\tint count;\n\n\tbuf = NewWithoutGC_N(char, SAVE_BUF_SIZE);\n\twhile ((count = ISread_n(uf.stream, buf, SAVE_BUF_SIZE)) > 0) {\n\t    if (fwrite(buf, 1, count, ff) != count) {\n\t\tretval = -2;\n\t\tgoto _end;\n\t    }\n\t    linelen += count;\n\t    showProgress(&linelen, &trbyte);\n\t}\n    }\n  _end:\n    bcopy(env_bak, AbortLoading, sizeof(JMP_BUF));\n    TRAP_OFF;\n    xfree(buf);\n    fclose(ff);\n    current_content_length = 0;\n    return retval;\n}\n\nBuffer *\ndoExternal(URLFile uf, char *type, Buffer *defaultbuf)\n{\n    Str tmpf, command;\n    struct mailcap *mcap;\n    int mc_stat;\n    Buffer *buf = NULL;\n    char *header, *src = NULL, *ext = uf.ext;\n\n    if (!(mcap = searchExtViewer(type)))\n\treturn NULL;\n\n    if (mcap->nametemplate) {\n\ttmpf = unquote_mailcap(mcap->nametemplate, NULL, \"\", NULL, NULL);\n\tif (tmpf->ptr[0] == '.')\n\t    ext = tmpf->ptr;\n    }\n    tmpf = tmpfname(TMPF_DFL, (ext && *ext) ? ext : NULL);\n\n    if (IStype(uf.stream) != IST_ENCODED)\n\tuf.stream = newEncodedStream(uf.stream, uf.encoding);\n    header = checkHeader(defaultbuf, \"Content-Type:\");\n    if (header)\n\theader = conv_to_system(header);\n    command = unquote_mailcap(mcap->viewer, type, tmpf->ptr, header, &mc_stat);\n#ifndef __EMX__\n    if (!(mc_stat & MCSTAT_REPNAME)) {\n\tStr tmp = Sprintf(\"(%s) < %s\", command->ptr, shell_quote(tmpf->ptr));\n\tcommand = tmp;\n    }\n#endif\n\n#ifdef HAVE_SETPGRP\n    if (!(mcap->flags & (MAILCAP_HTMLOUTPUT | MAILCAP_COPIOUSOUTPUT)) &&\n\t!(mcap->flags & MAILCAP_NEEDSTERMINAL) && BackgroundExtViewer) {\n\tflush_tty();\n\tif (!fork()) {\n\t    setup_child(FALSE, 0, UFfileno(&uf));\n\t    if (save2tmp(uf, tmpf->ptr) < 0)\n\t\texit(1);\n\t    UFclose(&uf);\n\t    myExec(command->ptr);\n\t}\n\treturn NO_BUFFER;\n    }\n    else\n#endif\n    {\n\tif (save2tmp(uf, tmpf->ptr) < 0) {\n\t    return NULL;\n\t}\n    }\n    if (mcap->flags & (MAILCAP_HTMLOUTPUT | MAILCAP_COPIOUSOUTPUT)) {\n\tif (defaultbuf == NULL)\n\t    defaultbuf = newBuffer(INIT_BUFFER_WIDTH);\n\tif (defaultbuf->sourcefile)\n\t    src = defaultbuf->sourcefile;\n\telse\n\t    src = tmpf->ptr;\n\tdefaultbuf->sourcefile = NULL;\n\tdefaultbuf->mailcap = mcap;\n    }\n    if (mcap->flags & MAILCAP_HTMLOUTPUT) {\n\tbuf = loadcmdout(command->ptr, loadHTMLBuffer, defaultbuf);\n\tif (buf && buf != NO_BUFFER) {\n\t    buf->type = \"text/html\";\n\t    buf->mailcap_source = buf->sourcefile;\n\t    buf->sourcefile = src;\n\t}\n    }\n    else if (mcap->flags & MAILCAP_COPIOUSOUTPUT) {\n\tbuf = loadcmdout(command->ptr, loadBuffer, defaultbuf);\n\tif (buf && buf != NO_BUFFER) {\n\t    buf->type = \"text/plain\";\n\t    buf->mailcap_source = buf->sourcefile;\n\t    buf->sourcefile = src;\n\t}\n    }\n    else {\n\tif (mcap->flags & MAILCAP_NEEDSTERMINAL || !BackgroundExtViewer) {\n\t    fmTerm();\n\t    mySystem(command->ptr, 0);\n\t    fmInit();\n\t    if (CurrentTab && Currentbuf)\n\t\tdisplayBuffer(Currentbuf, B_FORCE_REDRAW);\n\t}\n\telse {\n\t    mySystem(command->ptr, 1);\n\t}\n\tbuf = NO_BUFFER;\n    }\n    if (buf && buf != NO_BUFFER) {\n\tif ((buf->buffername == NULL || buf->buffername[0] == '\\0') &&\n\t    buf->filename)\n\t    buf->buffername = conv_from_system(lastFileName(buf->filename));\n\tbuf->edit = mcap->edit;\n\tbuf->mailcap = mcap;\n    }\n    return buf;\n}\n\nstatic int\n_MoveFile(char *path1, char *path2)\n{\n    InputStream f1;\n    FILE *f2;\n    int is_pipe;\n    clen_t linelen = 0, trbyte = 0;\n    char *buf = NULL;\n    int count;\n\n    f1 = openIS(path1);\n    if (f1 == NULL)\n\treturn -1;\n    if (*path2 == '|' && PermitSaveToPipe) {\n\tis_pipe = TRUE;\n\tf2 = popen(path2 + 1, \"w\");\n    }\n    else {\n\tis_pipe = FALSE;\n\tf2 = fopen(path2, \"wb\");\n    }\n    if (f2 == NULL) {\n\tISclose(f1);\n\treturn -1;\n    }\n    current_content_length = 0;\n    buf = NewWithoutGC_N(char, SAVE_BUF_SIZE);\n    while ((count = ISread_n(f1, buf, SAVE_BUF_SIZE)) > 0) {\n\tfwrite(buf, 1, count, f2);\n\tlinelen += count;\n\tshowProgress(&linelen, &trbyte);\n    }\n    xfree(buf);\n    ISclose(f1);\n    if (is_pipe)\n\tpclose(f2);\n    else\n\tfclose(f2);\n    return 0;\n}\n\nint\n_doFileCopy(char *tmpf, char *defstr, int download)\n{\n#ifndef __MINGW32_VERSION\n    Str msg;\n    Str filen;\n    char *p, *q = NULL;\n    pid_t pid;\n    char *lock;\n#if !(defined(HAVE_SYMLINK) && defined(HAVE_LSTAT))\n    FILE *f;\n#endif\n    struct stat st;\n    clen_t size = 0;\n    int is_pipe = FALSE;\n\n    if (fmInitialized) {\n\tp = searchKeyData();\n\tif (p == NULL || *p == '\\0') {\n\t    /* FIXME: gettextize? */\n\t    q = inputLineHist(\"(Download)Save file to: \",\n\t\t\t      defstr, IN_COMMAND, SaveHist);\n\t    if (q == NULL || *q == '\\0')\n\t\treturn FALSE;\n\t    p = conv_to_system(q);\n\t}\n\tif (*p == '|' && PermitSaveToPipe)\n\t    is_pipe = TRUE;\n\telse {\n\t    if (q) {\n\t\tp = unescape_spaces(Strnew_charp(q))->ptr;\n\t\tp = conv_to_system(p);\n\t    }\n\t    p = expandPath(p);\n\t    if (checkOverWrite(p) < 0)\n\t\treturn -1;\n\t}\n\tif (checkCopyFile(tmpf, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    msg = Sprintf(\"Can't copy. %s and %s are identical.\",\n\t\t\t  conv_from_system(tmpf), conv_from_system(p));\n\t    disp_err_message(msg->ptr, FALSE);\n\t    return -1;\n\t}\n\tif (!download) {\n\t    if (_MoveFile(tmpf, p) < 0) {\n\t\t/* FIXME: gettextize? */\n\t\tmsg = Sprintf(\"Can't save to %s\", conv_from_system(p));\n\t\tdisp_err_message(msg->ptr, FALSE);\n\t    }\n\t    return -1;\n\t}\n\tlock = tmpfname(TMPF_DFL, \".lock\")->ptr;\n#if defined(HAVE_SYMLINK) && defined(HAVE_LSTAT)\n\tsymlink(p, lock);\n#else\n\tf = fopen(lock, \"w\");\n\tif (f)\n\t    fclose(f);\n#endif\n\tflush_tty();\n\tpid = fork();\n\tif (!pid) {\n\t    setup_child(FALSE, 0, -1);\n\t    if (!_MoveFile(tmpf, p) && PreserveTimestamp && !is_pipe &&\n\t\t!stat(tmpf, &st))\n\t\tsetModtime(p, st.st_mtime);\n\t    unlink(lock);\n\t    exit(0);\n\t}\n\tif (!stat(tmpf, &st))\n\t    size = st.st_size;\n\taddDownloadList(pid, conv_from_system(tmpf), p, lock, size);\n    }\n    else {\n\tq = searchKeyData();\n\tif (q == NULL || *q == '\\0') {\n\t    /* FIXME: gettextize? */\n\t    printf(\"(Download)Save file to: \");\n\t    fflush(stdout);\n\t    filen = Strfgets(stdin);\n\t    if (filen->length == 0)\n\t\treturn -1;\n\t    q = filen->ptr;\n\t}\n\tfor (p = q + strlen(q) - 1; IS_SPACE(*p); p--) ;\n\t*(p + 1) = '\\0';\n\tif (*q == '\\0')\n\t    return -1;\n\tp = q;\n\tif (*p == '|' && PermitSaveToPipe)\n\t    is_pipe = TRUE;\n\telse {\n\t    p = expandPath(p);\n\t    if (checkOverWrite(p) < 0)\n\t\treturn -1;\n\t}\n\tif (checkCopyFile(tmpf, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    printf(\"Can't copy. %s and %s are identical.\", tmpf, p);\n\t    return -1;\n\t}\n\tif (_MoveFile(tmpf, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    printf(\"Can't save to %s\\n\", p);\n\t    return -1;\n\t}\n\tif (PreserveTimestamp && !is_pipe && !stat(tmpf, &st))\n\t    setModtime(p, st.st_mtime);\n    }\n#endif /* __MINGW32_VERSION */\n    return 0;\n}\n\nint\ndoFileMove(char *tmpf, char *defstr)\n{\n    int ret = doFileCopy(tmpf, defstr);\n    unlink(tmpf);\n    return ret;\n}\n\nint\ndoFileSave(URLFile uf, char *defstr)\n{\n#ifndef __MINGW32_VERSION\n    Str msg;\n    Str filen;\n    char *p, *q;\n    pid_t pid;\n    char *lock;\n    char *tmpf = NULL; \n#if !(defined(HAVE_SYMLINK) && defined(HAVE_LSTAT))\n    FILE *f;\n#endif\n\n    if (fmInitialized) {\n\tp = searchKeyData();\n\tif (p == NULL || *p == '\\0') {\n\t    /* FIXME: gettextize? */\n\t    p = inputLineHist(\"(Download)Save file to: \",\n\t\t\t      defstr, IN_FILENAME, SaveHist);\n\t    if (p == NULL || *p == '\\0')\n\t\treturn -1;\n\t    p = conv_to_system(p);\n\t}\n\tif (checkOverWrite(p) < 0)\n\t    return -1;\n\tif (checkSaveFile(uf.stream, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    msg = Sprintf(\"Can't save. Load file and %s are identical.\",\n\t\t\t  conv_from_system(p));\n\t    disp_err_message(msg->ptr, FALSE);\n\t    return -1;\n\t}\n\t/*\n\t * if (save2tmp(uf, p) < 0) {\n\t * msg = Sprintf(\"Can't save to %s\", conv_from_system(p));\n\t * disp_err_message(msg->ptr, FALSE);\n\t * }\n\t */\n\tlock = tmpfname(TMPF_DFL, \".lock\")->ptr;\n#if defined(HAVE_SYMLINK) && defined(HAVE_LSTAT)\n\tsymlink(p, lock);\n#else\n\tf = fopen(lock, \"w\");\n\tif (f)\n\t    fclose(f);\n#endif\n\tflush_tty();\n\tpid = fork();\n\tif (!pid) {\n\t    int err;\n\t    if ((uf.content_encoding != CMP_NOCOMPRESS) && AutoUncompress) {\n\t\tuncompress_stream(&uf, &tmpf);\n\t\tif (tmpf)\n\t\t    unlink(tmpf);\n\t    }\n\t    setup_child(FALSE, 0, UFfileno(&uf));\n\t    err = save2tmp(uf, p);\n\t    if (err == 0 && PreserveTimestamp && uf.modtime != -1)\n\t\tsetModtime(p, uf.modtime);\n\t    UFclose(&uf);\n\t    unlink(lock);\n\t    if (err != 0)\n\t\texit(-err);\n\t    exit(0);\n\t}\n\taddDownloadList(pid, uf.url, p, lock, current_content_length);\n    }\n    else {\n\tq = searchKeyData();\n\tif (q == NULL || *q == '\\0') {\n\t    /* FIXME: gettextize? */\n\t    printf(\"(Download)Save file to: \");\n\t    fflush(stdout);\n\t    filen = Strfgets(stdin);\n\t    if (filen->length == 0)\n\t\treturn -1;\n\t    q = filen->ptr;\n\t}\n\tfor (p = q + strlen(q) - 1; IS_SPACE(*p); p--) ;\n\t*(p + 1) = '\\0';\n\tif (*q == '\\0')\n\t    return -1;\n\tp = expandPath(q);\n\tif (checkOverWrite(p) < 0)\n\t    return -1;\n\tif (checkSaveFile(uf.stream, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    printf(\"Can't save. Load file and %s are identical.\", p);\n\t    return -1;\n\t}\n\tif (uf.content_encoding != CMP_NOCOMPRESS && AutoUncompress) {\n\t    uncompress_stream(&uf, &tmpf);\n\t    if (tmpf)\n\t\tunlink(tmpf);\n\t}\n\tif (save2tmp(uf, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    printf(\"Can't save to %s\\n\", p);\n\t    return -1;\n\t}\n\tif (PreserveTimestamp && uf.modtime != -1)\n\t    setModtime(p, uf.modtime);\n    }\n#endif /* __MINGW32_VERSION */\n    return 0;\n}\n\nint\ncheckCopyFile(char *path1, char *path2)\n{\n    struct stat st1, st2;\n\n    if (*path2 == '|' && PermitSaveToPipe)\n\treturn 0;\n    if ((stat(path1, &st1) == 0) && (stat(path2, &st2) == 0))\n\tif (st1.st_ino == st2.st_ino)\n\t    return -1;\n    return 0;\n}\n\nint\ncheckSaveFile(InputStream stream, char *path2)\n{\n    struct stat st1, st2;\n    int des = ISfileno(stream);\n\n    if (des < 0)\n\treturn 0;\n    if (*path2 == '|' && PermitSaveToPipe)\n\treturn 0;\n    if ((fstat(des, &st1) == 0) && (stat(path2, &st2) == 0))\n\tif (st1.st_ino == st2.st_ino)\n\t    return -1;\n    return 0;\n}\n\nint\ncheckOverWrite(char *path)\n{\n    struct stat st;\n    char *ans;\n\n    if (stat(path, &st) < 0)\n\treturn 0;\n    /* FIXME: gettextize? */\n    ans = inputAnswer(\"File exists. Overwrite? (y/n)\");\n    if (ans && TOLOWER(*ans) == 'y')\n\treturn 0;\n    else\n\treturn -1;\n}\n\nchar *\ninputAnswer(char *prompt)\n{\n    char *ans;\n\n    if (QuietMessage)\n\treturn \"n\";\n    if (fmInitialized) {\n\tterm_raw();\n\tans = inputChar(prompt);\n    }\n    else {\n\tprintf(\"%s\", prompt);\n\tfflush(stdout);\n\tans = Strfgets(stdin)->ptr;\n    }\n    return ans;\n}\n\nstatic void\nuncompress_stream(URLFile *uf, char **src)\n{\n#ifndef __MINGW32_VERSION\n    pid_t pid1;\n    FILE *f1;\n    char *expand_cmd = GUNZIP_CMDNAME;\n    char *expand_name = GUNZIP_NAME;\n    char *tmpf = NULL;\n    char *ext = NULL;\n    struct compression_decoder *d;\n\n    if (IStype(uf->stream) != IST_ENCODED) {\n\tuf->stream = newEncodedStream(uf->stream, uf->encoding);\n\tuf->encoding = ENC_7BIT;\n    }\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tif (uf->compression == d->type) {\n\t    if (d->auxbin_p)\n\t\texpand_cmd = auxbinFile(d->cmd);\n\t    else\n\t\texpand_cmd = d->cmd;\n\t    expand_name = d->name;\n\t    ext = d->ext;\n\t    break;\n\t}\n    }\n    uf->compression = CMP_NOCOMPRESS;\n\n    if (uf->scheme != SCM_LOCAL\n#ifdef USE_IMAGE\n\t&& !image_source\n#endif\n\t) {\n\ttmpf = tmpfname(TMPF_DFL, ext)->ptr;\n    }\n\n    /* child1 -- stdout|f1=uf -> parent */\n    pid1 = open_pipe_rw(&f1, NULL);\n    if (pid1 < 0) {\n\tUFclose(uf);\n\treturn;\n    }\n    if (pid1 == 0) {\n\t/* child */\n\tpid_t pid2;\n\tFILE *f2 = stdin;\n\n\t/* uf -> child2 -- stdout|stdin -> child1 */\n\tpid2 = open_pipe_rw(&f2, NULL);\n\tif (pid2 < 0) {\n\t    UFclose(uf);\n\t    exit(1);\n\t}\n\tif (pid2 == 0) {\n\t    /* child2 */\n\t    char *buf = NewWithoutGC_N(char, SAVE_BUF_SIZE);\n\t    int count;\n\t    FILE *f = NULL;\n\n\t    setup_child(TRUE, 2, UFfileno(uf));\n\t    if (tmpf)\n\t\tf = fopen(tmpf, \"wb\");\n\t    while ((count = ISread_n(uf->stream, buf, SAVE_BUF_SIZE)) > 0) {\n\t\tif (fwrite(buf, 1, count, stdout) != count)\n\t\t    break;\n\t\tif (f && fwrite(buf, 1, count, f) != count)\n\t\t    break;\n\t    }\n\t    UFclose(uf);\n\t    if (f)\n\t\tfclose(f);\n\t    xfree(buf);\n\t    exit(0);\n\t}\n\t/* child1 */\n\tdup2(1, 2);\t\t/* stderr>&stdout */\n\tsetup_child(TRUE, -1, -1);\n\texeclp(expand_cmd, expand_name, NULL);\n\texit(1);\n    }\n    if (tmpf) {\n\tif (src)\n\t    *src = tmpf;\n\telse\n\t    uf->scheme = SCM_LOCAL;\n    }\n    UFhalfclose(uf);\n    uf->stream = newFileStream(f1, (void (*)())fclose);\n#endif /* __MINGW32_VERSION */\n}\n\nstatic FILE *\nlessopen_stream(char *path)\n{\n    char *lessopen;\n    FILE *fp;\n\n    lessopen = getenv(\"LESSOPEN\");\n    if (lessopen == NULL) {\n\treturn NULL;\n    }\n    if (lessopen[0] == '\\0') {\n\treturn NULL;\n    }\n\n    if (lessopen[0] == '|') {\n\t/* pipe mode */\n\tStr tmpf;\n\tint c;\n\n\t++lessopen;\n\ttmpf = Sprintf(lessopen, shell_quote(path));\n\tfp = popen(tmpf->ptr, \"r\");\n\tif (fp == NULL) {\n\t    return NULL;\n\t}\n\tc = getc(fp);\n\tif (c == EOF) {\n\t    pclose(fp);\n\t    return NULL;\n\t}\n\tungetc(c, fp);\n    }\n    else {\n\t/* filename mode */\n\t/* not supported m(__)m */\n\tfp = NULL;\n    }\n    return fp;\n}\n\n#if 0\nvoid\nreloadBuffer(Buffer *buf)\n{\n    URLFile uf;\n\n    if (buf->sourcefile == NULL || buf->pagerSource != NULL)\n\treturn;\n    init_stream(&uf, SCM_UNKNOWN, NULL);\n    examineFile(buf->mailcap_source ? buf->mailcap_source : buf->sourcefile,\n\t\t&uf);\n    if (uf.stream == NULL)\n\treturn;\n    is_redisplay = TRUE;\n    buf->allLine = 0;\n    buf->href = NULL;\n    buf->name = NULL;\n    buf->img = NULL;\n    buf->formitem = NULL;\n    buf->linklist = NULL;\n    buf->maplist = NULL;\n    if (buf->hmarklist)\n\tbuf->hmarklist->nmark = 0;\n    if (buf->imarklist)\n\tbuf->imarklist->nmark = 0;\n    if (is_html_type(buf->type))\n\tloadHTMLBuffer(&uf, buf);\n    else\n\tloadBuffer(&uf, buf);\n    UFclose(&uf);\n    is_redisplay = FALSE;\n}\n#endif\n\nstatic char *\nguess_filename(char *file)\n{\n    char *p = NULL, *s;\n\n    if (file != NULL)\n\tp = mybasename(file);\n    if (p == NULL || *p == '\\0')\n\treturn DEF_SAVE_FILE;\n    s = p;\n    if (*p == '#')\n\tp++;\n    while (*p != '\\0') {\n\tif ((*p == '#' && *(p + 1) != '\\0') || *p == '?') {\n\t    *p = '\\0';\n\t    break;\n\t}\n\tp++;\n    }\n    return s;\n}\n\nchar *\nguess_save_name(Buffer *buf, char *path)\n{\n    if (buf && buf->document_header) {\n\tStr name = NULL;\n\tchar *p, *q;\n\tif ((p = checkHeader(buf, \"Content-Disposition:\")) != NULL &&\n\t    (q = strcasestr(p, \"filename\")) != NULL &&\n\t    (q == p || IS_SPACE(*(q - 1)) || *(q - 1) == ';') &&\n\t    matchattr(q, \"filename\", 8, &name))\n\t    path = name->ptr;\n\telse if ((p = checkHeader(buf, \"Content-Type:\")) != NULL &&\n\t\t (q = strcasestr(p, \"name\")) != NULL &&\n\t\t (q == p || IS_SPACE(*(q - 1)) || *(q - 1) == ';') &&\n\t\t matchattr(q, \"name\", 4, &name))\n\t    path = name->ptr;\n    }\n    return guess_filename(path);\n}\n\n/* Local Variables:    */\n/* c-basic-offset: 4   */\n/* tab-width: 8        */\n/* End:                */\n", "/* $Id: parsetagx.c,v 1.18 2006/06/07 03:52:03 inu Exp $ */\n#include \"fm.h\"\n#include \"myctype.h\"\n#include \"indep.h\"\n#include \"Str.h\"\n#include \"parsetagx.h\"\n#include \"hash.h\"\n\n#include \"html.c\"\n\n/* parse HTML tag */\n\nstatic int noConv(char *, char **);\nstatic int toNumber(char *, int *);\nstatic int toLength(char *, int *);\nstatic int toAlign(char *, int *);\nstatic int toVAlign(char *, int *);\n\n/* *INDENT-OFF* */\nstatic int (*toValFunc[]) () = {\n    noConv,\t\t/* VTYPE_NONE    */\n    noConv,\t\t/* VTYPE_STR     */\n    toNumber,\t\t/* VTYPE_NUMBER  */\n    toLength,\t\t/* VTYPE_LENGTH  */\n    toAlign,\t\t/* VTYPE_ALIGN   */\n    toVAlign,\t\t/* VTYPE_VALIGN  */\n    noConv,\t\t/* VTYPE_ACTION  */\n    noConv,\t\t/* VTYPE_ENCTYPE */\n    noConv,\t\t/* VTYPE_METHOD  */\n    noConv,\t\t/* VTYPE_MLENGTH */\n    noConv,\t\t/* VTYPE_TYPE    */\n};\n/* *INDENT-ON* */\n\nstatic int\nnoConv(char *oval, char **str)\n{\n    *str = oval;\n    return 1;\n}\n\nstatic int\ntoNumber(char *oval, int *num)\n{\n    char *ep;\n    int x;\n\n    x = strtol(oval, &ep, 10);\n\n    if (ep > oval) {\n\t*num = x;\n\treturn 1;\n    }\n    else\n\treturn 0;\n}\n\nstatic int\ntoLength(char *oval, int *len)\n{\n    int w;\n    if (!IS_DIGIT(oval[0]))\n\treturn 0;\n    w = atoi(oval);\n    if (w < 0)\n\treturn 0;\n    if (w == 0)\n\tw = 1;\n    if (oval[strlen(oval) - 1] == '%')\n\t*len = -w;\n    else\n\t*len = w;\n    return 1;\n}\n\nstatic int\ntoAlign(char *oval, int *align)\n{\n    if (strcasecmp(oval, \"left\") == 0)\n\t*align = ALIGN_LEFT;\n    else if (strcasecmp(oval, \"right\") == 0)\n\t*align = ALIGN_RIGHT;\n    else if (strcasecmp(oval, \"center\") == 0)\n\t*align = ALIGN_CENTER;\n    else if (strcasecmp(oval, \"top\") == 0)\n\t*align = ALIGN_TOP;\n    else if (strcasecmp(oval, \"bottom\") == 0)\n\t*align = ALIGN_BOTTOM;\n    else if (strcasecmp(oval, \"middle\") == 0)\n\t*align = ALIGN_MIDDLE;\n    else\n\treturn 0;\n    return 1;\n}\n\nstatic int\ntoVAlign(char *oval, int *valign)\n{\n    if (strcasecmp(oval, \"top\") == 0 || strcasecmp(oval, \"baseline\") == 0)\n\t*valign = VALIGN_TOP;\n    else if (strcasecmp(oval, \"bottom\") == 0)\n\t*valign = VALIGN_BOTTOM;\n    else if (strcasecmp(oval, \"middle\") == 0)\n\t*valign = VALIGN_MIDDLE;\n    else\n\treturn 0;\n    return 1;\n}\n\nextern Hash_si tagtable;\n#define MAX_TAG_LEN 64\n\nstruct parsed_tag *\nparse_tag(char **s, int internal)\n{\n    struct parsed_tag *tag = NULL;\n    int tag_id;\n    char tagname[MAX_TAG_LEN], attrname[MAX_TAG_LEN];\n    char *p, *q;\n    int i, attr_id = 0, nattr;\n\n    /* Parse tag name */\n    q = (*s) + 1;\n    p = tagname;\n    if (*q == '/') {\n\t*(p++) = *(q++);\n\tSKIP_BLANKS(q);\n    }\n    while (*q && !IS_SPACE(*q) && !(tagname[0] != '/' && *q == '/') &&\n\t   *q != '>' && p - tagname < MAX_TAG_LEN - 1) {\n\t*(p++) = TOLOWER(*q);\n\tq++;\n    }\n    *p = '\\0';\n    while (*q && !IS_SPACE(*q) && !(tagname[0] != '/' && *q == '/') &&\n\t   *q != '>')\n\tq++;\n\n    tag_id = getHash_si(&tagtable, tagname, HTML_UNKNOWN);\n\n    if (tag_id == HTML_UNKNOWN ||\n\t(!internal && TagMAP[tag_id].flag & TFLG_INT))\n\tgoto skip_parse_tagarg;\n\n    tag = New(struct parsed_tag);\n    bzero(tag, sizeof(struct parsed_tag));\n    tag->tagid = tag_id;\n\n    if ((nattr = TagMAP[tag_id].max_attribute) > 0) {\n\ttag->attrid = NewAtom_N(unsigned char, nattr);\n\ttag->value = New_N(char *, nattr);\n\ttag->map = NewAtom_N(unsigned char, MAX_TAGATTR);\n\tmemset(tag->map, MAX_TAGATTR, MAX_TAGATTR);\n\tmemset(tag->attrid, ATTR_UNKNOWN, nattr);\n\tfor (i = 0; i < nattr; i++)\n\t    tag->map[TagMAP[tag_id].accept_attribute[i]] = i;\n    }\n\n    /* Parse tag arguments */\n    SKIP_BLANKS(q);\n    while (1) {\n       Str value = NULL, value_tmp = NULL;\n\tif (*q == '>' || *q == '\\0')\n\t    goto done_parse_tag;\n\tp = attrname;\n\twhile (*q && *q != '=' && !IS_SPACE(*q) &&\n\t       *q != '>' && p - attrname < MAX_TAG_LEN - 1) {\n\t    *(p++) = TOLOWER(*q);\n\t    q++;\n\t}\n\t*p = '\\0';\n\twhile (*q && *q != '=' && !IS_SPACE(*q) && *q != '>')\n\t    q++;\n\tSKIP_BLANKS(q);\n\tif (*q == '=') {\n\t    /* get value */\n\t    value_tmp = Strnew();\n\t    q++;\n\t    SKIP_BLANKS(q);\n\t    if (*q == '\"') {\n\t\tq++;\n\t\twhile (*q && *q != '\"') {\n\t\t    Strcat_char(value_tmp, *q);\n\t\t    if (!tag->need_reconstruct && is_html_quote(*q))\n\t\t\ttag->need_reconstruct = TRUE;\n\t\t    q++;\n\t\t}\n\t\tif (*q == '\"')\n\t\t    q++;\n\t    }\n\t    else if (*q == '\\'') {\n\t\tq++;\n\t\twhile (*q && *q != '\\'') {\n\t\t    Strcat_char(value_tmp, *q);\n\t\t    if (!tag->need_reconstruct && is_html_quote(*q))\n\t\t\ttag->need_reconstruct = TRUE;\n\t\t    q++;\n\t\t}\n\t\tif (*q == '\\'')\n\t\t    q++;\n\t    }\n\t    else if (*q) {\n\t\twhile (*q && !IS_SPACE(*q) && *q != '>') {\n                   Strcat_char(value_tmp, *q);\n\t\t    if (!tag->need_reconstruct && is_html_quote(*q))\n\t\t\ttag->need_reconstruct = TRUE;\n\t\t    q++;\n\t\t}\n\t    }\n\t}\n\tfor (i = 0; i < nattr; i++) {\n\t    if ((tag)->attrid[i] == ATTR_UNKNOWN &&\n\t\tstrcmp(AttrMAP[TagMAP[tag_id].accept_attribute[i]].name,\n\t\t       attrname) == 0) {\n\t\tattr_id = TagMAP[tag_id].accept_attribute[i];\n\t\tbreak;\n\t    }\n\t}\n\n       if (value_tmp) {\n         int j, hidden=FALSE;\n         for (j=0; j<i; j++) {\n           if (tag->attrid[j] == ATTR_TYPE &&\n               tag->value[j] &&\n               strcmp(\"hidden\",tag->value[j]) == 0) {\n             hidden=TRUE;\n             break;\n           }\n         }\n         if ((tag_id == HTML_INPUT || tag_id == HTML_INPUT_ALT) &&\n             attr_id == ATTR_VALUE && hidden) {\n           value = value_tmp;\n         } else {\n           char *x;\n           value = Strnew();\n           for (x = value_tmp->ptr; *x; x++) {\n             if (*x != '\\n')\n               Strcat_char(value, *x);\n           }\n         }\n       }\n\n\tif (i != nattr) {\n\t    if (!internal &&\n\t\t((AttrMAP[attr_id].flag & AFLG_INT) ||\n\t\t (value && AttrMAP[attr_id].vtype == VTYPE_METHOD &&\n\t\t  !strcasecmp(value->ptr, \"internal\")))) {\n\t\ttag->need_reconstruct = TRUE;\n\t\tcontinue;\n\t    }\n\t    tag->attrid[i] = attr_id;\n\t    if (value)\n\t\ttag->value[i] = html_unquote(value->ptr);\n\t    else\n\t\ttag->value[i] = NULL;\n\t}\n\telse {\n\t    tag->need_reconstruct = TRUE;\n\t}\n    }\n\n  skip_parse_tagarg:\n    while (*q != '>' && *q)\n\tq++;\n  done_parse_tag:\n    if (*q == '>')\n\tq++;\n    *s = q;\n    return tag;\n}\n\nint\nparsedtag_set_value(struct parsed_tag *tag, int id, char *value)\n{\n    int i;\n\n    if (!parsedtag_accepts(tag, id))\n\treturn 0;\n\n    i = tag->map[id];\n    tag->attrid[i] = id;\n    if (value)\n\ttag->value[i] = allocStr(value, -1);\n    else\n\ttag->value[i] = NULL;\n    tag->need_reconstruct = TRUE;\n    return 1;\n}\n\nint\nparsedtag_get_value(struct parsed_tag *tag, int id, void *value)\n{\n    int i;\n    if (!parsedtag_exists(tag, id) || !tag->value[i = tag->map[id]])\n\treturn 0;\n    return toValFunc[AttrMAP[id].vtype] (tag->value[i], value);\n}\n\nStr\nparsedtag2str(struct parsed_tag *tag)\n{\n    int i;\n    int tag_id = tag->tagid;\n    int nattr = TagMAP[tag_id].max_attribute;\n    Str tagstr = Strnew();\n    Strcat_char(tagstr, '<');\n    Strcat_charp(tagstr, TagMAP[tag_id].name);\n    for (i = 0; i < nattr; i++) {\n\tif (tag->attrid[i] != ATTR_UNKNOWN) {\n\t    Strcat_char(tagstr, ' ');\n\t    Strcat_charp(tagstr, AttrMAP[tag->attrid[i]].name);\n\t    if (tag->value[i])\n\t\tStrcat(tagstr, Sprintf(\"=\\\"%s\\\"\", html_quote(tag->value[i])));\n\t}\n    }\n    Strcat_char(tagstr, '>');\n    return tagstr;\n}\n"], "fixing_code": ["/* $Id: file.c,v 1.266 2012/05/22 09:45:56 inu Exp $ */\n#include \"fm.h\"\n#include <sys/types.h>\n#include \"myctype.h\"\n#include <signal.h>\n#include <setjmp.h>\n#if defined(HAVE_WAITPID) || defined(HAVE_WAIT3)\n#include <sys/wait.h>\n#endif\n#include <stdio.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <utime.h>\n/* foo */\n\n#include \"html.h\"\n#include \"parsetagx.h\"\n#include \"local.h\"\n#include \"regex.h\"\n\n#ifndef max\n#define max(a,b)        ((a) > (b) ? (a) : (b))\n#endif\t\t\t\t/* not max */\n#ifndef min\n#define min(a,b)        ((a) > (b) ? (b) : (a))\n#endif\t\t\t\t/* not min */\n\n#define MAX_INPUT_SIZE 80 /* TODO - max should be screen line length */\n\nstatic int frame_source = 0;\n\nstatic char *guess_filename(char *file);\nstatic int _MoveFile(char *path1, char *path2);\nstatic void uncompress_stream(URLFile *uf, char **src);\nstatic FILE *lessopen_stream(char *path);\nstatic Buffer *loadcmdout(char *cmd,\n\t\t\t  Buffer *(*loadproc) (URLFile *, Buffer *),\n\t\t\t  Buffer *defaultbuf);\n#ifndef USE_ANSI_COLOR\n#define addnewline(a,b,c,d,e,f,g) _addnewline(a,b,c,e,f,g)\n#endif\nstatic void addnewline(Buffer *buf, char *line, Lineprop *prop,\n\t\t       Linecolor *color, int pos, int width, int nlines);\nstatic void addLink(Buffer *buf, struct parsed_tag *tag);\n\nstatic JMP_BUF AbortLoading;\n\nstatic struct table *tables[MAX_TABLE];\nstatic struct table_mode table_mode[MAX_TABLE];\n\n#if defined(USE_M17N) || defined(USE_IMAGE)\nstatic ParsedURL *cur_baseURL = NULL;\n#endif\n#ifdef USE_M17N\nstatic wc_ces cur_document_charset = 0;\n#endif\n\nstatic Str cur_title;\nstatic Str cur_select;\nstatic Str select_str;\nstatic int select_is_multiple;\nstatic int n_selectitem;\nstatic Str cur_option;\nstatic Str cur_option_value;\nstatic Str cur_option_label;\nstatic int cur_option_selected;\nstatic int cur_status;\n#ifdef MENU_SELECT\n/* menu based <select>  */\nFormSelectOption *select_option;\nint max_select = MAX_SELECT;\nstatic int n_select;\nstatic int cur_option_maxwidth;\n#endif\t\t\t\t/* MENU_SELECT */\n\nstatic Str cur_textarea;\nStr *textarea_str;\nstatic int cur_textarea_size;\nstatic int cur_textarea_rows;\nstatic int cur_textarea_readonly;\nstatic int n_textarea;\nstatic int ignore_nl_textarea;\nint max_textarea = MAX_TEXTAREA;\n\nstatic int http_response_code;\n\n#ifdef USE_M17N\nstatic wc_ces content_charset = 0;\nstatic wc_ces meta_charset = 0;\nstatic char *check_charset(char *p);\nstatic char *check_accept_charset(char *p);\n#endif\n\n#define set_prevchar(x,y,n) Strcopy_charp_n((x),(y),(n))\n#define set_space_to_prevchar(x) Strcopy_charp_n((x),\" \",1)\n\nstruct link_stack {\n    int cmd;\n    short offset;\n    short pos;\n    struct link_stack *next;\n};\n\nstatic struct link_stack *link_stack = NULL;\n\n#define FORMSTACK_SIZE 10\n#define FRAMESTACK_SIZE 10\n\n#ifdef USE_NNTP\n#define Str_news_endline(s) ((s)->ptr[0]=='.'&&((s)->ptr[1]=='\\n'||(s)->ptr[1]=='\\r'||(s)->ptr[1]=='\\0'))\n#endif\t\t\t\t/* USE_NNTP */\n\n#define INITIAL_FORM_SIZE 10\nstatic FormList **forms;\nstatic int *form_stack;\nstatic int form_max = -1;\nstatic int forms_size = 0;\n#define cur_form_id ((form_sp >= 0)? form_stack[form_sp] : -1)\nstatic int form_sp = 0;\n\nstatic clen_t current_content_length;\n\nstatic int cur_hseq;\n#ifdef USE_IMAGE\nstatic int cur_iseq;\n#endif\n\n#define MAX_UL_LEVEL\t9\n#define UL_SYMBOL(x)\t(N_GRAPH_SYMBOL + (x))\n#define UL_SYMBOL_DISC\t\tUL_SYMBOL(9)\n#define UL_SYMBOL_CIRCLE\tUL_SYMBOL(10)\n#define UL_SYMBOL_SQUARE\tUL_SYMBOL(11)\n#define IMG_SYMBOL\t\tUL_SYMBOL(12)\n#define HR_SYMBOL\t26\n\n#ifdef USE_COOKIE\n/* This array should be somewhere else */\n/* FIXME: gettextize? */\nchar *violations[COO_EMAX] = {\n    \"internal error\",\n    \"tail match failed\",\n    \"wrong number of dots\",\n    \"RFC 2109 4.3.2 rule 1\",\n    \"RFC 2109 4.3.2 rule 2.1\",\n    \"RFC 2109 4.3.2 rule 2.2\",\n    \"RFC 2109 4.3.2 rule 3\",\n    \"RFC 2109 4.3.2 rule 4\",\n    \"RFC XXXX 4.3.2 rule 5\"\n};\n#endif\n\n/* *INDENT-OFF* */\nstatic struct compression_decoder {\n    int type;\n    char *ext;\n    char *mime_type;\n    int auxbin_p;\n    char *cmd;\n    char *name;\n    char *encoding;\n    char *encodings[4];\n} compression_decoders[] = {\n    { CMP_COMPRESS, \".gz\", \"application/x-gzip\",\n      0, GUNZIP_CMDNAME, GUNZIP_NAME, \"gzip\", \n      {\"gzip\", \"x-gzip\", NULL} }, \n    { CMP_COMPRESS, \".Z\", \"application/x-compress\",\n      0, GUNZIP_CMDNAME, GUNZIP_NAME, \"compress\",\n      {\"compress\", \"x-compress\", NULL} }, \n    { CMP_BZIP2, \".bz2\", \"application/x-bzip\",\n      0, BUNZIP2_CMDNAME, BUNZIP2_NAME, \"bzip, bzip2\",\n      {\"x-bzip\", \"bzip\", \"bzip2\", NULL} }, \n    { CMP_DEFLATE, \".deflate\", \"application/x-deflate\",\n      1, INFLATE_CMDNAME, INFLATE_NAME, \"deflate\",\n      {\"deflate\", \"x-deflate\", NULL} }, \n    { CMP_NOCOMPRESS, NULL, NULL, 0, NULL, NULL, NULL, {NULL}},\n};\n/* *INDENT-ON* */\n\n#define SAVE_BUF_SIZE 1536\n\nstatic MySignalHandler\nKeyAbort(SIGNAL_ARG)\n{\n    LONGJMP(AbortLoading, 1);\n    SIGNAL_RETURN;\n}\n\nstatic void\nUFhalfclose(URLFile *f)\n{\n    switch (f->scheme) {\n    case SCM_FTP:\n\tcloseFTP();\n\tbreak;\n#ifdef USE_NNTP\n    case SCM_NEWS:\n    case SCM_NNTP:\n\tcloseNews();\n\tbreak;\n#endif\n    default:\n\tUFclose(f);\n\tbreak;\n    }\n}\n\nint\ncurrentLn(Buffer *buf)\n{\n    if (buf->currentLine)\n\t/*     return buf->currentLine->real_linenumber + 1;      */\n\treturn buf->currentLine->linenumber + 1;\n    else\n\treturn 1;\n}\n\nstatic Buffer *\nloadSomething(URLFile *f,\n\t      Buffer *(*loadproc) (URLFile *, Buffer *), Buffer *defaultbuf)\n{\n    Buffer *buf;\n\n    if ((buf = loadproc(f, defaultbuf)) == NULL)\n\treturn NULL;\n\n    if (buf->buffername == NULL || buf->buffername[0] == '\\0') {\n\tbuf->buffername = checkHeader(buf, \"Subject:\");\n\tif (buf->buffername == NULL && buf->filename != NULL)\n\t    buf->buffername = conv_from_system(lastFileName(buf->filename));\n    }\n    if (buf->currentURL.scheme == SCM_UNKNOWN)\n\tbuf->currentURL.scheme = f->scheme;\n    if (f->scheme == SCM_LOCAL && buf->sourcefile == NULL)\n\tbuf->sourcefile = buf->filename;\n    if (loadproc == loadHTMLBuffer\n#ifdef USE_IMAGE\n\t|| loadproc == loadImageBuffer\n#endif\n       )\n\tbuf->type = \"text/html\";\n    else\n\tbuf->type = \"text/plain\";\n    return buf;\n}\n\nint\ndir_exist(char *path)\n{\n    struct stat stbuf;\n\n    if (path == NULL || *path == '\\0')\n\treturn 0;\n    if (stat(path, &stbuf) == -1)\n\treturn 0;\n    return IS_DIRECTORY(stbuf.st_mode);\n}\n\nstatic int\nis_dump_text_type(char *type)\n{\n    struct mailcap *mcap;\n    return (type && (mcap = searchExtViewer(type)) &&\n\t    (mcap->flags & (MAILCAP_HTMLOUTPUT | MAILCAP_COPIOUSOUTPUT)));\n}\n\nstatic int\nis_text_type(char *type)\n{\n    return (type == NULL || type[0] == '\\0' ||\n\t    strncasecmp(type, \"text/\", 5) == 0 ||\n\t    (strncasecmp(type, \"application/\", 12) == 0 &&\n\t\tstrstr(type, \"xhtml\") != NULL) ||\n\t    strncasecmp(type, \"message/\", sizeof(\"message/\") - 1) == 0);\n}\n\nstatic int\nis_plain_text_type(char *type)\n{\n    return ((type && strcasecmp(type, \"text/plain\") == 0) ||\n\t    (is_text_type(type) && !is_dump_text_type(type)));\n}\n\nint\nis_html_type(char *type)\n{\n    return (type && (strcasecmp(type, \"text/html\") == 0 ||\n\t\t     strcasecmp(type, \"application/xhtml+xml\") == 0));\n}\n\nstatic void\ncheck_compression(char *path, URLFile *uf)\n{\n    int len;\n    struct compression_decoder *d;\n\n    if (path == NULL)\n\treturn;\n\n    len = strlen(path);\n    uf->compression = CMP_NOCOMPRESS;\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tint elen;\n\tif (d->ext == NULL)\n\t    continue;\n\telen = strlen(d->ext);\n\tif (len > elen && strcasecmp(&path[len - elen], d->ext) == 0) {\n\t    uf->compression = d->type;\n\t    uf->guess_type = d->mime_type;\n\t    break;\n\t}\n    }\n}\n\nstatic char *\ncompress_application_type(int compression)\n{\n    struct compression_decoder *d;\n\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tif (d->type == compression)\n\t    return d->mime_type;\n    }\n    return NULL;\n}\n\nstatic char *\nuncompressed_file_type(char *path, char **ext)\n{\n    int len, slen;\n    Str fn;\n    char *t0;\n    struct compression_decoder *d;\n\n    if (path == NULL)\n\treturn NULL;\n\n    slen = 0;\n    len = strlen(path);\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tif (d->ext == NULL)\n\t    continue;\n\tslen = strlen(d->ext);\n\tif (len > slen && strcasecmp(&path[len - slen], d->ext) == 0)\n\t    break;\n    }\n    if (d->type == CMP_NOCOMPRESS)\n\treturn NULL;\n\n    fn = Strnew_charp(path);\n    Strshrink(fn, slen);\n    if (ext)\n\t*ext = filename_extension(fn->ptr, 0);\n    t0 = guessContentType(fn->ptr);\n    if (t0 == NULL)\n\tt0 = \"text/plain\";\n    return t0;\n}\n\nstatic int\nsetModtime(char *path, time_t modtime)\n{\n    struct utimbuf t;\n    struct stat st;\n\n    if (stat(path, &st) == 0)\n\tt.actime = st.st_atime;\n    else\n\tt.actime = time(NULL);\n    t.modtime = modtime;\n    return utime(path, &t);\n}\n\nvoid\nexamineFile(char *path, URLFile *uf)\n{\n    struct stat stbuf;\n\n    uf->guess_type = NULL;\n    if (path == NULL || *path == '\\0' ||\n\tstat(path, &stbuf) == -1 || NOT_REGULAR(stbuf.st_mode)) {\n\tuf->stream = NULL;\n\treturn;\n    }\n    uf->stream = openIS(path);\n    if (!do_download) {\n\tif (use_lessopen && getenv(\"LESSOPEN\") != NULL) {\n\t    FILE *fp;\n\t    uf->guess_type = guessContentType(path);\n\t    if (uf->guess_type == NULL)\n\t\tuf->guess_type = \"text/plain\";\n\t    if (is_html_type(uf->guess_type))\n\t\treturn;\n\t    if ((fp = lessopen_stream(path))) {\n\t\tUFclose(uf);\n\t\tuf->stream = newFileStream(fp, (void (*)())pclose);\n\t\tuf->guess_type = \"text/plain\";\n\t\treturn;\n\t    }\n\t}\n\tcheck_compression(path, uf);\n\tif (uf->compression != CMP_NOCOMPRESS) {\n\t    char *ext = uf->ext;\n\t    char *t0 = uncompressed_file_type(path, &ext);\n\t    uf->guess_type = t0;\n\t    uf->ext = ext;\n\t    uncompress_stream(uf, NULL);\n\t    return;\n\t}\n    }\n}\n\n#define S_IXANY\t(S_IXUSR|S_IXGRP|S_IXOTH)\n\nint\ncheck_command(char *cmd, int auxbin_p)\n{\n    static char *path = NULL;\n    Str dirs;\n    char *p, *np;\n    Str pathname;\n    struct stat st;\n\n    if (path == NULL)\n\tpath = getenv(\"PATH\");\n    if (auxbin_p)\n\tdirs = Strnew_charp(w3m_auxbin_dir());\n    else\n\tdirs = Strnew_charp(path);\n    for (p = dirs->ptr; p != NULL; p = np) {\n\tnp = strchr(p, PATH_SEPARATOR);\n\tif (np)\n\t    *np++ = '\\0';\n\tpathname = Strnew();\n\tStrcat_charp(pathname, p);\n\tStrcat_char(pathname, '/');\n\tStrcat_charp(pathname, cmd);\n\tif (stat(pathname->ptr, &st) == 0 && S_ISREG(st.st_mode)\n\t    && (st.st_mode & S_IXANY) != 0)\n\t    return 1;\n    }\n    return 0;\n}\n\nchar *\nacceptableEncoding()\n{\n    static Str encodings = NULL;\n    struct compression_decoder *d;\n    TextList *l;\n    char *p;\n\n    if (encodings != NULL)\n\treturn encodings->ptr;\n    l = newTextList();\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tif (check_command(d->cmd, d->auxbin_p)) {\n\t    pushText(l, d->encoding);\n\t}\n    }\n    encodings = Strnew();\n    while ((p = popText(l)) != NULL) {\n\tif (encodings->length)\n\t    Strcat_charp(encodings, \", \");\n\tStrcat_charp(encodings, p);\n    }\n    return encodings->ptr;\n}\n\n/* \n * convert line\n */\n#ifdef USE_M17N\nStr\nconvertLine(URLFile *uf, Str line, int mode, wc_ces * charset,\n\t    wc_ces doc_charset)\n#else\nStr\nconvertLine0(URLFile *uf, Str line, int mode)\n#endif\n{\n#ifdef USE_M17N\n    line = wc_Str_conv_with_detect(line, charset, doc_charset, InnerCharset);\n#endif\n    if (mode != RAW_MODE)\n\tcleanup_line(line, mode);\n#ifdef USE_NNTP\n    if (uf && uf->scheme == SCM_NEWS)\n\tStrchop(line);\n#endif\t\t\t\t/* USE_NNTP */\n    return line;\n}\n\nint\nmatchattr(char *p, char *attr, int len, Str *value)\n{\n    int quoted;\n    char *q = NULL;\n\n    if (strncasecmp(p, attr, len) == 0) {\n\tp += len;\n\tSKIP_BLANKS(p);\n\tif (value) {\n\t    *value = Strnew();\n\t    if (*p == '=') {\n\t\tp++;\n\t\tSKIP_BLANKS(p);\n\t\tquoted = 0;\n\t\twhile (!IS_ENDL(*p) && (quoted || *p != ';')) {\n\t\t    if (!IS_SPACE(*p))\n\t\t\tq = p;\n\t\t    if (*p == '\"')\n\t\t\tquoted = (quoted) ? 0 : 1;\n\t\t    else\n\t\t\tStrcat_char(*value, *p);\n\t\t    p++;\n\t\t}\n\t\tif (q)\n\t\t    Strshrink(*value, p - q - 1);\n\t    }\n\t    return 1;\n\t}\n\telse {\n\t    if (IS_ENDT(*p)) {\n\t\treturn 1;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n#ifdef USE_IMAGE\n#ifdef USE_XFACE\nstatic char *\nxface2xpm(char *xface)\n{\n    Image image;\n    ImageCache *cache;\n    FILE *f;\n    struct stat st;\n\n    SKIP_BLANKS(xface);\n    image.url = xface;\n    image.ext = \".xpm\";\n    image.width = 48;\n    image.height = 48;\n    image.cache = NULL;\n    cache = getImage(&image, NULL, IMG_FLAG_AUTO);\n    if (cache->loaded & IMG_FLAG_LOADED && !stat(cache->file, &st))\n\treturn cache->file;\n    cache->loaded = IMG_FLAG_ERROR;\n\n    f = popen(Sprintf(\"%s > %s\", shell_quote(auxbinFile(XFACE2XPM)),\n\t\t      shell_quote(cache->file))->ptr, \"w\");\n    if (!f)\n\treturn NULL;\n    fputs(xface, f);\n    pclose(f);\n    if (stat(cache->file, &st) || !st.st_size)\n\treturn NULL;\n    cache->loaded = IMG_FLAG_LOADED | IMG_FLAG_DONT_REMOVE;\n    cache->index = 0;\n    return cache->file;\n}\n#endif\n#endif\n\nvoid\nreadHeader(URLFile *uf, Buffer *newBuf, int thru, ParsedURL *pu)\n{\n    char *p, *q;\n#ifdef USE_COOKIE\n    char *emsg;\n#endif\n    char c;\n    Str lineBuf2 = NULL;\n    Str tmp;\n    TextList *headerlist;\n#ifdef USE_M17N\n    wc_ces charset = WC_CES_US_ASCII, mime_charset;\n#endif\n    char *tmpf;\n    FILE *src = NULL;\n    Lineprop *propBuffer;\n\n    headerlist = newBuf->document_header = newTextList();\n    if (uf->scheme == SCM_HTTP\n#ifdef USE_SSL\n\t|| uf->scheme == SCM_HTTPS\n#endif\t\t\t\t/* USE_SSL */\n\t)\n\thttp_response_code = -1;\n    else\n\thttp_response_code = 0;\n\n    if (thru && !newBuf->header_source\n#ifdef USE_IMAGE\n\t&& !image_source\n#endif\n\t) {\n\ttmpf = tmpfname(TMPF_DFL, NULL)->ptr;\n\tsrc = fopen(tmpf, \"w\");\n\tif (src)\n\t    newBuf->header_source = tmpf;\n    }\n    while ((tmp = StrmyUFgets(uf))->length) {\n#ifdef USE_NNTP\n\tif (uf->scheme == SCM_NEWS && tmp->ptr[0] == '.')\n\t    Strshrinkfirst(tmp, 1);\n#endif\n\tif(w3m_reqlog){\n\t    FILE *ff;\n\t    ff = fopen(w3m_reqlog, \"a\");\n\t    Strfputs(tmp, ff);\n\t    fclose(ff);\n\t}\n\tif (src)\n\t    Strfputs(tmp, src);\n\tcleanup_line(tmp, HEADER_MODE);\n\tif (tmp->ptr[0] == '\\n' || tmp->ptr[0] == '\\r' || tmp->ptr[0] == '\\0') {\n\t    if (!lineBuf2)\n\t\t/* there is no header */\n\t\tbreak;\n\t    /* last header */\n\t}\n\telse if (!(w3m_dump & DUMP_HEAD)) {\n\t    if (lineBuf2) {\n\t\tStrcat(lineBuf2, tmp);\n\t    }\n\t    else {\n\t\tlineBuf2 = tmp;\n\t    }\n\t    c = UFgetc(uf);\n\t    UFundogetc(uf);\n\t    if (c == ' ' || c == '\\t')\n\t\t/* header line is continued */\n\t\tcontinue;\n\t    lineBuf2 = decodeMIME(lineBuf2, &mime_charset);\n\t    lineBuf2 = convertLine(NULL, lineBuf2, RAW_MODE,\n\t\t\t\t   mime_charset ? &mime_charset : &charset,\n\t\t\t\t   mime_charset ? mime_charset\n\t\t\t\t   : DocumentCharset);\n\t    /* separated with line and stored */\n\t    tmp = Strnew_size(lineBuf2->length);\n\t    for (p = lineBuf2->ptr; *p; p = q) {\n\t\tfor (q = p; *q && *q != '\\r' && *q != '\\n'; q++) ;\n\t\tlineBuf2 = checkType(Strnew_charp_n(p, q - p), &propBuffer,\n\t\t\t\t     NULL);\n\t\tStrcat(tmp, lineBuf2);\n\t\tif (thru)\n\t\t    addnewline(newBuf, lineBuf2->ptr, propBuffer, NULL,\n\t\t\t       lineBuf2->length, FOLD_BUFFER_WIDTH, -1);\n\t\tfor (; *q && (*q == '\\r' || *q == '\\n'); q++) ;\n\t    }\n#ifdef USE_IMAGE\n\t    if (thru && activeImage && displayImage) {\n\t\tStr src = NULL;\n\t\tif (!strncasecmp(tmp->ptr, \"X-Image-URL:\", 12)) {\n\t\t    tmpf = &tmp->ptr[12];\n\t\t    SKIP_BLANKS(tmpf);\n\t\t    src = Strnew_m_charp(\"<img src=\\\"\", html_quote(tmpf),\n\t\t\t\t\t \"\\\" alt=\\\"X-Image-URL\\\">\", NULL);\n\t\t}\n#ifdef USE_XFACE\n\t\telse if (!strncasecmp(tmp->ptr, \"X-Face:\", 7)) {\n\t\t    tmpf = xface2xpm(&tmp->ptr[7]);\n\t\t    if (tmpf)\n\t\t\tsrc = Strnew_m_charp(\"<img src=\\\"file:\",\n\t\t\t\t\t     html_quote(tmpf),\n\t\t\t\t\t     \"\\\" alt=\\\"X-Face\\\"\",\n\t\t\t\t\t     \" width=48 height=48>\", NULL);\n\t\t}\n#endif\n\t\tif (src) {\n\t\t    URLFile f;\n\t\t    Line *l;\n#ifdef USE_M17N\n\t\t    wc_ces old_charset = newBuf->document_charset;\n#endif\n\t\t    init_stream(&f, SCM_LOCAL, newStrStream(src));\n\t\t    loadHTMLstream(&f, newBuf, NULL, TRUE);\n\t\t    UFclose(&f);\n\t\t    for (l = newBuf->lastLine; l && l->real_linenumber;\n\t\t\t l = l->prev)\n\t\t\tl->real_linenumber = 0;\n#ifdef USE_M17N\n\t\t    newBuf->document_charset = old_charset;\n#endif\n\t\t}\n\t    }\n#endif\n\t    lineBuf2 = tmp;\n\t}\n\telse {\n\t    lineBuf2 = tmp;\n\t}\n\tif ((uf->scheme == SCM_HTTP\n#ifdef USE_SSL\n\t     || uf->scheme == SCM_HTTPS\n#endif\t\t\t\t/* USE_SSL */\n\t    ) && http_response_code == -1) {\n\t    p = lineBuf2->ptr;\n\t    while (*p && !IS_SPACE(*p))\n\t\tp++;\n\t    while (*p && IS_SPACE(*p))\n\t\tp++;\n\t    http_response_code = atoi(p);\n\t    if (fmInitialized) {\n\t\tmessage(lineBuf2->ptr, 0, 0);\n\t\trefresh();\n\t    }\n\t}\n\tif (!strncasecmp(lineBuf2->ptr, \"content-transfer-encoding:\", 26)) {\n\t    p = lineBuf2->ptr + 26;\n\t    while (IS_SPACE(*p))\n\t\tp++;\n\t    if (!strncasecmp(p, \"base64\", 6))\n\t\tuf->encoding = ENC_BASE64;\n\t    else if (!strncasecmp(p, \"quoted-printable\", 16))\n\t\tuf->encoding = ENC_QUOTE;\n\t    else if (!strncasecmp(p, \"uuencode\", 8) ||\n\t\t     !strncasecmp(p, \"x-uuencode\", 10))\n\t\tuf->encoding = ENC_UUENCODE;\n\t    else\n\t\tuf->encoding = ENC_7BIT;\n\t}\n\telse if (!strncasecmp(lineBuf2->ptr, \"content-encoding:\", 17)) {\n\t    struct compression_decoder *d;\n\t    p = lineBuf2->ptr + 17;\n\t    while (IS_SPACE(*p))\n\t\tp++;\n\t    uf->compression = CMP_NOCOMPRESS;\n\t    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\t\tchar **e;\n\t\tfor (e = d->encodings; *e != NULL; e++) {\n\t\t    if (strncasecmp(p, *e, strlen(*e)) == 0) {\n\t\t\tuf->compression = d->type;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (uf->compression != CMP_NOCOMPRESS)\n\t\t    break;\n\t    }\n\t    uf->content_encoding = uf->compression;\n\t}\n#ifdef USE_COOKIE\n\telse if (use_cookie && accept_cookie &&\n\t\t pu && check_cookie_accept_domain(pu->host) &&\n\t\t (!strncasecmp(lineBuf2->ptr, \"Set-Cookie:\", 11) ||\n\t\t  !strncasecmp(lineBuf2->ptr, \"Set-Cookie2:\", 12))) {\n\t    Str name = Strnew(), value = Strnew(), domain = NULL, path = NULL,\n\t\tcomment = NULL, commentURL = NULL, port = NULL, tmp2;\n\t    int version, quoted, flag = 0;\n\t    time_t expires = (time_t) - 1;\n\n\t    q = NULL;\n\t    if (lineBuf2->ptr[10] == '2') {\n\t\tp = lineBuf2->ptr + 12;\n\t\tversion = 1;\n\t    }\n\t    else {\n\t\tp = lineBuf2->ptr + 11;\n\t\tversion = 0;\n\t    }\n#ifdef DEBUG\n\t    fprintf(stderr, \"Set-Cookie: [%s]\\n\", p);\n#endif\t\t\t\t/* DEBUG */\n\t    SKIP_BLANKS(p);\n\t    while (*p != '=' && !IS_ENDT(*p))\n\t\tStrcat_char(name, *(p++));\n\t    Strremovetrailingspaces(name);\n\t    if (*p == '=') {\n\t\tp++;\n\t\tSKIP_BLANKS(p);\n\t\tquoted = 0;\n\t\twhile (!IS_ENDL(*p) && (quoted || *p != ';')) {\n\t\t    if (!IS_SPACE(*p))\n\t\t\tq = p;\n\t\t    if (*p == '\"')\n\t\t\tquoted = (quoted) ? 0 : 1;\n\t\t    Strcat_char(value, *(p++));\n\t\t}\n\t\tif (q)\n\t\t    Strshrink(value, p - q - 1);\n\t    }\n\t    while (*p == ';') {\n\t\tp++;\n\t\tSKIP_BLANKS(p);\n\t\tif (matchattr(p, \"expires\", 7, &tmp2)) {\n\t\t    /* version 0 */\n\t\t    expires = mymktime(tmp2->ptr);\n\t\t}\n\t\telse if (matchattr(p, \"max-age\", 7, &tmp2)) {\n\t\t    /* XXX Is there any problem with max-age=0? (RFC 2109 ss. 4.2.1, 4.2.2 */\n\t\t    expires = time(NULL) + atol(tmp2->ptr);\n\t\t}\n\t\telse if (matchattr(p, \"domain\", 6, &tmp2)) {\n\t\t    domain = tmp2;\n\t\t}\n\t\telse if (matchattr(p, \"path\", 4, &tmp2)) {\n\t\t    path = tmp2;\n\t\t}\n\t\telse if (matchattr(p, \"secure\", 6, NULL)) {\n\t\t    flag |= COO_SECURE;\n\t\t}\n\t\telse if (matchattr(p, \"comment\", 7, &tmp2)) {\n\t\t    comment = tmp2;\n\t\t}\n\t\telse if (matchattr(p, \"version\", 7, &tmp2)) {\n\t\t    version = atoi(tmp2->ptr);\n\t\t}\n\t\telse if (matchattr(p, \"port\", 4, &tmp2)) {\n\t\t    /* version 1, Set-Cookie2 */\n\t\t    port = tmp2;\n\t\t}\n\t\telse if (matchattr(p, \"commentURL\", 10, &tmp2)) {\n\t\t    /* version 1, Set-Cookie2 */\n\t\t    commentURL = tmp2;\n\t\t}\n\t\telse if (matchattr(p, \"discard\", 7, NULL)) {\n\t\t    /* version 1, Set-Cookie2 */\n\t\t    flag |= COO_DISCARD;\n\t\t}\n\t\tquoted = 0;\n\t\twhile (!IS_ENDL(*p) && (quoted || *p != ';')) {\n\t\t    if (*p == '\"')\n\t\t\tquoted = (quoted) ? 0 : 1;\n\t\t    p++;\n\t\t}\n\t    }\n\t    if (pu && name->length > 0) {\n\t\tint err;\n\t\tif (show_cookie) {\n\t\t    if (flag & COO_SECURE)\n\t\t        disp_message_nsec(\"Received a secured cookie\", FALSE, 1,\n\t\t\t\t      TRUE, FALSE);\n\t\t    else\n\t\t        disp_message_nsec(Sprintf(\"Received cookie: %s=%s\",\n\t\t\t\t\t      name->ptr, value->ptr)->ptr,\n\t\t\t\t      FALSE, 1, TRUE, FALSE);\n\t\t}\n\t\terr =\n\t\t    add_cookie(pu, name, value, expires, domain, path, flag,\n\t\t\t       comment, version, port, commentURL);\n\t\tif (err) {\n\t\t    char *ans = (accept_bad_cookie == ACCEPT_BAD_COOKIE_ACCEPT)\n\t\t\t? \"y\" : NULL;\n\t\t    if (fmInitialized && (err & COO_OVERRIDE_OK) &&\n\t\t\taccept_bad_cookie == ACCEPT_BAD_COOKIE_ASK) {\n\t\t\tStr msg = Sprintf(\"Accept bad cookie from %s for %s?\",\n\t\t\t\t\t  pu->host,\n\t\t\t\t\t  ((domain && domain->ptr)\n\t\t\t\t\t   ? domain->ptr : \"<localdomain>\"));\n\t\t\tif (msg->length > COLS - 10)\n\t\t\t    Strshrink(msg, msg->length - (COLS - 10));\n\t\t\tStrcat_charp(msg, \" (y/n)\");\n\t\t\tans = inputAnswer(msg->ptr);\n\t\t    }\n\t\t    if (ans == NULL || TOLOWER(*ans) != 'y' ||\n\t\t\t(err =\n\t\t\t add_cookie(pu, name, value, expires, domain, path,\n\t\t\t\t    flag | COO_OVERRIDE, comment, version,\n\t\t\t\t    port, commentURL))) {\n\t\t\terr = (err & ~COO_OVERRIDE_OK) - 1;\n\t\t\tif (err >= 0 && err < COO_EMAX)\n\t\t\t    emsg = Sprintf(\"This cookie was rejected \"\n\t\t\t\t\t   \"to prevent security violation. [%s]\",\n\t\t\t\t\t   violations[err])->ptr;\n\t\t\telse\n\t\t\t    emsg =\n\t\t\t\t\"This cookie was rejected to prevent security violation.\";\n\t\t\trecord_err_message(emsg);\n\t\t\tif (show_cookie)\n\t\t\t    disp_message_nsec(emsg, FALSE, 1, TRUE, FALSE);\n\t\t    }\n\t\t    else\n\t\t\tif (show_cookie)\n\t\t\t    disp_message_nsec(Sprintf\n\t\t\t\t\t  (\"Accepting invalid cookie: %s=%s\",\n\t\t\t\t\t   name->ptr, value->ptr)->ptr, FALSE,\n\t\t\t\t\t  1, TRUE, FALSE);\n\t\t}\n\t    }\n\t}\n#endif\t\t\t\t/* USE_COOKIE */\n\telse if (!strncasecmp(lineBuf2->ptr, \"w3m-control:\", 12) &&\n\t\t uf->scheme == SCM_LOCAL_CGI) {\n\t    Str funcname = Strnew();\n\t    int f;\n\n\t    p = lineBuf2->ptr + 12;\n\t    SKIP_BLANKS(p);\n\t    while (*p && !IS_SPACE(*p))\n\t\tStrcat_char(funcname, *(p++));\n\t    SKIP_BLANKS(p);\n\t    f = getFuncList(funcname->ptr);\n\t    if (f >= 0) {\n\t\ttmp = Strnew_charp(p);\n\t\tStrchop(tmp);\n\t\tpushEvent(f, tmp->ptr);\n\t    }\n\t}\n\tif (headerlist)\n\t    pushText(headerlist, lineBuf2->ptr);\n\tStrfree(lineBuf2);\n\tlineBuf2 = NULL;\n    }\n    if (thru)\n\taddnewline(newBuf, \"\", propBuffer, NULL, 0, -1, -1);\n    if (src)\n\tfclose(src);\n}\n\nchar *\ncheckHeader(Buffer *buf, char *field)\n{\n    int len;\n    TextListItem *i;\n    char *p;\n\n    if (buf == NULL || field == NULL || buf->document_header == NULL)\n\treturn NULL;\n    len = strlen(field);\n    for (i = buf->document_header->first; i != NULL; i = i->next) {\n\tif (!strncasecmp(i->ptr, field, len)) {\n\t    p = i->ptr + len;\n\t    return remove_space(p);\n\t}\n    }\n    return NULL;\n}\n\nchar *\ncheckContentType(Buffer *buf)\n{\n    char *p;\n    Str r;\n    p = checkHeader(buf, \"Content-Type:\");\n    if (p == NULL)\n\treturn NULL;\n    r = Strnew();\n    while (*p && *p != ';' && !IS_SPACE(*p))\n\tStrcat_char(r, *p++);\n#ifdef USE_M17N\n    if ((p = strcasestr(p, \"charset\")) != NULL) {\n\tp += 7;\n\tSKIP_BLANKS(p);\n\tif (*p == '=') {\n\t    p++;\n\t    SKIP_BLANKS(p);\n\t    if (*p == '\"')\n\t\tp++;\n\t    content_charset = wc_guess_charset(p, 0);\n\t}\n    }\n#endif\n    return r->ptr;\n}\n\nstruct auth_param {\n    char *name;\n    Str val;\n};\n\nstruct http_auth {\n    int pri;\n    char *scheme;\n    struct auth_param *param;\n    Str (*cred) (struct http_auth * ha, Str uname, Str pw, ParsedURL *pu,\n\t\t HRequest *hr, FormList *request);\n};\n\nenum {\n    AUTHCHR_NUL,\n    AUTHCHR_SEP,\n    AUTHCHR_TOKEN,\n};\n\nstatic int\nskip_auth_token(char **pp)\n{\n    char *p;\n    int first = AUTHCHR_NUL, typ;\n\n    for (p = *pp ;; ++p) {\n\tswitch (*p) {\n\tcase '\\0':\n\t    goto endoftoken;\n\tdefault:\n\t    if ((unsigned char)*p > 037) {\n\t\ttyp = AUTHCHR_TOKEN;\n\t\tbreak;\n\t    }\n\t    /* thru */\n\tcase '\\177':\n\tcase '[':\n\tcase ']':\n\tcase '(':\n\tcase ')':\n\tcase '<':\n\tcase '>':\n\tcase '@':\n\tcase ';':\n\tcase ':':\n\tcase '\\\\':\n\tcase '\"':\n\tcase '/':\n\tcase '?':\n\tcase '=':\n\tcase ' ':\n\tcase '\\t':\n\tcase ',':\n\t    typ = AUTHCHR_SEP;\n\t    break;\n\t}\n\n\tif (!first)\n\t    first = typ;\n\telse if (first != typ)\n\t    break;\n    }\nendoftoken:\n    *pp = p;\n    return first;\n}\n\nstatic Str\nextract_auth_val(char **q)\n{\n    unsigned char *qq = *(unsigned char **)q;\n    int quoted = 0;\n    Str val = Strnew();\n\n    SKIP_BLANKS(qq);\n    if (*qq == '\"') {\n\tquoted = TRUE;\n\tStrcat_char(val, *qq++);\n    }\n    while (*qq != '\\0') {\n\tif (quoted && *qq == '\"') {\n\t    Strcat_char(val, *qq++);\n\t    break;\n\t}\n\tif (!quoted) {\n\t    switch (*qq) {\n\t    case '[':\n\t    case ']':\n\t    case '(':\n\t    case ')':\n\t    case '<':\n\t    case '>':\n\t    case '@':\n\t    case ';':\n\t    case ':':\n\t    case '\\\\':\n\t    case '\"':\n\t    case '/':\n\t    case '?':\n\t    case '=':\n\t    case ' ':\n\t    case '\\t':\n\t\tqq++;\n\t    case ',':\n\t\tgoto end_token;\n\t    default:\n\t\tif (*qq <= 037 || *qq == 0177) {\n\t\t    qq++;\n\t\t    goto end_token;\n\t\t}\n\t    }\n\t}\n\telse if (quoted && *qq == '\\\\')\n\t    Strcat_char(val, *qq++);\n\tStrcat_char(val, *qq++);\n    }\n  end_token:\n    *q = (char *)qq;\n    return val;\n}\n\nstatic Str\nqstr_unquote(Str s)\n{\n    char *p;\n\n    if (s == NULL)\n\treturn NULL;\n    p = s->ptr;\n    if (*p == '\"') {\n\tStr tmp = Strnew();\n\tfor (p++; *p != '\\0'; p++) {\n\t    if (*p == '\\\\')\n\t\tp++;\n\t    Strcat_char(tmp, *p);\n\t}\n\tif (Strlastchar(tmp) == '\"')\n\t    Strshrink(tmp, 1);\n\treturn tmp;\n    }\n    else\n\treturn s;\n}\n\nstatic char *\nextract_auth_param(char *q, struct auth_param *auth)\n{\n    struct auth_param *ap;\n    char *p;\n\n    for (ap = auth; ap->name != NULL; ap++) {\n\tap->val = NULL;\n    }\n\n    while (*q != '\\0') {\n\tSKIP_BLANKS(q);\n\tfor (ap = auth; ap->name != NULL; ap++) {\n\t    size_t len;\n\n\t    len = strlen(ap->name);\n\t    if (strncasecmp(q, ap->name, len) == 0 &&\n\t\t(IS_SPACE(q[len]) || q[len] == '=')) {\n\t\tp = q + len;\n\t\tSKIP_BLANKS(p);\n\t\tif (*p != '=')\n\t\t    return q;\n\t\tq = p + 1;\n\t\tap->val = extract_auth_val(&q);\n\t\tbreak;\n\t    }\n\t}\n\tif (ap->name == NULL) {\n\t    /* skip unknown param */\n\t    int token_type;\n\t    p = q;\n\t    if ((token_type = skip_auth_token(&q)) == AUTHCHR_TOKEN &&\n\t\t(IS_SPACE(*q) || *q == '=')) {\n\t\tSKIP_BLANKS(q);\n\t\tif (*q != '=')\n\t\t    return p;\n\t\tq++;\n\t\textract_auth_val(&q);\n\t    }\n\t    else\n\t\treturn p;\n\t}\n\tif (*q != '\\0') {\n\t    SKIP_BLANKS(q);\n\t    if (*q == ',')\n\t\tq++;\n\t    else\n\t\tbreak;\n\t}\n    }\n    return q;\n}\n\nstatic Str\nget_auth_param(struct auth_param *auth, char *name)\n{\n    struct auth_param *ap;\n    for (ap = auth; ap->name != NULL; ap++) {\n\tif (strcasecmp(name, ap->name) == 0)\n\t    return ap->val;\n    }\n    return NULL;\n}\n\nstatic Str\nAuthBasicCred(struct http_auth *ha, Str uname, Str pw, ParsedURL *pu,\n\t      HRequest *hr, FormList *request)\n{\n    Str s = Strdup(uname);\n    Strcat_char(s, ':');\n    Strcat(s, pw);\n    return Strnew_m_charp(\"Basic \", encodeB(s->ptr)->ptr, NULL);\n}\n\n#ifdef USE_DIGEST_AUTH\n#include <openssl/md5.h>\n\n/* RFC2617: 3.2.2 The Authorization Request Header\n * \n * credentials      = \"Digest\" digest-response\n * digest-response  = 1#( username | realm | nonce | digest-uri\n *                    | response | [ algorithm ] | [cnonce] |\n *                     [opaque] | [message-qop] |\n *                         [nonce-count]  | [auth-param] )\n *\n * username         = \"username\" \"=\" username-value\n * username-value   = quoted-string\n * digest-uri       = \"uri\" \"=\" digest-uri-value\n * digest-uri-value = request-uri   ; As specified by HTTP/1.1\n * message-qop      = \"qop\" \"=\" qop-value\n * cnonce           = \"cnonce\" \"=\" cnonce-value\n * cnonce-value     = nonce-value\n * nonce-count      = \"nc\" \"=\" nc-value\n * nc-value         = 8LHEX\n * response         = \"response\" \"=\" request-digest\n * request-digest = <\"> 32LHEX <\">\n * LHEX             =  \"0\" | \"1\" | \"2\" | \"3\" |\n *                     \"4\" | \"5\" | \"6\" | \"7\" |\n *                     \"8\" | \"9\" | \"a\" | \"b\" |\n *                     \"c\" | \"d\" | \"e\" | \"f\"\n */\n\nstatic Str\ndigest_hex(unsigned char *p)\n{\n    char *h = \"0123456789abcdef\";\n    Str tmp = Strnew_size(MD5_DIGEST_LENGTH * 2 + 1);\n    int i;\n    for (i = 0; i < MD5_DIGEST_LENGTH; i++, p++) {\n\tStrcat_char(tmp, h[(*p >> 4) & 0x0f]);\n\tStrcat_char(tmp, h[*p & 0x0f]);\n    }\n    return tmp;\n}\n\nenum {\n    QOP_NONE,\n    QOP_AUTH,\n    QOP_AUTH_INT,\n};\n\nstatic Str\nAuthDigestCred(struct http_auth *ha, Str uname, Str pw, ParsedURL *pu,\n\t       HRequest *hr, FormList *request)\n{\n    Str tmp, a1buf, a2buf, rd, s;\n    unsigned char md5[MD5_DIGEST_LENGTH + 1];\n    Str uri = HTTPrequestURI(pu, hr);\n    char nc[] = \"00000001\";\n    FILE *fp;\n\n    Str algorithm = qstr_unquote(get_auth_param(ha->param, \"algorithm\"));\n    Str nonce = qstr_unquote(get_auth_param(ha->param, \"nonce\"));\n    Str cnonce /* = qstr_unquote(get_auth_param(ha->param, \"cnonce\")) */;\n    /* cnonce is what client should generate. */\n    Str qop = qstr_unquote(get_auth_param(ha->param, \"qop\"));\n\n    static union {\n\tint r[4];\n\tunsigned char s[sizeof(int) * 4];\n    } cnonce_seed;\n    int qop_i = QOP_NONE;\n\n    cnonce_seed.r[0] = rand();\n    cnonce_seed.r[1] = rand();\n    cnonce_seed.r[2] = rand();\n    MD5(cnonce_seed.s, sizeof(cnonce_seed.s), md5);\n    cnonce = digest_hex(md5);\n    cnonce_seed.r[3]++;\n\n    if (qop) {\n\tchar *p;\n\tsize_t i;\n\n\tp = qop->ptr;\n\tSKIP_BLANKS(p);\n\n\tfor (;;) {\n\t    if ((i = strcspn(p, \" \\t,\")) > 0) {\n\t\tif (i == sizeof(\"auth-int\") - sizeof(\"\") && !strncasecmp(p, \"auth-int\", i)) {\n\t\t    if (qop_i < QOP_AUTH_INT)\n\t\t\tqop_i = QOP_AUTH_INT;\n\t\t}\n\t\telse if (i == sizeof(\"auth\") - sizeof(\"\") && !strncasecmp(p, \"auth\", i)) {\n\t\t    if (qop_i < QOP_AUTH)\n\t\t\tqop_i = QOP_AUTH;\n\t\t}\n\t    }\n\n\t    if (p[i]) {\n\t\tp += i + 1;\n\t\tSKIP_BLANKS(p);\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n\n    /* A1 = unq(username-value) \":\" unq(realm-value) \":\" passwd */\n    tmp = Strnew_m_charp(uname->ptr, \":\",\n\t\t\t qstr_unquote(get_auth_param(ha->param, \"realm\"))->ptr,\n\t\t\t \":\", pw->ptr, NULL);\n    MD5(tmp->ptr, strlen(tmp->ptr), md5);\n    a1buf = digest_hex(md5);\n\n    if (algorithm) {\n\tif (strcasecmp(algorithm->ptr, \"MD5-sess\") == 0) {\n\t    /* A1 = H(unq(username-value) \":\" unq(realm-value) \":\" passwd)\n\t     *      \":\" unq(nonce-value) \":\" unq(cnonce-value)\n\t     */\n\t    if (nonce == NULL)\n\t\treturn NULL;\n\t    tmp = Strnew_m_charp(a1buf->ptr, \":\",\n\t\t\t\t qstr_unquote(nonce)->ptr,\n\t\t\t\t \":\", qstr_unquote(cnonce)->ptr, NULL);\n\t    MD5(tmp->ptr, strlen(tmp->ptr), md5);\n\t    a1buf = digest_hex(md5);\n\t}\n\telse if (strcasecmp(algorithm->ptr, \"MD5\") == 0)\n\t    /* ok default */\n\t    ;\n\telse\n\t    /* unknown algorithm */\n\t    return NULL;\n    }\n\n    /* A2 = Method \":\" digest-uri-value */\n    tmp = Strnew_m_charp(HTTPrequestMethod(hr)->ptr, \":\", uri->ptr, NULL);\n    if (qop_i == QOP_AUTH_INT) {\n\t/*  A2 = Method \":\" digest-uri-value \":\" H(entity-body) */\n\tif (request && request->body) {\n\t    if (request->method == FORM_METHOD_POST && request->enctype == FORM_ENCTYPE_MULTIPART) {\n\t\tfp = fopen(request->body, \"r\");\n\t\tif (fp != NULL) {\n\t\t    Str ebody;\n\t\t    ebody = Strfgetall(fp);\n\t\t    fclose(fp);\n\t\t    MD5(ebody->ptr, strlen(ebody->ptr), md5);\n\t\t}\n\t\telse {\n\t\t    MD5(\"\", 0, md5);\n\t\t}\n\t    }\n\t    else {\n\t\tMD5(request->body, request->length, md5);\n\t    }\n\t}\n\telse {\n\t    MD5(\"\", 0, md5);\n\t}\n\tStrcat_char(tmp, ':');\n\tStrcat(tmp, digest_hex(md5));\n    }\n    MD5(tmp->ptr, strlen(tmp->ptr), md5);\n    a2buf = digest_hex(md5);\n\n    if (qop_i >= QOP_AUTH) {\n\t/* request-digest  = <\"> < KD ( H(A1),     unq(nonce-value)\n\t *                      \":\" nc-value\n\t *                      \":\" unq(cnonce-value)\n\t *                      \":\" unq(qop-value)\n\t *                      \":\" H(A2)\n\t *                      ) <\">\n\t */\n\tif (nonce == NULL)\n\t    return NULL;\n\ttmp = Strnew_m_charp(a1buf->ptr, \":\", qstr_unquote(nonce)->ptr,\n\t\t\t     \":\", nc,\n\t\t\t     \":\", qstr_unquote(cnonce)->ptr,\n\t\t\t     \":\", qop_i == QOP_AUTH ? \"auth\" : \"auth-int\",\n\t\t\t     \":\", a2buf->ptr, NULL);\n\tMD5(tmp->ptr, strlen(tmp->ptr), md5);\n\trd = digest_hex(md5);\n    }\n    else {\n\t/* compatibility with RFC 2069\n\t * request_digest = KD(H(A1),  unq(nonce), H(A2))\n\t */\n\ttmp = Strnew_m_charp(a1buf->ptr, \":\",\n\t\t\t     qstr_unquote(get_auth_param(ha->param, \"nonce\"))->\n\t\t\t     ptr, \":\", a2buf->ptr, NULL);\n\tMD5(tmp->ptr, strlen(tmp->ptr), md5);\n\trd = digest_hex(md5);\n    }\n\n    /*\n     * digest-response  = 1#( username | realm | nonce | digest-uri\n     *                          | response | [ algorithm ] | [cnonce] |\n     *                          [opaque] | [message-qop] |\n     *                          [nonce-count]  | [auth-param] )\n     */\n\n    tmp = Strnew_m_charp(\"Digest username=\\\"\", uname->ptr, \"\\\"\", NULL);\n    Strcat_m_charp(tmp, \", realm=\",\n\t\t   get_auth_param(ha->param, \"realm\")->ptr, NULL);\n    Strcat_m_charp(tmp, \", nonce=\",\n\t\t   get_auth_param(ha->param, \"nonce\")->ptr, NULL);\n    Strcat_m_charp(tmp, \", uri=\\\"\", uri->ptr, \"\\\"\", NULL);\n    Strcat_m_charp(tmp, \", response=\\\"\", rd->ptr, \"\\\"\", NULL);\n\n    if (algorithm)\n\tStrcat_m_charp(tmp, \", algorithm=\",\n\t\t       get_auth_param(ha->param, \"algorithm\")->ptr, NULL);\n\n    if (cnonce)\n\tStrcat_m_charp(tmp, \", cnonce=\\\"\", cnonce->ptr, \"\\\"\", NULL);\n\n    if ((s = get_auth_param(ha->param, \"opaque\")) != NULL)\n\tStrcat_m_charp(tmp, \", opaque=\", s->ptr, NULL);\n\n    if (qop_i >= QOP_AUTH) {\n\tStrcat_m_charp(tmp, \", qop=\",\n\t\t       qop_i == QOP_AUTH ? \"auth\" : \"auth-int\",\n\t\t       NULL);\n\t/* XXX how to count? */\n\t/* Since nonce is unique up to each *-Authenticate and w3m does not re-use *-Authenticate: headers,\n\t   nonce-count should be always \"00000001\". */\n\tStrcat_m_charp(tmp, \", nc=\", nc, NULL);\n    }\n\n    return tmp;\n}\n#endif\n\n/* *INDENT-OFF* */\nstruct auth_param none_auth_param[] = {\n    {NULL, NULL}\n};\n\nstruct auth_param basic_auth_param[] = {\n    {\"realm\", NULL},\n    {NULL, NULL}\n};\n\n#ifdef USE_DIGEST_AUTH\n/* RFC2617: 3.2.1 The WWW-Authenticate Response Header\n * challenge        =  \"Digest\" digest-challenge\n * \n * digest-challenge  = 1#( realm | [ domain ] | nonce |\n *                       [ opaque ] |[ stale ] | [ algorithm ] |\n *                        [ qop-options ] | [auth-param] )\n *\n * domain            = \"domain\" \"=\" <\"> URI ( 1*SP URI ) <\">\n * URI               = absoluteURI | abs_path\n * nonce             = \"nonce\" \"=\" nonce-value\n * nonce-value       = quoted-string\n * opaque            = \"opaque\" \"=\" quoted-string\n * stale             = \"stale\" \"=\" ( \"true\" | \"false\" )\n * algorithm         = \"algorithm\" \"=\" ( \"MD5\" | \"MD5-sess\" |\n *                        token )\n * qop-options       = \"qop\" \"=\" <\"> 1#qop-value <\">\n * qop-value         = \"auth\" | \"auth-int\" | token\n */\nstruct auth_param digest_auth_param[] = {\n    {\"realm\", NULL},\n    {\"domain\", NULL},\n    {\"nonce\", NULL},\n    {\"opaque\", NULL},\n    {\"stale\", NULL},\n    {\"algorithm\", NULL},\n    {\"qop\", NULL},\n    {NULL, NULL}\n};\n#endif\n/* for RFC2617: HTTP Authentication */\nstruct http_auth www_auth[] = {\n    { 1, \"Basic \", basic_auth_param, AuthBasicCred },\n#ifdef USE_DIGEST_AUTH\n    { 10, \"Digest \", digest_auth_param, AuthDigestCred },\n#endif\n    { 0, NULL, NULL, NULL,}\n};\n/* *INDENT-ON* */\n\nstatic struct http_auth *\nfindAuthentication(struct http_auth *hauth, Buffer *buf, char *auth_field)\n{\n    struct http_auth *ha;\n    int len = strlen(auth_field), slen;\n    TextListItem *i;\n    char *p0, *p;\n\n    bzero(hauth, sizeof(struct http_auth));\n    for (i = buf->document_header->first; i != NULL; i = i->next) {\n\tif (strncasecmp(i->ptr, auth_field, len) == 0) {\n\t    for (p = i->ptr + len; p != NULL && *p != '\\0';) {\n\t\tSKIP_BLANKS(p);\n\t\tp0 = p;\n\t\tfor (ha = &www_auth[0]; ha->scheme != NULL; ha++) {\n\t\t    slen = strlen(ha->scheme);\n\t\t    if (strncasecmp(p, ha->scheme, slen) == 0) {\n\t\t\tp += slen;\n\t\t\tSKIP_BLANKS(p);\n\t\t\tif (hauth->pri < ha->pri) {\n\t\t\t    *hauth = *ha;\n\t\t\t    p = extract_auth_param(p, hauth->param);\n\t\t\t    break;\n\t\t\t}\n\t\t\telse {\n\t\t\t    /* weak auth */\n\t\t\t    p = extract_auth_param(p, none_auth_param);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (p0 == p) {\n\t\t    /* all unknown auth failed */\n\t\t    int token_type;\n\t\t    if ((token_type = skip_auth_token(&p)) == AUTHCHR_TOKEN && IS_SPACE(*p)) {\n\t\t\tSKIP_BLANKS(p);\n\t\t\tp = extract_auth_param(p, none_auth_param);\n\t\t    }\n\t\t    else\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n    }\n    return hauth->scheme ? hauth : NULL;\n}\n\nstatic void\ngetAuthCookie(struct http_auth *hauth, char *auth_header,\n\t      TextList *extra_header, ParsedURL *pu, HRequest *hr,\n\t      FormList *request,\n\t      volatile Str *uname, volatile Str *pwd)\n{\n    Str ss = NULL;\n    Str tmp;\n    TextListItem *i;\n    int a_found;\n    int auth_header_len = strlen(auth_header);\n    char *realm = NULL;\n    int proxy;\n\n    if (hauth)\n\trealm = qstr_unquote(get_auth_param(hauth->param, \"realm\"))->ptr;\n\n    if (!realm)\n\treturn;\n\n    a_found = FALSE;\n    for (i = extra_header->first; i != NULL; i = i->next) {\n\tif (!strncasecmp(i->ptr, auth_header, auth_header_len)) {\n\t    a_found = TRUE;\n\t    break;\n\t}\n    }\n    proxy = !strncasecmp(\"Proxy-Authorization:\", auth_header,\n\t\t\t auth_header_len);\n    if (a_found) {\n\t/* This means that *-Authenticate: header is received after\n\t * Authorization: header is sent to the server. \n\t */\n\tif (fmInitialized) {\n\t    message(\"Wrong username or password\", 0, 0);\n\t    refresh();\n\t}\n\telse\n\t    fprintf(stderr, \"Wrong username or password\\n\");\n\tsleep(1);\n\t/* delete Authenticate: header from extra_header */\n\tdelText(extra_header, i);\n\tinvalidate_auth_user_passwd(pu, realm, *uname, *pwd, proxy);\n    }\n    *uname = NULL;\n    *pwd = NULL;\n\n    if (!a_found && find_auth_user_passwd(pu, realm, (Str*)uname, (Str*)pwd, \n\t\t\t\t\t  proxy)) {\n\t/* found username & password in passwd file */ ;\n    }\n    else {\n\tif (QuietMessage)\n\t    return;\n\t/* input username and password */\n\tsleep(2);\n\tif (fmInitialized) {\n\t    char *pp;\n\t    term_raw();\n\t    /* FIXME: gettextize? */\n\t    if ((pp = inputStr(Sprintf(\"Username for %s: \", realm)->ptr,\n\t\t\t       NULL)) == NULL)\n\t\treturn;\n\t    *uname = Str_conv_to_system(Strnew_charp(pp));\n\t    if ((pp = inputLine(Sprintf(\"Password for %s: \", realm)->ptr, NULL,\n\t\t\t\tIN_PASSWORD)) == NULL) {\n\t\t*uname = NULL;\n\t\treturn;\n\t    }\n\t    *pwd = Str_conv_to_system(Strnew_charp(pp));\n\t    term_cbreak();\n\t}\n\telse {\n\t    /*\n\t     * If post file is specified as '-', stdin is closed at this\n\t     * point.\n\t     * In this case, w3m cannot read username from stdin.\n\t     * So exit with error message.\n\t     * (This is same behavior as lwp-request.)\n\t     */\n\t    if (feof(stdin) || ferror(stdin)) {\n\t\t/* FIXME: gettextize? */\n\t\tfprintf(stderr, \"w3m: Authorization required for %s\\n\",\n\t\t\trealm);\n\t\texit(1);\n\t    }\n\t    \n\t    /* FIXME: gettextize? */\n\t    printf(proxy ? \"Proxy Username for %s: \" : \"Username for %s: \",\n\t\t   realm);\n\t    fflush(stdout);\n\t    *uname = Strfgets(stdin);\n\t    Strchop(*uname);\n#ifdef HAVE_GETPASSPHRASE\n\t    *pwd = Strnew_charp((char *)\n\t\t\t\tgetpassphrase(proxy ? \"Proxy Password: \" :\n\t\t\t\t\t      \"Password: \"));\n#else\n#ifndef __MINGW32_VERSION\n\t    *pwd = Strnew_charp((char *)\n\t\t\t\tgetpass(proxy ? \"Proxy Password: \" :\n\t\t\t\t\t\"Password: \"));\n#else\n\t    term_raw();\n\t    *pwd = Strnew_charp((char *)\n\t\t\t\tinputLine(proxy ? \"Proxy Password: \" :\n\t\t\t\t\t  \"Password: \", NULL, IN_PASSWORD));\n\t    term_cbreak();\n#endif /* __MINGW32_VERSION */\n#endif\n\t}\n    }\n    ss = hauth->cred(hauth, *uname, *pwd, pu, hr, request);\n    if (ss) {\n\ttmp = Strnew_charp(auth_header);\n\tStrcat_m_charp(tmp, \" \", ss->ptr, \"\\r\\n\", NULL);\n\tpushText(extra_header, tmp->ptr);\n    }\n    else {\n\t*uname = NULL;\n\t*pwd = NULL;\n    }\n    return;\n}\n\nstatic int\nsame_url_p(ParsedURL *pu1, ParsedURL *pu2)\n{\n    return (pu1->scheme == pu2->scheme && pu1->port == pu2->port &&\n\t    (pu1->host ? pu2->host ? !strcasecmp(pu1->host, pu2->host) : 0 : 1)\n\t    && (pu1->file ? pu2->\n\t\tfile ? !strcmp(pu1->file, pu2->file) : 0 : 1));\n}\n\nstatic int\ncheckRedirection(ParsedURL *pu)\n{\n    static ParsedURL *puv = NULL;\n    static int nredir = 0;\n    static int nredir_size = 0;\n    Str tmp;\n\n    if (pu == NULL) {\n\tnredir = 0;\n\tnredir_size = 0;\n\tpuv = NULL;\n\treturn TRUE;\n    }\n    if (nredir >= FollowRedirection) {\n\t/* FIXME: gettextize? */\n\ttmp = Sprintf(\"Number of redirections exceeded %d at %s\",\n\t\t      FollowRedirection, parsedURL2Str(pu)->ptr);\n\tdisp_err_message(tmp->ptr, FALSE);\n\treturn FALSE;\n    }\n    else if (nredir_size > 0 &&\n\t     (same_url_p(pu, &puv[(nredir - 1) % nredir_size]) ||\n\t      (!(nredir % 2)\n\t       && same_url_p(pu, &puv[(nredir / 2) % nredir_size])))) {\n\t/* FIXME: gettextize? */\n\ttmp = Sprintf(\"Redirection loop detected (%s)\",\n\t\t      parsedURL2Str(pu)->ptr);\n\tdisp_err_message(tmp->ptr, FALSE);\n\treturn FALSE;\n    }\n    if (!puv) {\n\tnredir_size = FollowRedirection / 2 + 1;\n\tpuv = New_N(ParsedURL, nredir_size);\n\tmemset(puv, 0, sizeof(ParsedURL) * nredir_size);\n    }\n    copyParsedURL(&puv[nredir % nredir_size], pu);\n    nredir++;\n    return TRUE;\n}\n\nStr\ngetLinkNumberStr(int correction)\n{\n    return Sprintf(\"[%d]\", cur_hseq + correction);\n}\n\n/* \n * loadGeneralFile: load file to buffer\n */\n#define DO_EXTERNAL ((Buffer *(*)(URLFile *, Buffer *))doExternal)\nBuffer *\nloadGeneralFile(char *path, ParsedURL *volatile current, char *referer,\n\t\tint flag, FormList *volatile request)\n{\n    URLFile f, *volatile of = NULL;\n    ParsedURL pu;\n    Buffer *b = NULL;\n    Buffer *(*volatile proc)(URLFile *, Buffer *) = loadBuffer;\n    char *volatile tpath;\n    char *volatile t = \"text/plain\", *p, *volatile real_type = NULL;\n    Buffer *volatile t_buf = NULL;\n    int volatile searchHeader = SearchHeader;\n    int volatile searchHeader_through = TRUE;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    TextList *extra_header = newTextList();\n    volatile Str uname = NULL;\n    volatile Str pwd = NULL;\n    volatile Str realm = NULL;\n    int volatile add_auth_cookie_flag;\n    unsigned char status = HTST_NORMAL;\n    URLOption url_option;\n    Str tmp;\n    Str volatile page = NULL;\n#ifdef USE_M17N\n    wc_ces charset = WC_CES_US_ASCII;\n#endif\n    HRequest hr;\n    ParsedURL *volatile auth_pu;\n\n    tpath = path;\n    prevtrap = NULL;\n    add_auth_cookie_flag = 0;\n\n    checkRedirection(NULL);\n\n  load_doc:\n    {\n\tconst char *sc_redirect;\n\tparseURL2(tpath, &pu, current);\n\tsc_redirect = query_SCONF_SUBSTITUTE_URL(&pu);\n\tif (sc_redirect && *sc_redirect && checkRedirection(&pu)) {\n\t    tpath = (char *)sc_redirect;\n\t    request = NULL;\n\t    add_auth_cookie_flag = 0;\n\t    current = New(ParsedURL);\n\t    *current = pu;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n    }\n    TRAP_OFF;\n    url_option.referer = referer;\n    url_option.flag = flag;\n    f = openURL(tpath, &pu, current, &url_option, request, extra_header, of,\n\t\t&hr, &status);\n    of = NULL;\n#ifdef USE_M17N\n    content_charset = 0;\n#endif\n    if (f.stream == NULL) {\n\tswitch (f.scheme) {\n\tcase SCM_LOCAL:\n\t    {\n\t\tstruct stat st;\n\t\tif (stat(pu.real_file, &st) < 0)\n\t\t    return NULL;\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t    if (UseExternalDirBuffer) {\n\t\t\tStr cmd = Sprintf(\"%s?dir=%s#current\",\n\t\t\t\t\t  DirBufferCommand, pu.file);\n\t\t\tb = loadGeneralFile(cmd->ptr, NULL, NO_REFERER, 0,\n\t\t\t\t\t    NULL);\n\t\t\tif (b != NULL && b != NO_BUFFER) {\n\t\t\t    copyParsedURL(&b->currentURL, &pu);\n\t\t\t    b->filename = b->currentURL.real_file;\n\t\t\t}\n\t\t\treturn b;\n\t\t    }\n\t\t    else {\n\t\t\tpage = loadLocalDir(pu.real_file);\n\t\t\tt = \"local:directory\";\n#ifdef USE_M17N\n\t\t\tcharset = SystemCharset;\n#endif\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase SCM_FTPDIR:\n\t    page = loadFTPDir(&pu, &charset);\n\t    t = \"ftp:directory\";\n\t    break;\n#ifdef USE_NNTP\n\tcase SCM_NEWS_GROUP:\n\t    page = loadNewsgroup(&pu, &charset);\n\t    t = \"news:group\";\n\t    break;\n#endif\n\tcase SCM_UNKNOWN:\n#ifdef USE_EXTERNAL_URI_LOADER\n\t    tmp = searchURIMethods(&pu);\n\t    if (tmp != NULL) {\n\t\tb = loadGeneralFile(tmp->ptr, current, referer, flag, request);\n\t\tif (b != NULL && b != NO_BUFFER)\n\t\t    copyParsedURL(&b->currentURL, &pu);\n\t\treturn b;\n\t    }\n#endif\n\t    /* FIXME: gettextize? */\n\t    disp_err_message(Sprintf(\"Unknown URI: %s\",\n\t\t\t\t     parsedURL2Str(&pu)->ptr)->ptr, FALSE);\n\t    break;\n\t}\n\tif (page && page->length > 0)\n\t    goto page_loaded;\n\treturn NULL;\n    }\n\n    if (status == HTST_MISSING) {\n\tTRAP_OFF;\n\tUFclose(&f);\n\treturn NULL;\n    }\n\n    /* openURL() succeeded */\n    if (SETJMP(AbortLoading) != 0) {\n\t/* transfer interrupted */\n\tTRAP_OFF;\n\tif (b)\n\t    discardBuffer(b);\n\tUFclose(&f);\n\treturn NULL;\n    }\n\n    b = NULL;\n    if (f.is_cgi) {\n\t/* local CGI */\n\tsearchHeader = TRUE;\n\tsearchHeader_through = FALSE;\n    }\n    if (header_string)\n\theader_string = NULL;\n    TRAP_ON;\n    if (pu.scheme == SCM_HTTP ||\n#ifdef USE_SSL\n\tpu.scheme == SCM_HTTPS ||\n#endif\t\t\t\t/* USE_SSL */\n\t((\n#ifdef USE_GOPHER\n\t     (pu.scheme == SCM_GOPHER && non_null(GOPHER_proxy)) ||\n#endif\t\t\t\t/* USE_GOPHER */\n\t     (pu.scheme == SCM_FTP && non_null(FTP_proxy))\n\t ) && !Do_not_use_proxy && !check_no_proxy(pu.host))) {\n\n\tif (fmInitialized) {\n\t    term_cbreak();\n\t    /* FIXME: gettextize? */\n\t    message(Sprintf(\"%s contacted. Waiting for reply...\", pu.host)->\n\t\t    ptr, 0, 0);\n\t    refresh();\n\t}\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n#if 0\t\t\t\t/* USE_SSL */\n\tif (IStype(f.stream) == IST_SSL) {\n\t    Str s = ssl_get_certificate(f.stream, pu.host);\n\t    if (s == NULL)\n\t\treturn NULL;\n\t    else\n\t\tt_buf->ssl_certificate = s->ptr;\n\t}\n#endif\n\treadHeader(&f, t_buf, FALSE, &pu);\n\tif (((http_response_code >= 301 && http_response_code <= 303)\n\t     || http_response_code == 307)\n\t    && (p = checkHeader(t_buf, \"Location:\")) != NULL\n\t    && checkRedirection(&pu)) {\n\t    /* document moved */\n\t    /* 301: Moved Permanently */\n\t    /* 302: Found */\n\t    /* 303: See Other */\n\t    /* 307: Temporary Redirect (HTTP/1.1) */\n\t    tpath = url_encode(p, NULL, 0);\n\t    request = NULL;\n\t    UFclose(&f);\n\t    current = New(ParsedURL);\n\t    copyParsedURL(current, &pu);\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    t_buf->bufferprop |= BP_REDIRECTED;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n\tt = checkContentType(t_buf);\n\tif (t == NULL && pu.file != NULL) {\n\t    if (!((http_response_code >= 400 && http_response_code <= 407) ||\n\t\t  (http_response_code >= 500 && http_response_code <= 505)))\n\t\tt = guessContentType(pu.file);\n\t}\n\tif (t == NULL)\n\t    t = \"text/plain\";\n\tif (add_auth_cookie_flag && realm && uname && pwd) {\n\t    /* If authorization is required and passed */\n\t    add_auth_user_passwd(&pu, qstr_unquote(realm)->ptr, uname, pwd, \n\t\t\t\t  0);\n\t    add_auth_cookie_flag = 0;\n\t}\n\tif ((p = checkHeader(t_buf, \"WWW-Authenticate:\")) != NULL &&\n\t    http_response_code == 401) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \"WWW-Authenticate:\") != NULL\n\t\t&& (realm = get_auth_param(hauth.param, \"realm\")) != NULL) {\n\t\tauth_pu = &pu;\n\t\tgetAuthCookie(&hauth, \"Authorization:\", extra_header,\n\t\t\t      auth_pu, &hr, request, &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tgoto load_doc;\n\t    }\n\t}\n\tif ((p = checkHeader(t_buf, \"Proxy-Authenticate:\")) != NULL &&\n\t    http_response_code == 407) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \"Proxy-Authenticate:\")\n\t\t!= NULL\n\t\t&& (realm = get_auth_param(hauth.param, \"realm\")) != NULL) {\n\t\tauth_pu = schemeToProxy(pu.scheme);\n\t\tgetAuthCookie(&hauth, \"Proxy-Authorization:\",\n\t\t\t      extra_header, auth_pu, &hr, request, \n\t\t\t      &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tadd_auth_user_passwd(auth_pu, qstr_unquote(realm)->ptr, uname, pwd, 1);\n\t\tgoto load_doc;\n\t    }\n\t}\n\t/* XXX: RFC2617 3.2.3 Authentication-Info: ? */\n\n\tif (status == HTST_CONNECT) {\n\t    of = &f;\n\t    goto load_doc;\n\t}\n\n\tf.modtime = mymktime(checkHeader(t_buf, \"Last-Modified:\"));\n    }\n#ifdef USE_NNTP\n    else if (pu.scheme == SCM_NEWS || pu.scheme == SCM_NNTP) {\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\treadHeader(&f, t_buf, TRUE, &pu);\n\tt = checkContentType(t_buf);\n\tif (t == NULL)\n\t    t = \"text/plain\";\n    }\n#endif\t\t\t\t/* USE_NNTP */\n#ifdef USE_GOPHER\n    else if (pu.scheme == SCM_GOPHER) {\n\tswitch (*pu.file) {\n\tcase '0':\n\t    t = \"text/plain\";\n\t    break;\n\tcase '1':\n\tcase 'm':\n\t    page = loadGopherDir(&f, &pu, &charset);\n\t    t = \"gopher:directory\";\n\t    TRAP_OFF;\n\t    goto page_loaded;\n\tcase 's':\n\t    t = \"audio/basic\";\n\t    break;\n\tcase 'g':\n\t    t = \"image/gif\";\n\t    break;\n\tcase 'h':\n\t    t = \"text/html\";\n\t    break;\n\t}\n    }\n#endif\t\t\t\t/* USE_GOPHER */\n    else if (pu.scheme == SCM_FTP) {\n\tcheck_compression(path, &f);\n\tif (f.compression != CMP_NOCOMPRESS) {\n\t    char *t1 = uncompressed_file_type(pu.file, NULL);\n\t    real_type = f.guess_type;\n#if 0\n\t    if (t1 && strncasecmp(t1, \"application/\", 12) == 0) {\n\t\tf.compression = CMP_NOCOMPRESS;\n\t\tt = real_type;\n\t    }\n\t    else\n#endif\n\t    if (t1)\n\t\tt = t1;\n\t    else\n\t\tt = real_type;\n\t}\n\telse {\n\t    real_type = guessContentType(pu.file);\n\t    if (real_type == NULL)\n\t\treal_type = \"text/plain\";\n\t    t = real_type;\n\t}\n#if 0\n\tif (!strncasecmp(t, \"application/\", 12)) {\n\t    char *tmpf = tmpfname(TMPF_DFL, NULL)->ptr;\n\t    current_content_length = 0;\n\t    if (save2tmp(f, tmpf) < 0)\n\t\tUFclose(&f);\n\t    else {\n\t\tUFclose(&f);\n\t\tTRAP_OFF;\n\t\tdoFileMove(tmpf, guess_save_name(t_buf, pu.file));\n\t    }\n\t    return NO_BUFFER;\n\t}\n#endif\n    }\n    else if (pu.scheme == SCM_DATA) {\n\tt = f.guess_type;\n    }\n    else if (searchHeader) {\n\tsearchHeader = SearchHeader = FALSE;\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\treadHeader(&f, t_buf, searchHeader_through, &pu);\n\tif (f.is_cgi && (p = checkHeader(t_buf, \"Location:\")) != NULL &&\n\t    checkRedirection(&pu)) {\n\t    /* document moved */\n\t    tpath = url_encode(remove_space(p), NULL, 0);\n\t    request = NULL;\n\t    UFclose(&f);\n\t    add_auth_cookie_flag = 0;\n\t    current = New(ParsedURL);\n\t    copyParsedURL(current, &pu);\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    t_buf->bufferprop |= BP_REDIRECTED;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n#ifdef AUTH_DEBUG\n\tif ((p = checkHeader(t_buf, \"WWW-Authenticate:\")) != NULL) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \"WWW-Authenticate:\") != NULL\n\t\t&& (realm = get_auth_param(hauth.param, \"realm\")) != NULL) {\n\t\tauth_pu = &pu;\n\t\tgetAuthCookie(&hauth, \"Authorization:\", extra_header,\n\t\t\t      auth_pu, &hr, request, &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tgoto load_doc;\n\t    }\n\t}\n#endif /* defined(AUTH_DEBUG) */\n\tt = checkContentType(t_buf);\n\tif (t == NULL)\n\t    t = \"text/plain\";\n    }\n    else if (DefaultType) {\n\tt = DefaultType;\n\tDefaultType = NULL;\n    }\n    else {\n\tt = guessContentType(pu.file);\n\tif (t == NULL)\n\t    t = \"text/plain\";\n\treal_type = t;\n\tif (f.guess_type)\n\t    t = f.guess_type;\n    }\n\n    /* XXX: can we use guess_type to give the type to loadHTMLstream\n     *      to support default utf8 encoding for XHTML here? */\n    f.guess_type = t;\n    \n  page_loaded:\n    if (page) {\n\tFILE *src;\n#ifdef USE_IMAGE\n\tif (image_source)\n\t    return NULL;\n#endif\n\ttmp = tmpfname(TMPF_SRC, \".html\");\n\tsrc = fopen(tmp->ptr, \"w\");\n\tif (src) {\n\t    Str s;\n\t    s = wc_Str_conv_strict(page, InnerCharset, charset);\n\t    Strfputs(s, src);\n\t    fclose(src);\n\t}\n\tif (do_download) {\n\t    char *file;\n\t    if (!src)\n\t\treturn NULL;\n\t    file = guess_filename(pu.file);\n#ifdef USE_GOPHER\n\t    if (f.scheme == SCM_GOPHER)\n\t\tfile = Sprintf(\"%s.html\", file)->ptr;\n#endif\n#ifdef USE_NNTP\n\t    if (f.scheme == SCM_NEWS_GROUP)\n\t\tfile = Sprintf(\"%s.html\", file)->ptr;\n#endif\n\t    doFileMove(tmp->ptr, file);\n\t    return NO_BUFFER;\n\t}\n\tb = loadHTMLString(page);\n\tif (b) {\n\t    copyParsedURL(&b->currentURL, &pu);\n\t    b->real_scheme = pu.scheme;\n\t    b->real_type = t;\n\t    if (src)\n\t\tb->sourcefile = tmp->ptr;\n#ifdef USE_M17N\n\t    b->document_charset = charset;\n#endif\n\t}\n\treturn b;\n    }\n\n    if (real_type == NULL)\n\treal_type = t;\n    proc = loadBuffer;\n\n    current_content_length = 0;\n    if ((p = checkHeader(t_buf, \"Content-Length:\")) != NULL)\n\tcurrent_content_length = strtoclen(p);\n    if (do_download) {\n\t/* download only */\n\tchar *file;\n\tTRAP_OFF;\n\tif (DecodeCTE && IStype(f.stream) != IST_ENCODED)\n\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\tif (pu.scheme == SCM_LOCAL) {\n\t    struct stat st;\n\t    if (PreserveTimestamp && !stat(pu.real_file, &st))\n\t\tf.modtime = st.st_mtime;\n\t    file = conv_from_system(guess_save_name(NULL, pu.real_file));\n\t}\n\telse\n\t    file = guess_save_name(t_buf, pu.file);\n\tif (doFileSave(f, file) == 0)\n\t    UFhalfclose(&f);\n\telse\n\t    UFclose(&f);\n\treturn NO_BUFFER;\n    }\n\n    if ((f.content_encoding != CMP_NOCOMPRESS) && AutoUncompress\n\t&& !(w3m_dump & DUMP_EXTRA)) {\n\tuncompress_stream(&f, &pu.real_file);\n    }\n    else if (f.compression != CMP_NOCOMPRESS) {\n\tif (!(w3m_dump & DUMP_SOURCE) &&\n\t    (w3m_dump & ~DUMP_FRAME || is_text_type(t)\n\t     || searchExtViewer(t))) {\n\t    if (t_buf == NULL)\n\t\tt_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    uncompress_stream(&f, &t_buf->sourcefile);\n\t    uncompressed_file_type(pu.file, &f.ext);\n\t}\n\telse {\n\t    t = compress_application_type(f.compression);\n\t    f.compression = CMP_NOCOMPRESS;\n\t}\n    }\n#ifdef USE_IMAGE\n    if (image_source) {\n\tBuffer *b = NULL;\n\tif (IStype(f.stream) != IST_ENCODED)\n\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\tif (save2tmp(f, image_source) == 0) {\n\t    b = newBuffer(INIT_BUFFER_WIDTH);\n\t    b->sourcefile = image_source;\n\t    b->real_type = t;\n\t}\n\tUFclose(&f);\n\tTRAP_OFF;\n\treturn b;\n    }\n#endif\n\n    if (is_html_type(t))\n\tproc = loadHTMLBuffer;\n    else if (is_plain_text_type(t))\n\tproc = loadBuffer;\n#ifdef USE_IMAGE\n    else if (activeImage && displayImage && !useExtImageViewer &&\n\t     !(w3m_dump & ~DUMP_FRAME) && !strncasecmp(t, \"image/\", 6))\n\tproc = loadImageBuffer;\n#endif\n    else if (w3m_backend) ;\n    else if (!(w3m_dump & ~DUMP_FRAME) || is_dump_text_type(t)) {\n\tif (!do_download && searchExtViewer(t) != NULL) {\n\t    proc = DO_EXTERNAL;\n\t}\n\telse {\n\t    TRAP_OFF;\n\t    if (pu.scheme == SCM_LOCAL) {\n\t\tUFclose(&f);\n\t\t_doFileCopy(pu.real_file,\n\t\t\t    conv_from_system(guess_save_name\n\t\t\t\t\t     (NULL, pu.real_file)), TRUE);\n\t    }\n\t    else {\n\t\tif (DecodeCTE && IStype(f.stream) != IST_ENCODED)\n\t\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\t\tif (doFileSave(f, guess_save_name(t_buf, pu.file)) == 0)\n\t\t    UFhalfclose(&f);\n\t\telse\n\t\t    UFclose(&f);\n\t    }\n\t    return NO_BUFFER;\n\t}\n    }\n    else if (w3m_dump & DUMP_FRAME)\n\treturn NULL;\n\n    if (t_buf == NULL)\n\tt_buf = newBuffer(INIT_BUFFER_WIDTH);\n    copyParsedURL(&t_buf->currentURL, &pu);\n    t_buf->filename = pu.real_file ? pu.real_file :\n\tpu.file ? conv_to_system(pu.file) : NULL;\n    if (flag & RG_FRAME) {\n\tt_buf->bufferprop |= BP_FRAME;\n    }\n#ifdef USE_SSL\n    t_buf->ssl_certificate = f.ssl_certificate;\n#endif\n    frame_source = flag & RG_FRAME_SRC;\n    if (proc == DO_EXTERNAL) {\n\tb = doExternal(f, t, t_buf);\n    } else {\n\tb = loadSomething(&f, proc, t_buf);\n    }\n    UFclose(&f);\n    frame_source = 0;\n    if (b && b != NO_BUFFER) {\n\tb->real_scheme = f.scheme;\n\tb->real_type = real_type;\n\tif (w3m_backend)\n\t    b->type = allocStr(t, -1);\n\tif (pu.label) {\n\t    if (proc == loadHTMLBuffer) {\n\t\tAnchor *a;\n\t\ta = searchURLLabel(b, pu.label);\n\t\tif (a != NULL) {\n\t\t    gotoLine(b, a->start.line);\n\t\t    if (label_topline)\n\t\t\tb->topLine = lineSkip(b, b->topLine,\n\t\t\t\t\t      b->currentLine->linenumber\n\t\t\t\t\t      - b->topLine->linenumber, FALSE);\n\t\t    b->pos = a->start.pos;\n\t\t    arrangeCursor(b);\n\t\t}\n\t    }\n\t    else {\t\t/* plain text */\n\t\tint l = atoi(pu.label);\n\t\tgotoRealLine(b, l);\n\t\tb->pos = 0;\n\t\tarrangeCursor(b);\n\t    }\n\t}\n    }\n    if (header_string)\n\theader_string = NULL;\n#ifdef USE_NNTP\n    if (b && b != NO_BUFFER && (f.scheme == SCM_NNTP || f.scheme == SCM_NEWS))\n\treAnchorNewsheader(b);\n#endif\n    if (b && b != NO_BUFFER)\n\tpreFormUpdateBuffer(b);\n    TRAP_OFF;\n    return b;\n}\n\n#define TAG_IS(s,tag,len)\\\n  (strncasecmp(s,tag,len)==0&&(s[len] == '>' || IS_SPACE((int)s[len])))\n\nstatic char *\nhas_hidden_link(struct readbuffer *obuf, int cmd)\n{\n    Str line = obuf->line;\n    struct link_stack *p;\n\n    if (Strlastchar(line) != '>')\n\treturn NULL;\n\n    for (p = link_stack; p; p = p->next)\n\tif (p->cmd == cmd)\n\t    break;\n    if (!p)\n\treturn NULL;\n\n    if (obuf->pos == p->pos)\n\treturn line->ptr + p->offset;\n\n    return NULL;\n}\n\nstatic void\npush_link(int cmd, int offset, int pos)\n{\n    struct link_stack *p;\n    p = New(struct link_stack);\n    p->cmd = cmd;\n    p->offset = offset;\n    p->pos = pos;\n    p->next = link_stack;\n    link_stack = p;\n}\n\nstatic int\nis_period_char(unsigned char *ch)\n{\n    switch (*ch) {\n    case ',':\n    case '.':\n    case ':':\n    case ';':\n    case '?':\n    case '!':\n    case ')':\n    case ']':\n    case '}':\n    case '>':\n\treturn 1;\n    default:\n\treturn 0;\n    }\n}\n\nstatic int\nis_beginning_char(unsigned char *ch)\n{\n    switch (*ch) {\n    case '(':\n    case '[':\n    case '{':\n    case '`':\n    case '<':\n\treturn 1;\n    default:\n\treturn 0;\n    }\n}\n\nstatic int\nis_word_char(unsigned char *ch)\n{\n    Lineprop ctype = get_mctype(ch);\n\n#ifdef USE_M17N\n    if (ctype & (PC_CTRL | PC_KANJI | PC_UNKNOWN))\n\treturn 0;\n    if (ctype & (PC_WCHAR1 | PC_WCHAR2))\n\treturn 1;\n#else\n    if (ctype == PC_CTRL)\n\treturn 0;\n#endif\n\n    if (IS_ALNUM(*ch))\n\treturn 1;\n\n    switch (*ch) {\n    case ',':\n    case '.':\n    case ':':\n    case '\\\"':\t\t\t/* \" */\n    case '\\'':\n    case '$':\n    case '%':\n    case '*':\n    case '+':\n    case '-':\n    case '@':\n    case '~':\n    case '_':\n\treturn 1;\n    }\n#ifdef USE_M17N\n    if (*ch == NBSP_CODE)\n\treturn 1;\n#else\n    if (*ch == TIMES_CODE || *ch == DIVIDE_CODE || *ch == ANSP_CODE)\n\treturn 0;\n    if (*ch >= AGRAVE_CODE || *ch == NBSP_CODE)\n\treturn 1;\n#endif\n    return 0;\n}\n\n#ifdef USE_M17N\nstatic int\nis_combining_char(unsigned char *ch)\n{\n    Lineprop ctype = get_mctype(ch);\n\n    if (ctype & PC_WCHAR2)\n\treturn 1;\n    return 0;\n}\n#endif\n\nint\nis_boundary(unsigned char *ch1, unsigned char *ch2)\n{\n    if (!*ch1 || !*ch2)\n\treturn 1;\n\n    if (*ch1 == ' ' && *ch2 == ' ')\n\treturn 0;\n\n    if (*ch1 != ' ' && is_period_char(ch2))\n\treturn 0;\n\n    if (*ch2 != ' ' && is_beginning_char(ch1))\n\treturn 0;\n\n#ifdef USE_M17N\n    if (is_combining_char(ch2))\n\treturn 0;\n#endif\n    if (is_word_char(ch1) && is_word_char(ch2))\n\treturn 0;\n\n    return 1;\n}\n\n\nstatic void\nset_breakpoint(struct readbuffer *obuf, int tag_length)\n{\n    obuf->bp.len = obuf->line->length;\n    obuf->bp.pos = obuf->pos;\n    obuf->bp.tlen = tag_length;\n    obuf->bp.flag = obuf->flag;\n#ifdef FORMAT_NICE\n    obuf->bp.flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n    obuf->bp.top_margin = obuf->top_margin;\n    obuf->bp.bottom_margin = obuf->bottom_margin;\n\n    if (!obuf->bp.init_flag)\n\treturn;\n\n    bcopy((void *)&obuf->anchor, (void *)&obuf->bp.anchor,\n\t  sizeof(obuf->anchor));\n    obuf->bp.img_alt = obuf->img_alt;\n    obuf->bp.input_alt = obuf->input_alt;\n    obuf->bp.in_bold = obuf->in_bold;\n    obuf->bp.in_italic = obuf->in_italic;\n    obuf->bp.in_under = obuf->in_under;\n    obuf->bp.in_strike = obuf->in_strike;\n    obuf->bp.in_ins = obuf->in_ins;\n    obuf->bp.nobr_level = obuf->nobr_level;\n    obuf->bp.prev_ctype = obuf->prev_ctype;\n    obuf->bp.init_flag = 0;\n}\n\nstatic void\nback_to_breakpoint(struct readbuffer *obuf)\n{\n    obuf->flag = obuf->bp.flag;\n    bcopy((void *)&obuf->bp.anchor, (void *)&obuf->anchor,\n\t  sizeof(obuf->anchor));\n    obuf->img_alt = obuf->bp.img_alt;\n    obuf->input_alt = obuf->bp.input_alt;\n    obuf->in_bold = obuf->bp.in_bold;\n    obuf->in_italic = obuf->bp.in_italic;\n    obuf->in_under = obuf->bp.in_under;\n    obuf->in_strike = obuf->bp.in_strike;\n    obuf->in_ins = obuf->bp.in_ins;\n    obuf->prev_ctype = obuf->bp.prev_ctype;\n    obuf->pos = obuf->bp.pos;\n    obuf->top_margin = obuf->bp.top_margin;\n    obuf->bottom_margin = obuf->bp.bottom_margin;\n    if (obuf->flag & RB_NOBR)\n\tobuf->nobr_level = obuf->bp.nobr_level;\n}\n\nstatic void\nappend_tags(struct readbuffer *obuf)\n{\n    int i;\n    int len = obuf->line->length;\n    int set_bp = 0;\n\n    for (i = 0; i < obuf->tag_sp; i++) {\n\tswitch (obuf->tag_stack[i]->cmd) {\n\tcase HTML_A:\n\tcase HTML_IMG_ALT:\n\tcase HTML_B:\n\tcase HTML_U:\n\tcase HTML_I:\n\tcase HTML_S:\n\t    push_link(obuf->tag_stack[i]->cmd, obuf->line->length, obuf->pos);\n\t    break;\n\t}\n\tStrcat_charp(obuf->line, obuf->tag_stack[i]->cmdname);\n\tswitch (obuf->tag_stack[i]->cmd) {\n\tcase HTML_NOBR:\n\t    if (obuf->nobr_level > 1)\n\t\tbreak;\n\tcase HTML_WBR:\n\t    set_bp = 1;\n\t    break;\n\t}\n    }\n    obuf->tag_sp = 0;\n    if (set_bp)\n\tset_breakpoint(obuf, obuf->line->length - len);\n}\n\nstatic void\npush_tag(struct readbuffer *obuf, char *cmdname, int cmd)\n{\n    obuf->tag_stack[obuf->tag_sp] = New(struct cmdtable);\n    obuf->tag_stack[obuf->tag_sp]->cmdname = allocStr(cmdname, -1);\n    obuf->tag_stack[obuf->tag_sp]->cmd = cmd;\n    obuf->tag_sp++;\n    if (obuf->tag_sp >= TAG_STACK_SIZE || obuf->flag & (RB_SPECIAL & ~RB_NOBR))\n\tappend_tags(obuf);\n}\n\nstatic void\npush_nchars(struct readbuffer *obuf, int width,\n\t    char *str, int len, Lineprop mode)\n{\n    append_tags(obuf);\n    Strcat_charp_n(obuf->line, str, len);\n    obuf->pos += width;\n    if (width > 0) {\n\tset_prevchar(obuf->prevchar, str, len);\n\tobuf->prev_ctype = mode;\n    }\n    obuf->flag |= RB_NFLUSHED;\n}\n\n#define push_charp(obuf, width, str, mode)\\\npush_nchars(obuf, width, str, strlen(str), mode)\n\n#define push_str(obuf, width, str, mode)\\\npush_nchars(obuf, width, str->ptr, str->length, mode)\n\nstatic void\ncheck_breakpoint(struct readbuffer *obuf, int pre_mode, char *ch)\n{\n    int tlen, len = obuf->line->length;\n\n    append_tags(obuf);\n    if (pre_mode)\n\treturn;\n    tlen = obuf->line->length - len;\n    if (tlen > 0\n\t|| is_boundary((unsigned char *)obuf->prevchar->ptr,\n\t\t       (unsigned char *)ch))\n\tset_breakpoint(obuf, tlen);\n}\n\nstatic void\npush_char(struct readbuffer *obuf, int pre_mode, char ch)\n{\n    check_breakpoint(obuf, pre_mode, &ch);\n    Strcat_char(obuf->line, ch);\n    obuf->pos++;\n    set_prevchar(obuf->prevchar, &ch, 1);\n    if (ch != ' ')\n\tobuf->prev_ctype = PC_ASCII;\n    obuf->flag |= RB_NFLUSHED;\n}\n\n#define PUSH(c) push_char(obuf, obuf->flag & RB_SPECIAL, c)\n\nstatic void\npush_spaces(struct readbuffer *obuf, int pre_mode, int width)\n{\n    int i;\n\n    if (width <= 0)\n\treturn;\n    check_breakpoint(obuf, pre_mode, \" \");\n    for (i = 0; i < width; i++)\n\tStrcat_char(obuf->line, ' ');\n    obuf->pos += width;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->flag |= RB_NFLUSHED;\n}\n\nstatic void\nproc_mchar(struct readbuffer *obuf, int pre_mode,\n\t   int width, char **str, Lineprop mode)\n{\n    check_breakpoint(obuf, pre_mode, *str);\n    obuf->pos += width;\n    Strcat_charp_n(obuf->line, *str, get_mclen(*str));\n    if (width > 0) {\n\tset_prevchar(obuf->prevchar, *str, 1);\n\tif (**str != ' ')\n\t    obuf->prev_ctype = mode;\n    }\n    (*str) += get_mclen(*str);\n    obuf->flag |= RB_NFLUSHED;\n}\n\nvoid\npush_render_image(Str str, int width, int limit,\n\t\t  struct html_feed_environ *h_env)\n{\n    struct readbuffer *obuf = h_env->obuf;\n    int indent = h_env->envs[h_env->envc].indent;\n\n    push_spaces(obuf, 1, (limit - width) / 2);\n    push_str(obuf, width, str, PC_ASCII);\n    push_spaces(obuf, 1, (limit - width + 1) / 2);\n    if (width > 0)\n\tflushline(h_env, obuf, indent, 0, h_env->limit);\n}\n\nstatic int\nsloppy_parse_line(char **str)\n{\n    if (**str == '<') {\n\twhile (**str && **str != '>')\n\t    (*str)++;\n\tif (**str == '>')\n\t    (*str)++;\n\treturn 1;\n    }\n    else {\n\twhile (**str && **str != '<')\n\t    (*str)++;\n\treturn 0;\n    }\n}\n\nstatic void\npassthrough(struct readbuffer *obuf, char *str, int back)\n{\n    int cmd;\n    Str tok = Strnew();\n    char *str_bak;\n\n    if (back) {\n\tStr str_save = Strnew_charp(str);\n\tStrshrink(obuf->line, obuf->line->ptr + obuf->line->length - str);\n\tstr = str_save->ptr;\n    }\n    while (*str) {\n\tstr_bak = str;\n\tif (sloppy_parse_line(&str)) {\n\t    char *q = str_bak;\n\t    cmd = gethtmlcmd(&q);\n\t    if (back) {\n\t\tstruct link_stack *p;\n\t\tfor (p = link_stack; p; p = p->next) {\n\t\t    if (p->cmd == cmd) {\n\t\t\tlink_stack = p->next;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tback = 0;\n\t    }\n\t    else {\n\t\tStrcat_charp_n(tok, str_bak, str - str_bak);\n\t\tpush_tag(obuf, tok->ptr, cmd);\n\t\tStrclear(tok);\n\t    }\n\t}\n\telse {\n\t    push_nchars(obuf, 0, str_bak, str - str_bak, obuf->prev_ctype);\n\t}\n    }\n}\n\n#if 0\nint\nis_blank_line(char *line, int indent)\n{\n    int i, is_blank = 0;\n\n    for (i = 0; i < indent; i++) {\n\tif (line[i] == '\\0') {\n\t    is_blank = 1;\n\t}\n\telse if (line[i] != ' ') {\n\t    break;\n\t}\n    }\n    if (i == indent && line[i] == '\\0')\n\tis_blank = 1;\n    return is_blank;\n}\n#endif\n\nvoid\nfillline(struct readbuffer *obuf, int indent)\n{\n    push_spaces(obuf, 1, indent - obuf->pos);\n    obuf->flag &= ~RB_NFLUSHED;\n}\n\nvoid\nflushline(struct html_feed_environ *h_env, struct readbuffer *obuf, int indent,\n\t  int force, int width)\n{\n    TextLineList *buf = h_env->buf;\n    FILE *f = h_env->f;\n    Str line = obuf->line, pass = NULL;\n    char *hidden_anchor = NULL, *hidden_img = NULL, *hidden_bold = NULL,\n\t*hidden_under = NULL, *hidden_italic = NULL, *hidden_strike = NULL,\n\t*hidden_ins = NULL, *hidden_input = NULL, *hidden = NULL;\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *df = fopen(\"zzzproc1\", \"a\");\n\tfprintf(df, \"flushline(%s,%d,%d,%d)\\n\", obuf->line->ptr, indent, force,\n\t\twidth);\n\tif (buf) {\n\t    TextLineListItem *p;\n\t    for (p = buf->first; p; p = p->next) {\n\t\tfprintf(df, \"buf=\\\"%s\\\"\\n\", p->ptr->line->ptr);\n\t    }\n\t}\n\tfclose(df);\n    }\n#endif\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && Strlastchar(line) == ' ') {\n\tStrshrink(line, 1);\n\tobuf->pos--;\n    }\n\n    append_tags(obuf);\n\n    if (obuf->anchor.url)\n\thidden = hidden_anchor = has_hidden_link(obuf, HTML_A);\n    if (obuf->img_alt) {\n\tif ((hidden_img = has_hidden_link(obuf, HTML_IMG_ALT)) != NULL) {\n\t    if (!hidden || hidden_img < hidden)\n\t\thidden = hidden_img;\n\t}\n    }\n    if (obuf->input_alt.in) {\n\tif ((hidden_input = has_hidden_link(obuf, HTML_INPUT_ALT)) != NULL) {\n\t    if (!hidden || hidden_input < hidden)\n\t\thidden = hidden_input;\n\t}\n    }\n    if (obuf->in_bold) {\n\tif ((hidden_bold = has_hidden_link(obuf, HTML_B)) != NULL) {\n\t    if (!hidden || hidden_bold < hidden)\n\t\thidden = hidden_bold;\n\t}\n    }\n    if (obuf->in_italic) {\n\tif ((hidden_italic = has_hidden_link(obuf, HTML_I)) != NULL) {\n\t    if (!hidden || hidden_italic < hidden)\n\t\thidden = hidden_italic;\n\t}\n    }\n    if (obuf->in_under) {\n\tif ((hidden_under = has_hidden_link(obuf, HTML_U)) != NULL) {\n\t    if (!hidden || hidden_under < hidden)\n\t\thidden = hidden_under;\n\t}\n    }\n    if (obuf->in_strike) {\n\tif ((hidden_strike = has_hidden_link(obuf, HTML_S)) != NULL) {\n\t    if (!hidden || hidden_strike < hidden)\n\t\thidden = hidden_strike;\n\t}\n    }\n    if (obuf->in_ins) {\n\tif ((hidden_ins = has_hidden_link(obuf, HTML_INS)) != NULL) {\n\t    if (!hidden || hidden_ins < hidden)\n\t\thidden = hidden_ins;\n\t}\n    }\n    if (hidden) {\n\tpass = Strnew_charp(hidden);\n\tStrshrink(line, line->ptr + line->length - hidden);\n    }\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && obuf->pos > width) {\n\tchar *tp = &line->ptr[obuf->bp.len - obuf->bp.tlen];\n\tchar *ep = &line->ptr[line->length];\n\n\tif (obuf->bp.pos == obuf->pos && tp <= ep &&\n\t    tp > line->ptr && tp[-1] == ' ') {\n\t    bcopy(tp, tp - 1, ep - tp + 1);\n\t    line->length--;\n\t    obuf->pos--;\n\t}\n    }\n\n    if (obuf->anchor.url && !hidden_anchor)\n\tStrcat_charp(line, \"</a>\");\n    if (obuf->img_alt && !hidden_img)\n\tStrcat_charp(line, \"</img_alt>\");\n    if (obuf->input_alt.in && !hidden_input)\n\tStrcat_charp(line, \"</input_alt>\");\n    if (obuf->in_bold && !hidden_bold)\n\tStrcat_charp(line, \"</b>\");\n    if (obuf->in_italic && !hidden_italic)\n\tStrcat_charp(line, \"</i>\");\n    if (obuf->in_under && !hidden_under)\n\tStrcat_charp(line, \"</u>\");\n    if (obuf->in_strike && !hidden_strike)\n\tStrcat_charp(line, \"</s>\");\n    if (obuf->in_ins && !hidden_ins)\n\tStrcat_charp(line, \"</ins>\");\n\n    if (obuf->top_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \"<pre_int>\");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \"</pre_int>\");\n\tfor (i = 0; i < obuf->top_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n\n    if (force == 1 || obuf->flag & RB_NFLUSHED) {\n\tTextLine *lbuf = newTextLine(line, obuf->pos);\n\tif (RB_GET_ALIGN(obuf) == RB_CENTER) {\n\t    align(lbuf, width, ALIGN_CENTER);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_RIGHT) {\n\t    align(lbuf, width, ALIGN_RIGHT);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_LEFT && obuf->flag & RB_INTABLE) {\n\t    align(lbuf, width, ALIGN_LEFT);\n\t}\n#ifdef FORMAT_NICE\n\telse if (obuf->flag & RB_FILL) {\n\t    char *p;\n\t    int rest, rrest;\n\t    int nspace, d, i;\n\n\t    rest = width - get_Str_strwidth(line);\n\t    if (rest > 1) {\n\t\tnspace = 0;\n\t\tfor (p = line->ptr + indent; *p; p++) {\n\t\t    if (*p == ' ')\n\t\t\tnspace++;\n\t\t}\n\t\tif (nspace > 0) {\n\t\t    int indent_here = 0;\n\t\t    d = rest / nspace;\n\t\t    p = line->ptr;\n\t\t    while (IS_SPACE(*p)) {\n\t\t\tp++;\n\t\t\tindent_here++;\n\t\t    }\n\t\t    rrest = rest - d * nspace;\n\t\t    line = Strnew_size(width + 1);\n\t\t    for (i = 0; i < indent_here; i++)\n\t\t\tStrcat_char(line, ' ');\n\t\t    for (; *p; p++) {\n\t\t\tStrcat_char(line, *p);\n\t\t\tif (*p == ' ') {\n\t\t\t    for (i = 0; i < d; i++)\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t    if (rrest > 0) {\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t\trrest--;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    lbuf = newTextLine(line, width);\n\t\t}\n\t    }\n\t}\n#endif\t\t\t\t/* FORMAT_NICE */\n#ifdef TABLE_DEBUG\n\tif (w3m_debug) {\n\t    FILE *f = fopen(\"zzzproc1\", \"a\");\n\t    fprintf(f, \"pos=%d,%d, maxlimit=%d\\n\",\n\t\t    visible_length(lbuf->line->ptr), lbuf->pos,\n\t\t    h_env->maxlimit);\n\t    fclose(f);\n\t}\n#endif\n\tif (lbuf->pos > h_env->maxlimit)\n\t    h_env->maxlimit = lbuf->pos;\n\tif (buf)\n\t    pushTextLine(buf, lbuf);\n\telse if (f) {\n\t    Strfputs(Str_conv_to_halfdump(lbuf->line), f);\n\t    fputc('\\n', f);\n\t}\n\tif (obuf->flag & RB_SPECIAL || obuf->flag & RB_NFLUSHED)\n\t    h_env->blank_lines = 0;\n\telse\n\t    h_env->blank_lines++;\n    }\n    else {\n\tchar *p = line->ptr, *q;\n\tStr tmp = Strnew(), tmp2 = Strnew();\n\n#define APPEND(str) \\\n\tif (buf) \\\n\t    appendTextLine(buf,(str),0); \\\n\telse if (f) \\\n\t    Strfputs((str),f)\n\n\twhile (*p) {\n\t    q = p;\n\t    if (sloppy_parse_line(&p)) {\n\t\tStrcat_charp_n(tmp, q, p - q);\n\t\tif (force == 2) {\n\t\t    APPEND(tmp);\n\t\t}\n\t\telse\n\t\t    Strcat(tmp2, tmp);\n\t\tStrclear(tmp);\n\t    }\n\t}\n\tif (force == 2) {\n\t    if (pass) {\n\t\tAPPEND(pass);\n\t    }\n\t    pass = NULL;\n\t}\n\telse {\n\t    if (pass)\n\t\tStrcat(tmp2, pass);\n\t    pass = tmp2;\n\t}\n    }\n\n    if (obuf->bottom_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \"<pre_int>\");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \"</pre_int>\");\n\tfor (i = 0; i < obuf->bottom_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n    if (obuf->top_margin < 0 || obuf->bottom_margin < 0)\n\treturn;\n\n    obuf->line = Strnew_size(256);\n    obuf->pos = 0;\n    obuf->top_margin = 0;\n    obuf->bottom_margin = 0;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->bp.init_flag = 1;\n    obuf->flag &= ~RB_NFLUSHED;\n    set_breakpoint(obuf, 0);\n    obuf->prev_ctype = PC_ASCII;\n    link_stack = NULL;\n    fillline(obuf, indent);\n    if (pass)\n\tpassthrough(obuf, pass->ptr, 0);\n    if (!hidden_anchor && obuf->anchor.url) {\n\tStr tmp;\n\tif (obuf->anchor.hseq > 0)\n\t    obuf->anchor.hseq = -obuf->anchor.hseq;\n\ttmp = Sprintf(\"<A HSEQ=\\\"%d\\\" HREF=\\\"\", obuf->anchor.hseq);\n\tStrcat_charp(tmp, html_quote(obuf->anchor.url));\n\tif (obuf->anchor.target) {\n\t    Strcat_charp(tmp, \"\\\" TARGET=\\\"\");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.target));\n\t}\n\tif (obuf->anchor.referer) {\n\t    Strcat_charp(tmp, \"\\\" REFERER=\\\"\");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.referer));\n\t}\n\tif (obuf->anchor.title) {\n\t    Strcat_charp(tmp, \"\\\" TITLE=\\\"\");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.title));\n\t}\n\tif (obuf->anchor.accesskey) {\n\t    char *c = html_quote_char(obuf->anchor.accesskey);\n\t    Strcat_charp(tmp, \"\\\" ACCESSKEY=\\\"\");\n\t    if (c)\n\t\tStrcat_charp(tmp, c);\n\t    else\n\t\tStrcat_char(tmp, obuf->anchor.accesskey);\n\t}\n\tStrcat_charp(tmp, \"\\\">\");\n\tpush_tag(obuf, tmp->ptr, HTML_A);\n    }\n    if (!hidden_img && obuf->img_alt) {\n\tStr tmp = Strnew_charp(\"<IMG_ALT SRC=\\\"\");\n\tStrcat_charp(tmp, html_quote(obuf->img_alt->ptr));\n\tStrcat_charp(tmp, \"\\\">\");\n\tpush_tag(obuf, tmp->ptr, HTML_IMG_ALT);\n    }\n    if (!hidden_input && obuf->input_alt.in) {\n\tStr tmp;\n\tif (obuf->input_alt.hseq > 0)\n\t    obuf->input_alt.hseq = - obuf->input_alt.hseq;\n\ttmp = Sprintf(\"<INPUT_ALT hseq=\\\"%d\\\" fid=\\\"%d\\\" name=\\\"%s\\\" type=\\\"%s\\\" value=\\\"%s\\\">\",\n\t\t     obuf->input_alt.hseq,\n\t\t     obuf->input_alt.fid,\n\t\t     obuf->input_alt.name ? obuf->input_alt.name->ptr : \"\",\n\t\t     obuf->input_alt.type ? obuf->input_alt.type->ptr : \"\",\n\t\t     obuf->input_alt.value ? obuf->input_alt.value->ptr : \"\");\n\tpush_tag(obuf, tmp->ptr, HTML_INPUT_ALT);\n    }\n    if (!hidden_bold && obuf->in_bold)\n\tpush_tag(obuf, \"<B>\", HTML_B);\n    if (!hidden_italic && obuf->in_italic)\n\tpush_tag(obuf, \"<I>\", HTML_I);\n    if (!hidden_under && obuf->in_under)\n\tpush_tag(obuf, \"<U>\", HTML_U);\n    if (!hidden_strike && obuf->in_strike)\n\tpush_tag(obuf, \"<S>\", HTML_S);\n    if (!hidden_ins && obuf->in_ins)\n\tpush_tag(obuf, \"<INS>\", HTML_INS);\n}\n\nvoid\ndo_blankline(struct html_feed_environ *h_env, struct readbuffer *obuf,\n\t     int indent, int indent_incr, int width)\n{\n    if (h_env->blank_lines == 0)\n\tflushline(h_env, obuf, indent, 1, width);\n}\n\nvoid\npurgeline(struct html_feed_environ *h_env)\n{\n    char *p, *q;\n    Str tmp;\n\n    if (h_env->buf == NULL || h_env->blank_lines == 0)\n\treturn;\n\n    p = rpopTextLine(h_env->buf)->line->ptr;\n    tmp = Strnew();\n    while (*p) {\n\tq = p;\n\tif (sloppy_parse_line(&p)) {\n\t    Strcat_charp_n(tmp, q, p - q);\n\t}\n    }\n    appendTextLine(h_env->buf, tmp, 0);\n    h_env->blank_lines--;\n}\n\nstatic int\nclose_effect0(struct readbuffer *obuf, int cmd)\n{\n    int i;\n    char *p;\n\n    for (i = obuf->tag_sp - 1; i >= 0; i--) {\n\tif (obuf->tag_stack[i]->cmd == cmd)\n\t    break;\n    }\n    if (i >= 0) {\n\tobuf->tag_sp--;\n\tbcopy(&obuf->tag_stack[i + 1], &obuf->tag_stack[i],\n\t      (obuf->tag_sp - i) * sizeof(struct cmdtable *));\n\treturn 1;\n    }\n    else if ((p = has_hidden_link(obuf, cmd)) != NULL) {\n\tpassthrough(obuf, p, 1);\n\treturn 1;\n    }\n    return 0;\n}\n\nstatic void\nclose_anchor(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    if (obuf->anchor.url) {\n\tint i;\n\tchar *p = NULL;\n\tint is_erased = 0;\n\n\tfor (i = obuf->tag_sp - 1; i >= 0; i--) {\n\t    if (obuf->tag_stack[i]->cmd == HTML_A)\n\t\tbreak;\n\t}\n\tif (i < 0 && obuf->anchor.hseq > 0 && Strlastchar(obuf->line) == ' ') {\n\t    Strshrink(obuf->line, 1);\n\t    obuf->pos--;\n\t    is_erased = 1;\n\t}\n\n\tif (i >= 0 || (p = has_hidden_link(obuf, HTML_A))) {\n\t    if (obuf->anchor.hseq > 0) {\n\t\tHTMLlineproc1(ANSP, h_env);\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t    }\n\t    else {\n\t\tif (i >= 0) {\n\t\t    obuf->tag_sp--;\n\t\t    bcopy(&obuf->tag_stack[i + 1], &obuf->tag_stack[i],\n\t\t\t  (obuf->tag_sp - i) * sizeof(struct cmdtable *));\n\t\t}\n\t\telse {\n\t\t    passthrough(obuf, p, 1);\n\t\t}\n\t\tbzero((void *)&obuf->anchor, sizeof(obuf->anchor));\n\t\treturn;\n\t    }\n\t    is_erased = 0;\n\t}\n\tif (is_erased) {\n\t    Strcat_char(obuf->line, ' ');\n\t    obuf->pos++;\n\t}\n\n\tpush_tag(obuf, \"</a>\", HTML_N_A);\n    }\n    bzero((void *)&obuf->anchor, sizeof(obuf->anchor));\n}\n\nvoid\nsave_fonteffect(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    if (obuf->fontstat_sp < FONT_STACK_SIZE)\n\tbcopy(obuf->fontstat, obuf->fontstat_stack[obuf->fontstat_sp],\n\t      FONTSTAT_SIZE);\n    obuf->fontstat_sp++;\n    if (obuf->in_bold)\n\tpush_tag(obuf, \"</b>\", HTML_N_B);\n    if (obuf->in_italic)\n\tpush_tag(obuf, \"</i>\", HTML_N_I);\n    if (obuf->in_under)\n\tpush_tag(obuf, \"</u>\", HTML_N_U);\n    if (obuf->in_strike)\n\tpush_tag(obuf, \"</s>\", HTML_N_S);\n    if (obuf->in_ins)\n\tpush_tag(obuf, \"</ins>\", HTML_N_INS);\n    bzero(obuf->fontstat, FONTSTAT_SIZE);\n}\n\nvoid\nrestore_fonteffect(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    if (obuf->fontstat_sp > 0)\n\tobuf->fontstat_sp--;\n    if (obuf->fontstat_sp < FONT_STACK_SIZE)\n\tbcopy(obuf->fontstat_stack[obuf->fontstat_sp], obuf->fontstat,\n\t      FONTSTAT_SIZE);\n    if (obuf->in_bold)\n\tpush_tag(obuf, \"<b>\", HTML_B);\n    if (obuf->in_italic)\n\tpush_tag(obuf, \"<i>\", HTML_I);\n    if (obuf->in_under)\n\tpush_tag(obuf, \"<u>\", HTML_U);\n    if (obuf->in_strike)\n\tpush_tag(obuf, \"<s>\", HTML_S);\n    if (obuf->in_ins)\n\tpush_tag(obuf, \"<ins>\", HTML_INS);\n}\n\nstatic Str\nprocess_title(struct parsed_tag *tag)\n{\n    cur_title = Strnew();\n    return NULL;\n}\n\nstatic Str\nprocess_n_title(struct parsed_tag *tag)\n{\n    Str tmp;\n\n    if (!cur_title)\n\treturn NULL;\n    Strremovefirstspaces(cur_title);\n    Strremovetrailingspaces(cur_title);\n    tmp = Strnew_m_charp(\"<title_alt title=\\\"\",\n\t\t\t html_quote(cur_title->ptr), \"\\\">\", NULL);\n    cur_title = NULL;\n    return tmp;\n}\n\nstatic void\nfeed_title(char *str)\n{\n    if (!cur_title)\n\treturn;\n    while (*str) {\n\tif (*str == '&')\n\t    Strcat_charp(cur_title, getescapecmd(&str));\n\telse if (*str == '\\n' || *str == '\\r') {\n\t    Strcat_char(cur_title, ' ');\n\t    str++;\n\t}\n\telse\n\t    Strcat_char(cur_title, *(str++));\n    }\n}\n\nStr\nprocess_img(struct parsed_tag *tag, int width)\n{\n    char *p, *q, *r, *r2 = NULL, *s, *t;\n#ifdef USE_IMAGE\n    int w, i, nw, ni = 1, n, w0 = -1, i0 = -1;\n    int align, xoffset, yoffset, top, bottom, ismap = 0;\n    int use_image = activeImage && displayImage;\n#else\n    int w, i, nw, n;\n#endif\n    int pre_int = FALSE, ext_pre_int = FALSE;\n    Str tmp = Strnew();\n\n    if (!parsedtag_get_value(tag, ATTR_SRC, &p))\n\treturn tmp;\n    p = url_encode(remove_space(p), cur_baseURL, cur_document_charset);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_ALT, &q);\n    if (!pseudoInlines && (q == NULL || (*q == '\\0' && ignore_null_img_alt)))\n\treturn tmp;\n    t = q;\n    parsedtag_get_value(tag, ATTR_TITLE, &t);\n    w = -1;\n    if (parsedtag_get_value(tag, ATTR_WIDTH, &w)) {\n\tif (w < 0) {\n\t    if (width > 0)\n\t\tw = (int)(-width * pixel_per_char * w / 100 + 0.5);\n\t    else\n\t\tw = -1;\n\t}\n#ifdef USE_IMAGE\n\tif (use_image) {\n\t    if (w > 0) {\n\t\tw = (int)(w * image_scale / 100 + 0.5);\n\t\tif (w == 0)\n\t\t    w = 1;\n\t\telse if (w > MAX_IMAGE_SIZE)\n\t\t    w = MAX_IMAGE_SIZE;\n\t    }\n\t}\n#endif\n    }\n#ifdef USE_IMAGE\n    if (use_image) {\n\ti = -1;\n\tif (parsedtag_get_value(tag, ATTR_HEIGHT, &i)) {\n\t    if (i > 0) {\n\t\ti = (int)(i * image_scale / 100 + 0.5);\n\t\tif (i == 0)\n\t\t    i = 1;\n\t\telse if (i > MAX_IMAGE_SIZE)\n\t\t    i = MAX_IMAGE_SIZE;\n\t    }\n\t    else {\n\t\ti = -1;\n\t    }\n\t}\n\talign = -1;\n\tparsedtag_get_value(tag, ATTR_ALIGN, &align);\n\tismap = 0;\n\tif (parsedtag_exists(tag, ATTR_ISMAP))\n\t    ismap = 1;\n    }\n    else\n#endif\n\tparsedtag_get_value(tag, ATTR_HEIGHT, &i);\n    r = NULL;\n    parsedtag_get_value(tag, ATTR_USEMAP, &r);\n    if (parsedtag_exists(tag, ATTR_PRE_INT))\n\text_pre_int = TRUE;\n\n    tmp = Strnew_size(128);\n#ifdef USE_IMAGE\n    if (use_image) {\n\tswitch (align) {\n\tcase ALIGN_LEFT:\n\t    Strcat_charp(tmp, \"<div_int align=left>\");\n\t    break;\n\tcase ALIGN_CENTER:\n\t    Strcat_charp(tmp, \"<div_int align=center>\");\n\t    break;\n\tcase ALIGN_RIGHT:\n\t    Strcat_charp(tmp, \"<div_int align=right>\");\n\t    break;\n\t}\n    }\n#endif\n    if (r) {\n\tStr tmp2;\n\tr2 = strchr(r, '#');\n\ts = \"<form_int method=internal action=map>\";\n\ttmp2 = process_form(parse_tag(&s, TRUE));\n\tif (tmp2)\n\t    Strcat(tmp, tmp2);\n\tStrcat(tmp, Sprintf(\"<input_alt fid=\\\"%d\\\" \"\n\t\t\t    \"type=hidden name=link value=\\\"\", cur_form_id));\n\tStrcat_charp(tmp, html_quote((r2) ? r2 + 1 : r));\n\tStrcat(tmp, Sprintf(\"\\\"><input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" \"\n\t\t\t    \"type=submit no_effect=true>\",\n\t\t\t    cur_hseq++, cur_form_id));\n    }\n#ifdef USE_IMAGE\n    if (use_image) {\n\tw0 = w;\n\ti0 = i;\n\tif (w < 0 || i < 0) {\n\t    Image image;\n\t    ParsedURL u;\n\n\t    parseURL2(p, &u, cur_baseURL);\n\t    image.url = parsedURL2Str(&u)->ptr;\n\t    if (!uncompressed_file_type(u.file, &image.ext))\n\t\timage.ext = filename_extension(u.file, TRUE);\n\t    image.cache = NULL;\n\t    image.width = w;\n\t    image.height = i;\n\n\t    image.cache = getImage(&image, cur_baseURL, IMG_FLAG_SKIP);\n\t    if (image.cache && image.cache->width > 0 &&\n\t\timage.cache->height > 0) {\n\t\tw = w0 = image.cache->width;\n\t\ti = i0 = image.cache->height;\n\t    }\n\t    if (w < 0)\n\t\tw = 8 * pixel_per_char;\n\t    if (i < 0)\n\t\ti = pixel_per_line;\n\t}\n\tif (enable_inline_image) {\n\t    nw = (w > 1) ? ((w - 1) / pixel_per_char_i + 1) : 1 ;\n\t    ni = (i > 1) ? ((i - 1) / pixel_per_line_i + 1) : 1 ;\n\t}\n\telse {\n\t    nw = (w > 3) ? (int)((w - 3) / pixel_per_char + 1) : 1;\n\t    ni = (i > 3) ? (int)((i - 3) / pixel_per_line + 1) : 1;\n\t}\n\tStrcat(tmp,\n\t       Sprintf(\"<pre_int><img_alt hseq=\\\"%d\\\" src=\\\"\", cur_iseq++));\n\tpre_int = TRUE;\n    }\n    else\n#endif\n    {\n\tif (w < 0)\n\t    w = 12 * pixel_per_char;\n\tnw = w ? (int)((w - 1) / pixel_per_char + 1) : 1;\n\tif (r) {\n\t    Strcat_charp(tmp, \"<pre_int>\");\n\t    pre_int = TRUE;\n\t}\n\tStrcat_charp(tmp, \"<img_alt src=\\\"\");\n    }\n    Strcat_charp(tmp, html_quote(p));\n    Strcat_charp(tmp, \"\\\"\");\n    if (t) {\n\tStrcat_charp(tmp, \" title=\\\"\");\n\tStrcat_charp(tmp, html_quote(t));\n\tStrcat_charp(tmp, \"\\\"\");\n    }\n#ifdef USE_IMAGE\n    if (use_image) {\n\tif (w0 >= 0)\n\t    Strcat(tmp, Sprintf(\" width=%d\", w0));\n\tif (i0 >= 0)\n\t    Strcat(tmp, Sprintf(\" height=%d\", i0));\n\tswitch (align) {\n\tcase ALIGN_MIDDLE:\n\t    if (!enable_inline_image) {\n\t\ttop = ni / 2;\n\t\tbottom = top;\n\t\tif (top * 2 == ni)\n\t\t    yoffset = (int)(((ni + 1) * pixel_per_line - i) / 2);\n\t\telse\n\t\t    yoffset = (int)((ni * pixel_per_line - i) / 2);\n\t\tbreak;\n\t    }\n\tcase ALIGN_TOP:\n\t    top = 0;\n\t    bottom = ni - 1;\n\t    yoffset = 0;\n\t    break;\n\tcase ALIGN_BOTTOM:\n\t    top = ni - 1;\n\t    bottom = 0;\n\t    yoffset = (int)(ni * pixel_per_line - i);\n\t    break;\n\tdefault:\n\t    top = ni - 1;\n\t    bottom = 0;\n\t    if (ni == 1 && ni * pixel_per_line > i)\n\t\tyoffset = 0;\n\t    else {\n\t\tyoffset = (int)(ni * pixel_per_line - i);\n\t\tif (yoffset <= -2)\n\t\t    yoffset++;\n\t    }\n\t    break;\n\t}\n\n\tif (enable_inline_image)\n\t    xoffset = 0;\n\telse\n\t    xoffset = (int)((nw * pixel_per_char - w) / 2);\n\n\tif (xoffset)\n\t    Strcat(tmp, Sprintf(\" xoffset=%d\", xoffset));\n\tif (yoffset)\n\t    Strcat(tmp, Sprintf(\" yoffset=%d\", yoffset));\n\tif (top)\n\t    Strcat(tmp, Sprintf(\" top_margin=%d\", top));\n\tif (bottom)\n\t    Strcat(tmp, Sprintf(\" bottom_margin=%d\", bottom));\n\tif (r) {\n\t    Strcat_charp(tmp, \" usemap=\\\"\");\n\t    Strcat_charp(tmp, html_quote((r2) ? r2 + 1 : r));\n\t    Strcat_charp(tmp, \"\\\"\");\n\t}\n\tif (ismap)\n\t    Strcat_charp(tmp, \" ismap\");\n    }\n#endif\n    Strcat_charp(tmp, \">\");\n    if (q != NULL && *q == '\\0' && ignore_null_img_alt)\n\tq = NULL;\n    if (q != NULL) {\n\tn = get_strwidth(q);\n#ifdef USE_IMAGE\n\tif (use_image) {\n\t    if (n > nw) {\n\t\tchar *r;\n\t\tfor (r = q, n = 0; r; r += get_mclen(r), n += get_mcwidth(r)) {\n\t\t    if (n + get_mcwidth(r) > nw)\n\t\t\tbreak;\n\t\t}\n\t\tStrcat_charp(tmp, html_quote(Strnew_charp_n(q, r - q)->ptr));\n\t    }\n\t    else\n\t\tStrcat_charp(tmp, html_quote(q));\n\t}\n\telse\n#endif\n\t    Strcat_charp(tmp, html_quote(q));\n\tgoto img_end;\n    }\n    if (w > 0 && i > 0) {\n\t/* guess what the image is! */\n\tif (w < 32 && i < 48) {\n\t    /* must be an icon or space */\n\t    n = 1;\n\t    if (strcasestr(p, \"space\") || strcasestr(p, \"blank\"))\n\t\tStrcat_charp(tmp, \"_\");\n\t    else {\n\t\tif (w * i < 8 * 16)\n\t\t    Strcat_charp(tmp, \"*\");\n\t\telse {\n\t\t    if (!pre_int) {\n\t\t\tStrcat_charp(tmp, \"<pre_int>\");\n\t\t\tpre_int = TRUE;\n\t\t    }\n\t\t    push_symbol(tmp, IMG_SYMBOL, symbol_width, 1);\n\t\t    n = symbol_width;\n\t\t}\n\t    }\n\t    goto img_end;\n\t}\n\tif (w > 200 && i < 13) {\n\t    /* must be a horizontal line */\n\t    if (!pre_int) {\n\t\tStrcat_charp(tmp, \"<pre_int>\");\n\t\tpre_int = TRUE;\n\t    }\n\t    w = w / pixel_per_char / symbol_width;\n\t    if (w <= 0)\n\t\tw = 1;\n\t    push_symbol(tmp, HR_SYMBOL, symbol_width, w);\n\t    n = w * symbol_width;\n\t    goto img_end;\n\t}\n    }\n    for (q = p; *q; q++) ;\n    while (q > p && *q != '/')\n\tq--;\n    if (*q == '/')\n\tq++;\n    Strcat_char(tmp, '[');\n    n = 1;\n    p = q;\n    for (; *q; q++) {\n\tif (!IS_ALNUM(*q) && *q != '_' && *q != '-') {\n\t    break;\n\t}\n\tStrcat_char(tmp, *q);\n\tn++;\n\tif (n + 1 >= nw)\n\t    break;\n    }\n    Strcat_char(tmp, ']');\n    n++;\n  img_end:\n#ifdef USE_IMAGE\n    if (use_image) {\n\tfor (; n < nw; n++)\n\t    Strcat_char(tmp, ' ');\n    }\n#endif\n    Strcat_charp(tmp, \"</img_alt>\");\n    if (pre_int && !ext_pre_int)\n\tStrcat_charp(tmp, \"</pre_int>\");\n    if (r) {\n\tStrcat_charp(tmp, \"</input_alt>\");\n\tprocess_n_form();\n    }\n#ifdef USE_IMAGE\n    if (use_image) {\n\tswitch (align) {\n\tcase ALIGN_RIGHT:\n\tcase ALIGN_CENTER:\n\tcase ALIGN_LEFT:\n\t    Strcat_charp(tmp, \"</div_int>\");\n\t    break;\n\t}\n    }\n#endif\n    return tmp;\n}\n\nStr\nprocess_anchor(struct parsed_tag *tag, char *tagbuf)\n{\n    if (parsedtag_need_reconstruct(tag)) {\n\tparsedtag_set_value(tag, ATTR_HSEQ, Sprintf(\"%d\", cur_hseq++)->ptr);\n\treturn parsedtag2str(tag);\n    }\n    else {\n\tStr tmp = Sprintf(\"<a hseq=\\\"%d\\\"\", cur_hseq++);\n\tStrcat_charp(tmp, tagbuf + 2);\n\treturn tmp;\n    }\n}\n\nStr\nprocess_input(struct parsed_tag *tag)\n{\n    int i = 20, v, x, y, z, iw, ih, size = 20;\n    char *q, *p, *r, *p2, *s;\n    Str tmp = NULL;\n    char *qq = \"\";\n    int qlen = 0;\n\n    if (cur_form_id < 0) {\n\tchar *s = \"<form_int method=internal action=none>\";\n\ttmp = process_form(parse_tag(&s, TRUE));\n    }\n    if (tmp == NULL)\n\ttmp = Strnew();\n\n    p = \"text\";\n    parsedtag_get_value(tag, ATTR_TYPE, &p);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_VALUE, &q);\n    r = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &r);\n    parsedtag_get_value(tag, ATTR_SIZE, &size);\n    if (size > MAX_INPUT_SIZE)\n\t    size = MAX_INPUT_SIZE;\n    parsedtag_get_value(tag, ATTR_MAXLENGTH, &i);\n    p2 = NULL;\n    parsedtag_get_value(tag, ATTR_ALT, &p2);\n    x = parsedtag_exists(tag, ATTR_CHECKED);\n    y = parsedtag_exists(tag, ATTR_ACCEPT);\n    z = parsedtag_exists(tag, ATTR_READONLY);\n\n    v = formtype(p);\n    if (v == FORM_UNKNOWN)\n\treturn NULL;\n\n    if (!q) {\n\tswitch (v) {\n\tcase FORM_INPUT_IMAGE:\n\tcase FORM_INPUT_SUBMIT:\n\tcase FORM_INPUT_BUTTON:\n\t    q = \"SUBMIT\";\n\t    break;\n\tcase FORM_INPUT_RESET:\n\t    q = \"RESET\";\n\t    break;\n\t    /* if no VALUE attribute is specified in \n\t     * <INPUT TYPE=CHECKBOX> tag, then the value \"on\" is used \n\t     * as a default value. It is not a part of HTML4.0 \n\t     * specification, but an imitation of Netscape behaviour. \n\t     */\n\tcase FORM_INPUT_CHECKBOX:\n\t    q = \"on\";\n\t}\n    }\n    /* VALUE attribute is not allowed in <INPUT TYPE=FILE> tag. */\n    if (v == FORM_INPUT_FILE)\n\tq = NULL;\n    if (q) {\n\tqq = html_quote(q);\n\tqlen = get_strwidth(q);\n    }\n\n    Strcat_charp(tmp, \"<pre_int>\");\n    switch (v) {\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_CHECKBOX:\n\tif (displayLinkNumber)\n\t    Strcat(tmp, getLinkNumberStr(0));\n\tStrcat_char(tmp, '[');\n\tbreak;\n    case FORM_INPUT_RADIO:\n\tif (displayLinkNumber)\n\t    Strcat(tmp, getLinkNumberStr(0));\n\tStrcat_char(tmp, '(');\n    }\n    Strcat(tmp, Sprintf(\"<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" type=\\\"%s\\\" \"\n\t\t\t\"name=\\\"%s\\\" width=%d maxlength=%d value=\\\"%s\\\"\",\n\t\t\tcur_hseq++, cur_form_id, html_quote(p),\n\t\t\thtml_quote(r), size, i, qq));\n    if (x)\n\tStrcat_charp(tmp, \" checked\");\n    if (y)\n\tStrcat_charp(tmp, \" accept\");\n    if (z)\n\tStrcat_charp(tmp, \" readonly\");\n    Strcat_char(tmp, '>');\n\n    if (v == FORM_INPUT_HIDDEN)\n\tStrcat_charp(tmp, \"</input_alt></pre_int>\");\n    else {\n\tswitch (v) {\n\tcase FORM_INPUT_PASSWORD:\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_FILE:\n\t    Strcat_charp(tmp, \"<u>\");\n\t    break;\n\tcase FORM_INPUT_IMAGE:\n\t    s = NULL;\n\t    parsedtag_get_value(tag, ATTR_SRC, &s);\n\t    if (s) {\n\t\tStrcat(tmp, Sprintf(\"<img src=\\\"%s\\\"\", html_quote(s)));\n\t\tif (p2)\n\t\t    Strcat(tmp, Sprintf(\" alt=\\\"%s\\\"\", html_quote(p2)));\n\t\tif (parsedtag_get_value(tag, ATTR_WIDTH, &iw))\n\t\t    Strcat(tmp, Sprintf(\" width=\\\"%d\\\"\", iw));\n\t\tif (parsedtag_get_value(tag, ATTR_HEIGHT, &ih))\n\t\t    Strcat(tmp, Sprintf(\" height=\\\"%d\\\"\", ih));\n\t\tStrcat_charp(tmp, \" pre_int>\");\n\t\tStrcat_charp(tmp, \"</input_alt></pre_int>\");\n\t\treturn tmp;\n\t    }\n\tcase FORM_INPUT_SUBMIT:\n\tcase FORM_INPUT_BUTTON:\n\tcase FORM_INPUT_RESET:\n\t    if (displayLinkNumber)\n\t\tStrcat(tmp, getLinkNumberStr(-1));\n\t    Strcat_charp(tmp, \"[\");\n\t    break;\n\t}\n\tswitch (v) {\n\tcase FORM_INPUT_PASSWORD:\n\t    i = 0;\n\t    if (q) {\n\t\tfor (; i < qlen && i < size; i++)\n\t\t    Strcat_char(tmp, '*');\n\t    }\n\t    for (; i < size; i++)\n\t\tStrcat_char(tmp, ' ');\n\t    break;\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_FILE:\n\t    if (q)\n\t\tStrcat(tmp, textfieldrep(Strnew_charp(q), size));\n\t    else {\n\t\tfor (i = 0; i < size; i++)\n\t\t    Strcat_char(tmp, ' ');\n\t    }\n\t    break;\n\tcase FORM_INPUT_SUBMIT:\n\tcase FORM_INPUT_BUTTON:\n\t    if (p2)\n\t\tStrcat_charp(tmp, html_quote(p2));\n\t    else\n\t\tStrcat_charp(tmp, qq);\n\t    break;\n\tcase FORM_INPUT_RESET:\n\t    Strcat_charp(tmp, qq);\n\t    break;\n\tcase FORM_INPUT_RADIO:\n\tcase FORM_INPUT_CHECKBOX:\n\t    if (x)\n\t\tStrcat_char(tmp, '*');\n\t    else\n\t\tStrcat_char(tmp, ' ');\n\t    break;\n\t}\n\tswitch (v) {\n\tcase FORM_INPUT_PASSWORD:\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_FILE:\n\t    Strcat_charp(tmp, \"</u>\");\n\t    break;\n\tcase FORM_INPUT_IMAGE:\n\tcase FORM_INPUT_SUBMIT:\n\tcase FORM_INPUT_BUTTON:\n\tcase FORM_INPUT_RESET:\n\t    Strcat_charp(tmp, \"]\");\n\t}\n\tStrcat_charp(tmp, \"</input_alt>\");\n\tswitch (v) {\n\tcase FORM_INPUT_PASSWORD:\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_FILE:\n\tcase FORM_INPUT_CHECKBOX:\n\t    Strcat_char(tmp, ']');\n\t    break;\n\tcase FORM_INPUT_RADIO:\n\t    Strcat_char(tmp, ')');\n\t}\n\tStrcat_charp(tmp, \"</pre_int>\");\n    }\n    return tmp;\n}\n\nStr\nprocess_button(struct parsed_tag *tag)\n{\n    Str tmp = NULL;\n    char *p, *q, *r, *qq = \"\";\n    int qlen, v;\n\n    if (cur_form_id < 0) {\n       char *s = \"<form_int method=internal action=none>\";\n       tmp = process_form(parse_tag(&s, TRUE));\n    }\n    if (tmp == NULL)\n       tmp = Strnew();\n\n    p = \"submit\";\n    parsedtag_get_value(tag, ATTR_TYPE, &p);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_VALUE, &q);\n    r = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &r);\n\n    v = formtype(p);\n    if (v == FORM_UNKNOWN)\n       return NULL;\n\n    switch (v) {\n    case FORM_INPUT_SUBMIT:\n    case FORM_INPUT_BUTTON:\n    case FORM_INPUT_RESET:\n\tbreak;\n    default:\n\tp = \"submit\";\n\tv = FORM_INPUT_SUBMIT;\n\tbreak;\n    }\n\n    if (!q) {\n       switch (v) {\n       case FORM_INPUT_SUBMIT:\n       case FORM_INPUT_BUTTON:\n           q = \"SUBMIT\";\n           break;\n       case FORM_INPUT_RESET:\n           q = \"RESET\";\n           break;\n       }\n    }\n    if (q) {\n       qq = html_quote(q);\n       qlen = strlen(q);\n    }\n\n    /*    Strcat_charp(tmp, \"<pre_int>\"); */\n    Strcat(tmp, Sprintf(\"<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" type=\\\"%s\\\" \"\n                       \"name=\\\"%s\\\" value=\\\"%s\\\">\",\n                       cur_hseq++, cur_form_id, html_quote(p),\n                       html_quote(r), qq));\n    return tmp;\n}\n\nStr\nprocess_n_button(void)\n{\n    Str tmp = Strnew();\n    Strcat_charp(tmp, \"</input_alt>\");\n    /*    Strcat_charp(tmp, \"</pre_int>\"); */\n    return tmp;\n}\n\nStr\nprocess_select(struct parsed_tag *tag)\n{\n    Str tmp = NULL;\n    char *p;\n\n    if (cur_form_id < 0) {\n\tchar *s = \"<form_int method=internal action=none>\";\n\ttmp = process_form(parse_tag(&s, TRUE));\n    }\n\n    p = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &p);\n    cur_select = Strnew_charp(p);\n    select_is_multiple = parsedtag_exists(tag, ATTR_MULTIPLE);\n\n#ifdef MENU_SELECT\n    if (!select_is_multiple) {\n\tselect_str = Strnew_charp(\"<pre_int>\");\n\tif (displayLinkNumber)\n\t    Strcat(select_str, getLinkNumberStr(0));\n\tStrcat(select_str, Sprintf(\"[<input_alt hseq=\\\"%d\\\" \"\n\t\t\t     \"fid=\\\"%d\\\" type=select name=\\\"%s\\\" selectnumber=%d\",\n\t\t\t     cur_hseq++, cur_form_id, html_quote(p), n_select));\n\tStrcat_charp(select_str, \">\");\n\tif (n_select == max_select) {\n\t    max_select *= 2;\n\t    select_option =\n\t\tNew_Reuse(FormSelectOption, select_option, max_select);\n\t}\n\tselect_option[n_select].first = NULL;\n\tselect_option[n_select].last = NULL;\n\tcur_option_maxwidth = 0;\n    }\n    else\n#endif\t\t\t\t/* MENU_SELECT */\n\tselect_str = Strnew();\n    cur_option = NULL;\n    cur_status = R_ST_NORMAL;\n    n_selectitem = 0;\n    return tmp;\n}\n\nStr\nprocess_n_select(void)\n{\n    if (cur_select == NULL)\n\treturn NULL;\n    process_option();\n#ifdef MENU_SELECT\n    if (!select_is_multiple) {\n\tif (select_option[n_select].first) {\n\t    FormItemList sitem;\n\t    chooseSelectOption(&sitem, select_option[n_select].first);\n\t    Strcat(select_str, textfieldrep(sitem.label, cur_option_maxwidth));\n\t}\n\tStrcat_charp(select_str, \"</input_alt>]</pre_int>\");\n\tn_select++;\n    }\n    else\n#endif\t\t\t\t/* MENU_SELECT */\n\tStrcat_charp(select_str, \"<br>\");\n    cur_select = NULL;\n    n_selectitem = 0;\n    return select_str;\n}\n\nvoid\nfeed_select(char *str)\n{\n    Str tmp = Strnew();\n    int prev_status = cur_status;\n    static int prev_spaces = -1;\n    char *p;\n\n    if (cur_select == NULL)\n\treturn;\n    while (read_token(tmp, &str, &cur_status, 0, 0)) {\n\tif (cur_status != R_ST_NORMAL || prev_status != R_ST_NORMAL)\n\t    continue;\n\tp = tmp->ptr;\n\tif (tmp->ptr[0] == '<' && Strlastchar(tmp) == '>') {\n\t    struct parsed_tag *tag;\n\t    char *q;\n\t    if (!(tag = parse_tag(&p, FALSE)))\n\t\tcontinue;\n\t    switch (tag->tagid) {\n\t    case HTML_OPTION:\n\t\tprocess_option();\n\t\tcur_option = Strnew();\n\t\tif (parsedtag_get_value(tag, ATTR_VALUE, &q))\n\t\t    cur_option_value = Strnew_charp(q);\n\t\telse\n\t\t    cur_option_value = NULL;\n\t\tif (parsedtag_get_value(tag, ATTR_LABEL, &q))\n\t\t    cur_option_label = Strnew_charp(q);\n\t\telse\n\t\t    cur_option_label = NULL;\n\t\tcur_option_selected = parsedtag_exists(tag, ATTR_SELECTED);\n\t\tprev_spaces = -1;\n\t\tbreak;\n\t    case HTML_N_OPTION:\n\t\t/* do nothing */\n\t\tbreak;\n\t    default:\n\t\t/* never happen */\n\t\tbreak;\n\t    }\n\t}\n\telse if (cur_option) {\n\t    while (*p) {\n\t\tif (IS_SPACE(*p) && prev_spaces != 0) {\n\t\t    p++;\n\t\t    if (prev_spaces > 0)\n\t\t\tprev_spaces++;\n\t\t}\n\t\telse {\n\t\t    if (IS_SPACE(*p))\n\t\t\tprev_spaces = 1;\n\t\t    else\n\t\t\tprev_spaces = 0;\n\t\t    if (*p == '&')\n\t\t\tStrcat_charp(cur_option, getescapecmd(&p));\n\t\t    else\n\t\t\tStrcat_char(cur_option, *(p++));\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid\nprocess_option(void)\n{\n    char begin_char = '[', end_char = ']';\n    int len;\n\n    if (cur_select == NULL || cur_option == NULL)\n\treturn;\n    while (cur_option->length > 0 && IS_SPACE(Strlastchar(cur_option)))\n\tStrshrink(cur_option, 1);\n    if (cur_option_value == NULL)\n\tcur_option_value = cur_option;\n    if (cur_option_label == NULL)\n\tcur_option_label = cur_option;\n#ifdef MENU_SELECT\n    if (!select_is_multiple) {\n\tlen = get_Str_strwidth(cur_option_label);\n\tif (len > cur_option_maxwidth)\n\t    cur_option_maxwidth = len;\n\taddSelectOption(&select_option[n_select],\n\t\t\tcur_option_value,\n\t\t\tcur_option_label, cur_option_selected);\n\treturn;\n    }\n#endif\t\t\t\t/* MENU_SELECT */\n    if (!select_is_multiple) {\n\tbegin_char = '(';\n\tend_char = ')';\n    }\n    Strcat(select_str, Sprintf(\"<br><pre_int>%c<input_alt hseq=\\\"%d\\\" \"\n\t\t\t       \"fid=\\\"%d\\\" type=%s name=\\\"%s\\\" value=\\\"%s\\\"\",\n\t\t\t       begin_char, cur_hseq++, cur_form_id,\n\t\t\t       select_is_multiple ? \"checkbox\" : \"radio\",\n\t\t\t       html_quote(cur_select->ptr),\n\t\t\t       html_quote(cur_option_value->ptr)));\n    if (cur_option_selected)\n\tStrcat_charp(select_str, \" checked>*</input_alt>\");\n    else\n\tStrcat_charp(select_str, \"> </input_alt>\");\n    Strcat_char(select_str, end_char);\n    Strcat_charp(select_str, html_quote(cur_option_label->ptr));\n    Strcat_charp(select_str, \"</pre_int>\");\n    n_selectitem++;\n}\n\nStr\nprocess_textarea(struct parsed_tag *tag, int width)\n{\n    Str tmp = NULL;\n    char *p;\n#define TEXTAREA_ATTR_COL_MAX 4096\n#define TEXTAREA_ATTR_ROWS_MAX 4096\n\n    if (cur_form_id < 0) {\n\tchar *s = \"<form_int method=internal action=none>\";\n\ttmp = process_form(parse_tag(&s, TRUE));\n    }\n\n    p = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &p);\n    cur_textarea = Strnew_charp(p);\n    cur_textarea_size = 20;\n    if (parsedtag_get_value(tag, ATTR_COLS, &p)) {\n\tcur_textarea_size = atoi(p);\n\tif (p[strlen(p) - 1] == '%')\n\t    cur_textarea_size = width * cur_textarea_size / 100 - 2;\n\tif (cur_textarea_size <= 0) {\n\t    cur_textarea_size = 20;\n\t} else if (cur_textarea_size > TEXTAREA_ATTR_COL_MAX) {\n\t    cur_textarea_size = TEXTAREA_ATTR_COL_MAX;\n\t}\n    }\n    cur_textarea_rows = 1;\n    if (parsedtag_get_value(tag, ATTR_ROWS, &p)) {\n\tcur_textarea_rows = atoi(p);\n\tif (cur_textarea_rows <= 0) {\n\t    cur_textarea_rows = 1;\n\t} else if (cur_textarea_rows > TEXTAREA_ATTR_ROWS_MAX) {\n\t    cur_textarea_rows = TEXTAREA_ATTR_ROWS_MAX;\n\t}\n    }\n    cur_textarea_readonly = parsedtag_exists(tag, ATTR_READONLY);\n    if (n_textarea >= max_textarea) {\n\tmax_textarea *= 2;\n\ttextarea_str = New_Reuse(Str, textarea_str, max_textarea);\n    }\n    textarea_str[n_textarea] = Strnew();\n    ignore_nl_textarea = TRUE;\n\n    return tmp;\n}\n\nStr\nprocess_n_textarea(void)\n{\n    Str tmp;\n    int i;\n\n    if (cur_textarea == NULL)\n\treturn NULL;\n\n    tmp = Strnew();\n    Strcat(tmp, Sprintf(\"<pre_int>[<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" \"\n\t\t\t\"type=textarea name=\\\"%s\\\" size=%d rows=%d \"\n\t\t\t\"top_margin=%d textareanumber=%d\",\n\t\t\tcur_hseq, cur_form_id,\n\t\t\thtml_quote(cur_textarea->ptr),\n\t\t\tcur_textarea_size, cur_textarea_rows,\n\t\t\tcur_textarea_rows - 1, n_textarea));\n    if (cur_textarea_readonly)\n\tStrcat_charp(tmp, \" readonly\");\n    Strcat_charp(tmp, \"><u>\");\n    for (i = 0; i < cur_textarea_size; i++)\n\tStrcat_char(tmp, ' ');\n    Strcat_charp(tmp, \"</u></input_alt>]</pre_int>\\n\");\n    cur_hseq++;\n    n_textarea++;\n    cur_textarea = NULL;\n\n    return tmp;\n}\n\nvoid\nfeed_textarea(char *str)\n{\n    if (cur_textarea == NULL)\n\treturn;\n    if (ignore_nl_textarea) {\n\tif (*str == '\\r')\n\t    str++;\n\tif (*str == '\\n')\n\t    str++;\n    }\n    ignore_nl_textarea = FALSE;\n    while (*str) {\n\tif (*str == '&')\n\t    Strcat_charp(textarea_str[n_textarea], getescapecmd(&str));\n\telse if (*str == '\\n') {\n\t    Strcat_charp(textarea_str[n_textarea], \"\\r\\n\");\n\t    str++;\n\t}\n\telse if (*str != '\\r')\n\t    Strcat_char(textarea_str[n_textarea], *(str++));\n    }\n}\n\nStr\nprocess_hr(struct parsed_tag *tag, int width, int indent_width)\n{\n    Str tmp = Strnew_charp(\"<nobr>\");\n    int w = 0;\n    int x = ALIGN_CENTER;\n#define HR_ATTR_WIDTH_MAX 65535\n\n    if (width > indent_width)\n\twidth -= indent_width;\n    if (parsedtag_get_value(tag, ATTR_WIDTH, &w)) {\n\tif (w > HR_ATTR_WIDTH_MAX) {\n\t    w = HR_ATTR_WIDTH_MAX;\n\t}\n\tw = REAL_WIDTH(w, width);\n    } else {\n\tw = width;\n    }\n\n    parsedtag_get_value(tag, ATTR_ALIGN, &x);\n    switch (x) {\n    case ALIGN_CENTER:\n\tStrcat_charp(tmp, \"<div_int align=center>\");\n\tbreak;\n    case ALIGN_RIGHT:\n\tStrcat_charp(tmp, \"<div_int align=right>\");\n\tbreak;\n    case ALIGN_LEFT:\n\tStrcat_charp(tmp, \"<div_int align=left>\");\n\tbreak;\n    }\n    w /= symbol_width;\n    if (w <= 0)\n\tw = 1;\n    push_symbol(tmp, HR_SYMBOL, symbol_width, w);\n    Strcat_charp(tmp, \"</div_int></nobr>\");\n    return tmp;\n}\n\n#ifdef USE_M17N\nstatic char *\ncheck_charset(char *p)\n{\n    return wc_guess_charset(p, 0) ? p : NULL;\n}\n\nstatic char *\ncheck_accept_charset(char *ac)\n{\n    char *s = ac, *e;\n\n    while (*s) {\n\twhile (*s && (IS_SPACE(*s) || *s == ','))\n\t    s++;\n\tif (!*s)\n\t    break;\n\te = s;\n\twhile (*e && !(IS_SPACE(*e) || *e == ','))\n\t    e++;\n\tif (wc_guess_charset(Strnew_charp_n(s, e - s)->ptr, 0))\n\t    return ac;\n\ts = e;\n    }\n    return NULL;\n}\n#endif\n\nstatic Str\nprocess_form_int(struct parsed_tag *tag, int fid)\n{\n    char *p, *q, *r, *s, *tg, *n;\n\n    p = \"get\";\n    parsedtag_get_value(tag, ATTR_METHOD, &p);\n    q = \"!CURRENT_URL!\";\n    parsedtag_get_value(tag, ATTR_ACTION, &q);\n    q = url_encode(remove_space(q), cur_baseURL, cur_document_charset);\n    r = NULL;\n#ifdef USE_M17N\n    if (parsedtag_get_value(tag, ATTR_ACCEPT_CHARSET, &r))\n\tr = check_accept_charset(r);\n    if (!r && parsedtag_get_value(tag, ATTR_CHARSET, &r))\n\tr = check_charset(r);\n#endif\n    s = NULL;\n    parsedtag_get_value(tag, ATTR_ENCTYPE, &s);\n    tg = NULL;\n    parsedtag_get_value(tag, ATTR_TARGET, &tg);\n    n = NULL;\n    parsedtag_get_value(tag, ATTR_NAME, &n);\n\n    if (fid < 0) {\n\tform_max++;\n\tform_sp++;\n\tfid = form_max;\n    }\n    else {\t\t\t/* <form_int> */\n\tif (form_max < fid)\n\t    form_max = fid;\n\tform_sp = fid;\n    }\n    if (forms_size == 0) {\n\tforms_size = INITIAL_FORM_SIZE;\n\tforms = New_N(FormList *, forms_size);\n\tform_stack = NewAtom_N(int, forms_size);\n    }\n    if (forms_size <= form_max) {\n\tforms_size += form_max;\n\tforms = New_Reuse(FormList *, forms, forms_size);\n\tform_stack = New_Reuse(int, form_stack, forms_size);\n    }\n    form_stack[form_sp] = fid;\n\n    if (w3m_halfdump) {\n\tStr tmp = Sprintf(\"<form_int fid=\\\"%d\\\" action=\\\"%s\\\" method=\\\"%s\\\"\",\n\t\t\t  fid, html_quote(q), html_quote(p));\n\tif (s)\n\t    Strcat(tmp, Sprintf(\" enctype=\\\"%s\\\"\", html_quote(s)));\n\tif (tg)\n\t    Strcat(tmp, Sprintf(\" target=\\\"%s\\\"\", html_quote(tg)));\n\tif (n)\n\t    Strcat(tmp, Sprintf(\" name=\\\"%s\\\"\", html_quote(n)));\n#ifdef USE_M17N\n\tif (r)\n\t    Strcat(tmp, Sprintf(\" accept-charset=\\\"%s\\\"\", html_quote(r)));\n#endif\n\tStrcat_charp(tmp, \">\");\n\treturn tmp;\n    }\n\n    forms[fid] = newFormList(q, p, r, s, tg, n, NULL);\n    return NULL;\n}\n\nStr\nprocess_form(struct parsed_tag *tag)\n{\n    return process_form_int(tag, -1);\n}\n\nStr\nprocess_n_form(void)\n{\n    if (form_sp >= 0)\n\tform_sp--;\n    return NULL;\n}\n\nstatic void\nclear_ignore_p_flag(int cmd, struct readbuffer *obuf)\n{\n    static int clear_flag_cmd[] = {\n\tHTML_HR, HTML_UNKNOWN\n    };\n    int i;\n\n    for (i = 0; clear_flag_cmd[i] != HTML_UNKNOWN; i++) {\n\tif (cmd == clear_flag_cmd[i]) {\n\t    obuf->flag &= ~RB_IGNORE_P;\n\t    return;\n\t}\n    }\n}\n\nstatic void\nset_alignment(struct readbuffer *obuf, struct parsed_tag *tag)\n{\n    long flag = -1;\n    int align;\n\n    if (parsedtag_get_value(tag, ATTR_ALIGN, &align)) {\n\tswitch (align) {\n\tcase ALIGN_CENTER:\n\t    flag = RB_CENTER;\n\t    break;\n\tcase ALIGN_RIGHT:\n\t    flag = RB_RIGHT;\n\t    break;\n\tcase ALIGN_LEFT:\n\t    flag = RB_LEFT;\n\t}\n    }\n    RB_SAVE_FLAG(obuf);\n    if (flag != -1) {\n\tRB_SET_ALIGN(obuf, flag);\n    }\n}\n\n#ifdef ID_EXT\nstatic void\nprocess_idattr(struct readbuffer *obuf, int cmd, struct parsed_tag *tag)\n{\n    char *id = NULL, *framename = NULL;\n    Str idtag = NULL;\n\n    /* \n     * HTML_TABLE is handled by the other process.\n     */\n    if (cmd == HTML_TABLE)\n\treturn;\n\n    parsedtag_get_value(tag, ATTR_ID, &id);\n    parsedtag_get_value(tag, ATTR_FRAMENAME, &framename);\n    if (id == NULL)\n\treturn;\n    if (framename)\n\tidtag = Sprintf(\"<_id id=\\\"%s\\\" framename=\\\"%s\\\">\",\n\t\t\thtml_quote(id), html_quote(framename));\n    else\n\tidtag = Sprintf(\"<_id id=\\\"%s\\\">\", html_quote(id));\n    push_tag(obuf, idtag->ptr, HTML_NOP);\n}\n#endif\t\t\t\t/* ID_EXT */\n\n#define CLOSE_P if (obuf->flag & RB_P) { \\\n      flushline(h_env, obuf, envs[h_env->envc].indent,0,h_env->limit);\\\n      RB_RESTORE_FLAG(obuf);\\\n      obuf->flag &= ~RB_P;\\\n    }\n\n#define CLOSE_A \\\n    CLOSE_P; \\\n    close_anchor(h_env, obuf);\n\n#define CLOSE_DT \\\n    if (obuf->flag & RB_IN_DT) { \\\n      obuf->flag &= ~RB_IN_DT; \\\n      HTMLlineproc1(\"</b>\", h_env); \\\n    }\n\n#define PUSH_ENV(cmd) \\\n    if (++h_env->envc_real < h_env->nenv) { \\\n      ++h_env->envc; \\\n      envs[h_env->envc].env = cmd; \\\n      envs[h_env->envc].count = 0; \\\n      if (h_env->envc <= MAX_INDENT_LEVEL) \\\n        envs[h_env->envc].indent = envs[h_env->envc - 1].indent + INDENT_INCR; \\\n      else \\\n        envs[h_env->envc].indent = envs[h_env->envc - 1].indent; \\\n    }\n\n#define POP_ENV \\\n    if (h_env->envc_real-- < h_env->nenv) \\\n      h_env->envc--;\n\nstatic int\nul_type(struct parsed_tag *tag, int default_type)\n{\n    char *p;\n    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\tif (!strcasecmp(p, \"disc\"))\n\t    return (int)'d';\n\telse if (!strcasecmp(p, \"circle\"))\n\t    return (int)'c';\n\telse if (!strcasecmp(p, \"square\"))\n\t    return (int)'s';\n    }\n    return default_type;\n}\n\nint\ngetMetaRefreshParam(char *q, Str *refresh_uri)\n{\n    int refresh_interval;\n    char *r;\n    Str s_tmp = NULL;\n\n    if (q == NULL || refresh_uri == NULL)\n\treturn 0;\n\n    refresh_interval = atoi(q);\n    if (refresh_interval < 0)\n\treturn 0;\n\n    while (*q) {\n\tif (!strncasecmp(q, \"url=\", 4)) {\n\t    q += 4;\n\t    if (*q == '\\\"' || *q == '\\'')\t/* \" or ' */\n\t\tq++;\n\t    r = q;\n\t    while (*r && !IS_SPACE(*r) && *r != ';')\n\t\tr++;\n\t    s_tmp = Strnew_charp_n(q, r - q);\n\n\t    if (s_tmp->ptr[s_tmp->length - 1] == '\\\"'          /* \" */\n\t       || s_tmp->ptr[s_tmp->length - 1] == '\\'') {     /* ' */\n\t\ts_tmp->length--;\n\t\ts_tmp->ptr[s_tmp->length] = '\\0';\n\t    }\n\t    q = r;\n\t}\n\twhile (*q && *q != ';')\n\t    q++;\n\tif (*q == ';')\n\t    q++;\n\twhile (*q && *q == ' ')\n\t    q++;\n    }\n    *refresh_uri = s_tmp;\n    return refresh_interval;\n}\n\nint\nHTMLtagproc1(struct parsed_tag *tag, struct html_feed_environ *h_env)\n{\n    char *p, *q, *r;\n    int i, w, x, y, z, count, width;\n    struct readbuffer *obuf = h_env->obuf;\n    struct environment *envs = h_env->envs;\n    Str tmp;\n    int hseq;\n    int cmd;\n#ifdef ID_EXT\n    char *id = NULL;\n#endif\t\t\t\t/* ID_EXT */\n\n    cmd = tag->tagid;\n\n    if (obuf->flag & RB_PRE) {\n\tswitch (cmd) {\n\tcase HTML_NOBR:\n\tcase HTML_N_NOBR:\n\tcase HTML_PRE_INT:\n\tcase HTML_N_PRE_INT:\n\t    return 1;\n\t}\n    }\n\n    switch (cmd) {\n    case HTML_B:\n\tobuf->in_bold++;\n\tif (obuf->in_bold > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_B:\n\tif (obuf->in_bold == 1 && close_effect0(obuf, HTML_B))\n\t    obuf->in_bold = 0;\n\tif (obuf->in_bold > 0) {\n\t    obuf->in_bold--;\n\t    if (obuf->in_bold == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_I:\n\tobuf->in_italic++;\n\tif (obuf->in_italic > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_I:\n\tif (obuf->in_italic == 1 && close_effect0(obuf, HTML_I))\n\t    obuf->in_italic = 0;\n\tif (obuf->in_italic > 0) {\n\t    obuf->in_italic--;\n\t    if (obuf->in_italic == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_U:\n\tobuf->in_under++;\n\tif (obuf->in_under > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_U:\n\tif (obuf->in_under == 1 && close_effect0(obuf, HTML_U))\n\t    obuf->in_under = 0;\n\tif (obuf->in_under > 0) {\n\t    obuf->in_under--;\n\t    if (obuf->in_under == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_EM:\n\tHTMLlineproc1(\"<i>\", h_env);\n\treturn 1;\n    case HTML_N_EM:\n\tHTMLlineproc1(\"</i>\", h_env);\n\treturn 1;\n    case HTML_STRONG:\n\tHTMLlineproc1(\"<b>\", h_env);\n\treturn 1;\n    case HTML_N_STRONG:\n\tHTMLlineproc1(\"</b>\", h_env);\n\treturn 1;\n    case HTML_Q:\n\tHTMLlineproc1(\"`\", h_env);\n\treturn 1;\n    case HTML_N_Q:\n\tHTMLlineproc1(\"'\", h_env);\n\treturn 1;\n    case HTML_P:\n    case HTML_N_P:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 1, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\tif (cmd == HTML_P) {\n\t    set_alignment(obuf, tag);\n\t    obuf->flag |= RB_P;\n\t}\n\treturn 1;\n    case HTML_BR:\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 1, h_env->limit);\n\th_env->blank_lines = 0;\n\treturn 1;\n    case HTML_H:\n\tif (!(obuf->flag & (RB_PREMODE | RB_IGNORE_P))) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tHTMLlineproc1(\"<b>\", h_env);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_H:\n\tHTMLlineproc1(\"</b>\", h_env);\n\tif (!(obuf->flag & RB_PREMODE)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t}\n\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\tclose_anchor(h_env, obuf);\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_UL:\n    case HTML_OL:\n    case HTML_BLQ:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!(obuf->flag & RB_PREMODE) &&\n\t\t(h_env->envc == 0 || cmd == HTML_BLQ))\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\tPUSH_ENV(cmd);\n\tif (cmd == HTML_UL || cmd == HTML_OL) {\n\t    if (parsedtag_get_value(tag, ATTR_START, &count)) {\n\t\tenvs[h_env->envc].count = count - 1;\n\t    }\n\t}\n\tif (cmd == HTML_OL) {\n\t    envs[h_env->envc].type = '1';\n\t    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\t\tenvs[h_env->envc].type = (int)*p;\n\t    }\n\t}\n\tif (cmd == HTML_UL)\n\t    envs[h_env->envc].type = ul_type(tag, 0);\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 1;\n    case HTML_N_UL:\n    case HTML_N_OL:\n    case HTML_N_DL:\n    case HTML_N_BLQ:\n\tCLOSE_DT;\n\tCLOSE_A;\n\tif (h_env->envc > 0) {\n\t    flushline(h_env, obuf, envs[h_env->envc - 1].indent, 0,\n\t\t      h_env->limit);\n\t    POP_ENV;\n\t    if (!(obuf->flag & RB_PREMODE) &&\n\t\t(h_env->envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ)) {\n\t\tdo_blankline(h_env, obuf,\n\t\t\t     envs[h_env->envc].indent,\n\t\t\t     INDENT_INCR, h_env->limit);\n\t\tobuf->flag |= RB_IGNORE_P;\n\t    }\n\t}\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_DL:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!(obuf->flag & RB_PREMODE))\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\tPUSH_ENV(cmd);\n\tif (parsedtag_exists(tag, ATTR_COMPACT))\n\t    envs[h_env->envc].env = HTML_DL_COMPACT;\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_LI:\n\tCLOSE_A;\n\tCLOSE_DT;\n\tif (h_env->envc > 0) {\n\t    Str num;\n\t    flushline(h_env, obuf,\n\t\t      envs[h_env->envc - 1].indent, 0, h_env->limit);\n\t    envs[h_env->envc].count++;\n\t    if (parsedtag_get_value(tag, ATTR_VALUE, &p)) {\n\t\tcount = atoi(p);\n\t\tif (count > 0)\n\t\t    envs[h_env->envc].count = count;\n\t\telse\n\t\t    envs[h_env->envc].count = 0;\n\t    }\n\t    switch (envs[h_env->envc].env) {\n\t    case HTML_UL:\n\t\tenvs[h_env->envc].type = ul_type(tag, envs[h_env->envc].type);\n\t\tfor (i = 0; i < INDENT_INCR - 3; i++)\n\t\t    push_charp(obuf, 1, NBSP, PC_ASCII);\n\t\ttmp = Strnew();\n\t\tswitch (envs[h_env->envc].type) {\n\t\tcase 'd':\n\t\t    push_symbol(tmp, UL_SYMBOL_DISC, symbol_width, 1);\n\t\t    break;\n\t\tcase 'c':\n\t\t    push_symbol(tmp, UL_SYMBOL_CIRCLE, symbol_width, 1);\n\t\t    break;\n\t\tcase 's':\n\t\t    push_symbol(tmp, UL_SYMBOL_SQUARE, symbol_width, 1);\n\t\t    break;\n\t\tdefault:\n\t\t    push_symbol(tmp,\n\t\t\t\tUL_SYMBOL((h_env->envc_real -\n\t\t\t\t\t   1) % MAX_UL_LEVEL), symbol_width,\n\t\t\t\t1);\n\t\t    break;\n\t\t}\n\t\tif (symbol_width == 1)\n\t\t    push_charp(obuf, 1, NBSP, PC_ASCII);\n\t\tpush_str(obuf, symbol_width, tmp, PC_ASCII);\n\t\tpush_charp(obuf, 1, NBSP, PC_ASCII);\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t\tbreak;\n\t    case HTML_OL:\n\t\tif (parsedtag_get_value(tag, ATTR_TYPE, &p))\n\t\t    envs[h_env->envc].type = (int)*p;\n\t\tswitch ((envs[h_env->envc].count > 0)? envs[h_env->envc].type: '1') {\n\t\tcase 'i':\n\t\t    num = romanNumeral(envs[h_env->envc].count);\n\t\t    break;\n\t\tcase 'I':\n\t\t    num = romanNumeral(envs[h_env->envc].count);\n\t\t    Strupper(num);\n\t\t    break;\n\t\tcase 'a':\n\t\t    num = romanAlphabet(envs[h_env->envc].count);\n\t\t    break;\n\t\tcase 'A':\n\t\t    num = romanAlphabet(envs[h_env->envc].count);\n\t\t    Strupper(num);\n\t\t    break;\n\t\tdefault:\n\t\t    num = Sprintf(\"%d\", envs[h_env->envc].count);\n\t\t    break;\n\t\t}\n\t\tif (INDENT_INCR >= 4)\n\t\t    Strcat_charp(num, \". \");\n\t\telse\n\t\t    Strcat_char(num, '.');\n\t\tpush_spaces(obuf, 1, INDENT_INCR - num->length);\n\t\tpush_str(obuf, num->length, num, PC_ASCII);\n\t\tif (INDENT_INCR >= 4)\n\t\t    set_space_to_prevchar(obuf->prevchar);\n\t\tbreak;\n\t    default:\n\t\tpush_spaces(obuf, 1, INDENT_INCR);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    flushline(h_env, obuf, 0, 0, h_env->limit);\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_DT:\n\tCLOSE_A;\n\tif (h_env->envc == 0 ||\n\t    (h_env->envc_real < h_env->nenv &&\n\t     envs[h_env->envc].env != HTML_DL &&\n\t     envs[h_env->envc].env != HTML_DL_COMPACT)) {\n\t    PUSH_ENV(HTML_DL);\n\t}\n\tif (h_env->envc > 0) {\n\t    flushline(h_env, obuf,\n\t\t      envs[h_env->envc - 1].indent, 0, h_env->limit);\n\t}\n\tif (!(obuf->flag & RB_IN_DT)) {\n\t    HTMLlineproc1(\"<b>\", h_env);\n\t    obuf->flag |= RB_IN_DT;\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_DD:\n\tCLOSE_A;\n\tCLOSE_DT;\n\tif (h_env->envc == 0 ||\n\t    (h_env->envc_real < h_env->nenv &&\n\t     envs[h_env->envc].env != HTML_DL &&\n\t     envs[h_env->envc].env != HTML_DL_COMPACT)) {\n\t    PUSH_ENV(HTML_DL);\n\t}\n\tif (envs[h_env->envc].env == HTML_DL_COMPACT) {\n\t    if (obuf->pos > envs[h_env->envc].indent)\n\t\tflushline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t  h_env->limit);\n\t    else\n\t\tpush_spaces(obuf, 1, envs[h_env->envc].indent - obuf->pos);\n\t}\n\telse\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t/* obuf->flag |= RB_IGNORE_P; */\n\treturn 1;\n    case HTML_TITLE:\n\tclose_anchor(h_env, obuf);\n\tprocess_title(tag);\n\tobuf->flag |= RB_TITLE;\n\tobuf->end_tag = HTML_N_TITLE;\n\treturn 1;\n    case HTML_N_TITLE:\n\tif (!(obuf->flag & RB_TITLE))\n\t    return 1;\n\tobuf->flag &= ~RB_TITLE;\n\tobuf->end_tag = 0;\n\ttmp = process_n_title(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_TITLE_ALT:\n\tif (parsedtag_get_value(tag, ATTR_TITLE, &p))\n\t    h_env->title = html_unquote(p);\n\treturn 0;\n    case HTML_FRAMESET:\n\tPUSH_ENV(cmd);\n\tpush_charp(obuf, 9, \"--FRAME--\", PC_ASCII);\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 0;\n    case HTML_N_FRAMESET:\n\tif (h_env->envc > 0) {\n\t    POP_ENV;\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t}\n\treturn 0;\n    case HTML_NOFRAMES:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag |= (RB_NOFRAMES | RB_IGNORE_P);\n\t/* istr = str; */\n\treturn 1;\n    case HTML_N_NOFRAMES:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag &= ~RB_NOFRAMES;\n\treturn 1;\n    case HTML_FRAME:\n\tq = r = NULL;\n\tparsedtag_get_value(tag, ATTR_SRC, &q);\n\tparsedtag_get_value(tag, ATTR_NAME, &r);\n\tif (q) {\n\t    q = html_quote(q);\n\t    push_tag(obuf, Sprintf(\"<a hseq=\\\"%d\\\" href=\\\"%s\\\">\",\n\t\t\t\t   cur_hseq++, q)->ptr, HTML_A);\n\t    if (r)\n\t\tq = html_quote(r);\n\t    push_charp(obuf, get_strwidth(q), q, PC_ASCII);\n\t    push_tag(obuf, \"</a>\", HTML_N_A);\n\t}\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 0;\n    case HTML_HR:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_hr(tag, h_env->limit, envs[h_env->envc].indent);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\tset_space_to_prevchar(obuf->prevchar);\n\treturn 1;\n    case HTML_PRE:\n\tx = parsedtag_exists(tag, ATTR_FOR_TABLE);\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!x)\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\telse\n\t    fillline(obuf, envs[h_env->envc].indent);\n\tobuf->flag |= (RB_PRE | RB_IGNORE_P);\n\t/* istr = str; */\n\treturn 1;\n    case HTML_N_PRE:\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t    h_env->blank_lines++;\n\t}\n\tobuf->flag &= ~RB_PRE;\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_PRE_INT:\n\ti = obuf->line->length;\n\tappend_tags(obuf);\n\tif (!(obuf->flag & RB_SPECIAL)) {\n\t    set_breakpoint(obuf, obuf->line->length - i);\n\t}\n\tobuf->flag |= RB_PRE_INT;\n\treturn 0;\n    case HTML_N_PRE_INT:\n\tpush_tag(obuf, \"</pre_int>\", HTML_N_PRE_INT);\n\tobuf->flag &= ~RB_PRE_INT;\n\tif (!(obuf->flag & RB_SPECIAL) && obuf->pos > obuf->bp.pos) {\n\t    set_prevchar(obuf->prevchar, \"\", 0);\n\t    obuf->prev_ctype = PC_CTRL;\n\t}\n\treturn 1;\n    case HTML_NOBR:\n\tobuf->flag |= RB_NOBR;\n\tobuf->nobr_level++;\n\treturn 0;\n    case HTML_N_NOBR:\n\tif (obuf->nobr_level > 0)\n\t    obuf->nobr_level--;\n\tif (obuf->nobr_level == 0)\n\t    obuf->flag &= ~RB_NOBR;\n\treturn 0;\n    case HTML_PRE_PLAIN:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= (RB_PRE | RB_IGNORE_P);\n\treturn 1;\n    case HTML_N_PRE_PLAIN:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t}\n\tobuf->flag &= ~RB_PRE;\n\treturn 1;\n    case HTML_LISTING:\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= (RB_PLAIN | RB_IGNORE_P);\n\tswitch (cmd) {\n\tcase HTML_LISTING:\n\t    obuf->end_tag = HTML_N_LISTING;\n\t    break;\n\tcase HTML_XMP:\n\t    obuf->end_tag = HTML_N_XMP;\n\t    break;\n\tcase HTML_PLAINTEXT:\n\t    obuf->end_tag = MAX_HTMLTAG;\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_LISTING:\n    case HTML_N_XMP:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t}\n\tobuf->flag &= ~RB_PLAIN;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_SCRIPT:\n\tobuf->flag |= RB_SCRIPT;\n\tobuf->end_tag = HTML_N_SCRIPT;\n\treturn 1;\n    case HTML_STYLE:\n\tobuf->flag |= RB_STYLE;\n\tobuf->end_tag = HTML_N_STYLE;\n\treturn 1;\n    case HTML_N_SCRIPT:\n\tobuf->flag &= ~RB_SCRIPT;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_N_STYLE:\n\tobuf->flag &= ~RB_STYLE;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_A:\n\tif (obuf->anchor.url)\n\t    close_anchor(h_env, obuf);\n\n\thseq = 0;\n\n\tif (parsedtag_get_value(tag, ATTR_HREF, &p))\n\t    obuf->anchor.url = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_TARGET, &p))\n\t    obuf->anchor.target = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_REFERER, &p))\n\t    obuf->anchor.referer = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_TITLE, &p))\n\t    obuf->anchor.title = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_ACCESSKEY, &p))\n\t    obuf->anchor.accesskey = (unsigned char)*p;\n\tif (parsedtag_get_value(tag, ATTR_HSEQ, &hseq))\n\t    obuf->anchor.hseq = hseq;\n\n\tif (hseq == 0 && obuf->anchor.url) {\n\t    obuf->anchor.hseq = cur_hseq;\n\t    tmp = process_anchor(tag, h_env->tagbuf->ptr);\n\t    push_tag(obuf, tmp->ptr, HTML_A);\n\t    if (displayLinkNumber)\n\t\tHTMLlineproc1(getLinkNumberStr(-1)->ptr, h_env);\n\t    return 1;\n\t}\n\treturn 0;\n    case HTML_N_A:\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_IMG:\n\ttmp = process_img(tag, h_env->limit);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_IMG_ALT:\n\tif (parsedtag_get_value(tag, ATTR_SRC, &p))\n\t    obuf->img_alt = Strnew_charp(p);\n#ifdef USE_IMAGE\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_TOP_MARGIN, &i)) {\n\t    if (i > obuf->top_margin)\n\t\tobuf->top_margin = i;\n\t}\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &i)) {\n\t    if (i > obuf->bottom_margin)\n\t\tobuf->bottom_margin = i;\n\t}\n#endif\n\treturn 0;\n    case HTML_N_IMG_ALT:\n\tif (obuf->img_alt) {\n\t    if (!close_effect0(obuf, HTML_IMG_ALT))\n\t\tpush_tag(obuf, \"</img_alt>\", HTML_N_IMG_ALT);\n\t    obuf->img_alt = NULL;\n\t}\n\treturn 1;\n    case HTML_INPUT_ALT:\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_TOP_MARGIN, &i)) {\n\t    if (i > obuf->top_margin)\n\t\tobuf->top_margin = i;\n\t}\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &i)) {\n\t    if (i > obuf->bottom_margin)\n\t\tobuf->bottom_margin = i;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_HSEQ, &hseq)) {\n\t    obuf->input_alt.hseq = hseq;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_FID, &i)) {\n\t    obuf->input_alt.fid = i;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\t    obuf->input_alt.type = Strnew_charp(p);\n\t}\n\tif (parsedtag_get_value(tag, ATTR_VALUE, &p)) {\n\t    obuf->input_alt.value = Strnew_charp(p);\n\t}\n\tif (parsedtag_get_value(tag, ATTR_NAME, &p)) {\n\t    obuf->input_alt.name = Strnew_charp(p);\n\t}\n\tobuf->input_alt.in = 1;\n\treturn 0;\n    case HTML_N_INPUT_ALT:\n\tif (obuf->input_alt.in) {\n\t    if (!close_effect0(obuf, HTML_INPUT_ALT))\n\t\tpush_tag(obuf, \"</input_alt>\", HTML_N_INPUT_ALT);\n\t    obuf->input_alt.hseq = 0;\n\t    obuf->input_alt.fid = -1;\n\t    obuf->input_alt.in = 0;\n\t    obuf->input_alt.type = NULL;\n\t    obuf->input_alt.name = NULL;\n\t    obuf->input_alt.value = NULL;\n\t}\n\treturn 1;\n    case HTML_TABLE:\n\tclose_anchor(h_env, obuf);\n\tobuf->table_level++;\n\tif (obuf->table_level >= MAX_TABLE)\n\t    break;\n\tw = BORDER_NONE;\n\t/* x: cellspacing, y: cellpadding */\n\tx = 2;\n\ty = 1;\n\tz = 0;\n\twidth = 0;\n\tif (parsedtag_exists(tag, ATTR_BORDER)) {\n\t    if (parsedtag_get_value(tag, ATTR_BORDER, &w)) {\n\t\tif (w > 2)\n\t\t    w = BORDER_THICK;\n\t\telse if (w < 0) {\t/* weird */\n\t\t    w = BORDER_THIN;\n\t\t}\n\t    }\n\t    else\n\t\tw = BORDER_THIN;\n\t}\n\tif (DisplayBorders && w == BORDER_NONE)\n\t    w = BORDER_THIN;\n\tif (parsedtag_get_value(tag, ATTR_WIDTH, &i)) {\n\t    if (obuf->table_level == 0)\n\t\twidth = REAL_WIDTH(i, h_env->limit - envs[h_env->envc].indent);\n\t    else\n\t\twidth = RELATIVE_WIDTH(i);\n\t}\n\tif (parsedtag_exists(tag, ATTR_HBORDER))\n\t    w = BORDER_NOWIN;\n#define MAX_CELLSPACING 1000\n#define MAX_CELLPADDING 1000\n#define MAX_VSPACE 1000\n\tparsedtag_get_value(tag, ATTR_CELLSPACING, &x);\n\tparsedtag_get_value(tag, ATTR_CELLPADDING, &y);\n\tparsedtag_get_value(tag, ATTR_VSPACE, &z);\n\tif (x > MAX_CELLSPACING)\n\t    x = MAX_CELLSPACING;\n\tif (y > MAX_CELLPADDING)\n\t    y = MAX_CELLPADDING;\n\tif (z > MAX_VSPACE)\n\t    z = MAX_VSPACE;\n#ifdef ID_EXT\n\tparsedtag_get_value(tag, ATTR_ID, &id);\n#endif\t\t\t\t/* ID_EXT */\n\ttables[obuf->table_level] = begin_table(w, x, y, z);\n#ifdef ID_EXT\n\tif (id != NULL)\n\t    tables[obuf->table_level]->id = Strnew_charp(id);\n#endif\t\t\t\t/* ID_EXT */\n\ttable_mode[obuf->table_level].pre_mode = 0;\n\ttable_mode[obuf->table_level].indent_level = 0;\n\ttable_mode[obuf->table_level].nobr_level = 0;\n\ttable_mode[obuf->table_level].caption = 0;\n\ttable_mode[obuf->table_level].end_tag = 0;\t/* HTML_UNKNOWN */\n#ifndef TABLE_EXPAND\n\ttables[obuf->table_level]->total_width = width;\n#else\n\ttables[obuf->table_level]->real_width = width;\n\ttables[obuf->table_level]->total_width = 0;\n#endif\n\treturn 1;\n    case HTML_N_TABLE:\n\t/* should be processed in HTMLlineproc() */\n\treturn 1;\n    case HTML_CENTER:\n\tCLOSE_A;\n\tif (!(obuf->flag & (RB_PREMODE | RB_IGNORE_P)))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_SAVE_FLAG(obuf);\n\tRB_SET_ALIGN(obuf, RB_CENTER);\n\treturn 1;\n    case HTML_N_CENTER:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_PREMODE))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_DIV:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_DIV:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_DIV_INT:\n\tCLOSE_P;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_DIV_INT:\n\tCLOSE_P;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_FORM:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\ttmp = process_form(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_N_FORM:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag |= RB_IGNORE_P;\n\tprocess_n_form();\n\treturn 1;\n    case HTML_INPUT:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_input(tag);\n       if (tmp)\n           HTMLlineproc1(tmp->ptr, h_env);\n       return 1;\n    case HTML_BUTTON:\n       tmp = process_button(tag);\n       if (tmp)\n           HTMLlineproc1(tmp->ptr, h_env);\n       return 1;\n    case HTML_N_BUTTON:\n       tmp = process_n_button();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_SELECT:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_select(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\tobuf->flag |= RB_INSELECT;\n\tobuf->end_tag = HTML_N_SELECT;\n\treturn 1;\n    case HTML_N_SELECT:\n\tobuf->flag &= ~RB_INSELECT;\n\tobuf->end_tag = 0;\n\ttmp = process_n_select();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_OPTION:\n\t/* nothing */\n\treturn 1;\n    case HTML_TEXTAREA:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_textarea(tag, h_env->limit);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\tobuf->flag |= RB_INTXTA;\n\tobuf->end_tag = HTML_N_TEXTAREA;\n\treturn 1;\n    case HTML_N_TEXTAREA:\n\tobuf->flag &= ~RB_INTXTA;\n\tobuf->end_tag = 0;\n\ttmp = process_n_textarea();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_ISINDEX:\n\tp = \"\";\n\tq = \"!CURRENT_URL!\";\n\tparsedtag_get_value(tag, ATTR_PROMPT, &p);\n\tparsedtag_get_value(tag, ATTR_ACTION, &q);\n\ttmp = Strnew_m_charp(\"<form method=get action=\\\"\",\n\t\t\t     html_quote(q),\n\t\t\t     \"\\\">\",\n\t\t\t     html_quote(p),\n\t\t\t     \"<input type=text name=\\\"\\\" accept></form>\",\n\t\t\t     NULL);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_META:\n\tp = q = r = NULL;\n\tparsedtag_get_value(tag, ATTR_HTTP_EQUIV, &p);\n\tparsedtag_get_value(tag, ATTR_CONTENT, &q);\n#ifdef USE_M17N\n\tparsedtag_get_value(tag, ATTR_CHARSET, &r);\n\tif (r) {\n\t    /* <meta charset=\"\"> */\n\t    SKIP_BLANKS(r);\n\t    meta_charset = wc_guess_charset(r, 0);\n\t}\n\telse\n\tif (p && q && !strcasecmp(p, \"Content-Type\") &&\n\t    (q = strcasestr(q, \"charset\")) != NULL) {\n\t    q += 7;\n\t    SKIP_BLANKS(q);\n\t    if (*q == '=') {\n\t\tq++;\n\t\tSKIP_BLANKS(q);\n\t\tmeta_charset = wc_guess_charset(q, 0);\n\t    }\n\t}\n\telse\n#endif\n\tif (p && q && !strcasecmp(p, \"refresh\")) {\n\t    int refresh_interval;\n\t    tmp = NULL;\n\t    refresh_interval = getMetaRefreshParam(q, &tmp);\n\t    if (tmp) {\n\t\tq = html_quote(tmp->ptr);\n\t\ttmp = Sprintf(\"Refresh (%d sec) <a href=\\\"%s\\\">%s</a>\",\n\t\t\t      refresh_interval, q, q);\n\t    }\n\t    else if (refresh_interval > 0)\n\t\ttmp = Sprintf(\"Refresh (%d sec)\", refresh_interval);\n\t    if (tmp) {\n\t\tHTMLlineproc1(tmp->ptr, h_env);\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t\tif (!is_redisplay &&\n\t\t    !((obuf->flag & RB_NOFRAMES) && RenderFrame)) {\n\t\t    tag->need_reconstruct = TRUE;\n\t\t    return 0;\n\t\t}\n\t    }\n\t}\n\treturn 1;\n    case HTML_BASE:\n#if defined(USE_M17N) || defined(USE_IMAGE)\n\tp = NULL;\n\tif (parsedtag_get_value(tag, ATTR_HREF, &p)) {\n\t    cur_baseURL = New(ParsedURL);\n\t    parseURL(p, cur_baseURL, NULL);\n\t}\n#endif\n    case HTML_MAP:\n    case HTML_N_MAP:\n    case HTML_AREA:\n\treturn 0;\n    case HTML_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag |= RB_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>[DEL:</U>\", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_strike++;\n\t    if (obuf->in_strike == 1) {\n\t\tpush_tag(obuf, \"<s>\", HTML_S);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag &= ~RB_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>:DEL]</U>\", h_env);\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_strike == 0)\n\t\treturn 1;\n\t    if (obuf->in_strike == 1 && close_effect0(obuf, HTML_S))\n\t\tobuf->in_strike = 0;\n\t    if (obuf->in_strike > 0) {\n\t\tobuf->in_strike--;\n\t\tif (obuf->in_strike == 0) {\n\t\t    push_tag(obuf, \"</s>\", HTML_N_S);\n\t\t}\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag |= RB_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>[S:</U>\", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_strike++;\n\t    if (obuf->in_strike == 1) {\n\t\tpush_tag(obuf, \"<s>\", HTML_S);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag &= ~RB_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>:S]</U>\", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_strike == 0)\n\t\treturn 1;\n\t    if (obuf->in_strike == 1 && close_effect0(obuf, HTML_S))\n\t\tobuf->in_strike = 0;\n\t    if (obuf->in_strike > 0) {\n\t\tobuf->in_strike--;\n\t\tif (obuf->in_strike == 0) {\n\t\t    push_tag(obuf, \"</s>\", HTML_N_S);\n\t\t}\n\t    }\n\t}\n\treturn 1;\n    case HTML_INS:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>[INS:</U>\", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_ins++;\n\t    if (obuf->in_ins == 1) {\n\t\tpush_tag(obuf, \"<ins>\", HTML_INS);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_INS:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\"<U>:INS]</U>\", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_ins == 0)\n\t\treturn 1;\n\t    if (obuf->in_ins == 1 && close_effect0(obuf, HTML_INS))\n\t\tobuf->in_ins = 0;\n\t    if (obuf->in_ins > 0) {\n\t\tobuf->in_ins--;\n\t\tif (obuf->in_ins == 0) {\n\t\t    push_tag(obuf, \"</ins>\", HTML_N_INS);\n\t\t}\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_SUP:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\"^\", h_env);\n\treturn 1;\n    case HTML_N_SUP:\n\treturn 1;\n    case HTML_SUB:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\"[\", h_env);\n\treturn 1;\n    case HTML_N_SUB:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\"]\", h_env);\n\treturn 1;\n    case HTML_FONT:\n    case HTML_N_FONT:\n    case HTML_NOP:\n\treturn 1;\n    case HTML_BGSOUND:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\"<A HREF=\\\"%s\\\">bgsound(%s)</A>\", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_EMBED:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\"<A HREF=\\\"%s\\\">embed(%s)</A>\", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_APPLET:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_ARCHIVE, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\"<A HREF=\\\"%s\\\">applet archive(%s)</A>\", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_BODY:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_BACKGROUND, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\"<IMG SRC=\\\"%s\\\" ALT=\\\"bg image(%s)\\\"><BR>\", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n    case HTML_N_HEAD:\n\tif (obuf->flag & RB_TITLE)\n\t    HTMLlineproc1(\"</title>\", h_env);\n    case HTML_HEAD:\n    case HTML_N_BODY:\n\treturn 1;\n    default:\n\t/* obuf->prevchar = '\\0'; */\n\treturn 0;\n    }\n    /* not reached */\n    return 0;\n}\n\n#define PPUSH(p,c) {outp[pos]=(p);outc[pos]=(c);pos++;}\n#define PSIZE\t\\\n    if (out_size <= pos + 1) {\t\\\n\tout_size = pos * 3 / 2;\t\\\n\toutc = New_Reuse(char, outc, out_size);\t\\\n\toutp = New_Reuse(Lineprop, outp, out_size);\t\\\n    }\n\nstatic TextLineListItem *_tl_lp2;\n\nstatic Str\ntextlist_feed()\n{\n    TextLine *p;\n    if (_tl_lp2 != NULL) {\n\tp = _tl_lp2->ptr;\n\t_tl_lp2 = _tl_lp2->next;\n\treturn p->line;\n    }\n    return NULL;\n}\n\nstatic int\nex_efct(int ex)\n{\n    int effect = 0;\n\n    if (! ex)\n\treturn 0;\n\n    if (ex & PE_EX_ITALIC)\n\teffect |= PE_EX_ITALIC_E;\n\n    if (ex & PE_EX_INSERT)\n\teffect |= PE_EX_INSERT_E;\n\n    if (ex & PE_EX_STRIKE)\n\teffect |= PE_EX_STRIKE_E;\n\n    return effect;\n}\n\nstatic void\nHTMLlineproc2body(Buffer *buf, Str (*feed) (), int llimit)\n{\n    static char *outc = NULL;\n    static Lineprop *outp = NULL;\n    static int out_size = 0;\n    Anchor *a_href = NULL, *a_img = NULL, *a_form = NULL;\n    char *p, *q, *r, *s, *t, *str;\n    Lineprop mode, effect, ex_effect;\n    int pos;\n    int nlines;\n#ifdef DEBUG\n    FILE *debug = NULL;\n#endif\n    struct frameset *frameset_s[FRAMESTACK_SIZE];\n    int frameset_sp = -1;\n    union frameset_element *idFrame = NULL;\n    char *id = NULL;\n    int hseq, form_id;\n    Str line;\n    char *endp;\n    char symbol = '\\0';\n    int internal = 0;\n    Anchor **a_textarea = NULL;\n#ifdef MENU_SELECT\n    Anchor **a_select = NULL;\n#endif\n#if defined(USE_M17N) || defined(USE_IMAGE)\n    ParsedURL *base = baseURL(buf);\n#endif\n#ifdef USE_M17N\n    wc_ces name_charset = url_to_charset(NULL, &buf->currentURL,\n\t\t\t\t\t buf->document_charset);\n#endif\n\n    if (out_size == 0) {\n\tout_size = LINELEN;\n\toutc = NewAtom_N(char, out_size);\n\toutp = NewAtom_N(Lineprop, out_size);\n    }\n\n    n_textarea = -1;\n    if (!max_textarea) {\t/* halfload */\n\tmax_textarea = MAX_TEXTAREA;\n\ttextarea_str = New_N(Str, max_textarea);\n\ta_textarea = New_N(Anchor *, max_textarea);\n    }\n#ifdef MENU_SELECT\n    n_select = -1;\n    if (!max_select) {\t\t/* halfload */\n\tmax_select = MAX_SELECT;\n\tselect_option = New_N(FormSelectOption, max_select);\n\ta_select = New_N(Anchor *, max_select);\n    }\n#endif\n\n#ifdef DEBUG\n    if (w3m_debug)\n\tdebug = fopen(\"zzzerr\", \"a\");\n#endif\n\n    effect = 0;\n    ex_effect = 0;\n    nlines = 0;\n    while ((line = feed()) != NULL) {\n#ifdef DEBUG\n\tif (w3m_debug) {\n\t    Strfputs(line, debug);\n\t    fputc('\\n', debug);\n\t}\n#endif\n\tif (n_textarea >= 0 && *(line->ptr) != '<') {\t/* halfload */\n\t    Strcat(textarea_str[n_textarea], line);\n\t    continue;\n\t}\n      proc_again:\n\tif (++nlines == llimit)\n\t    break;\n\tpos = 0;\n#ifdef ENABLE_REMOVE_TRAILINGSPACES\n\tStrremovetrailingspaces(line);\n#endif\n\tstr = line->ptr;\n\tendp = str + line->length;\n\twhile (str < endp) {\n\t    PSIZE;\n\t    mode = get_mctype(str);\n\t    if ((effect | ex_efct(ex_effect)) & PC_SYMBOL && *str != '<') {\n#ifdef USE_M17N\n\t\tchar **buf = set_symbol(symbol_width0);\n\t\tint len;\n\n\t\tp = buf[(int)symbol];\n\t\tlen = get_mclen(p);\n\t\tmode = get_mctype(p);\n\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(p++));\n\t\tif (--len) {\n\t\t    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;\n\t\t    while (len--) {\n\t\t\tPSIZE;\n\t\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(p++));\n\t\t    }\n\t\t}\n#else\n\t\tPPUSH(PC_ASCII | effect | ex_efct(ex_effect), SYMBOL_BASE + symbol);\n#endif\n\t\tstr += symbol_width;\n\t    }\n#ifdef USE_M17N\n\t    else if (mode == PC_CTRL || mode == PC_UNDEF) {\n#else\n\t    else if (mode == PC_CTRL || IS_INTSPACE(*str)) {\n#endif\n\t\tPPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');\n\t\tstr++;\n\t    }\n#ifdef USE_M17N\n\t    else if (mode & PC_UNKNOWN) {\n\t\tPPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');\n\t\tstr += get_mclen(str);\n\t    }\n#endif\n\t    else if (*str != '<' && *str != '&') {\n#ifdef USE_M17N\n\t\tint len = get_mclen(str);\n#endif\n\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(str++));\n#ifdef USE_M17N\n\t\tif (--len) {\n\t\t    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;\n\t\t    while (len--) {\n\t\t\tPSIZE;\n\t\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(str++));\n\t\t    }\n\t\t}\n#endif\n\t    }\n\t    else if (*str == '&') {\n\t\t/* \n\t\t * & escape processing\n\t\t */\n\t\tp = getescapecmd(&str);\n\t\twhile (*p) {\n\t\t    PSIZE;\n\t\t    mode = get_mctype((unsigned char *)p);\n#ifdef USE_M17N\n\t\t    if (mode == PC_CTRL || mode == PC_UNDEF) {\n#else\n\t\t    if (mode == PC_CTRL || IS_INTSPACE(*str)) {\n#endif\n\t\t\tPPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');\n\t\t\tp++;\n\t\t    }\n#ifdef USE_M17N\n\t\t    else if (mode & PC_UNKNOWN) {\n\t\t\tPPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');\n\t\t\tp += get_mclen(p);\n\t\t    }\n#endif\n\t\t    else {\n#ifdef USE_M17N\n\t\t\tint len = get_mclen(p);\n#endif\n\t\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(p++));\n#ifdef USE_M17N\n\t\t\tif (--len) {\n\t\t\t    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;\n\t\t\t    while (len--) {\n\t\t\t\tPSIZE;\n\t\t\t\tPPUSH(mode | effect | ex_efct(ex_effect), *(p++));\n\t\t\t    }\n\t\t\t}\n#endif\n\t\t    }\n\t\t}\n\t    }\n\t    else {\n\t\t/* tag processing */\n\t\tstruct parsed_tag *tag;\n\t\tif (!(tag = parse_tag(&str, TRUE)))\n\t\t    continue;\n\t\tswitch (tag->tagid) {\n\t\tcase HTML_B:\n\t\t    effect |= PE_BOLD;\n\t\t    break;\n\t\tcase HTML_N_B:\n\t\t    effect &= ~PE_BOLD;\n\t\t    break;\n\t\tcase HTML_I:\n\t\t    ex_effect |= PE_EX_ITALIC;\n\t\t    break;\n\t\tcase HTML_N_I:\n\t\t    ex_effect &= ~PE_EX_ITALIC;\n\t\t    break;\n\t\tcase HTML_INS:\n\t\t    ex_effect |= PE_EX_INSERT;\n\t\t    break;\n\t\tcase HTML_N_INS:\n\t\t    ex_effect &= ~PE_EX_INSERT;\n\t\t    break;\n\t\tcase HTML_U:\n\t\t    effect |= PE_UNDER;\n\t\t    break;\n\t\tcase HTML_N_U:\n\t\t    effect &= ~PE_UNDER;\n\t\t    break;\n\t\tcase HTML_S:\n\t\t    ex_effect |= PE_EX_STRIKE;\n\t\t    break;\n\t\tcase HTML_N_S:\n\t\t    ex_effect &= ~PE_EX_STRIKE;\n\t\t    break;\n\t\tcase HTML_A:\n\t\t    if (renderFrameSet &&\n\t\t\tparsedtag_get_value(tag, ATTR_FRAMENAME, &p)) {\n\t\t\tp = url_quote_conv(p, buf->document_charset);\n\t\t\tif (!idFrame || strcmp(idFrame->body->name, p)) {\n\t\t\t    idFrame = search_frame(renderFrameSet, p);\n\t\t\t    if (idFrame && idFrame->body->attr != F_BODY)\n\t\t\t\tidFrame = NULL;\n\t\t\t}\n\t\t    }\n\t\t    p = r = s = NULL;\n\t\t    q = buf->baseTarget;\n\t\t    t = \"\";\n\t\t    hseq = 0;\n\t\t    id = NULL;\n\t\t    if (parsedtag_get_value(tag, ATTR_NAME, &id)) {\n\t\t\tid = url_quote_conv(id, name_charset);\n\t\t\tregisterName(buf, id, currentLn(buf), pos);\n\t\t    }\n\t\t    if (parsedtag_get_value(tag, ATTR_HREF, &p))\n\t\t\tp = url_encode(remove_space(p), base,\n\t\t\t\t       buf->document_charset);\n\t\t    if (parsedtag_get_value(tag, ATTR_TARGET, &q))\n\t\t\tq = url_quote_conv(q, buf->document_charset);\n\t\t    if (parsedtag_get_value(tag, ATTR_REFERER, &r))\n\t\t\tr = url_encode(r, base,\n\t\t\t\t       buf->document_charset);\n\t\t    parsedtag_get_value(tag, ATTR_TITLE, &s);\n\t\t    parsedtag_get_value(tag, ATTR_ACCESSKEY, &t);\n\t\t    parsedtag_get_value(tag, ATTR_HSEQ, &hseq);\n\t\t    if (hseq > 0)\n\t\t\tbuf->hmarklist =\n\t\t\t    putHmarker(buf->hmarklist, currentLn(buf),\n\t\t\t\t       pos, hseq - 1);\n\t\t    else if (hseq < 0) {\n\t\t\tint h = -hseq - 1;\n\t\t\tif (buf->hmarklist &&\n\t\t\t    h < buf->hmarklist->nmark &&\n\t\t\t    buf->hmarklist->marks[h].invalid) {\n\t\t\t    buf->hmarklist->marks[h].pos = pos;\n\t\t\t    buf->hmarklist->marks[h].line = currentLn(buf);\n\t\t\t    buf->hmarklist->marks[h].invalid = 0;\n\t\t\t    hseq = -hseq;\n\t\t\t}\n\t\t    }\n\t\t    if (id && idFrame)\n\t\t\tidFrame->body->nameList =\n\t\t\t    putAnchor(idFrame->body->nameList, id, NULL,\n\t\t\t\t      (Anchor **)NULL, NULL, NULL, '\\0',\n\t\t\t\t      currentLn(buf), pos);\n\t\t    if (p) {\n\t\t\teffect |= PE_ANCHOR;\n\t\t\ta_href = registerHref(buf, p, q, r, s,\n\t\t\t\t\t      *t, currentLn(buf), pos);\n\t\t\ta_href->hseq = ((hseq > 0) ? hseq : -hseq) - 1;\n\t\t\ta_href->slave = (hseq > 0) ? FALSE : TRUE;\n\t\t    }\n\t\t    break;\n\t\tcase HTML_N_A:\n\t\t    effect &= ~PE_ANCHOR;\n\t\t    if (a_href) {\n\t\t\ta_href->end.line = currentLn(buf);\n\t\t\ta_href->end.pos = pos;\n\t\t\tif (a_href->start.line == a_href->end.line &&\n\t\t\t    a_href->start.pos == a_href->end.pos) {\n\t\t\t    if (buf->hmarklist &&\n\t\t\t\ta_href->hseq < buf->hmarklist->nmark)\n\t\t\t\tbuf->hmarklist->marks[a_href->hseq].invalid = 1;\n\t\t\t    a_href->hseq = -1;\n\t\t\t}\n\t\t\ta_href = NULL;\n\t\t    }\n\t\t    break;\n\n\t\tcase HTML_LINK:\n\t\t    addLink(buf, tag);\n\t\t    break;\n\n\t\tcase HTML_IMG_ALT:\n\t\t    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {\n#ifdef USE_IMAGE\n\t\t\tint w = -1, h = -1, iseq = 0, ismap = 0;\n\t\t\tint xoffset = 0, yoffset = 0, top = 0, bottom = 0;\n\t\t\tparsedtag_get_value(tag, ATTR_HSEQ, &iseq);\n\t\t\tparsedtag_get_value(tag, ATTR_WIDTH, &w);\n\t\t\tparsedtag_get_value(tag, ATTR_HEIGHT, &h);\n\t\t\tparsedtag_get_value(tag, ATTR_XOFFSET, &xoffset);\n\t\t\tparsedtag_get_value(tag, ATTR_YOFFSET, &yoffset);\n\t\t\tparsedtag_get_value(tag, ATTR_TOP_MARGIN, &top);\n\t\t\tparsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &bottom);\n\t\t\tif (parsedtag_exists(tag, ATTR_ISMAP))\n\t\t\t    ismap = 1;\n\t\t\tq = NULL;\n\t\t\tparsedtag_get_value(tag, ATTR_USEMAP, &q);\n\t\t\tif (iseq > 0) {\n\t\t\t    buf->imarklist = putHmarker(buf->imarklist,\n\t\t\t\t\t\t\tcurrentLn(buf), pos,\n\t\t\t\t\t\t\tiseq - 1);\n\t\t\t}\n#endif\n\t\t\ts = NULL;\n\t\t\tparsedtag_get_value(tag, ATTR_TITLE, &s);\n\t\t\tp = url_quote_conv(remove_space(p),\n\t\t\t\t\t   buf->document_charset);\n\t\t\ta_img = registerImg(buf, p, s, currentLn(buf), pos);\n#ifdef USE_IMAGE\n\t\t\ta_img->hseq = iseq;\n\t\t\ta_img->image = NULL;\n\t\t\tif (iseq > 0) {\n\t\t\t    ParsedURL u;\n\t\t\t    Image *image;\n\n\t\t\t    parseURL2(a_img->url, &u, base);\n\t\t\t    a_img->image = image = New(Image);\n\t\t\t    image->url = parsedURL2Str(&u)->ptr;\n\t\t\t    if (!uncompressed_file_type(u.file, &image->ext))\n\t\t\t\timage->ext = filename_extension(u.file, TRUE);\n\t\t\t    image->cache = NULL;\n\t\t\t    image->width =\n\t\t\t\t(w > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : w;\n\t\t\t    image->height =\n\t\t\t\t(h > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : h;\n\t\t\t    image->xoffset = xoffset;\n\t\t\t    image->yoffset = yoffset;\n\t\t\t    image->y = currentLn(buf) - top;\n\t\t\t    if (image->xoffset < 0 && pos == 0)\n\t\t\t\timage->xoffset = 0;\n\t\t\t    if (image->yoffset < 0 && image->y == 1)\n\t\t\t\timage->yoffset = 0;\n\t\t\t    image->rows = 1 + top + bottom;\n\t\t\t    image->map = q;\n\t\t\t    image->ismap = ismap;\n\t\t\t    image->touch = 0;\n\t\t\t    image->cache = getImage(image, base,\n\t\t\t\t\t\t    IMG_FLAG_SKIP);\n\t\t\t}\n\t\t\telse if (iseq < 0) {\n\t\t\t    BufferPoint *po = buf->imarklist->marks - iseq - 1;\n\t\t\t    Anchor *a = retrieveAnchor(buf->img,\n\t\t\t\t\t\t       po->line, po->pos);\n\t\t\t    if (a) {\n\t\t\t\ta_img->url = a->url;\n\t\t\t\ta_img->image = a->image;\n\t\t\t    }\n\t\t\t}\n#endif\n\t\t    }\n\t\t    effect |= PE_IMAGE;\n\t\t    break;\n\t\tcase HTML_N_IMG_ALT:\n\t\t    effect &= ~PE_IMAGE;\n\t\t    if (a_img) {\n\t\t\ta_img->end.line = currentLn(buf);\n\t\t\ta_img->end.pos = pos;\n\t\t    }\n\t\t    a_img = NULL;\n\t\t    break;\n\t\tcase HTML_INPUT_ALT:\n\t\t    {\n\t\t\tFormList *form;\n\t\t\tint top = 0, bottom = 0;\n\t\t\tint textareanumber = -1;\n#ifdef MENU_SELECT\n\t\t\tint selectnumber = -1;\n#endif\n\t\t\thseq = 0;\n\t\t\tform_id = -1;\n\n\t\t\tparsedtag_get_value(tag, ATTR_HSEQ, &hseq);\n\t\t\tparsedtag_get_value(tag, ATTR_FID, &form_id);\n\t\t\tparsedtag_get_value(tag, ATTR_TOP_MARGIN, &top);\n\t\t\tparsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &bottom);\n\t\t\tif (form_id < 0 || form_id > form_max || forms == NULL)\n\t\t\t    break;\t/* outside of <form>..</form> */\n\t\t\tform = forms[form_id];\n\t\t\tif (hseq > 0) {\n\t\t\t    int hpos = pos;\n\t\t\t    if (*str == '[')\n\t\t\t\thpos++;\n\t\t\t    buf->hmarklist =\n\t\t\t\tputHmarker(buf->hmarklist, currentLn(buf),\n\t\t\t\t\t   hpos, hseq - 1);\n\t\t\t}\n\t\t\telse if (hseq < 0) {\n\t\t\t    int h = -hseq - 1;\n\t\t\t    int hpos = pos;\n\t\t\t    if (*str == '[')\n\t\t\t\thpos++;\n\t\t\t    if (buf->hmarklist &&\n\t\t\t\th < buf->hmarklist->nmark &&\n\t\t\t\tbuf->hmarklist->marks[h].invalid) {\n\t\t\t\tbuf->hmarklist->marks[h].pos = hpos;\n\t\t\t\tbuf->hmarklist->marks[h].line = currentLn(buf);\n\t\t\t\tbuf->hmarklist->marks[h].invalid = 0;\n\t\t\t\thseq = -hseq;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (!form->target)\n\t\t\t    form->target = buf->baseTarget;\n\t\t\tif (a_textarea &&\n\t\t\t    parsedtag_get_value(tag, ATTR_TEXTAREANUMBER,\n\t\t\t\t\t\t&textareanumber)) {\n\t\t\t    if (textareanumber >= max_textarea) {\n\t\t\t\tmax_textarea = 2 * textareanumber;\n\t\t\t\ttextarea_str = New_Reuse(Str, textarea_str,\n\t\t\t\t\t\t\t max_textarea);\n\t\t\t\ta_textarea = New_Reuse(Anchor *, a_textarea,\n\t\t\t\t\t\t       max_textarea);\n\t\t\t    }\n\t\t\t}\n#ifdef MENU_SELECT\n\t\t\tif (a_select &&\n\t\t\t    parsedtag_get_value(tag, ATTR_SELECTNUMBER,\n\t\t\t\t\t\t&selectnumber)) {\n\t\t\t    if (selectnumber >= max_select) {\n\t\t\t\tmax_select = 2 * selectnumber;\n\t\t\t\tselect_option = New_Reuse(FormSelectOption,\n\t\t\t\t\t\t\t  select_option,\n\t\t\t\t\t\t\t  max_select);\n\t\t\t\ta_select = New_Reuse(Anchor *, a_select,\n\t\t\t\t\t\t     max_select);\n\t\t\t    }\n\t\t\t}\n#endif\n\t\t\ta_form =\n\t\t\t    registerForm(buf, form, tag, currentLn(buf), pos);\n\t\t\tif (a_textarea && textareanumber >= 0)\n\t\t\t    a_textarea[textareanumber] = a_form;\n#ifdef MENU_SELECT\n\t\t\tif (a_select && selectnumber >= 0)\n\t\t\t    a_select[selectnumber] = a_form;\n#endif\n\t\t\tif (a_form) {\n\t\t\t    a_form->hseq = hseq - 1;\n\t\t\t    a_form->y = currentLn(buf) - top;\n\t\t\t    a_form->rows = 1 + top + bottom;\n\t\t\t    if (!parsedtag_exists(tag, ATTR_NO_EFFECT))\n\t\t\t\teffect |= PE_FORM;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\tcase HTML_N_INPUT_ALT:\n\t\t    effect &= ~PE_FORM;\n\t\t    if (a_form) {\n\t\t\ta_form->end.line = currentLn(buf);\n\t\t\ta_form->end.pos = pos;\n\t\t\tif (a_form->start.line == a_form->end.line &&\n\t\t\t    a_form->start.pos == a_form->end.pos)\n\t\t\t    a_form->hseq = -1;\n\t\t    }\n\t\t    a_form = NULL;\n\t\t    break;\n\t\tcase HTML_MAP:\n\t\t    if (parsedtag_get_value(tag, ATTR_NAME, &p)) {\n\t\t\tMapList *m = New(MapList);\n\t\t\tm->name = Strnew_charp(p);\n\t\t\tm->area = newGeneralList();\n\t\t\tm->next = buf->maplist;\n\t\t\tbuf->maplist = m;\n\t\t    }\n\t\t    break;\n\t\tcase HTML_N_MAP:\n\t\t    /* nothing to do */\n\t\t    break;\n\t\tcase HTML_AREA:\n\t\t    if (buf->maplist == NULL)\t/* outside of <map>..</map> */\n\t\t\tbreak;\n\t\t    if (parsedtag_get_value(tag, ATTR_HREF, &p)) {\n\t\t\tMapArea *a;\n\t\t\tp = url_encode(remove_space(p), base,\n\t\t\t\t       buf->document_charset);\n\t\t\tt = NULL;\n\t\t\tparsedtag_get_value(tag, ATTR_TARGET, &t);\n\t\t\tq = \"\";\n\t\t\tparsedtag_get_value(tag, ATTR_ALT, &q);\n\t\t\tr = NULL;\n\t\t\ts = NULL;\n#ifdef USE_IMAGE\n\t\t\tparsedtag_get_value(tag, ATTR_SHAPE, &r);\n\t\t\tparsedtag_get_value(tag, ATTR_COORDS, &s);\n#endif\n\t\t\ta = newMapArea(p, t, q, r, s);\n\t\t\tpushValue(buf->maplist->area, (void *)a);\n\t\t    }\n\t\t    break;\n\t\tcase HTML_FRAMESET:\n\t\t    frameset_sp++;\n\t\t    if (frameset_sp >= FRAMESTACK_SIZE)\n\t\t\tbreak;\n\t\t    frameset_s[frameset_sp] = newFrameSet(tag);\n\t\t    if (frameset_s[frameset_sp] == NULL)\n\t\t\tbreak;\n\t\t    if (frameset_sp == 0) {\n\t\t\tif (buf->frameset == NULL) {\n\t\t\t    buf->frameset = frameset_s[frameset_sp];\n\t\t\t}\n\t\t\telse\n\t\t\t    pushFrameTree(&(buf->frameQ),\n\t\t\t\t\t  frameset_s[frameset_sp], NULL);\n\t\t    }\n\t\t    else\n\t\t\taddFrameSetElement(frameset_s[frameset_sp - 1],\n\t\t\t\t\t   *(union frameset_element *)\n\t\t\t\t\t   &frameset_s[frameset_sp]);\n\t\t    break;\n\t\tcase HTML_N_FRAMESET:\n\t\t    if (frameset_sp >= 0)\n\t\t\tframeset_sp--;\n\t\t    break;\n\t\tcase HTML_FRAME:\n\t\t    if (frameset_sp >= 0 && frameset_sp < FRAMESTACK_SIZE) {\n\t\t\tunion frameset_element element;\n\n\t\t\telement.body = newFrame(tag, buf);\n\t\t\taddFrameSetElement(frameset_s[frameset_sp], element);\n\t\t    }\n\t\t    break;\n\t\tcase HTML_BASE:\n\t\t    if (parsedtag_get_value(tag, ATTR_HREF, &p)) {\n\t\t\tp = url_encode(remove_space(p), NULL,\n\t\t\t\t       buf->document_charset);\n\t\t\tif (!buf->baseURL)\n\t\t\t    buf->baseURL = New(ParsedURL);\n\t\t\tparseURL(p, buf->baseURL, NULL);\n#if defined(USE_M17N) || defined(USE_IMAGE)\n\t\t\tbase = buf->baseURL;\n#endif\n\t\t    }\n\t\t    if (parsedtag_get_value(tag, ATTR_TARGET, &p))\n\t\t\tbuf->baseTarget =\n\t\t\t    url_quote_conv(p, buf->document_charset);\n\t\t    break;\n\t\tcase HTML_META:\n\t\t    p = q = NULL;\n\t\t    parsedtag_get_value(tag, ATTR_HTTP_EQUIV, &p);\n\t\t    parsedtag_get_value(tag, ATTR_CONTENT, &q);\n\t\t    if (p && q && !strcasecmp(p, \"refresh\") && MetaRefresh) {\n\t\t\tStr tmp = NULL;\n\t\t\tint refresh_interval = getMetaRefreshParam(q, &tmp);\n#ifdef USE_ALARM\n\t\t\tif (tmp) {\n\t\t\t    p = url_encode(remove_space(tmp->ptr), base,\n\t\t\t\t\t   buf->document_charset);\n\t\t\t    buf->event = setAlarmEvent(buf->event,\n\t\t\t\t\t\t       refresh_interval,\n\t\t\t\t\t\t       AL_IMPLICIT_ONCE,\n\t\t\t\t\t\t       FUNCNAME_gorURL, p);\n\t\t\t}\n\t\t\telse if (refresh_interval > 0)\n\t\t\t    buf->event = setAlarmEvent(buf->event,\n\t\t\t\t\t\t       refresh_interval,\n\t\t\t\t\t\t       AL_IMPLICIT,\n\t\t\t\t\t\t       FUNCNAME_reload, NULL);\n#else\n\t\t\tif (tmp && refresh_interval == 0) {\n\t\t\t    p = url_encode(remove_space(tmp->ptr), base,\n\t\t\t\t\t   buf->document_charset);\n\t\t\t    pushEvent(FUNCNAME_gorURL, p);\n\t\t\t}\n#endif\n\t\t    }\n\t\t    break;\n\t\tcase HTML_INTERNAL:\n\t\t    internal = HTML_INTERNAL;\n\t\t    break;\n\t\tcase HTML_N_INTERNAL:\n\t\t    internal = HTML_N_INTERNAL;\n\t\t    break;\n\t\tcase HTML_FORM_INT:\n\t\t    if (parsedtag_get_value(tag, ATTR_FID, &form_id))\n\t\t\tprocess_form_int(tag, form_id);\n\t\t    break;\n\t\tcase HTML_TEXTAREA_INT:\n\t\t    if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER,\n\t\t\t\t\t    &n_textarea)\n\t\t\t&& n_textarea >= 0 && n_textarea < max_textarea) {\n\t\t\ttextarea_str[n_textarea] = Strnew();\n\t\t    }\n\t\t    else\n\t\t\tn_textarea = -1;\n\t\t    break;\n\t\tcase HTML_N_TEXTAREA_INT:\n\t\t    if (n_textarea >= 0) {\n\t\t\tFormItemList *item =\n\t\t\t    (FormItemList *)a_textarea[n_textarea]->url;\n\t\t\titem->init_value = item->value =\n\t\t\t    textarea_str[n_textarea];\n\t\t    }\n\t\t    break;\n#ifdef MENU_SELECT\n\t\tcase HTML_SELECT_INT:\n\t\t    if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &n_select)\n\t\t\t&& n_select >= 0 && n_select < max_select) {\n\t\t\tselect_option[n_select].first = NULL;\n\t\t\tselect_option[n_select].last = NULL;\n\t\t    }\n\t\t    else\n\t\t\tn_select = -1;\n\t\t    break;\n\t\tcase HTML_N_SELECT_INT:\n\t\t    if (n_select >= 0) {\n\t\t\tFormItemList *item =\n\t\t\t    (FormItemList *)a_select[n_select]->url;\n\t\t\titem->select_option = select_option[n_select].first;\n\t\t\tchooseSelectOption(item, item->select_option);\n\t\t\titem->init_selected = item->selected;\n\t\t\titem->init_value = item->value;\n\t\t\titem->init_label = item->label;\n\t\t    }\n\t\t    break;\n\t\tcase HTML_OPTION_INT:\n\t\t    if (n_select >= 0) {\n\t\t\tint selected;\n\t\t\tq = \"\";\n\t\t\tparsedtag_get_value(tag, ATTR_LABEL, &q);\n\t\t\tp = q;\n\t\t\tparsedtag_get_value(tag, ATTR_VALUE, &p);\n\t\t\tselected = parsedtag_exists(tag, ATTR_SELECTED);\n\t\t\taddSelectOption(&select_option[n_select],\n\t\t\t\t\tStrnew_charp(p), Strnew_charp(q),\n\t\t\t\t\tselected);\n\t\t    }\n\t\t    break;\n#endif\n\t\tcase HTML_TITLE_ALT:\n\t\t    if (parsedtag_get_value(tag, ATTR_TITLE, &p))\n\t\t\tbuf->buffername = html_unquote(p);\n\t\t    break;\n\t\tcase HTML_SYMBOL:\n\t\t    effect |= PC_SYMBOL;\n\t\t    if (parsedtag_get_value(tag, ATTR_TYPE, &p))\n\t\t\tsymbol = (char)atoi(p);\n\t\t    break;\n\t\tcase HTML_N_SYMBOL:\n\t\t    effect &= ~PC_SYMBOL;\n\t\t    break;\n\t\t}\n#ifdef\tID_EXT\n\t\tid = NULL;\n\t\tif (parsedtag_get_value(tag, ATTR_ID, &id)) {\n\t\t    id = url_quote_conv(id, name_charset);\n\t\t    registerName(buf, id, currentLn(buf), pos);\n\t\t}\n\t\tif (renderFrameSet &&\n\t\t    parsedtag_get_value(tag, ATTR_FRAMENAME, &p)) {\n\t\t    p = url_quote_conv(p, buf->document_charset);\n\t\t    if (!idFrame || strcmp(idFrame->body->name, p)) {\n\t\t\tidFrame = search_frame(renderFrameSet, p);\n\t\t\tif (idFrame && idFrame->body->attr != F_BODY)\n\t\t\t    idFrame = NULL;\n\t\t    }\n\t\t}\n\t\tif (id && idFrame)\n\t\t    idFrame->body->nameList =\n\t\t\tputAnchor(idFrame->body->nameList, id, NULL,\n\t\t\t\t  (Anchor **)NULL, NULL, NULL, '\\0',\n\t\t\t\t  currentLn(buf), pos);\n#endif\t\t\t\t/* ID_EXT */\n\t    }\n\t}\n\t/* end of processing for one line */\n\tif (!internal)\n\t    addnewline(buf, outc, outp, NULL, pos, -1, nlines);\n\tif (internal == HTML_N_INTERNAL)\n\t    internal = 0;\n\tif (str != endp) {\n\t    line = Strsubstr(line, str - line->ptr, endp - str);\n\t    goto proc_again;\n\t}\n    }\n#ifdef DEBUG\n    if (w3m_debug)\n\tfclose(debug);\n#endif\n    for (form_id = 1; form_id <= form_max; form_id++)\n\tif (forms[form_id])\n\t    forms[form_id]->next = forms[form_id - 1];\n    buf->formlist = (form_max >= 0) ? forms[form_max] : NULL;\n    if (n_textarea)\n\taddMultirowsForm(buf, buf->formitem);\n#ifdef USE_IMAGE\n    addMultirowsImg(buf, buf->img);\n#endif\n}\n\nstatic void\naddLink(Buffer *buf, struct parsed_tag *tag)\n{\n    char *href = NULL, *title = NULL, *ctype = NULL, *rel = NULL, *rev = NULL;\n    char type = LINK_TYPE_NONE;\n    LinkList *l;\n\n    parsedtag_get_value(tag, ATTR_HREF, &href);\n    if (href)\n\thref = url_encode(remove_space(href), baseURL(buf),\n\t\t\t  buf->document_charset);\n    parsedtag_get_value(tag, ATTR_TITLE, &title);\n    parsedtag_get_value(tag, ATTR_TYPE, &ctype);\n    parsedtag_get_value(tag, ATTR_REL, &rel);\n    if (rel != NULL) {\n\t/* forward link type */\n\ttype = LINK_TYPE_REL;\n\tif (title == NULL)\n\t    title = rel;\n    }\n    parsedtag_get_value(tag, ATTR_REV, &rev);\n    if (rev != NULL) {\n\t/* reverse link type */\n\ttype = LINK_TYPE_REV;\n\tif (title == NULL)\n\t    title = rev;\n    }\n\n    l = New(LinkList);\n    l->url = href;\n    l->title = title;\n    l->ctype = ctype;\n    l->type = type;\n    l->next = NULL;\n    if (buf->linklist) {\n\tLinkList *i;\n\tfor (i = buf->linklist; i->next; i = i->next) ;\n\ti->next = l;\n    }\n    else\n\tbuf->linklist = l;\n}\n\nvoid\nHTMLlineproc2(Buffer *buf, TextLineList *tl)\n{\n    _tl_lp2 = tl->first;\n    HTMLlineproc2body(buf, textlist_feed, -1);\n}\n\nstatic InputStream _file_lp2;\n\nstatic Str\nfile_feed()\n{\n    Str s;\n    s = StrISgets(_file_lp2);\n    if (s->length == 0) {\n\tISclose(_file_lp2);\n\treturn NULL;\n    }\n    return s;\n}\n\nvoid\nHTMLlineproc3(Buffer *buf, InputStream stream)\n{\n    _file_lp2 = stream;\n    HTMLlineproc2body(buf, file_feed, -1);\n}\n\nstatic void\nproc_escape(struct readbuffer *obuf, char **str_return)\n{\n    char *str = *str_return, *estr;\n    int ech = getescapechar(str_return);\n    int width, n_add = *str_return - str;\n    Lineprop mode = PC_ASCII;\n\n    if (ech < 0) {\n\t*str_return = str;\n\tproc_mchar(obuf, obuf->flag & RB_SPECIAL, 1, str_return, PC_ASCII);\n\treturn;\n    }\n    mode = IS_CNTRL(ech) ? PC_CTRL : PC_ASCII;\n\n    estr = conv_entity(ech);\n    check_breakpoint(obuf, obuf->flag & RB_SPECIAL, estr);\n    width = get_strwidth(estr);\n    if (width == 1 && ech == (unsigned char)*estr &&\n\tech != '&' && ech != '<' && ech != '>') {\n\tif (IS_CNTRL(ech))\n\t    mode = PC_CTRL;\n\tpush_charp(obuf, width, estr, mode);\n    }\n    else\n\tpush_nchars(obuf, width, str, n_add, mode);\n    set_prevchar(obuf->prevchar, estr, strlen(estr));\n    obuf->prev_ctype = mode;\n}\n\n\nstatic int\nneed_flushline(struct html_feed_environ *h_env, struct readbuffer *obuf,\n\t       Lineprop mode)\n{\n    char ch;\n\n    if (obuf->flag & RB_PRE_INT) {\n\tif (obuf->pos > h_env->limit)\n\t    return 1;\n\telse\n\t    return 0;\n    }\n\n    ch = Strlastchar(obuf->line);\n    /* if (ch == ' ' && obuf->tag_sp > 0) */\n    if (ch == ' ')\n\treturn 0;\n\n    if (obuf->pos > h_env->limit)\n\treturn 1;\n\n    return 0;\n}\n\nstatic int\ntable_width(struct html_feed_environ *h_env, int table_level)\n{\n    int width;\n    if (table_level < 0)\n\treturn 0;\n    width = tables[table_level]->total_width;\n    if (table_level > 0 || width > 0)\n\treturn width;\n    return h_env->limit - h_env->envs[h_env->envc].indent;\n}\n\n/* HTML processing first pass */\nvoid\nHTMLlineproc0(char *line, struct html_feed_environ *h_env, int internal)\n{\n    Lineprop mode;\n    int cmd;\n    struct readbuffer *obuf = h_env->obuf;\n    int indent, delta;\n    struct parsed_tag *tag;\n    Str tokbuf;\n    struct table *tbl = NULL;\n    struct table_mode *tbl_mode = NULL;\n    int tbl_width = 0;\n#ifdef USE_M17N\n    int is_hangul, prev_is_hangul = 0;\n#endif\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *f = fopen(\"zzzproc1\", \"a\");\n\tfprintf(f, \"%c%c%c%c\",\n\t\t(obuf->flag & RB_PREMODE) ? 'P' : ' ',\n\t\t(obuf->table_level >= 0) ? 'T' : ' ',\n\t\t(obuf->flag & RB_INTXTA) ? 'X' : ' ',\n\t\t(obuf->flag & (RB_SCRIPT | RB_STYLE)) ? 'S' : ' ');\n\tfprintf(f, \"HTMLlineproc1(\\\"%s\\\",%d,%lx)\\n\", line, h_env->limit,\n\t\t(unsigned long)h_env);\n\tfclose(f);\n    }\n#endif\n\n    tokbuf = Strnew();\n\n  table_start:\n    if (obuf->table_level >= 0) {\n\tint level = min(obuf->table_level, MAX_TABLE - 1);\n\ttbl = tables[level];\n\ttbl_mode = &table_mode[level];\n\ttbl_width = table_width(h_env, level);\n    }\n\n    while (*line != '\\0') {\n\tchar *str, *p;\n\tint is_tag = FALSE;\n\tint pre_mode = (obuf->table_level >= 0) ? tbl_mode->pre_mode :\n\t    obuf->flag;\n\tint end_tag = (obuf->table_level >= 0) ? tbl_mode->end_tag :\n\t    obuf->end_tag;\n\n\tif (*line == '<' || obuf->status != R_ST_NORMAL) {\n\t    /* \n\t     * Tag processing\n\t     */\n\t    if (obuf->status == R_ST_EOL)\n\t\tobuf->status = R_ST_NORMAL;\n\t    else {\n\t\tread_token(h_env->tagbuf, &line, &obuf->status,\n\t\t\t   pre_mode & RB_PREMODE, obuf->status != R_ST_NORMAL);\n\t\tif (obuf->status != R_ST_NORMAL)\n\t\t    return;\n\t    }\n\t    if (h_env->tagbuf->length == 0)\n\t\tcontinue;\n\t    str = h_env->tagbuf->ptr;\n\t    if (*str == '<') {\n\t\tif (str[1] && REALLY_THE_BEGINNING_OF_A_TAG(str))\n\t\t    is_tag = TRUE;\n\t\telse if (!(pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT |\n\t\t\t\t       RB_SCRIPT | RB_STYLE | RB_TITLE))) {\n\t\t    line = Strnew_m_charp(str + 1, line, NULL)->ptr;\n\t\t    str = \"&lt;\";\n\t\t}\n\t    }\n\t}\n\telse {\n\t    read_token(tokbuf, &line, &obuf->status, pre_mode & RB_PREMODE, 0);\n\t    if (obuf->status != R_ST_NORMAL)\t/* R_ST_AMP ? */\n\t\tobuf->status = R_ST_NORMAL;\n\t    str = tokbuf->ptr;\n\t}\n\n\tif (pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT | RB_SCRIPT |\n\t\t\tRB_STYLE | RB_TITLE)) {\n\t    if (is_tag) {\n\t\tp = str;\n\t\tif ((tag = parse_tag(&p, internal))) {\n\t\t    if (tag->tagid == end_tag ||\n\t\t\t(pre_mode & RB_INSELECT && tag->tagid == HTML_N_FORM)\n\t\t\t|| (pre_mode & RB_TITLE\n\t\t\t    && (tag->tagid == HTML_N_HEAD\n\t\t\t\t|| tag->tagid == HTML_BODY)))\n\t\t\tgoto proc_normal;\n\t\t}\n\t    }\n\t    /* title */\n\t    if (pre_mode & RB_TITLE) {\n\t\tfeed_title(str);\n\t\tcontinue;\n\t    }\n\t    /* select */\n\t    if (pre_mode & RB_INSELECT) {\n\t\tif (obuf->table_level >= 0)\n\t\t    goto proc_normal;\n\t\tfeed_select(str);\n\t\tcontinue;\n\t    }\n\t    if (is_tag) {\n\t\tif (strncmp(str, \"<!--\", 4) && (p = strchr(str + 1, '<'))) {\n\t\t    str = Strnew_charp_n(str, p - str)->ptr;\n\t\t    line = Strnew_m_charp(p, line, NULL)->ptr;\n\t\t}\n\t\tis_tag = FALSE;\n\t    }\n\t    if (obuf->table_level >= 0)\n\t\tgoto proc_normal;\n\t    /* textarea */\n\t    if (pre_mode & RB_INTXTA) {\n\t\tfeed_textarea(str);\n\t\tcontinue;\n\t    }\n\t    /* script */\n\t    if (pre_mode & RB_SCRIPT)\n\t\tcontinue;\n\t    /* style */\n\t    if (pre_mode & RB_STYLE)\n\t\tcontinue;\n\t}\n\n      proc_normal:\n\tif (obuf->table_level >= 0) {\n\t    /* \n\t     * within table: in <table>..</table>, all input tokens\n\t     * are fed to the table renderer, and then the renderer\n\t     * makes HTML output.\n\t     */\n\t    switch (feed_table(tbl, str, tbl_mode, tbl_width, internal)) {\n\t    case 0:\n\t\t/* </table> tag */\n\t\tobuf->table_level--;\n\t\tif (obuf->table_level >= MAX_TABLE - 1)\n\t\t    continue;\n\t\tend_table(tbl);\n\t\tif (obuf->table_level >= 0) {\n\t\t    struct table *tbl0 = tables[obuf->table_level];\n\t\t    str = Sprintf(\"<table_alt tid=%d>\", tbl0->ntable)->ptr;\n\t\t    pushTable(tbl0, tbl);\n\t\t    tbl = tbl0;\n\t\t    tbl_mode = &table_mode[obuf->table_level];\n\t\t    tbl_width = table_width(h_env, obuf->table_level);\n\t\t    feed_table(tbl, str, tbl_mode, tbl_width, TRUE);\n\t\t    continue;\n\t\t    /* continue to the next */\n\t\t}\n\t\tif (obuf->flag & RB_DEL)\n\t\t    continue;\n\t\t/* all tables have been read */\n\t\tif (tbl->vspace > 0 && !(obuf->flag & RB_IGNORE_P)) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t}\n\t\tsave_fonteffect(h_env, obuf);\n\t\trenderTable(tbl, tbl_width, h_env);\n\t\trestore_fonteffect(h_env, obuf);\n\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\tif (tbl->vspace > 0) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    obuf->flag |= RB_IGNORE_P;\n\t\t}\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t\tcontinue;\n\t    case 1:\n\t\t/* <table> tag */\n\t\tbreak;\n\t    default:\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (is_tag) {\n/*** Beginning of a new tag ***/\n\t    if ((tag = parse_tag(&str, internal)))\n\t\tcmd = tag->tagid;\n\t    else\n\t\tcontinue;\n\t    /* process tags */\n\t    if (HTMLtagproc1(tag, h_env) == 0) {\n\t\t/* preserve the tag for second-stage processing */\n\t\tif (parsedtag_need_reconstruct(tag))\n\t\t    h_env->tagbuf = parsedtag2str(tag);\n\t\tpush_tag(obuf, h_env->tagbuf->ptr, cmd);\n\t    }\n#ifdef ID_EXT\n\t    else {\n\t\tprocess_idattr(obuf, cmd, tag);\n\t    }\n#endif\t\t\t\t/* ID_EXT */\n\t    obuf->bp.init_flag = 1;\n\t    clear_ignore_p_flag(cmd, obuf);\n\t    if (cmd == HTML_TABLE)\n\t\tgoto table_start;\n\t    else\n\t\tcontinue;\n\t}\n\n\tif (obuf->flag & (RB_DEL | RB_S))\n\t    continue;\n\twhile (*str) {\n\t    mode = get_mctype(str);\n\t    delta = get_mcwidth(str);\n\t    if (obuf->flag & (RB_SPECIAL & ~RB_NOBR)) {\n\t\tchar ch = *str;\n\t\tif (!(obuf->flag & RB_PLAIN) && (*str == '&')) {\n\t\t    char *p = str;\n\t\t    int ech = getescapechar(&p);\n\t\t    if (ech == '\\n' || ech == '\\r') {\n\t\t\tch = '\\n';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t    else if (ech == '\\t') {\n\t\t\tch = '\\t';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t}\n\t\tif (ch != '\\n')\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif (ch == '\\n') {\n\t\t    str++;\n\t\t    if (obuf->flag & RB_IGNORE_P) {\n\t\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (obuf->flag & RB_PRE_INT)\n\t\t\tPUSH(' ');\n\t\t    else\n\t\t\tflushline(h_env, obuf, h_env->envs[h_env->envc].indent,\n\t\t\t\t  1, h_env->limit);\n\t\t}\n\t\telse if (ch == '\\t') {\n\t\t    do {\n\t\t\tPUSH(' ');\n\t\t    } while ((h_env->envs[h_env->envc].indent + obuf->pos)\n\t\t\t     % Tabstop != 0);\n\t\t    str++;\n\t\t}\n\t\telse if (obuf->flag & RB_PLAIN) {\n\t\t    char *p = html_quote_char(*str);\n\t\t    if (p) {\n\t\t\tpush_charp(obuf, 1, p, PC_ASCII);\n\t\t\tstr++;\n\t\t    }\n\t\t    else {\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t}\n\t\tif (obuf->flag & (RB_SPECIAL & ~RB_PRE_INT))\n\t\t    continue;\n\t    }\n\t    else {\n\t\tif (!IS_SPACE(*str))\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif ((mode == PC_ASCII || mode == PC_CTRL) && IS_SPACE(*str)) {\n\t\t    if (*obuf->prevchar->ptr != ' ') {\n\t\t\tPUSH(' ');\n\t\t    }\n\t\t    str++;\n\t\t}\n\t\telse {\n#ifdef USE_M17N\n\t\t    if (mode == PC_KANJI1)\n\t\t\tis_hangul = wtf_is_hangul((wc_uchar *) str);\n\t\t    else\n\t\t\tis_hangul = 0;\n\t\t    if (!SimplePreserveSpace && mode == PC_KANJI1 &&\n\t\t\t!is_hangul && !prev_is_hangul &&\n\t\t\tobuf->pos > h_env->envs[h_env->envc].indent &&\n\t\t\tStrlastchar(obuf->line) == ' ') {\n\t\t\twhile (obuf->line->length >= 2 &&\n\t\t\t       !strncmp(obuf->line->ptr + obuf->line->length -\n\t\t\t\t\t2, \"  \", 2)\n\t\t\t       && obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t\tif (obuf->line->length >= 3 &&\n\t\t\t    obuf->prev_ctype == PC_KANJI1 &&\n\t\t\t    Strlastchar(obuf->line) == ' ' &&\n\t\t\t    obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t    }\n\t\t    prev_is_hangul = is_hangul;\n#endif\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, obuf->flag & RB_SPECIAL, delta, &str,\n\t\t\t\t   mode);\n\t\t}\n\t    }\n\t    if (need_flushline(h_env, obuf, mode)) {\n\t\tchar *bp = obuf->line->ptr + obuf->bp.len;\n\t\tchar *tp = bp - obuf->bp.tlen;\n\t\tint i = 0;\n\n\t\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t\t    i = 1;\n\n\t\tindent = h_env->envs[h_env->envc].indent;\n\t\tif (obuf->bp.pos - i > indent) {\n\t\t    Str line;\n\t\t    append_tags(obuf);\n\t\t    line = Strnew_charp(bp);\n\t\t    Strshrink(obuf->line, obuf->line->length - obuf->bp.len);\n#ifdef FORMAT_NICE\n\t\t    if (obuf->pos - i > h_env->limit)\n\t\t\tobuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    back_to_breakpoint(obuf);\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    HTMLlineproc1(line->ptr, h_env);\n\t\t}\n\t    }\n\t}\n    }\n    if (!(obuf->flag & (RB_SPECIAL | RB_INTXTA | RB_INSELECT))) {\n\tchar *tp;\n\tint i = 0;\n\n\tif (obuf->bp.pos == obuf->pos) {\n\t    tp = &obuf->line->ptr[obuf->bp.len - obuf->bp.tlen];\n\t}\n\telse {\n\t    tp = &obuf->line->ptr[obuf->line->length];\n\t}\n\n\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t    i = 1;\n\tindent = h_env->envs[h_env->envc].indent;\n\tif (obuf->pos - i > h_env->limit) {\n#ifdef FORMAT_NICE\n\t    obuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t}\n    }\n}\n\nextern char *NullLine;\nextern Lineprop NullProp[];\n\n#ifndef USE_ANSI_COLOR\n#define addnewline2(a,b,c,d,e,f) _addnewline2(a,b,c,e,f)\n#endif\nstatic void\naddnewline2(Buffer *buf, char *line, Lineprop *prop, Linecolor *color, int pos,\n\t    int nlines)\n{\n    Line *l;\n    l = New(Line);\n    l->next = NULL;\n    l->lineBuf = line;\n    l->propBuf = prop;\n#ifdef USE_ANSI_COLOR\n    l->colorBuf = color;\n#endif\n    l->len = pos;\n    l->width = -1;\n    l->size = pos;\n    l->bpos = 0;\n    l->bwidth = 0;\n    l->prev = buf->currentLine;\n    if (buf->currentLine) {\n\tl->next = buf->currentLine->next;\n\tbuf->currentLine->next = l;\n    }\n    else\n\tl->next = NULL;\n    if (buf->lastLine == NULL || buf->lastLine == buf->currentLine)\n\tbuf->lastLine = l;\n    buf->currentLine = l;\n    if (buf->firstLine == NULL)\n\tbuf->firstLine = l;\n    l->linenumber = ++buf->allLine;\n    if (nlines < 0) {\n\t/*     l->real_linenumber = l->linenumber;     */\n\tl->real_linenumber = 0;\n    }\n    else {\n\tl->real_linenumber = nlines;\n    }\n    l = NULL;\n}\n\nstatic void\naddnewline(Buffer *buf, char *line, Lineprop *prop, Linecolor *color, int pos,\n\t   int width, int nlines)\n{\n    char *s;\n    Lineprop *p;\n#ifdef USE_ANSI_COLOR\n    Linecolor *c;\n#endif\n    Line *l;\n    int i, bpos, bwidth;\n\n    if (pos > 0) {\n\ts = allocStr(line, pos);\n\tp = NewAtom_N(Lineprop, pos);\n\tbcopy((void *)prop, (void *)p, pos * sizeof(Lineprop));\n    }\n    else {\n\ts = NullLine;\n\tp = NullProp;\n    }\n#ifdef USE_ANSI_COLOR\n    if (pos > 0 && color) {\n\tc = NewAtom_N(Linecolor, pos);\n\tbcopy((void *)color, (void *)c, pos * sizeof(Linecolor));\n    }\n    else {\n\tc = NULL;\n    }\n#endif\n    addnewline2(buf, s, p, c, pos, nlines);\n    if (pos <= 0 || width <= 0)\n\treturn;\n    bpos = 0;\n    bwidth = 0;\n    while (1) {\n\tl = buf->currentLine;\n\tl->bpos = bpos;\n\tl->bwidth = bwidth;\n\ti = columnLen(l, width);\n\tif (i == 0) {\n\t    i++;\n#ifdef USE_M17N\n\t    while (i < l->len && p[i] & PC_WCHAR2)\n\t\ti++;\n#endif\n\t}\n\tl->len = i;\n\tl->width = COLPOS(l, l->len);\n\tif (pos <= i)\n\t    return;\n\tbpos += l->len;\n\tbwidth += l->width;\n\ts += i;\n\tp += i;\n#ifdef USE_ANSI_COLOR\n\tif (c)\n\t    c += i;\n#endif\n\tpos -= i;\n\taddnewline2(buf, s, p, c, pos, nlines);\n    }\n}\n\n/* \n * loadHTMLBuffer: read file and make new buffer\n */\nBuffer *\nloadHTMLBuffer(URLFile *f, Buffer *newBuf)\n{\n    FILE *src = NULL;\n    Str tmp;\n\n    if (newBuf == NULL)\n\tnewBuf = newBuffer(INIT_BUFFER_WIDTH);\n    if (newBuf->sourcefile == NULL &&\n\t(f->scheme != SCM_LOCAL || newBuf->mailcap)) {\n\ttmp = tmpfname(TMPF_SRC, \".html\");\n\tsrc = fopen(tmp->ptr, \"w\");\n\tif (src)\n\t    newBuf->sourcefile = tmp->ptr;\n    }\n\n    loadHTMLstream(f, newBuf, src, newBuf->bufferprop & BP_FRAME);\n\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    if (n_textarea)\n\tformResetBuffer(newBuf, newBuf->formitem);\n    if (src)\n\tfclose(src);\n\n    return newBuf;\n}\n\nstatic char *_size_unit[] = { \"b\", \"kb\", \"Mb\", \"Gb\", \"Tb\",\n    \"Pb\", \"Eb\", \"Zb\", \"Bb\", \"Yb\", NULL\n};\n\nchar *\nconvert_size(clen_t size, int usefloat)\n{\n    float csize;\n    int sizepos = 0;\n    char **sizes = _size_unit;\n\n    csize = (float)size;\n    while (csize >= 999.495 && sizes[sizepos + 1]) {\n\tcsize = csize / 1024.0;\n\tsizepos++;\n    }\n    return Sprintf(usefloat ? \"%.3g%s\" : \"%.0f%s\",\n\t\t   floor(csize * 100.0 + 0.5) / 100.0, sizes[sizepos])->ptr;\n}\n\nchar *\nconvert_size2(clen_t size1, clen_t size2, int usefloat)\n{\n    char **sizes = _size_unit;\n    float csize, factor = 1;\n    int sizepos = 0;\n\n    csize = (float)((size1 > size2) ? size1 : size2);\n    while (csize / factor >= 999.495 && sizes[sizepos + 1]) {\n\tfactor *= 1024.0;\n\tsizepos++;\n    }\n    return Sprintf(usefloat ? \"%.3g/%.3g%s\" : \"%.0f/%.0f%s\",\n\t\t   floor(size1 / factor * 100.0 + 0.5) / 100.0,\n\t\t   floor(size2 / factor * 100.0 + 0.5) / 100.0,\n\t\t   sizes[sizepos])->ptr;\n}\n\nvoid\nshowProgress(clen_t * linelen, clen_t * trbyte)\n{\n    int i, j, rate, duration, eta, pos;\n    static time_t last_time, start_time;\n    time_t cur_time;\n    Str messages;\n    char *fmtrbyte, *fmrate;\n\n    if (!fmInitialized)\n\treturn;\n\n    if (*linelen < 1024)\n\treturn;\n    if (current_content_length > 0) {\n\tdouble ratio;\n\tcur_time = time(0);\n\tif (*trbyte == 0) {\n\t    move(LASTLINE, 0);\n\t    clrtoeolx();\n\t    start_time = cur_time;\n\t}\n\t*trbyte += *linelen;\n\t*linelen = 0;\n\tif (cur_time == last_time)\n\t    return;\n\tlast_time = cur_time;\n\tmove(LASTLINE, 0);\n\tratio = 100.0 * (*trbyte) / current_content_length;\n\tfmtrbyte = convert_size2(*trbyte, current_content_length, 1);\n\tduration = cur_time - start_time;\n\tif (duration) {\n\t    rate = *trbyte / duration;\n\t    fmrate = convert_size(rate, 1);\n\t    eta = rate ? (current_content_length - *trbyte) / rate : -1;\n\t    messages = Sprintf(\"%11s %3.0f%% \"\n\t\t\t       \"%7s/s \"\n\t\t\t       \"eta %02d:%02d:%02d     \",\n\t\t\t       fmtrbyte, ratio,\n\t\t\t       fmrate,\n\t\t\t       eta / (60 * 60), (eta / 60) % 60, eta % 60);\n\t}\n\telse {\n\t    messages = Sprintf(\"%11s %3.0f%%                          \",\n\t\t\t       fmtrbyte, ratio);\n\t}\n\taddstr(messages->ptr);\n\tpos = 42;\n\ti = pos + (COLS - pos - 1) * (*trbyte) / current_content_length;\n\tmove(LASTLINE, pos);\n\tstandout();\n\taddch(' ');\n\tfor (j = pos + 1; j <= i; j++)\n\t    addch('|');\n\tstandend();\n\t/* no_clrtoeol(); */\n\trefresh();\n    }\n    else {\n\tcur_time = time(0);\n\tif (*trbyte == 0) {\n\t    move(LASTLINE, 0);\n\t    clrtoeolx();\n\t    start_time = cur_time;\n\t}\n\t*trbyte += *linelen;\n\t*linelen = 0;\n\tif (cur_time == last_time)\n\t    return;\n\tlast_time = cur_time;\n\tmove(LASTLINE, 0);\n\tfmtrbyte = convert_size(*trbyte, 1);\n\tduration = cur_time - start_time;\n\tif (duration) {\n\t    fmrate = convert_size(*trbyte / duration, 1);\n\t    messages = Sprintf(\"%7s loaded %7s/s\", fmtrbyte, fmrate);\n\t}\n\telse {\n\t    messages = Sprintf(\"%7s loaded\", fmtrbyte);\n\t}\n\tmessage(messages->ptr, 0, 0);\n\trefresh();\n    }\n}\n\nvoid\ninit_henv(struct html_feed_environ *h_env, struct readbuffer *obuf,\n\t  struct environment *envs, int nenv, TextLineList *buf,\n\t  int limit, int indent)\n{\n    envs[0].indent = indent;\n\n    obuf->line = Strnew();\n    obuf->cprop = 0;\n    obuf->pos = 0;\n    obuf->prevchar = Strnew_size(8);\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->flag = RB_IGNORE_P;\n    obuf->flag_sp = 0;\n    obuf->status = R_ST_NORMAL;\n    obuf->table_level = -1;\n    obuf->nobr_level = 0;\n    bzero((void *)&obuf->anchor, sizeof(obuf->anchor));\n    obuf->img_alt = 0;\n    obuf->input_alt.hseq = 0;\n    obuf->input_alt.fid = -1;\n    obuf->input_alt.in = 0;\n    obuf->input_alt.type = NULL;\n    obuf->input_alt.name = NULL;\n    obuf->input_alt.value = NULL;\n    obuf->in_bold = 0;\n    obuf->in_italic = 0;\n    obuf->in_under = 0;\n    obuf->in_strike = 0;\n    obuf->in_ins = 0;\n    obuf->prev_ctype = PC_ASCII;\n    obuf->tag_sp = 0;\n    obuf->fontstat_sp = 0;\n    obuf->top_margin = 0;\n    obuf->bottom_margin = 0;\n    obuf->bp.init_flag = 1;\n    set_breakpoint(obuf, 0);\n\n    h_env->buf = buf;\n    h_env->f = NULL;\n    h_env->obuf = obuf;\n    h_env->tagbuf = Strnew();\n    h_env->limit = limit;\n    h_env->maxlimit = 0;\n    h_env->envs = envs;\n    h_env->nenv = nenv;\n    h_env->envc = 0;\n    h_env->envc_real = 0;\n    h_env->title = NULL;\n    h_env->blank_lines = 0;\n}\n\nvoid\ncompleteHTMLstream(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    close_anchor(h_env, obuf);\n    if (obuf->img_alt) {\n\tpush_tag(obuf, \"</img_alt>\", HTML_N_IMG_ALT);\n\tobuf->img_alt = NULL;\n    }\n    if (obuf->input_alt.in) {\n\tpush_tag(obuf, \"</input_alt>\", HTML_N_INPUT_ALT);\n\tobuf->input_alt.hseq = 0;\n\tobuf->input_alt.fid = -1;\n\tobuf->input_alt.in = 0;\n\tobuf->input_alt.type = NULL;\n\tobuf->input_alt.name = NULL;\n\tobuf->input_alt.value = NULL;\n    }\n    if (obuf->in_bold) {\n\tpush_tag(obuf, \"</b>\", HTML_N_B);\n\tobuf->in_bold = 0;\n    }\n    if (obuf->in_italic) {\n\tpush_tag(obuf, \"</i>\", HTML_N_I);\n\tobuf->in_italic = 0;\n    }\n    if (obuf->in_under) {\n\tpush_tag(obuf, \"</u>\", HTML_N_U);\n\tobuf->in_under = 0;\n    }\n    if (obuf->in_strike) {\n\tpush_tag(obuf, \"</s>\", HTML_N_S);\n\tobuf->in_strike = 0;\n    }\n    if (obuf->in_ins) {\n\tpush_tag(obuf, \"</ins>\", HTML_N_INS);\n\tobuf->in_ins = 0;\n    }\n    if (obuf->flag & RB_INTXTA)\n\tHTMLlineproc1(\"</textarea>\", h_env);\n    /* for unbalanced select tag */\n    if (obuf->flag & RB_INSELECT)\n\tHTMLlineproc1(\"</select>\", h_env);\n    if (obuf->flag & RB_TITLE)\n\tHTMLlineproc1(\"</title>\", h_env);\n\n    /* for unbalanced table tag */\n    if (obuf->table_level >= MAX_TABLE)\n\tobuf->table_level = MAX_TABLE - 1;\n\n    while (obuf->table_level >= 0) {\n\ttable_mode[obuf->table_level].pre_mode\n\t    &= ~(TBLM_SCRIPT | TBLM_STYLE | TBLM_PLAIN);\n\tHTMLlineproc1(\"</table>\", h_env);\n    }\n}\n\nstatic void\nprint_internal_information(struct html_feed_environ *henv)\n{\n    int i;\n    Str s;\n    TextLineList *tl = newTextLineList();\n\n    s = Strnew_charp(\"<internal>\");\n    pushTextLine(tl, newTextLine(s, 0));\n    if (henv->title) {\n\ts = Strnew_m_charp(\"<title_alt title=\\\"\",\n\t\t\t   html_quote(henv->title), \"\\\">\", NULL);\n\tpushTextLine(tl, newTextLine(s, 0));\n    }\n#if 0\n    if (form_max >= 0) {\n\tFormList *fp;\n\tfor (i = 0; i <= form_max; i++) {\n\t    fp = forms[i];\n\t    s = Sprintf(\"<form_int fid=\\\"%d\\\" action=\\\"%s\\\" method=\\\"%s\\\"\",\n\t\t\ti, html_quote(fp->action->ptr),\n\t\t\t(fp->method == FORM_METHOD_POST) ? \"post\"\n\t\t\t: ((fp->method ==\n\t\t\t    FORM_METHOD_INTERNAL) ? \"internal\" : \"get\"));\n\t    if (fp->target)\n\t\tStrcat(s, Sprintf(\" target=\\\"%s\\\"\", html_quote(fp->target)));\n\t    if (fp->enctype == FORM_ENCTYPE_MULTIPART)\n\t\tStrcat_charp(s, \" enctype=\\\"multipart/form-data\\\"\");\n#ifdef USE_M17N\n\t    if (fp->charset)\n\t\tStrcat(s, Sprintf(\" accept-charset=\\\"%s\\\"\",\n\t\t\t\t  html_quote(fp->charset)));\n#endif\n\t    Strcat_charp(s, \">\");\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t}\n    }\n#endif\n#ifdef MENU_SELECT\n    if (n_select > 0) {\n\tFormSelectOptionItem *ip;\n\tfor (i = 0; i < n_select; i++) {\n\t    s = Sprintf(\"<select_int selectnumber=%d>\", i);\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t    for (ip = select_option[i].first; ip; ip = ip->next) {\n\t\ts = Sprintf(\"<option_int value=\\\"%s\\\" label=\\\"%s\\\"%s>\",\n\t\t\t    html_quote(ip->value ? ip->value->ptr :\n\t\t\t\t       ip->label->ptr),\n\t\t\t    html_quote(ip->label->ptr),\n\t\t\t    ip->checked ? \" selected\" : \"\");\n\t\tpushTextLine(tl, newTextLine(s, 0));\n\t    }\n\t    s = Strnew_charp(\"</select_int>\");\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t}\n    }\n#endif\t\t\t\t/* MENU_SELECT */\n    if (n_textarea > 0) {\n\tfor (i = 0; i < n_textarea; i++) {\n\t    s = Sprintf(\"<textarea_int textareanumber=%d>\", i);\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t    s = Strnew_charp(html_quote(textarea_str[i]->ptr));\n\t    Strcat_charp(s, \"</textarea_int>\");\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t}\n    }\n    s = Strnew_charp(\"</internal>\");\n    pushTextLine(tl, newTextLine(s, 0));\n\n    if (henv->buf)\n\tappendTextLineList(henv->buf, tl);\n    else if (henv->f) {\n\tTextLineListItem *p;\n\tfor (p = tl->first; p; p = p->next)\n\t    fprintf(henv->f, \"%s\\n\", Str_conv_to_halfdump(p->ptr->line)->ptr);\n    }\n}\n\nvoid\nloadHTMLstream(URLFile *f, Buffer *newBuf, FILE * src, int internal)\n{\n    struct environment envs[MAX_ENV_LEVEL];\n    clen_t linelen = 0;\n    clen_t trbyte = 0;\n    Str lineBuf2 = Strnew();\n#ifdef USE_M17N\n    wc_ces charset = WC_CES_US_ASCII;\n    wc_ces volatile doc_charset = DocumentCharset;\n#endif\n    struct html_feed_environ htmlenv1;\n    struct readbuffer obuf;\n#ifdef USE_IMAGE\n    int volatile image_flag;\n#endif\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n\n#ifdef USE_M17N\n    if (fmInitialized && graph_ok()) {\n\tsymbol_width = symbol_width0 = 1;\n    }\n    else {\n\tsymbol_width0 = 0;\n\tget_symbol(DisplayCharset, &symbol_width0);\n\tsymbol_width = WcOption.use_wide ? symbol_width0 : 1;\n    }\n#else\n    symbol_width = symbol_width0 = 1;\n#endif\n\n    cur_title = NULL;\n    n_textarea = 0;\n    cur_textarea = NULL;\n    max_textarea = MAX_TEXTAREA;\n    textarea_str = New_N(Str, max_textarea);\n#ifdef MENU_SELECT\n    n_select = 0;\n    max_select = MAX_SELECT;\n    select_option = New_N(FormSelectOption, max_select);\n#endif\t\t\t\t/* MENU_SELECT */\n    cur_select = NULL;\n    form_sp = -1;\n    form_max = -1;\n    forms_size = 0;\n    forms = NULL;\n    cur_hseq = 1;\n#ifdef USE_IMAGE\n    cur_iseq = 1;\n    if (newBuf->image_flag)\n\timage_flag = newBuf->image_flag;\n    else if (activeImage && displayImage && autoImage)\n\timage_flag = IMG_FLAG_AUTO;\n    else\n\timage_flag = IMG_FLAG_SKIP;\n#endif\n\n    if (w3m_halfload) {\n\tnewBuf->buffername = \"---\";\n#ifdef USE_M17N\n\tnewBuf->document_charset = InnerCharset;\n#endif\n\tmax_textarea = 0;\n#ifdef MENU_SELECT\n\tmax_select = 0;\n#endif\n\tHTMLlineproc3(newBuf, f->stream);\n\tw3m_halfload = FALSE;\n\treturn;\n    }\n\n    init_henv(&htmlenv1, &obuf, envs, MAX_ENV_LEVEL, NULL, newBuf->width, 0);\n\n    if (w3m_halfdump)\n\thtmlenv1.f = stdout;\n    else\n\thtmlenv1.buf = newTextLineList();\n#if defined(USE_M17N) || defined(USE_IMAGE)\n    cur_baseURL = baseURL(newBuf);\n#endif\n\n    if (SETJMP(AbortLoading) != 0) {\n\tHTMLlineproc1(\"<br>Transfer Interrupted!<br>\", &htmlenv1);\n\tgoto phase2;\n    }\n    TRAP_ON;\n\n#ifdef USE_M17N\n    if (newBuf != NULL) {\n\tif (newBuf->bufferprop & BP_FRAME)\n\t    charset = InnerCharset;\n\telse if (newBuf->document_charset)\n\t    charset = doc_charset = newBuf->document_charset;\n    }\n    if (content_charset && UseContentCharset)\n\tdoc_charset = content_charset;\n    else if (f->guess_type && !strcasecmp(f->guess_type, \"application/xhtml+xml\"))\n\tdoc_charset = WC_CES_UTF_8;\n    meta_charset = 0;\n#endif\n#if\t0\n    do_blankline(&htmlenv1, &obuf, 0, 0, htmlenv1.limit);\n    obuf.flag = RB_IGNORE_P;\n#endif\n    if (IStype(f->stream) != IST_ENCODED)\n\tf->stream = newEncodedStream(f->stream, f->encoding);\n    while ((lineBuf2 = StrmyUFgets(f))->length) {\n#ifdef USE_NNTP\n\tif (f->scheme == SCM_NEWS && lineBuf2->ptr[0] == '.') {\n\t    Strshrinkfirst(lineBuf2, 1);\n\t    if (lineBuf2->ptr[0] == '\\n' || lineBuf2->ptr[0] == '\\r' ||\n\t\tlineBuf2->ptr[0] == '\\0') {\n\t\t/*\n\t\t * iseos(f->stream) = TRUE;\n\t\t */\n\t\tbreak;\n\t    }\n\t}\n#endif\t\t\t\t/* USE_NNTP */\n\tif (src)\n\t    Strfputs(lineBuf2, src);\n\tlinelen += lineBuf2->length;\n\tif (w3m_dump & DUMP_EXTRA)\n\t    printf(\"W3m-in-progress: %s\\n\", convert_size2(linelen, current_content_length, TRUE));\n\tif (w3m_dump & DUMP_SOURCE)\n\t    continue;\n\tshowProgress(&linelen, &trbyte);\n\t/*\n\t * if (frame_source)\n\t * continue;\n\t */\n#ifdef USE_M17N\n\tif (meta_charset) {\t/* <META> */\n\t    if (content_charset == 0 && UseContentCharset) {\n\t\tdoc_charset = meta_charset;\n\t\tcharset = WC_CES_US_ASCII;\n\t    }\n\t    meta_charset = 0;\n\t}\n#endif\n\tlineBuf2 = convertLine(f, lineBuf2, HTML_MODE, &charset, doc_charset);\n#ifdef USE_M17N\n\tcur_document_charset = charset;\n#endif\n\tHTMLlineproc0(lineBuf2->ptr, &htmlenv1, internal);\n    }\n    if (obuf.status != R_ST_NORMAL) {\n\tHTMLlineproc0(\"\\n\", &htmlenv1, internal);\n    }\n    obuf.status = R_ST_NORMAL;\n    completeHTMLstream(&htmlenv1, &obuf);\n    flushline(&htmlenv1, &obuf, 0, 2, htmlenv1.limit);\n#if defined(USE_M17N) || defined(USE_IMAGE)\n    cur_baseURL = NULL;\n#endif\n#ifdef USE_M17N\n    cur_document_charset = 0;\n#endif\n    if (htmlenv1.title)\n\tnewBuf->buffername = htmlenv1.title;\n    if (w3m_halfdump) {\n\tTRAP_OFF;\n\tprint_internal_information(&htmlenv1);\n\treturn;\n    }\n    if (w3m_backend) {\n\tTRAP_OFF;\n\tprint_internal_information(&htmlenv1);\n\tbackend_halfdump_buf = htmlenv1.buf;\n\treturn;\n    }\n  phase2:\n    newBuf->trbyte = trbyte + linelen;\n    TRAP_OFF;\n#ifdef USE_M17N\n    if (!(newBuf->bufferprop & BP_FRAME))\n\tnewBuf->document_charset = charset;\n#endif\n#ifdef USE_IMAGE\n    newBuf->image_flag = image_flag;\n#endif\n    HTMLlineproc2(newBuf, htmlenv1.buf);\n}\n\n/* \n * loadHTMLString: read string and make new buffer\n */\nBuffer *\nloadHTMLString(Str page)\n{\n    URLFile f;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    Buffer *newBuf;\n\n    init_stream(&f, SCM_LOCAL, newStrStream(page));\n\n    newBuf = newBuffer(INIT_BUFFER_WIDTH);\n    if (SETJMP(AbortLoading) != 0) {\n\tTRAP_OFF;\n\tdiscardBuffer(newBuf);\n\tUFclose(&f);\n\treturn NULL;\n    }\n    TRAP_ON;\n\n#ifdef USE_M17N\n    newBuf->document_charset = InnerCharset;\n#endif\n    loadHTMLstream(&f, newBuf, NULL, TRUE);\n#ifdef USE_M17N\n    newBuf->document_charset = WC_CES_US_ASCII;\n#endif\n\n    TRAP_OFF;\n    UFclose(&f);\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    newBuf->type = \"text/html\";\n    newBuf->real_type = newBuf->type;\n    if (n_textarea)\n\tformResetBuffer(newBuf, newBuf->formitem);\n    return newBuf;\n}\n\n#ifdef USE_GOPHER\n\n/* \n * loadGopherDir: get gopher directory\n */\nStr\nloadGopherDir(URLFile *uf, ParsedURL *pu, wc_ces * charset)\n{\n    Str volatile tmp;\n    Str lbuf, name, file, host, port;\n    char *volatile p, *volatile q;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n#ifdef USE_M17N\n    wc_ces doc_charset = DocumentCharset;\n#endif\n\n    tmp = parsedURL2Str(pu);\n    p = html_quote(tmp->ptr);\n    tmp =\n\tconvertLine(NULL, Strnew_charp(file_unquote(tmp->ptr)), RAW_MODE,\n\t\t    charset, doc_charset);\n    q = html_quote(tmp->ptr);\n    tmp = Strnew_m_charp(\"<html>\\n<head>\\n<base href=\\\"\", p, \"\\\">\\n<title>\", q,\n\t\t\t \"</title>\\n</head>\\n<body>\\n<h1>Index of \", q,\n\t\t\t \"</h1>\\n<table>\\n\", NULL);\n\n    if (SETJMP(AbortLoading) != 0)\n\tgoto gopher_end;\n    TRAP_ON;\n\n    while (1) {\n\tif (lbuf = StrUFgets(uf), lbuf->length == 0)\n\t    break;\n\tif (lbuf->ptr[0] == '.' &&\n\t    (lbuf->ptr[1] == '\\n' || lbuf->ptr[1] == '\\r'))\n\t    break;\n\tlbuf = convertLine(uf, lbuf, HTML_MODE, charset, doc_charset);\n\tp = lbuf->ptr;\n\tfor (q = p; *q && *q != '\\t'; q++) ;\n\tname = Strnew_charp_n(p, q - p);\n\tif (!*q)\n\t    continue;\n\tp = q + 1;\n\tfor (q = p; *q && *q != '\\t'; q++) ;\n\tfile = Strnew_charp_n(p, q - p);\n\tif (!*q)\n\t    continue;\n\tp = q + 1;\n\tfor (q = p; *q && *q != '\\t'; q++) ;\n\thost = Strnew_charp_n(p, q - p);\n\tif (!*q)\n\t    continue;\n\tp = q + 1;\n\tfor (q = p; *q && *q != '\\t' && *q != '\\r' && *q != '\\n'; q++) ;\n\tport = Strnew_charp_n(p, q - p);\n\n\tswitch (name->ptr[0]) {\n\tcase '0':\n\t    p = \"[text file]\";\n\t    break;\n\tcase '1':\n\t    p = \"[directory]\";\n\t    break;\n\tcase 'm':\n\t    p = \"[message]\";\n\t    break;\n\tcase 's':\n\t    p = \"[sound]\";\n\t    break;\n\tcase 'g':\n\t    p = \"[gif]\";\n\t    break;\n\tcase 'h':\n\t    p = \"[HTML]\";\n\t    break;\n\tdefault:\n\t    p = \"[unsupported]\";\n\t    break;\n\t}\n\tq = Strnew_m_charp(\"gopher://\", host->ptr, \":\", port->ptr,\n\t\t\t   \"/\", file->ptr, NULL)->ptr;\n\tStrcat_m_charp(tmp, \"<a href=\\\"\",\n\t\t       html_quote(url_encode(q, NULL, *charset)),\n\t\t       \"\\\">\", p, html_quote(name->ptr + 1), \"</a>\\n\", NULL);\n    }\n\n  gopher_end:\n    TRAP_OFF;\n\n    Strcat_charp(tmp, \"</table>\\n</body>\\n</html>\\n\");\n    return tmp;\n}\n#endif\t\t\t\t/* USE_GOPHER */\n\n/* \n * loadBuffer: read file and make new buffer\n */\nBuffer *\nloadBuffer(URLFile *uf, Buffer *volatile newBuf)\n{\n    FILE *volatile src = NULL;\n#ifdef USE_M17N\n    wc_ces charset = WC_CES_US_ASCII;\n    wc_ces volatile doc_charset = DocumentCharset;\n#endif\n    Str lineBuf2;\n    volatile char pre_lbuf = '\\0';\n    int nlines;\n    Str tmpf;\n    clen_t linelen = 0, trbyte = 0;\n    Lineprop *propBuffer = NULL;\n#ifdef USE_ANSI_COLOR\n    Linecolor *colorBuffer = NULL;\n#endif\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n\n    if (newBuf == NULL)\n\tnewBuf = newBuffer(INIT_BUFFER_WIDTH);\n\n    if (SETJMP(AbortLoading) != 0) {\n\tgoto _end;\n    }\n    TRAP_ON;\n\n    if (newBuf->sourcefile == NULL &&\n\t(uf->scheme != SCM_LOCAL || newBuf->mailcap)) {\n\ttmpf = tmpfname(TMPF_SRC, NULL);\n\tsrc = fopen(tmpf->ptr, \"w\");\n\tif (src)\n\t    newBuf->sourcefile = tmpf->ptr;\n    }\n#ifdef USE_M17N\n    if (newBuf->document_charset)\n\tcharset = doc_charset = newBuf->document_charset;\n    if (content_charset && UseContentCharset)\n\tdoc_charset = content_charset;\n#endif\n\n    nlines = 0;\n    if (IStype(uf->stream) != IST_ENCODED)\n\tuf->stream = newEncodedStream(uf->stream, uf->encoding);\n    while ((lineBuf2 = StrmyISgets(uf->stream))->length) {\n#ifdef USE_NNTP\n\tif (uf->scheme == SCM_NEWS && lineBuf2->ptr[0] == '.') {\n\t    Strshrinkfirst(lineBuf2, 1);\n\t    if (lineBuf2->ptr[0] == '\\n' || lineBuf2->ptr[0] == '\\r' ||\n\t\tlineBuf2->ptr[0] == '\\0') {\n\t\t/*\n\t\t * iseos(uf->stream) = TRUE;\n\t\t */\n\t\tbreak;\n\t    }\n\t}\n#endif\t\t\t\t/* USE_NNTP */\n\tif (src)\n\t    Strfputs(lineBuf2, src);\n\tlinelen += lineBuf2->length;\n\tif (w3m_dump & DUMP_EXTRA)\n\t    printf(\"W3m-in-progress: %s\\n\", convert_size2(linelen, current_content_length, TRUE));\n\tif (w3m_dump & DUMP_SOURCE)\n\t    continue;\n\tshowProgress(&linelen, &trbyte);\n\tif (frame_source)\n\t    continue;\n\tlineBuf2 =\n\t    convertLine(uf, lineBuf2, PAGER_MODE, &charset, doc_charset);\n\tif (squeezeBlankLine) {\n\t    if (lineBuf2->ptr[0] == '\\n' && pre_lbuf == '\\n') {\n\t\t++nlines;\n\t\tcontinue;\n\t    }\n\t    pre_lbuf = lineBuf2->ptr[0];\n\t}\n\t++nlines;\n\tStrchop(lineBuf2);\n\tlineBuf2 = checkType(lineBuf2, &propBuffer, NULL);\n\taddnewline(newBuf, lineBuf2->ptr, propBuffer, colorBuffer,\n\t\t   lineBuf2->length, FOLD_BUFFER_WIDTH, nlines);\n    }\n  _end:\n    TRAP_OFF;\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    newBuf->trbyte = trbyte + linelen;\n#ifdef USE_M17N\n    newBuf->document_charset = charset;\n#endif\n    if (src)\n\tfclose(src);\n\n    return newBuf;\n}\n\n#ifdef USE_IMAGE\nBuffer *\nloadImageBuffer(URLFile *uf, Buffer *newBuf)\n{\n    Image image;\n    ImageCache *cache;\n    Str tmp, tmpf;\n    FILE *src = NULL;\n    URLFile f;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    struct stat st;\n    const ParsedURL *pu = newBuf ? &newBuf->currentURL : NULL;\n\n    loadImage(newBuf, IMG_FLAG_STOP);\n    image.url = uf->url;\n    image.ext = uf->ext;\n    image.width = -1;\n    image.height = -1;\n    image.cache = NULL;\n    cache = getImage(&image, (ParsedURL *)pu, IMG_FLAG_AUTO);\n    if (!(pu && pu->is_nocache) && cache->loaded & IMG_FLAG_LOADED &&\n\t!stat(cache->file, &st))\n\tgoto image_buffer;\n\n    if (IStype(uf->stream) != IST_ENCODED)\n\tuf->stream = newEncodedStream(uf->stream, uf->encoding);\n    TRAP_ON;\n    if (save2tmp(*uf, cache->file) < 0) {\n\tTRAP_OFF;\n\treturn NULL;\n    }\n    TRAP_OFF;\n\n    cache->loaded = IMG_FLAG_LOADED;\n    cache->index = 0;\n\n  image_buffer:\n    if (newBuf == NULL)\n\tnewBuf = newBuffer(INIT_BUFFER_WIDTH);\n    cache->loaded |= IMG_FLAG_DONT_REMOVE;\n    if (newBuf->sourcefile == NULL && uf->scheme != SCM_LOCAL)\n\tnewBuf->sourcefile = cache->file;\n\n    tmp = Sprintf(\"<img src=\\\"%s\\\"><br><br>\", html_quote(image.url));\n    tmpf = tmpfname(TMPF_SRC, \".html\");\n    src = fopen(tmpf->ptr, \"w\");\n    newBuf->mailcap_source = tmpf->ptr;\n\n    init_stream(&f, SCM_LOCAL, newStrStream(tmp));\n    loadHTMLstream(&f, newBuf, src, TRUE);\n    UFclose(&f);\n    if (src)\n\tfclose(src);\n\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    newBuf->image_flag = IMG_FLAG_AUTO;\n    return newBuf;\n}\n#endif\n\nstatic Str\nconv_symbol(Line *l)\n{\n    Str tmp = NULL;\n    char *p = l->lineBuf, *ep = p + l->len;\n    Lineprop *pr = l->propBuf;\n#ifdef USE_M17N\n    int w;\n    char **symbol = NULL;\n#else\n    char **symbol = get_symbol();\n#endif\n\n    for (; p < ep; p++, pr++) {\n\tif (*pr & PC_SYMBOL) {\n#ifdef USE_M17N\n\t    char c = ((char)wtf_get_code((wc_uchar *) p) & 0x7f) - SYMBOL_BASE;\n\t    int len = get_mclen(p);\n#else\n\t    char c = *p - SYMBOL_BASE;\n#endif\n\t    if (tmp == NULL) {\n\t\ttmp = Strnew_size(l->len);\n\t\tStrcopy_charp_n(tmp, l->lineBuf, p - l->lineBuf);\n#ifdef USE_M17N\n\t\tw = (*pr & PC_KANJI) ? 2 : 1;\n\t\tsymbol = get_symbol(DisplayCharset, &w);\n#endif\n\t    }\n\t    Strcat_charp(tmp, symbol[(int)c]);\n#ifdef USE_M17N\n\t    p += len - 1;\n\t    pr += len - 1;\n#endif\n\t}\n\telse if (tmp != NULL)\n\t    Strcat_char(tmp, *p);\n    }\n    if (tmp)\n\treturn tmp;\n    else\n\treturn Strnew_charp_n(l->lineBuf, l->len);\n}\n\n/* \n * saveBuffer: write buffer to file\n */\nstatic void\n_saveBuffer(Buffer *buf, Line *l, FILE * f, int cont)\n{\n    Str tmp;\n    int is_html = FALSE;\n#ifdef USE_M17N\n    int set_charset = !DisplayCharset;\n    wc_ces charset = DisplayCharset ? DisplayCharset : WC_CES_US_ASCII;\n#endif\n\n    is_html = is_html_type(buf->type);\n\n  pager_next:\n    for (; l != NULL; l = l->next) {\n\tif (is_html)\n\t    tmp = conv_symbol(l);\n\telse\n\t    tmp = Strnew_charp_n(l->lineBuf, l->len);\n\ttmp = wc_Str_conv(tmp, InnerCharset, charset);\n\tStrfputs(tmp, f);\n\tif (Strlastchar(tmp) != '\\n' && !(cont && l->next && l->next->bpos))\n\t    putc('\\n', f);\n    }\n    if (buf->pagerSource && !(buf->bufferprop & BP_CLOSE)) {\n\tl = getNextPage(buf, PagerMax);\n#ifdef USE_M17N\n\tif (set_charset)\n\t    charset = buf->document_charset;\n#endif\n\tgoto pager_next;\n    }\n}\n\nvoid\nsaveBuffer(Buffer *buf, FILE * f, int cont)\n{\n    _saveBuffer(buf, buf->firstLine, f, cont);\n}\n\nvoid\nsaveBufferBody(Buffer *buf, FILE * f, int cont)\n{\n    Line *l = buf->firstLine;\n\n    while (l != NULL && l->real_linenumber == 0)\n\tl = l->next;\n    _saveBuffer(buf, l, f, cont);\n}\n\nstatic Buffer *\nloadcmdout(char *cmd,\n\t   Buffer *(*loadproc) (URLFile *, Buffer *), Buffer *defaultbuf)\n{\n    FILE *f, *popen(const char *, const char *);\n    Buffer *buf;\n    URLFile uf;\n\n    if (cmd == NULL || *cmd == '\\0')\n\treturn NULL;\n    f = popen(cmd, \"r\");\n    if (f == NULL)\n\treturn NULL;\n    init_stream(&uf, SCM_UNKNOWN, newFileStream(f, (void (*)())pclose));\n    buf = loadproc(&uf, defaultbuf);\n    UFclose(&uf);\n    return buf;\n}\n\n/* \n * getshell: execute shell command and get the result into a buffer\n */\nBuffer *\ngetshell(char *cmd)\n{\n    Buffer *buf;\n\n    buf = loadcmdout(cmd, loadBuffer, NULL);\n    if (buf == NULL)\n\treturn NULL;\n    buf->filename = cmd;\n    buf->buffername = Sprintf(\"%s %s\", SHELLBUFFERNAME,\n\t\t\t      conv_from_system(cmd))->ptr;\n    return buf;\n}\n\n/* \n * getpipe: execute shell command and connect pipe to the buffer\n */\nBuffer *\ngetpipe(char *cmd)\n{\n    FILE *f, *popen(const char *, const char *);\n    Buffer *buf;\n\n    if (cmd == NULL || *cmd == '\\0')\n\treturn NULL;\n    f = popen(cmd, \"r\");\n    if (f == NULL)\n\treturn NULL;\n    buf = newBuffer(INIT_BUFFER_WIDTH);\n    buf->pagerSource = newFileStream(f, (void (*)())pclose);\n    buf->filename = cmd;\n    buf->buffername = Sprintf(\"%s %s\", PIPEBUFFERNAME,\n\t\t\t      conv_from_system(cmd))->ptr;\n    buf->bufferprop |= BP_PIPE;\n#ifdef USE_M17N\n    buf->document_charset = WC_CES_US_ASCII;\n#endif\n    return buf;\n}\n\n/* \n * Open pager buffer\n */\nBuffer *\nopenPagerBuffer(InputStream stream, Buffer *buf)\n{\n\n    if (buf == NULL)\n\tbuf = newBuffer(INIT_BUFFER_WIDTH);\n    buf->pagerSource = stream;\n    buf->buffername = getenv(\"MAN_PN\");\n    if (buf->buffername == NULL)\n\tbuf->buffername = PIPEBUFFERNAME;\n    else\n\tbuf->buffername = conv_from_system(buf->buffername);\n    buf->bufferprop |= BP_PIPE;\n#ifdef USE_M17N\n    if (content_charset && UseContentCharset)\n\tbuf->document_charset = content_charset;\n    else\n\tbuf->document_charset = WC_CES_US_ASCII;\n#endif\n    buf->currentLine = buf->firstLine;\n\n    return buf;\n}\n\nBuffer *\nopenGeneralPagerBuffer(InputStream stream)\n{\n    Buffer *buf;\n    char *t = \"text/plain\";\n    Buffer *t_buf = NULL;\n    URLFile uf;\n\n    init_stream(&uf, SCM_UNKNOWN, stream);\n\n#ifdef USE_M17N\n    content_charset = 0;\n#endif\n    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n    copyParsedURL(&t_buf->currentURL, NULL);\n    t_buf->currentURL.scheme = SCM_LOCAL;\n    t_buf->currentURL.file = \"-\";\n    if (SearchHeader) {\n\treadHeader(&uf, t_buf, TRUE, NULL);\n\tt = checkContentType(t_buf);\n\tif (t == NULL)\n\t    t = \"text/plain\";\n\tif (t_buf) {\n\t    t_buf->topLine = t_buf->firstLine;\n\t    t_buf->currentLine = t_buf->lastLine;\n\t}\n\tSearchHeader = FALSE;\n    }\n    else if (DefaultType) {\n\tt = DefaultType;\n\tDefaultType = NULL;\n    }\n    if (is_html_type(t)) {\n\tbuf = loadHTMLBuffer(&uf, t_buf);\n\tbuf->type = \"text/html\";\n    }\n    else if (is_plain_text_type(t)) {\n\tif (IStype(stream) != IST_ENCODED)\n\t    stream = newEncodedStream(stream, uf.encoding);\n\tbuf = openPagerBuffer(stream, t_buf);\n\tbuf->type = \"text/plain\";\n    }\n#ifdef USE_IMAGE\n    else if (activeImage && displayImage && !useExtImageViewer &&\n\t     !(w3m_dump & ~DUMP_FRAME) && !strncasecmp(t, \"image/\", 6)) {\n\tbuf = loadImageBuffer(&uf, t_buf);\n\tbuf->type = \"text/html\";\n    }\n#endif\n    else {\n\tif (searchExtViewer(t)) {\n\t    buf = doExternal(uf, t, t_buf);\n\t    UFclose(&uf);\n\t    if (buf == NULL || buf == NO_BUFFER)\n\t\treturn buf;\n\t}\n\telse {\t\t\t/* unknown type is regarded as text/plain */\n\t    if (IStype(stream) != IST_ENCODED)\n\t\tstream = newEncodedStream(stream, uf.encoding);\n\t    buf = openPagerBuffer(stream, t_buf);\n\t    buf->type = \"text/plain\";\n\t}\n    }\n    buf->real_type = t;\n    return buf;\n}\n\nLine *\ngetNextPage(Buffer *buf, int plen)\n{\n    Line *volatile top = buf->topLine, *volatile last = buf->lastLine,\n\t*volatile cur = buf->currentLine;\n    int i;\n    int volatile nlines = 0;\n    clen_t linelen = 0, trbyte = buf->trbyte;\n    Str lineBuf2;\n    char volatile pre_lbuf = '\\0';\n    URLFile uf;\n#ifdef USE_M17N\n    wc_ces charset;\n    wc_ces volatile doc_charset = DocumentCharset;\n    wc_uint8 old_auto_detect = WcOption.auto_detect;\n#endif\n    int volatile squeeze_flag = FALSE;\n    Lineprop *propBuffer = NULL;\n\n#ifdef USE_ANSI_COLOR\n    Linecolor *colorBuffer = NULL;\n#endif\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n\n    if (buf->pagerSource == NULL)\n\treturn NULL;\n\n    if (last != NULL) {\n\tnlines = last->real_linenumber;\n\tpre_lbuf = *(last->lineBuf);\n\tif (pre_lbuf == '\\0')\n\t    pre_lbuf = '\\n';\n\tbuf->currentLine = last;\n    }\n\n#ifdef USE_M17N\n    charset = buf->document_charset;\n    if (buf->document_charset != WC_CES_US_ASCII)\n\tdoc_charset = buf->document_charset;\n    else if (UseContentCharset) {\n\tcontent_charset = 0;\n\tcheckContentType(buf);\n\tif (content_charset)\n\t    doc_charset = content_charset;\n    }\n    WcOption.auto_detect = buf->auto_detect;\n#endif\n\n    if (SETJMP(AbortLoading) != 0) {\n\tgoto pager_end;\n    }\n    TRAP_ON;\n\n    init_stream(&uf, SCM_UNKNOWN, NULL);\n    for (i = 0; i < plen; i++) {\n\tlineBuf2 = StrmyISgets(buf->pagerSource);\n\tif (lineBuf2->length == 0) {\n\t    /* Assume that `cmd == buf->filename' */\n\t    if (buf->filename)\n\t\tbuf->buffername = Sprintf(\"%s %s\",\n\t\t\t\t\t  CPIPEBUFFERNAME,\n\t\t\t\t\t  conv_from_system(buf->filename))->\n\t\t    ptr;\n\t    else if (getenv(\"MAN_PN\") == NULL)\n\t\tbuf->buffername = CPIPEBUFFERNAME;\n\t    buf->bufferprop |= BP_CLOSE;\n\t    break;\n\t}\n\tlinelen += lineBuf2->length;\n\tshowProgress(&linelen, &trbyte);\n\tlineBuf2 =\n\t    convertLine(&uf, lineBuf2, PAGER_MODE, &charset, doc_charset);\n\tif (squeezeBlankLine) {\n\t    squeeze_flag = FALSE;\n\t    if (lineBuf2->ptr[0] == '\\n' && pre_lbuf == '\\n') {\n\t\t++nlines;\n\t\t--i;\n\t\tsqueeze_flag = TRUE;\n\t\tcontinue;\n\t    }\n\t    pre_lbuf = lineBuf2->ptr[0];\n\t}\n\t++nlines;\n\tStrchop(lineBuf2);\n\tlineBuf2 = checkType(lineBuf2, &propBuffer, &colorBuffer);\n\taddnewline(buf, lineBuf2->ptr, propBuffer, colorBuffer,\n\t\t   lineBuf2->length, FOLD_BUFFER_WIDTH, nlines);\n\tif (!top) {\n\t    top = buf->firstLine;\n\t    cur = top;\n\t}\n\tif (buf->lastLine->real_linenumber - buf->firstLine->real_linenumber\n\t    >= PagerMax) {\n\t    Line *l = buf->firstLine;\n\t    do {\n\t\tif (top == l)\n\t\t    top = l->next;\n\t\tif (cur == l)\n\t\t    cur = l->next;\n\t\tif (last == l)\n\t\t    last = NULL;\n\t\tl = l->next;\n\t    } while (l && l->bpos);\n\t    buf->firstLine = l;\n\t    buf->firstLine->prev = NULL;\n\t}\n    }\n  pager_end:\n    TRAP_OFF;\n\n    buf->trbyte = trbyte + linelen;\n#ifdef USE_M17N\n    buf->document_charset = charset;\n    WcOption.auto_detect = old_auto_detect;\n#endif\n    buf->topLine = top;\n    buf->currentLine = cur;\n    if (!last)\n\tlast = buf->firstLine;\n    else if (last && (last->next || !squeeze_flag))\n\tlast = last->next;\n    return last;\n}\n\nint\nsave2tmp(URLFile uf, char *tmpf)\n{\n    FILE *ff;\n    int check;\n    clen_t linelen = 0, trbyte = 0;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    static JMP_BUF env_bak;\n    volatile int retval = 0;\n    char *volatile buf = NULL;\n\n    ff = fopen(tmpf, \"wb\");\n    if (ff == NULL) {\n\t/* fclose(f); */\n\treturn -1;\n    }\n    bcopy(AbortLoading, env_bak, sizeof(JMP_BUF));\n    if (SETJMP(AbortLoading) != 0) {\n\tgoto _end;\n    }\n    TRAP_ON;\n    check = 0;\n#ifdef USE_NNTP\n    if (uf.scheme == SCM_NEWS) {\n\tchar c;\n\twhile (c = UFgetc(&uf), !iseos(uf.stream)) {\n\t    if (c == '\\n') {\n\t\tif (check == 0)\n\t\t    check++;\n\t\telse if (check == 3)\n\t\t    break;\n\t    }\n\t    else if (c == '.' && check == 1)\n\t\tcheck++;\n\t    else if (c == '\\r' && check == 2)\n\t\tcheck++;\n\t    else\n\t\tcheck = 0;\n\t    putc(c, ff);\n\t    linelen += sizeof(c);\n\t    showProgress(&linelen, &trbyte);\n\t}\n    }\n    else\n#endif\t\t\t\t/* USE_NNTP */\n    {\n\tint count;\n\n\tbuf = NewWithoutGC_N(char, SAVE_BUF_SIZE);\n\twhile ((count = ISread_n(uf.stream, buf, SAVE_BUF_SIZE)) > 0) {\n\t    if (fwrite(buf, 1, count, ff) != count) {\n\t\tretval = -2;\n\t\tgoto _end;\n\t    }\n\t    linelen += count;\n\t    showProgress(&linelen, &trbyte);\n\t}\n    }\n  _end:\n    bcopy(env_bak, AbortLoading, sizeof(JMP_BUF));\n    TRAP_OFF;\n    xfree(buf);\n    fclose(ff);\n    current_content_length = 0;\n    return retval;\n}\n\nBuffer *\ndoExternal(URLFile uf, char *type, Buffer *defaultbuf)\n{\n    Str tmpf, command;\n    struct mailcap *mcap;\n    int mc_stat;\n    Buffer *buf = NULL;\n    char *header, *src = NULL, *ext = uf.ext;\n\n    if (!(mcap = searchExtViewer(type)))\n\treturn NULL;\n\n    if (mcap->nametemplate) {\n\ttmpf = unquote_mailcap(mcap->nametemplate, NULL, \"\", NULL, NULL);\n\tif (tmpf->ptr[0] == '.')\n\t    ext = tmpf->ptr;\n    }\n    tmpf = tmpfname(TMPF_DFL, (ext && *ext) ? ext : NULL);\n\n    if (IStype(uf.stream) != IST_ENCODED)\n\tuf.stream = newEncodedStream(uf.stream, uf.encoding);\n    header = checkHeader(defaultbuf, \"Content-Type:\");\n    if (header)\n\theader = conv_to_system(header);\n    command = unquote_mailcap(mcap->viewer, type, tmpf->ptr, header, &mc_stat);\n#ifndef __EMX__\n    if (!(mc_stat & MCSTAT_REPNAME)) {\n\tStr tmp = Sprintf(\"(%s) < %s\", command->ptr, shell_quote(tmpf->ptr));\n\tcommand = tmp;\n    }\n#endif\n\n#ifdef HAVE_SETPGRP\n    if (!(mcap->flags & (MAILCAP_HTMLOUTPUT | MAILCAP_COPIOUSOUTPUT)) &&\n\t!(mcap->flags & MAILCAP_NEEDSTERMINAL) && BackgroundExtViewer) {\n\tflush_tty();\n\tif (!fork()) {\n\t    setup_child(FALSE, 0, UFfileno(&uf));\n\t    if (save2tmp(uf, tmpf->ptr) < 0)\n\t\texit(1);\n\t    UFclose(&uf);\n\t    myExec(command->ptr);\n\t}\n\treturn NO_BUFFER;\n    }\n    else\n#endif\n    {\n\tif (save2tmp(uf, tmpf->ptr) < 0) {\n\t    return NULL;\n\t}\n    }\n    if (mcap->flags & (MAILCAP_HTMLOUTPUT | MAILCAP_COPIOUSOUTPUT)) {\n\tif (defaultbuf == NULL)\n\t    defaultbuf = newBuffer(INIT_BUFFER_WIDTH);\n\tif (defaultbuf->sourcefile)\n\t    src = defaultbuf->sourcefile;\n\telse\n\t    src = tmpf->ptr;\n\tdefaultbuf->sourcefile = NULL;\n\tdefaultbuf->mailcap = mcap;\n    }\n    if (mcap->flags & MAILCAP_HTMLOUTPUT) {\n\tbuf = loadcmdout(command->ptr, loadHTMLBuffer, defaultbuf);\n\tif (buf && buf != NO_BUFFER) {\n\t    buf->type = \"text/html\";\n\t    buf->mailcap_source = buf->sourcefile;\n\t    buf->sourcefile = src;\n\t}\n    }\n    else if (mcap->flags & MAILCAP_COPIOUSOUTPUT) {\n\tbuf = loadcmdout(command->ptr, loadBuffer, defaultbuf);\n\tif (buf && buf != NO_BUFFER) {\n\t    buf->type = \"text/plain\";\n\t    buf->mailcap_source = buf->sourcefile;\n\t    buf->sourcefile = src;\n\t}\n    }\n    else {\n\tif (mcap->flags & MAILCAP_NEEDSTERMINAL || !BackgroundExtViewer) {\n\t    fmTerm();\n\t    mySystem(command->ptr, 0);\n\t    fmInit();\n\t    if (CurrentTab && Currentbuf)\n\t\tdisplayBuffer(Currentbuf, B_FORCE_REDRAW);\n\t}\n\telse {\n\t    mySystem(command->ptr, 1);\n\t}\n\tbuf = NO_BUFFER;\n    }\n    if (buf && buf != NO_BUFFER) {\n\tif ((buf->buffername == NULL || buf->buffername[0] == '\\0') &&\n\t    buf->filename)\n\t    buf->buffername = conv_from_system(lastFileName(buf->filename));\n\tbuf->edit = mcap->edit;\n\tbuf->mailcap = mcap;\n    }\n    return buf;\n}\n\nstatic int\n_MoveFile(char *path1, char *path2)\n{\n    InputStream f1;\n    FILE *f2;\n    int is_pipe;\n    clen_t linelen = 0, trbyte = 0;\n    char *buf = NULL;\n    int count;\n\n    f1 = openIS(path1);\n    if (f1 == NULL)\n\treturn -1;\n    if (*path2 == '|' && PermitSaveToPipe) {\n\tis_pipe = TRUE;\n\tf2 = popen(path2 + 1, \"w\");\n    }\n    else {\n\tis_pipe = FALSE;\n\tf2 = fopen(path2, \"wb\");\n    }\n    if (f2 == NULL) {\n\tISclose(f1);\n\treturn -1;\n    }\n    current_content_length = 0;\n    buf = NewWithoutGC_N(char, SAVE_BUF_SIZE);\n    while ((count = ISread_n(f1, buf, SAVE_BUF_SIZE)) > 0) {\n\tfwrite(buf, 1, count, f2);\n\tlinelen += count;\n\tshowProgress(&linelen, &trbyte);\n    }\n    xfree(buf);\n    ISclose(f1);\n    if (is_pipe)\n\tpclose(f2);\n    else\n\tfclose(f2);\n    return 0;\n}\n\nint\n_doFileCopy(char *tmpf, char *defstr, int download)\n{\n#ifndef __MINGW32_VERSION\n    Str msg;\n    Str filen;\n    char *p, *q = NULL;\n    pid_t pid;\n    char *lock;\n#if !(defined(HAVE_SYMLINK) && defined(HAVE_LSTAT))\n    FILE *f;\n#endif\n    struct stat st;\n    clen_t size = 0;\n    int is_pipe = FALSE;\n\n    if (fmInitialized) {\n\tp = searchKeyData();\n\tif (p == NULL || *p == '\\0') {\n\t    /* FIXME: gettextize? */\n\t    q = inputLineHist(\"(Download)Save file to: \",\n\t\t\t      defstr, IN_COMMAND, SaveHist);\n\t    if (q == NULL || *q == '\\0')\n\t\treturn FALSE;\n\t    p = conv_to_system(q);\n\t}\n\tif (*p == '|' && PermitSaveToPipe)\n\t    is_pipe = TRUE;\n\telse {\n\t    if (q) {\n\t\tp = unescape_spaces(Strnew_charp(q))->ptr;\n\t\tp = conv_to_system(p);\n\t    }\n\t    p = expandPath(p);\n\t    if (checkOverWrite(p) < 0)\n\t\treturn -1;\n\t}\n\tif (checkCopyFile(tmpf, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    msg = Sprintf(\"Can't copy. %s and %s are identical.\",\n\t\t\t  conv_from_system(tmpf), conv_from_system(p));\n\t    disp_err_message(msg->ptr, FALSE);\n\t    return -1;\n\t}\n\tif (!download) {\n\t    if (_MoveFile(tmpf, p) < 0) {\n\t\t/* FIXME: gettextize? */\n\t\tmsg = Sprintf(\"Can't save to %s\", conv_from_system(p));\n\t\tdisp_err_message(msg->ptr, FALSE);\n\t    }\n\t    return -1;\n\t}\n\tlock = tmpfname(TMPF_DFL, \".lock\")->ptr;\n#if defined(HAVE_SYMLINK) && defined(HAVE_LSTAT)\n\tsymlink(p, lock);\n#else\n\tf = fopen(lock, \"w\");\n\tif (f)\n\t    fclose(f);\n#endif\n\tflush_tty();\n\tpid = fork();\n\tif (!pid) {\n\t    setup_child(FALSE, 0, -1);\n\t    if (!_MoveFile(tmpf, p) && PreserveTimestamp && !is_pipe &&\n\t\t!stat(tmpf, &st))\n\t\tsetModtime(p, st.st_mtime);\n\t    unlink(lock);\n\t    exit(0);\n\t}\n\tif (!stat(tmpf, &st))\n\t    size = st.st_size;\n\taddDownloadList(pid, conv_from_system(tmpf), p, lock, size);\n    }\n    else {\n\tq = searchKeyData();\n\tif (q == NULL || *q == '\\0') {\n\t    /* FIXME: gettextize? */\n\t    printf(\"(Download)Save file to: \");\n\t    fflush(stdout);\n\t    filen = Strfgets(stdin);\n\t    if (filen->length == 0)\n\t\treturn -1;\n\t    q = filen->ptr;\n\t}\n\tfor (p = q + strlen(q) - 1; IS_SPACE(*p); p--) ;\n\t*(p + 1) = '\\0';\n\tif (*q == '\\0')\n\t    return -1;\n\tp = q;\n\tif (*p == '|' && PermitSaveToPipe)\n\t    is_pipe = TRUE;\n\telse {\n\t    p = expandPath(p);\n\t    if (checkOverWrite(p) < 0)\n\t\treturn -1;\n\t}\n\tif (checkCopyFile(tmpf, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    printf(\"Can't copy. %s and %s are identical.\", tmpf, p);\n\t    return -1;\n\t}\n\tif (_MoveFile(tmpf, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    printf(\"Can't save to %s\\n\", p);\n\t    return -1;\n\t}\n\tif (PreserveTimestamp && !is_pipe && !stat(tmpf, &st))\n\t    setModtime(p, st.st_mtime);\n    }\n#endif /* __MINGW32_VERSION */\n    return 0;\n}\n\nint\ndoFileMove(char *tmpf, char *defstr)\n{\n    int ret = doFileCopy(tmpf, defstr);\n    unlink(tmpf);\n    return ret;\n}\n\nint\ndoFileSave(URLFile uf, char *defstr)\n{\n#ifndef __MINGW32_VERSION\n    Str msg;\n    Str filen;\n    char *p, *q;\n    pid_t pid;\n    char *lock;\n    char *tmpf = NULL; \n#if !(defined(HAVE_SYMLINK) && defined(HAVE_LSTAT))\n    FILE *f;\n#endif\n\n    if (fmInitialized) {\n\tp = searchKeyData();\n\tif (p == NULL || *p == '\\0') {\n\t    /* FIXME: gettextize? */\n\t    p = inputLineHist(\"(Download)Save file to: \",\n\t\t\t      defstr, IN_FILENAME, SaveHist);\n\t    if (p == NULL || *p == '\\0')\n\t\treturn -1;\n\t    p = conv_to_system(p);\n\t}\n\tif (checkOverWrite(p) < 0)\n\t    return -1;\n\tif (checkSaveFile(uf.stream, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    msg = Sprintf(\"Can't save. Load file and %s are identical.\",\n\t\t\t  conv_from_system(p));\n\t    disp_err_message(msg->ptr, FALSE);\n\t    return -1;\n\t}\n\t/*\n\t * if (save2tmp(uf, p) < 0) {\n\t * msg = Sprintf(\"Can't save to %s\", conv_from_system(p));\n\t * disp_err_message(msg->ptr, FALSE);\n\t * }\n\t */\n\tlock = tmpfname(TMPF_DFL, \".lock\")->ptr;\n#if defined(HAVE_SYMLINK) && defined(HAVE_LSTAT)\n\tsymlink(p, lock);\n#else\n\tf = fopen(lock, \"w\");\n\tif (f)\n\t    fclose(f);\n#endif\n\tflush_tty();\n\tpid = fork();\n\tif (!pid) {\n\t    int err;\n\t    if ((uf.content_encoding != CMP_NOCOMPRESS) && AutoUncompress) {\n\t\tuncompress_stream(&uf, &tmpf);\n\t\tif (tmpf)\n\t\t    unlink(tmpf);\n\t    }\n\t    setup_child(FALSE, 0, UFfileno(&uf));\n\t    err = save2tmp(uf, p);\n\t    if (err == 0 && PreserveTimestamp && uf.modtime != -1)\n\t\tsetModtime(p, uf.modtime);\n\t    UFclose(&uf);\n\t    unlink(lock);\n\t    if (err != 0)\n\t\texit(-err);\n\t    exit(0);\n\t}\n\taddDownloadList(pid, uf.url, p, lock, current_content_length);\n    }\n    else {\n\tq = searchKeyData();\n\tif (q == NULL || *q == '\\0') {\n\t    /* FIXME: gettextize? */\n\t    printf(\"(Download)Save file to: \");\n\t    fflush(stdout);\n\t    filen = Strfgets(stdin);\n\t    if (filen->length == 0)\n\t\treturn -1;\n\t    q = filen->ptr;\n\t}\n\tfor (p = q + strlen(q) - 1; IS_SPACE(*p); p--) ;\n\t*(p + 1) = '\\0';\n\tif (*q == '\\0')\n\t    return -1;\n\tp = expandPath(q);\n\tif (checkOverWrite(p) < 0)\n\t    return -1;\n\tif (checkSaveFile(uf.stream, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    printf(\"Can't save. Load file and %s are identical.\", p);\n\t    return -1;\n\t}\n\tif (uf.content_encoding != CMP_NOCOMPRESS && AutoUncompress) {\n\t    uncompress_stream(&uf, &tmpf);\n\t    if (tmpf)\n\t\tunlink(tmpf);\n\t}\n\tif (save2tmp(uf, p) < 0) {\n\t    /* FIXME: gettextize? */\n\t    printf(\"Can't save to %s\\n\", p);\n\t    return -1;\n\t}\n\tif (PreserveTimestamp && uf.modtime != -1)\n\t    setModtime(p, uf.modtime);\n    }\n#endif /* __MINGW32_VERSION */\n    return 0;\n}\n\nint\ncheckCopyFile(char *path1, char *path2)\n{\n    struct stat st1, st2;\n\n    if (*path2 == '|' && PermitSaveToPipe)\n\treturn 0;\n    if ((stat(path1, &st1) == 0) && (stat(path2, &st2) == 0))\n\tif (st1.st_ino == st2.st_ino)\n\t    return -1;\n    return 0;\n}\n\nint\ncheckSaveFile(InputStream stream, char *path2)\n{\n    struct stat st1, st2;\n    int des = ISfileno(stream);\n\n    if (des < 0)\n\treturn 0;\n    if (*path2 == '|' && PermitSaveToPipe)\n\treturn 0;\n    if ((fstat(des, &st1) == 0) && (stat(path2, &st2) == 0))\n\tif (st1.st_ino == st2.st_ino)\n\t    return -1;\n    return 0;\n}\n\nint\ncheckOverWrite(char *path)\n{\n    struct stat st;\n    char *ans;\n\n    if (stat(path, &st) < 0)\n\treturn 0;\n    /* FIXME: gettextize? */\n    ans = inputAnswer(\"File exists. Overwrite? (y/n)\");\n    if (ans && TOLOWER(*ans) == 'y')\n\treturn 0;\n    else\n\treturn -1;\n}\n\nchar *\ninputAnswer(char *prompt)\n{\n    char *ans;\n\n    if (QuietMessage)\n\treturn \"n\";\n    if (fmInitialized) {\n\tterm_raw();\n\tans = inputChar(prompt);\n    }\n    else {\n\tprintf(\"%s\", prompt);\n\tfflush(stdout);\n\tans = Strfgets(stdin)->ptr;\n    }\n    return ans;\n}\n\nstatic void\nuncompress_stream(URLFile *uf, char **src)\n{\n#ifndef __MINGW32_VERSION\n    pid_t pid1;\n    FILE *f1;\n    char *expand_cmd = GUNZIP_CMDNAME;\n    char *expand_name = GUNZIP_NAME;\n    char *tmpf = NULL;\n    char *ext = NULL;\n    struct compression_decoder *d;\n\n    if (IStype(uf->stream) != IST_ENCODED) {\n\tuf->stream = newEncodedStream(uf->stream, uf->encoding);\n\tuf->encoding = ENC_7BIT;\n    }\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tif (uf->compression == d->type) {\n\t    if (d->auxbin_p)\n\t\texpand_cmd = auxbinFile(d->cmd);\n\t    else\n\t\texpand_cmd = d->cmd;\n\t    expand_name = d->name;\n\t    ext = d->ext;\n\t    break;\n\t}\n    }\n    uf->compression = CMP_NOCOMPRESS;\n\n    if (uf->scheme != SCM_LOCAL\n#ifdef USE_IMAGE\n\t&& !image_source\n#endif\n\t) {\n\ttmpf = tmpfname(TMPF_DFL, ext)->ptr;\n    }\n\n    /* child1 -- stdout|f1=uf -> parent */\n    pid1 = open_pipe_rw(&f1, NULL);\n    if (pid1 < 0) {\n\tUFclose(uf);\n\treturn;\n    }\n    if (pid1 == 0) {\n\t/* child */\n\tpid_t pid2;\n\tFILE *f2 = stdin;\n\n\t/* uf -> child2 -- stdout|stdin -> child1 */\n\tpid2 = open_pipe_rw(&f2, NULL);\n\tif (pid2 < 0) {\n\t    UFclose(uf);\n\t    exit(1);\n\t}\n\tif (pid2 == 0) {\n\t    /* child2 */\n\t    char *buf = NewWithoutGC_N(char, SAVE_BUF_SIZE);\n\t    int count;\n\t    FILE *f = NULL;\n\n\t    setup_child(TRUE, 2, UFfileno(uf));\n\t    if (tmpf)\n\t\tf = fopen(tmpf, \"wb\");\n\t    while ((count = ISread_n(uf->stream, buf, SAVE_BUF_SIZE)) > 0) {\n\t\tif (fwrite(buf, 1, count, stdout) != count)\n\t\t    break;\n\t\tif (f && fwrite(buf, 1, count, f) != count)\n\t\t    break;\n\t    }\n\t    UFclose(uf);\n\t    if (f)\n\t\tfclose(f);\n\t    xfree(buf);\n\t    exit(0);\n\t}\n\t/* child1 */\n\tdup2(1, 2);\t\t/* stderr>&stdout */\n\tsetup_child(TRUE, -1, -1);\n\texeclp(expand_cmd, expand_name, NULL);\n\texit(1);\n    }\n    if (tmpf) {\n\tif (src)\n\t    *src = tmpf;\n\telse\n\t    uf->scheme = SCM_LOCAL;\n    }\n    UFhalfclose(uf);\n    uf->stream = newFileStream(f1, (void (*)())fclose);\n#endif /* __MINGW32_VERSION */\n}\n\nstatic FILE *\nlessopen_stream(char *path)\n{\n    char *lessopen;\n    FILE *fp;\n\n    lessopen = getenv(\"LESSOPEN\");\n    if (lessopen == NULL) {\n\treturn NULL;\n    }\n    if (lessopen[0] == '\\0') {\n\treturn NULL;\n    }\n\n    if (lessopen[0] == '|') {\n\t/* pipe mode */\n\tStr tmpf;\n\tint c;\n\n\t++lessopen;\n\ttmpf = Sprintf(lessopen, shell_quote(path));\n\tfp = popen(tmpf->ptr, \"r\");\n\tif (fp == NULL) {\n\t    return NULL;\n\t}\n\tc = getc(fp);\n\tif (c == EOF) {\n\t    pclose(fp);\n\t    return NULL;\n\t}\n\tungetc(c, fp);\n    }\n    else {\n\t/* filename mode */\n\t/* not supported m(__)m */\n\tfp = NULL;\n    }\n    return fp;\n}\n\n#if 0\nvoid\nreloadBuffer(Buffer *buf)\n{\n    URLFile uf;\n\n    if (buf->sourcefile == NULL || buf->pagerSource != NULL)\n\treturn;\n    init_stream(&uf, SCM_UNKNOWN, NULL);\n    examineFile(buf->mailcap_source ? buf->mailcap_source : buf->sourcefile,\n\t\t&uf);\n    if (uf.stream == NULL)\n\treturn;\n    is_redisplay = TRUE;\n    buf->allLine = 0;\n    buf->href = NULL;\n    buf->name = NULL;\n    buf->img = NULL;\n    buf->formitem = NULL;\n    buf->linklist = NULL;\n    buf->maplist = NULL;\n    if (buf->hmarklist)\n\tbuf->hmarklist->nmark = 0;\n    if (buf->imarklist)\n\tbuf->imarklist->nmark = 0;\n    if (is_html_type(buf->type))\n\tloadHTMLBuffer(&uf, buf);\n    else\n\tloadBuffer(&uf, buf);\n    UFclose(&uf);\n    is_redisplay = FALSE;\n}\n#endif\n\nstatic char *\nguess_filename(char *file)\n{\n    char *p = NULL, *s;\n\n    if (file != NULL)\n\tp = mybasename(file);\n    if (p == NULL || *p == '\\0')\n\treturn DEF_SAVE_FILE;\n    s = p;\n    if (*p == '#')\n\tp++;\n    while (*p != '\\0') {\n\tif ((*p == '#' && *(p + 1) != '\\0') || *p == '?') {\n\t    *p = '\\0';\n\t    break;\n\t}\n\tp++;\n    }\n    return s;\n}\n\nchar *\nguess_save_name(Buffer *buf, char *path)\n{\n    if (buf && buf->document_header) {\n\tStr name = NULL;\n\tchar *p, *q;\n\tif ((p = checkHeader(buf, \"Content-Disposition:\")) != NULL &&\n\t    (q = strcasestr(p, \"filename\")) != NULL &&\n\t    (q == p || IS_SPACE(*(q - 1)) || *(q - 1) == ';') &&\n\t    matchattr(q, \"filename\", 8, &name))\n\t    path = name->ptr;\n\telse if ((p = checkHeader(buf, \"Content-Type:\")) != NULL &&\n\t\t (q = strcasestr(p, \"name\")) != NULL &&\n\t\t (q == p || IS_SPACE(*(q - 1)) || *(q - 1) == ';') &&\n\t\t matchattr(q, \"name\", 4, &name))\n\t    path = name->ptr;\n    }\n    return guess_filename(path);\n}\n\n/* Local Variables:    */\n/* c-basic-offset: 4   */\n/* tab-width: 8        */\n/* End:                */\n", "/* $Id: parsetagx.c,v 1.18 2006/06/07 03:52:03 inu Exp $ */\n#include \"fm.h\"\n#include \"myctype.h\"\n#include \"indep.h\"\n#include \"Str.h\"\n#include \"parsetagx.h\"\n#include \"hash.h\"\n\n#include \"html.c\"\n\n/* parse HTML tag */\n\nstatic int noConv(char *, char **);\nstatic int toNumber(char *, int *);\nstatic int toLength(char *, int *);\nstatic int toAlign(char *, int *);\nstatic int toVAlign(char *, int *);\n\n/* *INDENT-OFF* */\nstatic int (*toValFunc[]) () = {\n    noConv,\t\t/* VTYPE_NONE    */\n    noConv,\t\t/* VTYPE_STR     */\n    toNumber,\t\t/* VTYPE_NUMBER  */\n    toLength,\t\t/* VTYPE_LENGTH  */\n    toAlign,\t\t/* VTYPE_ALIGN   */\n    toVAlign,\t\t/* VTYPE_VALIGN  */\n    noConv,\t\t/* VTYPE_ACTION  */\n    noConv,\t\t/* VTYPE_ENCTYPE */\n    noConv,\t\t/* VTYPE_METHOD  */\n    noConv,\t\t/* VTYPE_MLENGTH */\n    noConv,\t\t/* VTYPE_TYPE    */\n};\n/* *INDENT-ON* */\n\nstatic int\nnoConv(char *oval, char **str)\n{\n    *str = oval;\n    return 1;\n}\n\nstatic int\ntoNumber(char *oval, int *num)\n{\n    char *ep;\n    int x;\n\n    x = strtol(oval, &ep, 10);\n\n    if (ep > oval) {\n\t*num = x;\n\treturn 1;\n    }\n    else\n\treturn 0;\n}\n\nstatic int\ntoLength(char *oval, int *len)\n{\n    int w;\n    if (!IS_DIGIT(oval[0]))\n\treturn 0;\n    w = atoi(oval);\n    if (w < 0)\n\treturn 0;\n    if (w == 0)\n\tw = 1;\n    if (oval[strlen(oval) - 1] == '%')\n\t*len = -w;\n    else\n\t*len = w;\n    return 1;\n}\n\nstatic int\ntoAlign(char *oval, int *align)\n{\n    if (strcasecmp(oval, \"left\") == 0)\n\t*align = ALIGN_LEFT;\n    else if (strcasecmp(oval, \"right\") == 0)\n\t*align = ALIGN_RIGHT;\n    else if (strcasecmp(oval, \"center\") == 0)\n\t*align = ALIGN_CENTER;\n    else if (strcasecmp(oval, \"top\") == 0)\n\t*align = ALIGN_TOP;\n    else if (strcasecmp(oval, \"bottom\") == 0)\n\t*align = ALIGN_BOTTOM;\n    else if (strcasecmp(oval, \"middle\") == 0)\n\t*align = ALIGN_MIDDLE;\n    else\n\treturn 0;\n    return 1;\n}\n\nstatic int\ntoVAlign(char *oval, int *valign)\n{\n    if (strcasecmp(oval, \"top\") == 0 || strcasecmp(oval, \"baseline\") == 0)\n\t*valign = VALIGN_TOP;\n    else if (strcasecmp(oval, \"bottom\") == 0)\n\t*valign = VALIGN_BOTTOM;\n    else if (strcasecmp(oval, \"middle\") == 0)\n\t*valign = VALIGN_MIDDLE;\n    else\n\treturn 0;\n    return 1;\n}\n\nextern Hash_si tagtable;\n#define MAX_TAG_LEN 64\n\nstruct parsed_tag *\nparse_tag(char **s, int internal)\n{\n    struct parsed_tag *tag = NULL;\n    int tag_id;\n    char tagname[MAX_TAG_LEN], attrname[MAX_TAG_LEN];\n    char *p, *q;\n    int i, attr_id = 0, nattr;\n\n    /* Parse tag name */\n    tagname[0] = '\\0';\n    q = (*s) + 1;\n    p = tagname;\n    if (*q == '/') {\n\t*(p++) = *(q++);\n\tSKIP_BLANKS(q);\n    }\n    while (*q && !IS_SPACE(*q) && !(tagname[0] != '/' && *q == '/') &&\n\t   *q != '>' && p - tagname < MAX_TAG_LEN - 1) {\n\t*(p++) = TOLOWER(*q);\n\tq++;\n    }\n    *p = '\\0';\n    while (*q && !IS_SPACE(*q) && !(tagname[0] != '/' && *q == '/') &&\n\t   *q != '>')\n\tq++;\n\n    tag_id = getHash_si(&tagtable, tagname, HTML_UNKNOWN);\n\n    if (tag_id == HTML_UNKNOWN ||\n\t(!internal && TagMAP[tag_id].flag & TFLG_INT))\n\tgoto skip_parse_tagarg;\n\n    tag = New(struct parsed_tag);\n    bzero(tag, sizeof(struct parsed_tag));\n    tag->tagid = tag_id;\n\n    if ((nattr = TagMAP[tag_id].max_attribute) > 0) {\n\ttag->attrid = NewAtom_N(unsigned char, nattr);\n\ttag->value = New_N(char *, nattr);\n\ttag->map = NewAtom_N(unsigned char, MAX_TAGATTR);\n\tmemset(tag->map, MAX_TAGATTR, MAX_TAGATTR);\n\tmemset(tag->attrid, ATTR_UNKNOWN, nattr);\n\tfor (i = 0; i < nattr; i++)\n\t    tag->map[TagMAP[tag_id].accept_attribute[i]] = i;\n    }\n\n    /* Parse tag arguments */\n    SKIP_BLANKS(q);\n    while (1) {\n       Str value = NULL, value_tmp = NULL;\n\tif (*q == '>' || *q == '\\0')\n\t    goto done_parse_tag;\n\tp = attrname;\n\twhile (*q && *q != '=' && !IS_SPACE(*q) &&\n\t       *q != '>' && p - attrname < MAX_TAG_LEN - 1) {\n\t    *(p++) = TOLOWER(*q);\n\t    q++;\n\t}\n\t*p = '\\0';\n\twhile (*q && *q != '=' && !IS_SPACE(*q) && *q != '>')\n\t    q++;\n\tSKIP_BLANKS(q);\n\tif (*q == '=') {\n\t    /* get value */\n\t    value_tmp = Strnew();\n\t    q++;\n\t    SKIP_BLANKS(q);\n\t    if (*q == '\"') {\n\t\tq++;\n\t\twhile (*q && *q != '\"') {\n\t\t    Strcat_char(value_tmp, *q);\n\t\t    if (!tag->need_reconstruct && is_html_quote(*q))\n\t\t\ttag->need_reconstruct = TRUE;\n\t\t    q++;\n\t\t}\n\t\tif (*q == '\"')\n\t\t    q++;\n\t    }\n\t    else if (*q == '\\'') {\n\t\tq++;\n\t\twhile (*q && *q != '\\'') {\n\t\t    Strcat_char(value_tmp, *q);\n\t\t    if (!tag->need_reconstruct && is_html_quote(*q))\n\t\t\ttag->need_reconstruct = TRUE;\n\t\t    q++;\n\t\t}\n\t\tif (*q == '\\'')\n\t\t    q++;\n\t    }\n\t    else if (*q) {\n\t\twhile (*q && !IS_SPACE(*q) && *q != '>') {\n                   Strcat_char(value_tmp, *q);\n\t\t    if (!tag->need_reconstruct && is_html_quote(*q))\n\t\t\ttag->need_reconstruct = TRUE;\n\t\t    q++;\n\t\t}\n\t    }\n\t}\n\tfor (i = 0; i < nattr; i++) {\n\t    if ((tag)->attrid[i] == ATTR_UNKNOWN &&\n\t\tstrcmp(AttrMAP[TagMAP[tag_id].accept_attribute[i]].name,\n\t\t       attrname) == 0) {\n\t\tattr_id = TagMAP[tag_id].accept_attribute[i];\n\t\tbreak;\n\t    }\n\t}\n\n       if (value_tmp) {\n         int j, hidden=FALSE;\n         for (j=0; j<i; j++) {\n           if (tag->attrid[j] == ATTR_TYPE &&\n               tag->value[j] &&\n               strcmp(\"hidden\",tag->value[j]) == 0) {\n             hidden=TRUE;\n             break;\n           }\n         }\n         if ((tag_id == HTML_INPUT || tag_id == HTML_INPUT_ALT) &&\n             attr_id == ATTR_VALUE && hidden) {\n           value = value_tmp;\n         } else {\n           char *x;\n           value = Strnew();\n           for (x = value_tmp->ptr; *x; x++) {\n             if (*x != '\\n')\n               Strcat_char(value, *x);\n           }\n         }\n       }\n\n\tif (i != nattr) {\n\t    if (!internal &&\n\t\t((AttrMAP[attr_id].flag & AFLG_INT) ||\n\t\t (value && AttrMAP[attr_id].vtype == VTYPE_METHOD &&\n\t\t  !strcasecmp(value->ptr, \"internal\")))) {\n\t\ttag->need_reconstruct = TRUE;\n\t\tcontinue;\n\t    }\n\t    tag->attrid[i] = attr_id;\n\t    if (value)\n\t\ttag->value[i] = html_unquote(value->ptr);\n\t    else\n\t\ttag->value[i] = NULL;\n\t}\n\telse {\n\t    tag->need_reconstruct = TRUE;\n\t}\n    }\n\n  skip_parse_tagarg:\n    while (*q != '>' && *q)\n\tq++;\n  done_parse_tag:\n    if (*q == '>')\n\tq++;\n    *s = q;\n    return tag;\n}\n\nint\nparsedtag_set_value(struct parsed_tag *tag, int id, char *value)\n{\n    int i;\n\n    if (!parsedtag_accepts(tag, id))\n\treturn 0;\n\n    i = tag->map[id];\n    tag->attrid[i] = id;\n    if (value)\n\ttag->value[i] = allocStr(value, -1);\n    else\n\ttag->value[i] = NULL;\n    tag->need_reconstruct = TRUE;\n    return 1;\n}\n\nint\nparsedtag_get_value(struct parsed_tag *tag, int id, void *value)\n{\n    int i;\n    if (!parsedtag_exists(tag, id) || !tag->value[i = tag->map[id]])\n\treturn 0;\n    return toValFunc[AttrMAP[id].vtype] (tag->value[i], value);\n}\n\nStr\nparsedtag2str(struct parsed_tag *tag)\n{\n    int i;\n    int tag_id = tag->tagid;\n    int nattr = TagMAP[tag_id].max_attribute;\n    Str tagstr = Strnew();\n    Strcat_char(tagstr, '<');\n    Strcat_charp(tagstr, TagMAP[tag_id].name);\n    for (i = 0; i < nattr; i++) {\n\tif (tag->attrid[i] != ATTR_UNKNOWN) {\n\t    Strcat_char(tagstr, ' ');\n\t    Strcat_charp(tagstr, AttrMAP[tag->attrid[i]].name);\n\t    if (tag->value[i])\n\t\tStrcat(tagstr, Sprintf(\"=\\\"%s\\\"\", html_quote(tag->value[i])));\n\t}\n    }\n    Strcat_char(tagstr, '>');\n    return tagstr;\n}\n"], "filenames": ["file.c", "parsetagx.c"], "buggy_code_start_loc": [4688, 122], "buggy_code_end_loc": [4688, 122], "fixing_code_start_loc": [4689, 123], "fixing_code_end_loc": [4695, 124], "type": "CWE-20", "message": "parsetagx.c in w3m before 0.5.3+git20161009 does not properly initialize values, which allows remote attackers to crash the application via a crafted html file, related to a <i> tag.", "other": {"cve": {"id": "CVE-2016-9436", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-20T15:59:00.677", "lastModified": "2018-10-30T16:27:33.013", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "parsetagx.c in w3m before 0.5.3+git20161009 does not properly initialize values, which allows remote attackers to crash the application via a crafted html file, related to a <i> tag."}, {"lang": "es", "value": "parsetagx.c en w3m en versiones anteriores a 0.5.3+git20161009 no inicia valores adecuadamente, lo que permite a atacantes remotos bloquear la aplicaci\u00f3n a trav\u00e9s de un archivo html manipulado, relacionado con una etiqueta \n<i>.</i>"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.2:*:*:*:*:*:*:*", "matchCriteriaId": "1EA337A3-B9A3-4962-B8BD-8E0C7C5B28EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse_project:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "CF605E46-ADCE-45B3-BBBA-E593D3CEE2A6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:w3m_project:w3m:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.3\\+git20160718", "matchCriteriaId": "5CA1580D-FAA5-4022-B748-A4F9578491AF"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-12/msg00084.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/18/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94407", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/tats/w3m/commit/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Technical Description", "Patch"]}, {"url": "https://github.com/tats/w3m/issues/16", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201701-08", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/tats/w3m/commit/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd"}}