{"buggy_code": ["# mt7688-wiscan\n\n## Table of Contents\n\n1. [Overiew](#Overiew)    \n2. [Installation](#Installation) \n3. [Usage](#Usage)\n\n<a name=\"Overiew\"></a>\n## 1. Overview\n\n**mt7688-wiscan** is a wifi access points scanning tool which is running with node.js on MediaTek Linkit Smart 7688. This tool provides three APIs [lqi()](#API_lqi), [scan()](#API_scan), and [scanByEssid()](#API_scanByEssid) that help you with getting link quality indicator (LQI) to an specific AP, scanning neighbor wifi APs, and scanning a specific AP with its **essid**.  \n\nI am using this tool on machine nodes in my LWM2M IoT project. On each machine, there is a panel to show some information about the machine and to show LQI between machine and its router as well.  \n\n<a name=\"Installation\"></a>\n## 2. Installation\n\n> $ npm install mt7688-wiscan --save\n  \n<a name=\"Usage\"></a>\n## 3. Usage\n\n### Require the module\n\n```js\nvar wiscan = require('mt7688-wiscan');\n```\n\n********************************************\n<a name=\"API_lqi\"></a>\n### .lqi([intf,] essid, callback)\nQuery the LQI (link quality indicator) between your Linkit Smart 7688(in station mode) and its router(AP).  \n\n**Arguments:**  \n\n1. `intf` (_String_, optional): A default value of `'ra0'` will be used if not given.  \n2. `essid` (_String_): The ESSID of the AP to scan for.  \n3. `callback` (_Function_): `function(err, result) { ... }`. The `result` is a number between 0 and 100 to indicate the relative link quality between the station and access point. The value is bigger to show better link quality. If given 'essid' is not found after scan, `result` will be `null`.  \n  \n  \n**[Note]**\n* It takes around 5 seconds to accomplish a single scan.  \n* If you've changed the name of radio interface with OpenWrt configuration tool, you should give this method with the correct interface name, for example, `'myradio'`.  \n* You can also try this tool on other platforms, but be aware of that the radio interface name is subject to platforms. Use `iwconfig` command at console to get some hints.  \n  \n**Returns:**  \n  \n* _none_\n\n**Examples:**  \n  \n```js\n// scan with deafult radio interface, just give it an essid to scan for\nwiscan.lqi('my_office_ap', function (err, result) {\n    if (err)\n        console.log(err);       // null\n    else\n        console.log(result);    // 78\n});\n\n// if an AP with given essid is not around (result is nothing after scan)\nwiscan.lqi('ap_not_found', function (err, result) {\n    if (err)\n        console.log(err);       // null\n    else\n        console.log(result);    // null\n});\n\n// scan with the given radio interface and essid\nwiscan.lqi('ra0', 'my_office_ap', function (err, result) {\n    if (err)\n        console.log(err);       // null\n    else\n        console.log(result);    // 82\n});\n\n// scan with the given radio interface, e.g. 'bad_ra', that doesn't exist\nwiscan.lqi('bad_ra', 'my_office_ap', function (err, result) {\n    if (err)\n        console.log(err);       // [Error: No such wireless device: bad_ra]\n});\n\n```\n\n********************************************\n\n<a name=\"API_scan\"></a>\n### .scan([intf,] callback)\nScan neighbor wifi access points.  \n\n**Arguments:**  \n\n1. `intf` (_String_, optional): A default value of `'ra0'` will be used if not given.  \n2. `callback` (_Function_): `function(err, result) { ... }`. The `result` is an array of scanned report objects. Each report object has the following format:\n\n```js\n{ \n    address: 'D8:FE:E3:E5:9F:3B',    // String. MAC address of the found AP\n    essid: 'sivann',                 // String\n    mode: 'Master',                  // String\n    channel: 1,                      // Number\n    frequency: '2.412 GHz',          // Number\n    signal: -256,                    // Number. It seems MTK's driver does not report this value. Don't use it.\n    quality: 78,                     // Number. Valued from 0 ~ 100, bigger is better.\n    encryption: 'WPA2 PSK (AES-OCB)' // String\n}\n```\n  \n**Returns:**  \n  \n* _none_\n\n**Examples:**  \n  \n```js\n// scan with deafult radio interface\nwiscan.scan(function (err, result) {\n    console.log(result);\n\n    // [\n    //     { address: 'D8:FE:E3:E5:9F:3B',  essid: 'sivann', ...   },\n    //     { address: '20:0C:C8:01:1D:98',  essid: 'delta_01', ... },\n    //     { address: '9C:D6:43:01:7E:C7',  essid: 'AVIS', ...     },\n    //     ...\n    // ]\n});\n\n// scan with given radio interface\nwiscan.scan('ra0', function (err, result) {\n    console.log(result);\n});\n\n// given radio interface is not valid\nwiscan.scan('foo', function (err, result) {\n    console.log(err);   // [Error: No such wireless device: foo]\n});\n```\n\n********************************************\n\n<a name=\"API_scanByEssid\"></a>\n### .scanByEssid([intf,] essid, callback)\nScan for a specific AP with its essid.  \n\n**Arguments:**  \n\n1. `intf` (_String_, optional): A default value of `'ra0'` will be used if not given.  \n2. `essid` (_String_): The ESSID of the AP to scan for.  \n3. `callback` (_Function_): `function(err, result) { ... }`. The result is a report object, otherwise `null` if not found.  \n\n</br>\n  \n**Returns:**  \n  \n* _none_\n\n**Examples:**  \n  \n```js\nwiscan.scanByEssid('sivann', function (err, result) {\n    console.log(result);\n\n    // { \n    //     address: 'D8:FE:E3:E5:9F:3B',\n    //     essid: 'sivann',\n    //     mode: 'Master',\n    //     channel: 1,\n    //     frequency: '2.412 GHz',\n    //     signal: -256,\n    //     quality: 68,\n    //     encryption: 'WPA2 PSK (AES-OCB)' // String\n    // }\n});\n\n// AP not found\nwiscan.scanByEssid('no_such_ap', function (err, result) {\n    console.log(result);    // null\n});\n```\n\n## License\nMIT\n", "var exec = require('child_process').exec;\n\nvar defaultInterface = 'ra0',\n    freqs = [ '2.412', '2.417', '2.422', '2.427', '2.432', '2.437', '2.442', '2.447', '2.452', '2.457', '2.462' ];\n\nvar wiscan = {};\n\nwiscan.scan = function (intf, callback) {\n    var child;\n\n    if (typeof intf === 'function') {\n        callback = intf;\n        intf = defaultInterface;\n    }\n\n    intf = intf || defaultInterface;\n    callback = callback || function () {};\n\n    if (typeof intf !== 'string')\n        return callback(new Error('intf should be a string.'));\n\n    child = exec('iwinfo ' + intf + ' scan', function (error, stdout, stderr) {\n        if (error) {\n            stderr = stderr.trim();\n            return callback(new Error(stderr));\n        }\n\n        var info = stdout,\n            parsed = [];\n\n        info = info.replace(/\\n/g, ' ');\n        info = info.replace(/\"/g, '');\n        info = info.split(' ');\n        info.forEach(function (char, i) {\n            if (char === 'ESSID' && info[i+1] === '')\n                info[i+1] = 'unknown';\n            else if (char !== '')\n                parsed.push(char);\n        });\n\n        parsed = parse(parsed);\n        callback(null, parsed);\n    });\n};\n\nwiscan.scanByEssid = function (intf, essid, callback) {\n    var target = null;\n\n    if (arguments.length === 2) {\n        callback = essid;\n        essid = intf;\n        intf = defaultInterface;\n    }\n\n    intf = intf || defaultInterface;\n\n    if (typeof intf !== 'string')\n        return callback(new Error('intf should be a string.'));\n    else if (typeof essid !== 'string')\n        return callback(new Error('essid should be a string.'));\n\n    callback = callback || function () {};\n\n    wiscan.scan(intf, function (err, infos) {\n        if (err)\n            return callback(err);\n\n        infos.forEach(function (info) {\n            if (info.essid === essid)\n                target = info;\n        });\n\n        callback(null, target);\n    });\n};\n\nwiscan.lqi = function (intf, essid, callback) {\n    if (arguments.length === 2) {\n        callback = essid;\n        essid = intf;\n        intf = defaultInterface;\n    }\n\n    intf = intf || defaultInterface;\n\n    wiscan.scanByEssid(intf, essid, function (err, info) {\n        if (err)\n            return callback(err);\n\n        if (info)\n            callback(null, info.quality);\n        else\n            callback(null, null);\n    });\n};\n\nfunction parse(items) {\n    var parsed = [],\n        len = items.length,\n        idx = 0;\n\n    if (items.length === 0)\n        return parsed;\n\n    items.forEach(function (c, i) {\n        var val;\n        if (c === 'Cell') {\n            //- [deleted: need not cell field] val = items[i+1];\n            //- [deleted: need not cell field] val = isNaN(parseInt(val)) ? val : parseInt(val);\n            parsed.push({});\n        } else if (c === 'Address:') {\n            parsed[idx].address = items[i+1];\n        } else if (c === 'ESSID:') {\n            parsed[idx].essid = items[i+1];\n        } else if (c === 'Mode:') {\n            parsed[idx].mode = items[i+1];\n        } else if (c === 'Channel:') {\n            val = items[i+1];\n            val = isNaN(parseInt(val)) ? val : parseInt(val);\n            parsed[idx].channel = val;\n            parsed[idx].frequency = getFrequency(val);\n        } else if (c === 'Signal:') {\n            val = items[i+1];\n            val = isNaN(parseInt(val)) ? val : parseInt(val);\n            parsed[idx].signal = val;\n        } else if (c === 'Quality:') {\n\n            val = items[i+1].split('/')[0];\n            val = isNaN(parseInt(val)) ? val : parseInt(val);\n            parsed[idx].quality = val;\n        } else if (c === 'Encryption:') {\n            var x = i + 1,\n                enc = '';\n\n            while (items[x] !== 'Cell') {\n                if (x !== len) {\n                    enc = enc + items[x] + ' ';\n                    x += 1;\n                } else {\n                    break;\n                }\n            }\n            enc = enc.trim();\n            parsed[idx].encryption = enc;\n            idx += 1;\n        }\n    });\n    return parsed;\n}\n\nfunction getFrequency(ch) {\n    var f = freqs[ch - 1];\n\n    if (f)\n        f = f + ' GHz';\n    else\n        f = '';\n\n    return f;\n}\n\nmodule.exports = wiscan;\n", "{\n  \"name\": \"mt7688-wiscan\",\n  \"version\": \"0.8.2\",\n  \"description\": \"A wifi access points scanning tool for MediaTek Linkit Smart 7688\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/simenkid/mt7688-wiscan.git\"\n  },\n  \"keywords\": [\n    \"mt7688\",\n    \"linkit\",\n    \"wireless\",\n    \"rssi\",\n    \"lqi\"\n  ],\n  \"author\": \"Simen Li\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/simenkid/mt7688-wiscan/issues\"\n  },\n  \"homepage\": \"https://github.com/simenkid/mt7688-wiscan#readme\"\n}\n"], "fixing_code": ["# mt7688-wiscan\n\n## Table of Contents\n\n1. [Overiew](#Overiew)\n2. [Installation](#Installation)\n3. [Usage](#Usage)\n\n<a name=\"Overiew\"></a>\n\n## 1. Overview\n\n**mt7688-wiscan** is a wifi access points scanning tool which is running with node.js on MediaTek Linkit Smart 7688. This tool provides three APIs [lqi()](#API_lqi), [scan()](#API_scan), and [scanByEssid()](#API_scanByEssid) that help you with getting link quality indicator (LQI) to an specific AP, scanning neighbor wifi APs, and scanning a specific AP with its **essid**.\n\nI am using this tool on machine nodes in my LWM2M IoT project. On each machine, there is a panel to show some information about the machine and to show LQI between machine and its router as well.\n\n<a name=\"Installation\"></a>\n\n## 2. Installation\n\n> $ npm install mt7688-wiscan --save\n\n<a name=\"Usage\"></a>\n\n## 3. Usage\n\n### Require the module\n\n```js\nvar wiscan = require('mt7688-wiscan');\n```\n\n---\n\n<a name=\"API_lqi\"></a>\n\n### .lqi([intf,] essid, callback)\n\nQuery the LQI (link quality indicator) between your Linkit Smart 7688(in station mode) and its router(AP).\n\n**Arguments:**\n\n1. `intf` (_String_, optional): A default value of `'ra0'` will be used if not given.\n2. `essid` (_String_): The ESSID of the AP to scan for.\n3. `callback` (_Function_): `function(err, result) { ... }`. The `result` is a number between 0 and 100 to indicate the relative link quality between the station and access point. The value is bigger to show better link quality. If given 'essid' is not found after scan, `result` will be `null`.\n\n**[Note]**\n\n- It takes around 5 seconds to accomplish a single scan.\n- If you've changed the name of radio interface with OpenWrt configuration tool, you should give this method with the correct interface name, for example, `'myradio'`.\n- You can also try this tool on other platforms, but be aware of that the radio interface name is subject to platforms. Use `iwconfig` command at console to get some hints.\n\n**Returns:**\n\n- _none_\n\n**Examples:**\n\n```js\n// scan with deafult radio interface, just give it an essid to scan for\nwiscan.lqi('my_office_ap', function (err, result) {\n  if (err) console.log(err); // null\n  else console.log(result); // 78\n});\n\n// if an AP with given essid is not around (result is nothing after scan)\nwiscan.lqi('ap_not_found', function (err, result) {\n  if (err) console.log(err); // null\n  else console.log(result); // null\n});\n\n// scan with the given radio interface and essid\nwiscan.lqi('ra0', 'my_office_ap', function (err, result) {\n  if (err) console.log(err); // null\n  else console.log(result); // 82\n});\n\n// scan with the given radio interface, e.g. 'bad_ra', that doesn't exist\nwiscan.lqi('bad_ra', 'my_office_ap', function (err, result) {\n  if (err) console.log(err); // [Error: No such wireless device: bad_ra]\n});\n```\n\n---\n\n<a name=\"API_scan\"></a>\n\n### .scan([intf,] callback)\n\nScan neighbor wifi access points.\n\n**Arguments:**\n\n1. `intf` (_String_, optional): A default value of `'ra0'` will be used if not given.\n2. `callback` (_Function_): `function(err, result) { ... }`. The `result` is an array of scanned report objects. Each report object has the following format:\n\n```js\n{\n    address: 'D8:FE:E3:E5:9F:3B',    // String. MAC address of the found AP\n    essid: 'sivann',                 // String\n    mode: 'Master',                  // String\n    channel: 1,                      // Number\n    frequency: '2.412 GHz',          // Number\n    signal: -256,                    // Number. It seems MTK's driver does not report this value. Don't use it.\n    quality: 78,                     // Number. Valued from 0 ~ 100, bigger is better.\n    encryption: 'WPA2 PSK (AES-OCB)' // String\n}\n```\n\n**Returns:**\n\n- _none_\n\n**Examples:**\n\n```js\n// scan with deafult radio interface\nwiscan.scan(function (err, result) {\n  console.log(result);\n\n  // [\n  //     { address: 'D8:FE:E3:E5:9F:3B',  essid: 'sivann', ...   },\n  //     { address: '20:0C:C8:01:1D:98',  essid: 'delta_01', ... },\n  //     { address: '9C:D6:43:01:7E:C7',  essid: 'AVIS', ...     },\n  //     ...\n  // ]\n});\n\n// scan with given radio interface\nwiscan.scan('ra0', function (err, result) {\n  console.log(result);\n});\n\n// given radio interface is not valid\nwiscan.scan('foo', function (err, result) {\n  console.log(err); // [Error: No such wireless device: foo]\n});\n```\n\n---\n\n<a name=\"API_scanByEssid\"></a>\n\n### .scanByEssid([intf,] essid, callback)\n\nScan for a specific AP with its essid.\n\n**Arguments:**\n\n1. `intf` (_String_, optional): A default value of `'ra0'` will be used if not given.\n2. `essid` (_String_): The ESSID of the AP to scan for.\n3. `callback` (_Function_): `function(err, result) { ... }`. The result is a report object, otherwise `null` if not found.\n\n</br>\n  \n**Returns:**  \n  \n* _none_\n\n**Examples:**\n\n```js\nwiscan.scanByEssid('sivann', function (err, result) {\n  console.log(result);\n\n  // {\n  //     address: 'D8:FE:E3:E5:9F:3B',\n  //     essid: 'sivann',\n  //     mode: 'Master',\n  //     channel: 1,\n  //     frequency: '2.412 GHz',\n  //     signal: -256,\n  //     quality: 68,\n  //     encryption: 'WPA2 PSK (AES-OCB)' // String\n  // }\n});\n\n// AP not found\nwiscan.scanByEssid('no_such_ap', function (err, result) {\n  console.log(result); // null\n});\n```\n\n## License\n\nMIT\n", "var exec = require('child_process').exec;\n\nvar defaultInterface = 'ra0',\n  freqs = [\n    '2.412',\n    '2.417',\n    '2.422',\n    '2.427',\n    '2.432',\n    '2.437',\n    '2.442',\n    '2.447',\n    '2.452',\n    '2.457',\n    '2.462',\n  ];\n\nvar wiscan = {};\n\nwiscan.scan = function (intf, callback) {\n  var child;\n\n  if (typeof intf === 'function') {\n    callback = intf;\n    intf = defaultInterface;\n  }\n\n  intf = intf || defaultInterface;\n  callback = callback || function () {};\n\n  if (typeof intf !== 'string')\n    return callback(new Error('intf should be a string.'));\n\n  if (!/[0-9a-zA-Z]/.test(intf.charAt(0)))\n    return callback(new Error('Bad intf.'));\n\n  child = exec('iwinfo ' + intf + ' scan', function (error, stdout, stderr) {\n    if (error) {\n      stderr = stderr.trim();\n      return callback(new Error(stderr));\n    }\n\n    var info = stdout,\n      parsed = [];\n\n    info = info.replace(/\\n/g, ' ');\n    info = info.replace(/\"/g, '');\n    info = info.split(' ');\n    info.forEach(function (char, i) {\n      if (char === 'ESSID' && info[i + 1] === '') info[i + 1] = 'unknown';\n      else if (char !== '') parsed.push(char);\n    });\n\n    parsed = parse(parsed);\n    callback(null, parsed);\n  });\n};\n\nwiscan.scanByEssid = function (intf, essid, callback) {\n  var target = null;\n\n  if (arguments.length === 2) {\n    callback = essid;\n    essid = intf;\n    intf = defaultInterface;\n  }\n\n  intf = intf || defaultInterface;\n\n  if (typeof intf !== 'string')\n    return callback(new Error('intf should be a string.'));\n  else if (typeof essid !== 'string')\n    return callback(new Error('essid should be a string.'));\n\n  callback = callback || function () {};\n\n  wiscan.scan(intf, function (err, infos) {\n    if (err) return callback(err);\n\n    infos.forEach(function (info) {\n      if (info.essid === essid) target = info;\n    });\n\n    callback(null, target);\n  });\n};\n\nwiscan.lqi = function (intf, essid, callback) {\n  if (arguments.length === 2) {\n    callback = essid;\n    essid = intf;\n    intf = defaultInterface;\n  }\n\n  intf = intf || defaultInterface;\n\n  wiscan.scanByEssid(intf, essid, function (err, info) {\n    if (err) return callback(err);\n\n    if (info) callback(null, info.quality);\n    else callback(null, null);\n  });\n};\n\nfunction parse(items) {\n  var parsed = [],\n    len = items.length,\n    idx = 0;\n\n  if (items.length === 0) return parsed;\n\n  items.forEach(function (c, i) {\n    var val;\n    if (c === 'Cell') {\n      //- [deleted: need not cell field] val = items[i+1];\n      //- [deleted: need not cell field] val = isNaN(parseInt(val)) ? val : parseInt(val);\n      parsed.push({});\n    } else if (c === 'Address:') {\n      parsed[idx].address = items[i + 1];\n    } else if (c === 'ESSID:') {\n      parsed[idx].essid = items[i + 1];\n    } else if (c === 'Mode:') {\n      parsed[idx].mode = items[i + 1];\n    } else if (c === 'Channel:') {\n      val = items[i + 1];\n      val = isNaN(parseInt(val)) ? val : parseInt(val);\n      parsed[idx].channel = val;\n      parsed[idx].frequency = getFrequency(val);\n    } else if (c === 'Signal:') {\n      val = items[i + 1];\n      val = isNaN(parseInt(val)) ? val : parseInt(val);\n      parsed[idx].signal = val;\n    } else if (c === 'Quality:') {\n      val = items[i + 1].split('/')[0];\n      val = isNaN(parseInt(val)) ? val : parseInt(val);\n      parsed[idx].quality = val;\n    } else if (c === 'Encryption:') {\n      var x = i + 1,\n        enc = '';\n\n      while (items[x] !== 'Cell') {\n        if (x !== len) {\n          enc = enc + items[x] + ' ';\n          x += 1;\n        } else {\n          break;\n        }\n      }\n      enc = enc.trim();\n      parsed[idx].encryption = enc;\n      idx += 1;\n    }\n  });\n  return parsed;\n}\n\nfunction getFrequency(ch) {\n  var f = freqs[ch - 1];\n\n  if (f) f = f + ' GHz';\n  else f = '';\n\n  return f;\n}\n\nmodule.exports = wiscan;\n", "{\n  \"name\": \"mt7688-wiscan\",\n  \"version\": \"0.8.3\",\n  \"description\": \"A wifi access points scanning tool for MediaTek Linkit Smart 7688\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/simenkid/mt7688-wiscan.git\"\n  },\n  \"keywords\": [\n    \"mt7688\",\n    \"linkit\",\n    \"wireless\",\n    \"rssi\",\n    \"lqi\"\n  ],\n  \"author\": \"Simen Li\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/simenkid/mt7688-wiscan/issues\"\n  },\n  \"homepage\": \"https://github.com/simenkid/mt7688-wiscan#readme\"\n}\n"], "filenames": ["README.md", "index.js", "package.json"], "buggy_code_start_loc": [5, 4, 3], "buggy_code_end_loc": [182, 160, 4], "fixing_code_start_loc": [5, 4, 3], "fixing_code_end_loc": [186, 164, 4], "type": "CWE-77", "message": "Versions of the package mt7688-wiscan before 0.8.3 are vulnerable to Command Injection due to improper input sanitization in the 'wiscan.scan' function.", "other": {"cve": {"id": "CVE-2022-25916", "sourceIdentifier": "report@snyk.io", "published": "2023-02-01T05:15:12.063", "lastModified": "2023-02-08T15:35:41.380", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Versions of the package mt7688-wiscan before 0.8.3 are vulnerable to Command Injection due to improper input sanitization in the 'wiscan.scan' function."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.4, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mt7688-wiscan_project:mt7688-wiscan:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.8.3", "matchCriteriaId": "31892112-38E1-440A-BE98-692561B88527"}]}]}], "references": [{"url": "https://github.com/simenkid/mt7688-wiscan/blob/master/index.js%23L22", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/simenkid/mt7688-wiscan/commit/ff6d6567c65b4e972916a8fbc4533212f20a2fa5", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-MT7688WISCAN-3177394", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/simenkid/mt7688-wiscan/commit/ff6d6567c65b4e972916a8fbc4533212f20a2fa5"}}