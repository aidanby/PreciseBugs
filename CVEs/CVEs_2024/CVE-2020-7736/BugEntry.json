{"buggy_code": ["{\r\n  \"name\": \"bmoor\",\r\n  \"version\": \"0.8.11\",\r\n  \"author\": \"Brian Heilman <das.ist.junk@gmail.com>\",\r\n  \"description\": \"A basic foundation for other libraries, establishing useful patterbs, and letting them be more.\",\r\n  \"license\": \"MIT\",\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git://github.com/b-heilman/bmoor.git\"\r\n  },\r\n  \"main\": \"src/index.js\",\r\n  \"scripts\": {\r\n    \"demo\": \"gulp serve\",\r\n    \"build\": \"gulp build\"\r\n  },\r\n  \"dependencies\": {\r\n    \"uuid\": \"^3.4.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"chai\": \"^4.2.0\",\r\n    \"gulp\": \"^4.0.2\",\r\n    \"gulp-jshint\": \"^2.1.0\",\r\n    \"gulp-mocha\": \"^7.0.2\",\r\n    \"jshint\": \"^2.11.1\",\r\n    \"jshint-stylish\": \"2.1.0\",\r\n    \"mocha\": \"^6.2.3\",\r\n    \"sinon\": \"^7.5.0\",\r\n    \"yargs\": \"^15.3.1\"\r\n  }\r\n}\r\n", "/**\r\n * The core of bmoor's usefulness\r\n * @module bmoor\r\n **/\r\n\r\n/**\r\n * Tests if the value is undefined\r\n *\r\n * @function isUndefined\r\n * @param {*} value - The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isUndefined( value ) {\r\n\treturn value === undefined;\r\n}\r\n\r\n/**\r\n * Tests if the value is not undefined\r\n *\r\n * @function isDefined\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isDefined( value ) {\r\n\treturn value !== undefined;\r\n}\r\n\r\n/**\r\n * Tests if the value is a string\r\n *\r\n * @function isString\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isString( value ){\r\n\treturn typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Tests if the value is numeric\r\n *\r\n * @function isNumber\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isNumber( value ){\r\n\treturn typeof value === 'number';\r\n}\r\n\r\n/**\r\n * Tests if the value is a function\r\n *\r\n * @function isFuncion\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isFunction( value ){\r\n\treturn typeof value === 'function';\r\n}\r\n\r\n/**\r\n * Tests if the value is an object\r\n *\r\n * @function isObject\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isObject( value ){\r\n\treturn !!value && typeof value === 'object';\r\n}\r\n\r\n/**\r\n * Tests if the value is a boolean\r\n *\r\n * @function isBoolean\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isBoolean( value ){\r\n\treturn typeof value === 'boolean';\r\n}\r\n\r\n/**\r\n * Tests if the value can be used as an array\r\n *\r\n * @function isArrayLike\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isArrayLike( value ) {\r\n\t// for me, if you have a length, I'm assuming you're array like, might change\r\n\tif (value){\r\n\t\treturn isObject(value) && (value.length === 0 || (0 in value && (value.length-1) in value));\r\n\t}else{\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Tests if the value is an array\r\n *\r\n * @function isArray\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isArray( value ) {\r\n\treturn value instanceof Array;\r\n}\r\n\r\n/**\r\n * Tests if the value has no content.\r\n * If an object, has no own properties.\r\n * If array, has length == 0.\r\n * If other, is not defined\r\n *\r\n * @function isEmpty\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isEmpty( value ){\r\n\tvar key;\r\n\r\n\tif (isObject(value)){\r\n\t\tfor(key in value){ \r\n\t\t\tif (value.hasOwnProperty(key)){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t} else if (isArrayLike(value)){\r\n\t\treturn value.length === 0;\r\n\t} else {\r\n\t\treturn isUndefined( value );\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nfunction parse( path ){\r\n\tif (!path){\r\n\t\treturn [];\r\n\t} else if (isString(path)){\r\n\t\t// this isn't perfect, I'm making it work with arrays though\r\n\t\tif (path.indexOf('[') !== -1){\r\n\t\t\treturn path.match(/[^\\]\\[.]+/g)\r\n\t\t\t.map(d => {\r\n\t\t\t\tif (d[0] === '\"' || d[0] === '\\''){\r\n\t\t\t\t\treturn d.substring(1, d.length-1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn d;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\treturn path.split('.');\r\n\t\t}\r\n\t} else if (isArray(path)){\r\n\t\treturn path.slice(0);\r\n\t} else {\r\n\t\tthrow new Error(\r\n\t\t\t'unable to parse path: '+\r\n\t\t\tpath+ ' : '+typeof(path)\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * Sets a value to a namespace, returns the old value\r\n *\r\n * @function set\r\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\r\n * @param {string|array} space The namespace\r\n * @param {*} value The value to set the namespace to\r\n * @return {*}\r\n **/\r\nfunction set( root, space, value ){\r\n\tvar i, c, \r\n\t\tval,\r\n\t\tnextSpace,\r\n\t\tcurSpace = root;\r\n\t\r\n\tspace = parse(space);\r\n\r\n\tval = space.pop();\r\n\r\n\tfor( i = 0, c = space.length; i < c; i++ ){\r\n\t\tnextSpace = space[ i ];\r\n\t\t\t\r\n\t\tif ( isUndefined(curSpace[nextSpace]) ){\r\n\t\t\tcurSpace[ nextSpace ] = {};\r\n\t\t}\r\n\t\t\t\r\n\t\tcurSpace = curSpace[ nextSpace ];\r\n\t}\r\n\r\n\tcurSpace[ val ] = value;\r\n\r\n\treturn curSpace;\r\n}\r\n\r\nfunction _makeSetter( property, next ){\r\n\tif ( next ){\r\n\t\treturn function setter( ctx, value ){\r\n\t\t\tvar t = ctx[property];\r\n\r\n\t\t\tif ( !t ){\r\n\t\t\t\tt = ctx[property] = {};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn next( t, value );\r\n\t\t};\r\n\t}else{\r\n\t\treturn function( ctx, value ){\r\n\t\t\tctx[property] = value;\r\n\t\t\treturn ctx;\r\n\t\t};\r\n\t}\r\n}\r\n\r\nfunction makeSetter( space ){\r\n\tvar i,\r\n\t\tfn,\r\n\t\treadings = parse(space);\r\n\r\n\tfor( i = readings.length-1; i > -1; i-- ){\r\n\t\tfn = _makeSetter( readings[i], fn );\r\n\t}\r\n\r\n\treturn fn;\r\n}\r\n\r\n/**\r\n * get a value from a namespace, if it doesn't exist, the path will be created\r\n *\r\n * @function get\r\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\r\n * @param {string|array|function} space The namespace\r\n * @return {array}\r\n **/\r\nfunction get( root, path ){\r\n\tvar i, c,\r\n\t\tspace,\r\n\t\tnextSpace,\r\n\t\tcurSpace = root;\r\n\t\r\n\tif ( !root ){\r\n\t\treturn root;\r\n\t}\r\n\r\n\tspace = parse(path);\r\n\tif ( space.length ){\r\n\t\tfor( i = 0, c = space.length; i < c; i++ ){\r\n\t\t\tnextSpace = space[i];\r\n\t\t\t\t\r\n\t\t\tif ( isUndefined(curSpace[nextSpace]) ){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcurSpace = curSpace[nextSpace];\r\n\t\t}\r\n\t}\r\n\r\n\treturn curSpace;\r\n}\r\n\r\nfunction _makeGetter( property, next ){\r\n\tif (next){\r\n\t\treturn function getter( obj ){\r\n\t\t\ttry {\r\n\t\t\t\treturn next( obj[property] );\r\n\t\t\t}catch( ex ){\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t};\r\n\t}else{\r\n\t\treturn function getter( obj ){\r\n\t\t\ttry {\r\n\t\t\t\treturn obj[property];\r\n\t\t\t} catch(ex){\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n}\r\n\r\nfunction makeGetter( path ){\r\n\tvar i,\r\n\t\tfn,\r\n\t\tspace = parse(path);\r\n\r\n\tif ( space.length ){\r\n\t\tfor( i = space.length-1; i > -1; i-- ){\r\n\t\t\tfn = _makeGetter( space[i], fn );\r\n\t\t}\r\n\t}else{\r\n\t\treturn function( obj ){\r\n\t\t\treturn obj;\r\n\t\t};\r\n\t}\r\n\r\n\treturn fn;\r\n}\r\n\r\n/**\r\n * Delete a namespace, returns the old value\r\n *\r\n * @function del\r\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\r\n * @param {string|array} space The namespace\r\n * @return {*}\r\n **/\r\nfunction del( root, space ){\r\n\tvar old,\r\n\t\tval,\r\n\t\tnextSpace,\r\n\t\tcurSpace = root;\r\n\t\r\n\tif ( space && (isString(space) || isArrayLike(space)) ){\r\n\t\tspace = parse( space );\r\n\r\n\t\tval = space.pop();\r\n\r\n\t\tfor( var i = 0; i < space.length; i++ ){\r\n\t\t\tnextSpace = space[ i ];\r\n\t\t\t\t\r\n\t\t\tif ( isUndefined(curSpace[nextSpace]) ){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tcurSpace = curSpace[ nextSpace ];\r\n\t\t}\r\n\r\n\t\told = curSpace[ val ];\r\n\t\tdelete curSpace[ val ];\r\n\t}\r\n\r\n\treturn old;\r\n}\r\n\r\nmodule.exports = {\r\n\t// booleans\r\n\tisUndefined: isUndefined,\r\n\tisDefined: isDefined,\r\n\tisString: isString,\r\n\tisNumber: isNumber,\r\n\tisFunction: isFunction,\r\n\tisObject: isObject,\r\n\tisBoolean: isBoolean,\r\n\tisArrayLike: isArrayLike,\r\n\tisArray: isArray,\r\n\tisEmpty: isEmpty,\r\n\t// access\r\n\tparse: parse,\r\n\tset: set,\r\n\tmakeSetter: makeSetter,\r\n\tget: get,\r\n\tmakeGetter: makeGetter,\r\n\tdel: del\r\n};\r\n", "\nconst {expect} = require('chai');\n\nconst bmoor = require('./index.js');\n\ndescribe('Testing object setting/getting', function() {\n\tit('should have get working', function(){\n\t\tvar t = {\n\t\t\t\teins : 1,\n\t\t\t\tzwei: {\n\t\t\t\t\tdrei: 3\n\t\t\t\t}\n\t\t\t};\n\n\t\texpect( bmoor.get(t,'eins') ).to.equal(1);\n\t\texpect( bmoor.get(t,'zwei.drei') ).to.equal(3);\n\t});\n\n\tit('should have get working with empty strings', function(){\n\t\tvar t = {\n\t\t\t\teins : 1,\n\t\t\t\tzwei: {\n\t\t\t\t\tdrei: 3\n\t\t\t\t}\n\t\t\t};\n\n\t\texpect( bmoor.get(t,'') ).to.equal(t);\n\t});\n\n\tit('should have makeGetter working', function(){\n\t\tvar t = {\n\t\t\t\teins : 1,\n\t\t\t\tzwei: {\n\t\t\t\t\tdrei: 3\n\t\t\t\t}\n\t\t\t},\n\t\t\tf1 = bmoor.makeGetter('eins'),\n\t\t\tf2 = bmoor.makeGetter('zwei.drei');\n\n\t\texpect( f1(t) ).to.equal(1);\n\t\texpect( f2(t) ).to.equal(3);\n\t});\n\n\tit('should have makeGetter working with empty strings', function(){\n\t\tvar t = {\n\t\t\t\teins : 1,\n\t\t\t\tzwei: {\n\t\t\t\t\tdrei: 3\n\t\t\t\t}\n\t\t\t},\n\t\t\tf1 = bmoor.makeGetter('');\n\n\t\texpect( f1(t) ).to.equal(t);\n\t});\n\n\tit('should have set working', function(){\n\t\tvar t = {};\n\n\t\tbmoor.set(t,'eins',1);\n\t\tbmoor.set(t,'zwei.drei',3);\n\n\t\texpect( t.eins ).to.equal(1);\n\t\texpect( t.zwei.drei ).to.equal(3);\n\t});\n\n\tit('should have makeSetter working', function(){\n\t\tvar t = {},\n\t\t\tf1 = bmoor.makeSetter('eins'),\n\t\t\tf2 = bmoor.makeSetter('zwei.drei');\n\n\t\tf1(t,1);\n\t\tf2(t,3);\n\n\t\texpect( t.eins ).to.equal(1);\n\t\texpect( t.zwei.drei ).to.equal(3);\n\t});\n\n\tit('should have del working', function(){\n\t\tvar t = {\n\t\t\teins : 1,\n\t\t\tzwei: {\n\t\t\t\tdrei: 3\n\t\t\t}\n\t\t};\n\n\t\texpect( bmoor.del(t,'eins') ).to.equal(1);\n\t\texpect( bmoor.del(t,'zwei.drei') ).to.equal(3);\n\t\texpect( t.eins ).to.not.exist;\n\t\texpect( t.zwei ).to.exist;\n\t\texpect( t.zwei.drei ).to.not.exist;\n\t});\n\n\tdescribe('::parse', function(){\n\t\tit('should parse an array correctly', function(){\n\t\t\texpect(bmoor.parse([1,2,3]))\n\t\t\t.to.deep.equal([1,2,3]);\n\t\t});\n\n\t\tit('should parse dot notation correctly', function(){\n\t\t\texpect(bmoor.parse('1.2.3'))\n\t\t\t.to.deep.equal(['1','2','3']);\n\t\t});\n\n\t\tit('should parse brackets correctly', function(){\n\t\t\texpect(bmoor.parse('[1][2][3]'))\n\t\t\t.to.deep.equal(['1','2','3']);\n\t\t});\n\n\t\tit('should parse brackets with quotes correctly', function(){\n\t\t\texpect(bmoor.parse('[\\'1\\'][\"2\"][3]'))\n\t\t\t.to.deep.equal(['1','2','3']);\n\t\t});\n\n\t\tit('should parse mixed correctly', function(){\n\t\t\texpect(bmoor.parse('foo[\"bar\"].ok[hello]'))\n\t\t\t.to.deep.equal(['foo','bar','ok','hello']);\n\t\t});\n\t});\n});\n\ndescribe('Testing object functions', function() {\n\t// mask\n\tit('should allow for the creation of object from a base object', function(){\n\t\tvar t,\n\t\t\tv;\n\n\t\tfunction Foo( derp ){\n\t\t\tthis.woot = derp;\n\t\t}\n\n\t\tFoo.prototype.bar = 'yay';\n\n\t\tt = new Foo();\n\n\t\tv = bmoor.object.mask( t );\n\n\t\texpect( v.bar ).to.equal( 'yay' );\n\t});\n\n\n\t// extend\n\tit('should allow for objects to be extended by other objects', function(){\n\t\tvar t = {\n\t\t\t'foo'  : 1,\n\t\t\t'bar'  : 2 ,\n\t\t\t'woot' : 3\n\t\t};\n\n\t\tbmoor.object.extend( t, {\n\t\t\t'yay' : 'sup',\n\t\t\t'foo' : 'foo2'\n\t\t},{\n\t\t\t'woot' : '3!'\n\t\t});\n\n\t\texpect( t.foo ).to.equal( 'foo2' );\n\t\texpect( t.woot ).to.equal( '3!' );\n\t});\n\t// copy\n\t// TODO : yeah, need to do this one\n\n\t// equals\n\t// TODO : yeah, need to do this one\n\n\t// map\n\tit('should allow for the mapping of variables onto an object', function(){\n\t\tvar o = {},\n\t\t\tt = bmoor.object.explode({\n\t\t\t\thello:'world'\n\t\t\t},{\n\t\t\t\t'eins': 1, \n\t\t\t\t'zwei': 2,\n\t\t\t\t'drei': 3,\n\t\t\t\t'foo.bar': 'woot',\n\t\t\t\t'help.me': o\n\t\t\t});\n\n\t\texpect( t.eins ).to.equal( 1 );\n\t\texpect( t.foo.bar ).to.equal( 'woot' );\n\t\texpect( t.hello ).to.equal( 'world' );\n\t\texpect( t.help.me ).to.equal( o );\n\t});\n\n\tit('should allow for a new variable to be created from a map', function(){\n\t\tvar o = {},\n\t\t\tt = bmoor.object.explode({},\n\t\t\t{\n\t\t\t\t'eins': 1, \n\t\t\t\t'foo.bar': 'woot',\n\t\t\t\t'hello.world': o\n\t\t\t});\n\n\t\texpect( t.eins, 1 );\n\t\texpect( t.foo.bar, 'woot' );\n\t\texpect( t.hello.world ).to.equal( o );\n\t});\n\n\t/*\n\tdescribe('override', function(){\n\t\tit( 'should prune old properties', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tbmoor.object.override( t, {\n\t\t\t\tdrei : 3\n\t\t\t});\n\n\t\t\texpect( t.eins ).to.not.to.exist;\n\t\t\texpect( t.zwei ).to.not.to.exist;\n\t\t\texpect( t.drei ).to.equal( 3 );\n\t\t});\n\n\t\tit( 'should handle shallow object copy', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\to = {\n\t\t\t\t\tdrei : {\n\t\t\t\t\t\thello: 'world'\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tbmoor.object.override( t, o );\n\n\t\t\to.drei.hello = 'woot';\n\n\t\t\texpect( t.drei.hello ).to.equal( 'woot' );\n\t\t});\n\n\t\tit( 'should handle deep object copy', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\to = {\n\t\t\t\t\tdrei : {\n\t\t\t\t\t\thello: 'world'\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tbmoor.object.override( t, o, true );\n\n\t\t\to.drei.hello = 'woot';\n\n\t\t\texpect( t.drei.hello ).to.equal( 'world' );\n\t\t});\n\t});\n\t*/\n\tit( 'should allow for data to be merged', function(){\n\t\tvar t = {\n\t\t\teins : 1,\n\t\t\tzwei : {\n\t\t\t\tfoo : 1,\n\t\t\t\tbar : 2\n\t\t\t},\n\t\t\tdrei : 3\n\t\t};\n\n\t\tbmoor.object.merge( t, {\n\t\t\teins : 2,\n\t\t\tzwei : {\n\t\t\t\tfoo : 2\n\t\t\t},\n\t\t\tfier : 4\n\t\t});\n\n\t\texpect( t.eins ).to.equal( 2 );\n\t\texpect( t.zwei ).to.to.exist;\n\t\texpect( t.zwei.foo ).to.equal( 2 );\n\t\texpect( t.drei ).to.equal( 3 );\n\t\texpect( t.fier ).to.equal( 4 );\n\t});\n});\n\ndescribe('Testing the test functions', function(){\n\t// isBoolean\n\tit('should be able to test booleans', function(){\n\t\texpect( bmoor.isBoolean(true) ).to.equal( true );\n\t\texpect( bmoor.isBoolean(false) ).to.equal( true );\n\t\texpect( bmoor.isBoolean(1) ).to.equal( false );\n\t\texpect( bmoor.isBoolean(0) ).to.equal( false );\n\t});\n\t// isDefined\n\tit('should be able to test for variables being defined', function(){\n\t\tvar n = {},\n\t\t\tt;\n\n\t\texpect( bmoor.isDefined(true) ).to.equal( true );\n\t\texpect( bmoor.isDefined(false) ).to.equal( true );\n\t\texpect( bmoor.isDefined(1) ).to.equal( true );\n\t\texpect( bmoor.isDefined(0) ).to.equal( true );\n\t\texpect( bmoor.isDefined(n) ).to.equal( true );\n\t\texpect( bmoor.isDefined(t) ).to.equal( false );\n\t});\n\t// isUndefined\n\tit('should be able to test for variables being undefined', function(){\n\t\tvar n = {},\n\t\t\tt;\n\n\t\texpect( bmoor.isUndefined(true) ).to.equal( false );\n\t\texpect( bmoor.isUndefined(false) ).to.equal( false );\n\t\texpect( bmoor.isUndefined(1) ).to.equal( false );\n\t\texpect( bmoor.isUndefined(0) ).to.equal( false );\n\t\texpect( bmoor.isUndefined(n) ).to.equal( false );\n\t\texpect( bmoor.isUndefined(t) ).to.equal( true );\n\t});\n\t// isArray\n\tit('should be able to test for variables being arrays', function(){\n\t\texpect( bmoor.isArray([]) ).to.equal( true );\n\t\texpect( bmoor.isArray({}) ).to.equal( false );\n\t\texpect( bmoor.isArray(1) ).to.equal( false );\n\t\texpect( bmoor.isArray({length:0}) ).to.equal( false );\n\t\texpect( bmoor.isArray('') ).to.equal( false );\n\t});\n\t// isArrayLike\n\tit('should be able to test for variables being array like', function(){\n\t\texpect( bmoor.isArrayLike([]) ).to.equal( true );\n\t\texpect( bmoor.isArrayLike({}) ).to.equal( false );\n\t\texpect( bmoor.isArrayLike(1) ).to.equal( false );\n\t\texpect( bmoor.isArrayLike({length:0}) ).to.equal( true );\n\t\texpect( bmoor.isArrayLike('') ).to.equal( false );\n\t});\n\t// isObject\n\tit('should be able to test for variables being an object', function(){\n\t\tfunction Temp(){}\n\t\tvar t = new Temp();\n\n\t\texpect( bmoor.isObject([]) ).to.equal( true );\n\t\texpect( bmoor.isObject({}) ).to.equal( true );\n\t\texpect( bmoor.isObject(1) ).to.equal( false );\n\t\texpect( bmoor.isObject(false) ).to.equal( false );\n\t\texpect( bmoor.isObject(Temp) ).to.equal( false );\n\t\texpect( bmoor.isObject(t) ).to.equal( true );\n\t\texpect( bmoor.isObject('') ).to.equal( false );\n\t});\n\t// isFunction\n\tit('should be able to test for variables being a function', function(){\n\t\tfunction Temp(){}\n\t\tvar t = new Temp();\n\n\t\texpect( bmoor.isFunction([]) ).to.equal( false );\n\t\texpect( bmoor.isFunction({}) ).to.equal( false );\n\t\texpect( bmoor.isFunction(1) ).to.equal( false );\n\t\texpect( bmoor.isFunction(false) ).to.equal( false );\n\t\texpect( bmoor.isFunction(Temp) ).to.equal( true );\n\t\texpect( bmoor.isFunction(t) ).to.equal( false );\n\t\texpect( bmoor.isFunction('') ).to.equal( false );\n\t});\n\t// isNumber\n\tit('should be able to test for variables being a number', function(){\n\t\tfunction Temp(){}\n\t\tvar t = new Temp();\n\n\t\texpect( bmoor.isNumber([]) ).to.equal( false );\n\t\texpect( bmoor.isNumber({}) ).to.equal( false );\n\t\texpect( bmoor.isNumber(1) ).to.equal( true );\n\t\texpect( bmoor.isNumber(false) ).to.equal( false );\n\t\texpect( bmoor.isNumber(Temp) ).to.equal( false );\n\t\texpect( bmoor.isNumber(t) ).to.equal( false );\n\t\texpect( bmoor.isNumber('') ).to.equal( false );\n\t});\n\t\n\t// isString\n\tit('should be able to test for variables being a function', function(){\n\t\tfunction Temp(){}\n\t\tvar t = new Temp();\n\n\t\texpect( bmoor.isString([]) ).to.equal( false );\n\t\texpect( bmoor.isString({}) ).to.equal( false );\n\t\texpect( bmoor.isString(1) ).to.equal( false );\n\t\texpect( bmoor.isString(false) ).to.equal( false );\n\t\texpect( bmoor.isString(Temp) ).to.equal( false );\n\t\texpect( bmoor.isString(t) ).to.equal( false );\n\t\texpect( bmoor.isString('') ).to.equal( true );\n\t});\n\t\n\t// isEmpty\n\tit('should be able to test for variables being a function', function(){\n\t\tvar t;\n\n\t\texpect( bmoor.isEmpty([]) ).to.equal( true );\n\t\texpect( bmoor.isEmpty({}) ).to.equal( true );\n\t\texpect( bmoor.isEmpty(0) ).to.equal( false );\n\t\texpect( bmoor.isEmpty(t) ).to.equal( true );\n\t\texpect( bmoor.isEmpty(null) ).to.equal( false );\n\t\texpect( bmoor.isEmpty([0]) ).to.equal( false );\n\t\texpect( bmoor.isEmpty({'v':0}) ).to.equal( false );\n\t});\n});\n", "\r\nconst {expect} = require('chai');\r\n\r\ndescribe('bmoor.object', function() {\r\n\t\r\n\tconst bmoor = require('./index.js');\r\n\r\n\tit('should operate explode correctly', function(){\r\n\t\tvar t = {\r\n\t\t\t'eins.zwei': 12,\r\n\t\t\t'eins.drei': 13,\r\n\t\t\t'fier': 4\r\n\t\t};\r\n\r\n\t\texpect(bmoor.object.explode(t))\r\n\t\t.to.deep.equal({\r\n\t\t\teins: {\r\n\t\t\t\tzwei: 12,\r\n\t\t\t\tdrei: 13\r\n\t\t\t},\r\n\t\t\tfier: 4\r\n\t\t});\r\n\t});\r\n\r\n\tit('should operate makeExploder correctly', function(){\r\n\t\tvar t = {\r\n\t\t\t\t'eins.zwei': 12,\r\n\t\t\t\t'eins.drei': 13,\r\n\t\t\t\t'fier': 4\r\n\t\t\t},\r\n\t\t\texplode = bmoor.object.makeExploder( Object.keys(t) );\r\n\r\n\t\texpect(explode(t))\r\n\t\t.to.deep.equal({\r\n\t\t\teins: {\r\n\t\t\t\tzwei: 12,\r\n\t\t\t\tdrei: 13\r\n\t\t\t},\r\n\t\t\tfier: 4\r\n\t\t});\r\n\t});\r\n\r\n\tdescribe(':: implode', function(){\r\n\t\tit('should operate correctly', function(){\r\n\t\t\tvar t = {\r\n\t\t\t\ttime: {\r\n\t\t\t\t\tstart: 99,\r\n\t\t\t\t\tstop: 100\r\n\t\t\t\t},\r\n\t\t\t\tid: 'woot',\r\n\t\t\t\tfoo: {\r\n\t\t\t\t\tbar: {\r\n\t\t\t\t\t\thello: 'world'\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tarr: [{\r\n\t\t\t\t\teins: 1,\r\n\t\t\t\t}, {\r\n\t\t\t\t\tzwei: 2\r\n\t\t\t\t}],\r\n\t\t\t\tdouble: [\r\n\t\t\t\t\t[0]\r\n\t\t\t\t]\r\n\t\t\t};\r\n\r\n\t\t\texpect(bmoor.object.implode(t))\r\n\t\t\t.to.deep.equal({\r\n\t\t\t\t'time.start': 99,\r\n\t\t\t\t'time.stop': 100,\r\n\t\t\t\t'id': 'woot',\r\n\t\t\t\t'foo.bar.hello': 'world',\r\n\t\t\t\t'arr[0].eins': 1,\r\n\t\t\t\t'arr[1].zwei': 2,\r\n\t\t\t\t'double[0][0]': 0\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tit('should operate correctly', function(){\r\n\t\t\tvar t = {\r\n\t\t\t\ttime: {\r\n\t\t\t\t\tstart: 99,\r\n\t\t\t\t\tstop: 100\r\n\t\t\t\t},\r\n\t\t\t\tid: 'woot',\r\n\t\t\t\tfoo: {\r\n\t\t\t\t\tbar: {\r\n\t\t\t\t\t\thello: 'world'\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tarr: [{\r\n\t\t\t\t\teins: 1,\r\n\t\t\t\t}, {\r\n\t\t\t\t\tzwei: 2\r\n\t\t\t\t}],\r\n\t\t\t\tdouble: [\r\n\t\t\t\t\t[0]\r\n\t\t\t\t]\r\n\t\t\t};\r\n\r\n\t\t\texpect(bmoor.object.implode(t, {skipArray: true}))\r\n\t\t\t.to.deep.equal({\r\n\t\t\t\t'time.start': 99,\r\n\t\t\t\t'time.stop': 100,\r\n\t\t\t\t'id': 'woot',\r\n\t\t\t\t'foo.bar.hello': 'world',\r\n\t\t\t\t'arr': [{\r\n\t\t\t\t\teins: 1,\r\n\t\t\t\t}, {\r\n\t\t\t\t\tzwei: 2\r\n\t\t\t\t}],\r\n\t\t\t\t'double': [\r\n\t\t\t\t\t[0]\r\n\t\t\t\t]\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n\r\n\tit('should operate implode correctly - with an ignore', function(){\r\n\t\tvar t = {\r\n\t\t\ttime: {\r\n\t\t\t\tstart: 99,\r\n\t\t\t\tstop: 100\r\n\t\t\t},\r\n\t\t\tid: 'woot',\r\n\t\t\tfoo: {\r\n\t\t\t\tbar: {\r\n\t\t\t\t\thello: 'world'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\texpect(bmoor.object.implode(t, {\r\n\t\t\tignore: {\r\n\t\t\t\ttime:{\r\n\t\t\t\t\tstart:true\r\n\t\t\t\t},\r\n\t\t\t\tid: true,\r\n\t\t\t\tfoo: true\r\n\t\t\t}\r\n\t\t})).to.deep.equal({\r\n\t\t\t'time.stop': 100\r\n\t\t});\r\n\t});\r\n\r\n\tdescribe('::merge', function(){\r\n\t\tit('should replace null correctly', function(){\r\n\t\t\texpect( bmoor.object.merge({\r\n\t\t\t\tfoo: null,\r\n\t\t\t\tbar: { a: 'ok'},\r\n\t\t\t\thello: {\r\n\t\t\t\t\tworld: 1,\r\n\t\t\t\t\tother: 'thing',\r\n\t\t\t\t\tarr: null\r\n\t\t\t\t},\r\n\t\t\t\tarr: [1, 2],\r\n\t\t\t\tarr2: [8, 9]\r\n\t\t\t},{\r\n\t\t\t\tfoo: 'bar',\r\n\t\t\t\tbar: null,\r\n\t\t\t\thello: {\r\n\t\t\t\t\tworld: null,\r\n\t\t\t\t\tarr: [1, 2]\r\n\t\t\t\t},\r\n\t\t\t\tarr: null,\r\n\t\t\t\tarr2: [4, 5]\r\n\t\t\t}))\r\n\t\t\t.to.deep.equal({\r\n\t\t\t\tfoo: 'bar',\r\n\t\t\t\tbar: null,\r\n\t\t\t\thello: {\r\n\t\t\t\t\tworld: null,\r\n\t\t\t\t\tother: 'thing',\r\n\t\t\t\t\tarr: [1, 2]\r\n\t\t\t\t},\r\n\t\t\t\tarr: null,\r\n\t\t\t\tarr2: [4, 5]\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n});"], "fixing_code": ["{\r\n  \"name\": \"bmoor\",\r\n  \"version\": \"0.8.12\",\r\n  \"author\": \"Brian Heilman <das.ist.junk@gmail.com>\",\r\n  \"description\": \"A basic foundation for other libraries, establishing useful patterbs, and letting them be more.\",\r\n  \"license\": \"MIT\",\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git://github.com/b-heilman/bmoor.git\"\r\n  },\r\n  \"main\": \"src/index.js\",\r\n  \"scripts\": {\r\n    \"demo\": \"gulp serve\",\r\n    \"build\": \"gulp build\"\r\n  },\r\n  \"dependencies\": {\r\n    \"uuid\": \"^3.4.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"chai\": \"^4.2.0\",\r\n    \"gulp\": \"^4.0.2\",\r\n    \"gulp-jshint\": \"^2.1.0\",\r\n    \"gulp-mocha\": \"^7.0.2\",\r\n    \"jshint\": \"^2.11.1\",\r\n    \"jshint-stylish\": \"2.1.0\",\r\n    \"mocha\": \"^6.2.3\",\r\n    \"sinon\": \"^7.5.0\",\r\n    \"yargs\": \"^15.3.1\"\r\n  }\r\n}\r\n", "/**\r\n * The core of bmoor's usefulness\r\n * @module bmoor\r\n **/\r\n\r\n/**\r\n * Tests if the value is undefined\r\n *\r\n * @function isUndefined\r\n * @param {*} value - The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isUndefined( value ) {\r\n\treturn value === undefined;\r\n}\r\n\r\n/**\r\n * Tests if the value is not undefined\r\n *\r\n * @function isDefined\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isDefined( value ) {\r\n\treturn value !== undefined;\r\n}\r\n\r\n/**\r\n * Tests if the value is a string\r\n *\r\n * @function isString\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isString( value ){\r\n\treturn typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Tests if the value is numeric\r\n *\r\n * @function isNumber\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isNumber( value ){\r\n\treturn typeof value === 'number';\r\n}\r\n\r\n/**\r\n * Tests if the value is a function\r\n *\r\n * @function isFuncion\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isFunction( value ){\r\n\treturn typeof value === 'function';\r\n}\r\n\r\n/**\r\n * Tests if the value is an object\r\n *\r\n * @function isObject\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isObject( value ){\r\n\treturn !!value && typeof value === 'object';\r\n}\r\n\r\n/**\r\n * Tests if the value is a boolean\r\n *\r\n * @function isBoolean\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isBoolean( value ){\r\n\treturn typeof value === 'boolean';\r\n}\r\n\r\n/**\r\n * Tests if the value can be used as an array\r\n *\r\n * @function isArrayLike\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isArrayLike( value ) {\r\n\t// for me, if you have a length, I'm assuming you're array like, might change\r\n\tif (value){\r\n\t\treturn isObject(value) && (value.length === 0 || (0 in value && (value.length-1) in value));\r\n\t}else{\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Tests if the value is an array\r\n *\r\n * @function isArray\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isArray( value ) {\r\n\treturn value instanceof Array;\r\n}\r\n\r\n/**\r\n * Tests if the value has no content.\r\n * If an object, has no own properties.\r\n * If array, has length == 0.\r\n * If other, is not defined\r\n *\r\n * @function isEmpty\r\n * @param {*} value The variable to test\r\n * @return {boolean}\r\n **/\r\nfunction isEmpty( value ){\r\n\tvar key;\r\n\r\n\tif (isObject(value)){\r\n\t\tfor(key in value){ \r\n\t\t\tif (value.hasOwnProperty(key)){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t} else if (isArrayLike(value)){\r\n\t\treturn value.length === 0;\r\n\t} else {\r\n\t\treturn isUndefined( value );\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nfunction parse( path ){\r\n\tif (!path){\r\n\t\treturn [];\r\n\t} else if (isString(path)){\r\n\t\t// this isn't perfect, I'm making it work with arrays though\r\n\t\tif (path.indexOf('[') !== -1){\r\n\t\t\treturn path.match(/[^\\]\\[.]+/g)\r\n\t\t\t.map(d => {\r\n\t\t\t\tif (d[0] === '\"' || d[0] === '\\''){\r\n\t\t\t\t\treturn d.substring(1, d.length-1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn d;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\treturn path.split('.');\r\n\t\t}\r\n\t} else if (isArray(path)){\r\n\t\treturn path.slice(0);\r\n\t} else {\r\n\t\tthrow new Error(\r\n\t\t\t'unable to parse path: '+\r\n\t\t\tpath+ ' : '+typeof(path)\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * Sets a value to a namespace, returns the old value\r\n *\r\n * @function set\r\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\r\n * @param {string|array} space The namespace\r\n * @param {*} value The value to set the namespace to\r\n * @return {*}\r\n **/\r\nfunction set( root, space, value ){\r\n\tvar i, c, \r\n\t\tval,\r\n\t\tnextSpace,\r\n\t\tcurSpace = root;\r\n\t\r\n\tspace = parse(space);\r\n\r\n\tval = space.pop();\r\n\r\n\tfor( i = 0, c = space.length; i < c; i++ ){\r\n\t\tnextSpace = space[ i ];\r\n\t\t\t\r\n\t\tif (nextSpace === '__proto__'){\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif ( isUndefined(curSpace[nextSpace]) ){\r\n\t\t\tcurSpace[ nextSpace ] = {};\r\n\t\t}\r\n\t\t\t\r\n\t\tcurSpace = curSpace[ nextSpace ];\r\n\t}\r\n\r\n\tcurSpace[ val ] = value;\r\n\r\n\treturn curSpace;\r\n}\r\n\r\nfunction _makeSetter( property, next ){\r\n\tif (property === '__proto__'){\r\n\t\tthrow new Error('unable to access __proto__');\r\n\t}\r\n\r\n\tif ( next ){\r\n\t\treturn function setter( ctx, value ){\r\n\t\t\tvar t = ctx[property];\r\n\r\n\t\t\tif ( !t ){\r\n\t\t\t\tt = ctx[property] = {};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn next( t, value );\r\n\t\t};\r\n\t}else{\r\n\t\treturn function( ctx, value ){\r\n\t\t\tctx[property] = value;\r\n\t\t\treturn ctx;\r\n\t\t};\r\n\t}\r\n}\r\n\r\nfunction makeSetter( space ){\r\n\tvar i,\r\n\t\tfn,\r\n\t\treadings = parse(space);\r\n\r\n\tfor( i = readings.length-1; i > -1; i-- ){\r\n\t\tfn = _makeSetter( readings[i], fn );\r\n\t}\r\n\r\n\treturn fn;\r\n}\r\n\r\n/**\r\n * get a value from a namespace, if it doesn't exist, the path will be created\r\n *\r\n * @function get\r\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\r\n * @param {string|array|function} space The namespace\r\n * @return {array}\r\n **/\r\nfunction get( root, path ){\r\n\tvar i, c,\r\n\t\tspace,\r\n\t\tnextSpace,\r\n\t\tcurSpace = root;\r\n\t\r\n\tif ( !root ){\r\n\t\treturn root;\r\n\t}\r\n\r\n\tspace = parse(path);\r\n\tif ( space.length ){\r\n\t\tfor( i = 0, c = space.length; i < c; i++ ){\r\n\t\t\tnextSpace = space[i];\r\n\t\t\t\t\r\n\t\t\tif (nextSpace === '__proto__'){\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tif ( isUndefined(curSpace[nextSpace]) ){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcurSpace = curSpace[nextSpace];\r\n\t\t}\r\n\t}\r\n\r\n\treturn curSpace;\r\n}\r\n\r\nfunction _makeGetter( property, next ){\r\n\tif (property === '__proto__'){\r\n\t\tthrow new Error('unable to access __proto__');\r\n\t}\r\n\r\n\tif (next){\r\n\t\treturn function getter( obj ){\r\n\t\t\ttry {\r\n\t\t\t\treturn next( obj[property] );\r\n\t\t\t}catch( ex ){\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t};\r\n\t}else{\r\n\t\treturn function getter( obj ){\r\n\t\t\ttry {\r\n\t\t\t\treturn obj[property];\r\n\t\t\t} catch(ex){\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n}\r\n\r\nfunction makeGetter( path ){\r\n\tvar i,\r\n\t\tfn,\r\n\t\tspace = parse(path);\r\n\r\n\tif ( space.length ){\r\n\t\tfor( i = space.length-1; i > -1; i-- ){\r\n\t\t\tfn = _makeGetter( space[i], fn );\r\n\t\t}\r\n\t}else{\r\n\t\treturn function( obj ){\r\n\t\t\treturn obj;\r\n\t\t};\r\n\t}\r\n\r\n\treturn fn;\r\n}\r\n\r\n/**\r\n * Delete a namespace, returns the old value\r\n *\r\n * @function del\r\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\r\n * @param {string|array} space The namespace\r\n * @return {*}\r\n **/\r\nfunction del( root, space ){\r\n\tvar old,\r\n\t\tval,\r\n\t\tnextSpace,\r\n\t\tcurSpace = root;\r\n\t\r\n\tif ( space && (isString(space) || isArrayLike(space)) ){\r\n\t\tspace = parse( space );\r\n\r\n\t\tval = space.pop();\r\n\r\n\t\tfor( var i = 0; i < space.length; i++ ){\r\n\t\t\tnextSpace = space[ i ];\r\n\t\t\t\t\r\n\t\t\tif ( isUndefined(curSpace[nextSpace]) ){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tcurSpace = curSpace[ nextSpace ];\r\n\t\t}\r\n\r\n\t\told = curSpace[ val ];\r\n\t\tdelete curSpace[ val ];\r\n\t}\r\n\r\n\treturn old;\r\n}\r\n\r\nmodule.exports = {\r\n\t// booleans\r\n\tisUndefined: isUndefined,\r\n\tisDefined: isDefined,\r\n\tisString: isString,\r\n\tisNumber: isNumber,\r\n\tisFunction: isFunction,\r\n\tisObject: isObject,\r\n\tisBoolean: isBoolean,\r\n\tisArrayLike: isArrayLike,\r\n\tisArray: isArray,\r\n\tisEmpty: isEmpty,\r\n\t// access\r\n\tparse: parse,\r\n\tset: set,\r\n\tmakeSetter: makeSetter,\r\n\tget: get,\r\n\tmakeGetter: makeGetter,\r\n\tdel: del\r\n};\r\n", "\nconst {expect} = require('chai');\n\nconst bmoor = require('./index.js');\n\ndescribe('Testing object setting/getting', function() {\n\n\tdescribe('::get', function(){\n\t\tit('should be working', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei: {\n\t\t\t\t\t\tdrei: 3\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\texpect( bmoor.get(t,'eins') ).to.equal(1);\n\t\t\texpect( bmoor.get(t,'zwei.drei') ).to.equal(3);\n\t\t});\n\n\t\tit('should be working with empty strings', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei: {\n\t\t\t\t\t\tdrei: 3\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\texpect( bmoor.get(t,'') ).to.equal(t);\n\t\t});\n\n\t\tit('should not allow __proto__', function(){\n\t\t\tvar t = bmoor.get({}, '__proto__');\n\t\t\t\n\t\t\texpect(t)\n\t\t\t.to.equal(null);\n\t\t});\n\t});\n\t\n\tdescribe('::makeGetter', function(){\n\t\tit('should be working', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei: {\n\t\t\t\t\t\tdrei: 3\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tf1 = bmoor.makeGetter('eins'),\n\t\t\t\tf2 = bmoor.makeGetter('zwei.drei');\n\n\t\t\texpect( f1(t) ).to.equal(1);\n\t\t\texpect( f2(t) ).to.equal(3);\n\t\t});\n\n\t\tit('should fail with __proto__', function(){\n\t\t\tlet failed = false;\n\n\t\t\ttry {\n\t\t\t\tbmoor.makeGetter('__proto__.polluted');\n\t\t\t} catch(ex){\n\t\t\t\tfailed = true;\n\t\t\t}\n\n\t\t\texpect(failed)\n\t\t\t.to.equal(true);\n\t\t});\n\n\t\tit('should work with empty strings', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei: {\n\t\t\t\t\t\tdrei: 3\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tf1 = bmoor.makeGetter('');\n\n\t\t\texpect( f1(t) ).to.equal(t);\n\t\t});\n\t});\t\n\n\tdescribe('::set', function(){\n\t\tit('should be working working', function(){\n\t\t\tvar t = {};\n\n\t\t\tbmoor.set(t,'eins',1);\n\t\t\tbmoor.set(t,'zwei.drei',3);\n\n\t\t\texpect( t.eins ).to.equal(1);\n\t\t\texpect( t.zwei.drei ).to.equal(3);\n\t\t});\n\n\t\tit('should not allow __proto__', function(){\n\t\t\tvar t = {};\n\n\t\t\tbmoor.set(t,'__proto__.polluted', true);\n\t\t\t\n\t\t\texpect( t.polluted )\n\t\t\t.to.not.equal(true);\n\t\t});\n\t});\n\n\tdescribe('::makeSetter', function(){\n\t\tit('should actually work', function(){\n\t\t\tvar t = {},\n\t\t\t\tf1 = bmoor.makeSetter('eins'),\n\t\t\t\tf2 = bmoor.makeSetter('zwei.drei');\n\n\t\t\tf1(t,1);\n\t\t\tf2(t,3);\n\n\t\t\texpect( t.eins ).to.equal(1);\n\t\t\texpect( t.zwei.drei ).to.equal(3);\n\t\t});\n\n\t\tit('should fail with __proto__', function(){\n\t\t\tlet failed = false;\n\n\t\t\ttry {\n\t\t\t\tbmoor.makeGetter('__proto__.polluted');\n\t\t\t} catch(ex){\n\t\t\t\tfailed = true;\n\t\t\t}\n\t\t\t\t\n\n\t\t\texpect(failed)\n\t\t\t.to.equal(true);\n\t\t});\n\t});\n\n\tit('should have del working', function(){\n\t\tvar t = {\n\t\t\teins : 1,\n\t\t\tzwei: {\n\t\t\t\tdrei: 3\n\t\t\t}\n\t\t};\n\n\t\texpect( bmoor.del(t,'eins') ).to.equal(1);\n\t\texpect( bmoor.del(t,'zwei.drei') ).to.equal(3);\n\t\texpect( t.eins ).to.not.exist;\n\t\texpect( t.zwei ).to.exist;\n\t\texpect( t.zwei.drei ).to.not.exist;\n\t});\n\n\tdescribe('::parse', function(){\n\t\tit('should parse an array correctly', function(){\n\t\t\texpect(bmoor.parse([1,2,3]))\n\t\t\t.to.deep.equal([1,2,3]);\n\t\t});\n\n\t\tit('should parse dot notation correctly', function(){\n\t\t\texpect(bmoor.parse('1.2.3'))\n\t\t\t.to.deep.equal(['1','2','3']);\n\t\t});\n\n\t\tit('should parse brackets correctly', function(){\n\t\t\texpect(bmoor.parse('[1][2][3]'))\n\t\t\t.to.deep.equal(['1','2','3']);\n\t\t});\n\n\t\tit('should parse brackets with quotes correctly', function(){\n\t\t\texpect(bmoor.parse('[\\'1\\'][\"2\"][3]'))\n\t\t\t.to.deep.equal(['1','2','3']);\n\t\t});\n\n\t\tit('should parse mixed correctly', function(){\n\t\t\texpect(bmoor.parse('foo[\"bar\"].ok[hello]'))\n\t\t\t.to.deep.equal(['foo','bar','ok','hello']);\n\t\t});\n\t});\n});\n\ndescribe('Testing object functions', function() {\n\t// mask\n\tit('should allow for the creation of object from a base object', function(){\n\t\tvar t,\n\t\t\tv;\n\n\t\tfunction Foo( derp ){\n\t\t\tthis.woot = derp;\n\t\t}\n\n\t\tFoo.prototype.bar = 'yay';\n\n\t\tt = new Foo();\n\n\t\tv = bmoor.object.mask( t );\n\n\t\texpect( v.bar ).to.equal( 'yay' );\n\t});\n\n\n\t// extend\n\tit('should allow for objects to be extended by other objects', function(){\n\t\tvar t = {\n\t\t\t'foo'  : 1,\n\t\t\t'bar'  : 2 ,\n\t\t\t'woot' : 3\n\t\t};\n\n\t\tbmoor.object.extend( t, {\n\t\t\t'yay' : 'sup',\n\t\t\t'foo' : 'foo2'\n\t\t},{\n\t\t\t'woot' : '3!'\n\t\t});\n\n\t\texpect( t.foo ).to.equal( 'foo2' );\n\t\texpect( t.woot ).to.equal( '3!' );\n\t});\n\t// copy\n\t// TODO : yeah, need to do this one\n\n\t// equals\n\t// TODO : yeah, need to do this one\n\n\t// map\n\tit('should allow for the mapping of variables onto an object', function(){\n\t\tvar o = {},\n\t\t\tt = bmoor.object.explode({\n\t\t\t\thello:'world'\n\t\t\t},{\n\t\t\t\t'eins': 1, \n\t\t\t\t'zwei': 2,\n\t\t\t\t'drei': 3,\n\t\t\t\t'foo.bar': 'woot',\n\t\t\t\t'help.me': o\n\t\t\t});\n\n\t\texpect( t.eins ).to.equal( 1 );\n\t\texpect( t.foo.bar ).to.equal( 'woot' );\n\t\texpect( t.hello ).to.equal( 'world' );\n\t\texpect( t.help.me ).to.equal( o );\n\t});\n\n\tit('should allow for a new variable to be created from a map', function(){\n\t\tvar o = {},\n\t\t\tt = bmoor.object.explode({},\n\t\t\t{\n\t\t\t\t'eins': 1, \n\t\t\t\t'foo.bar': 'woot',\n\t\t\t\t'hello.world': o\n\t\t\t});\n\n\t\texpect( t.eins, 1 );\n\t\texpect( t.foo.bar, 'woot' );\n\t\texpect( t.hello.world ).to.equal( o );\n\t});\n\n\t/*\n\tdescribe('override', function(){\n\t\tit( 'should prune old properties', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tbmoor.object.override( t, {\n\t\t\t\tdrei : 3\n\t\t\t});\n\n\t\t\texpect( t.eins ).to.not.to.exist;\n\t\t\texpect( t.zwei ).to.not.to.exist;\n\t\t\texpect( t.drei ).to.equal( 3 );\n\t\t});\n\n\t\tit( 'should handle shallow object copy', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\to = {\n\t\t\t\t\tdrei : {\n\t\t\t\t\t\thello: 'world'\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tbmoor.object.override( t, o );\n\n\t\t\to.drei.hello = 'woot';\n\n\t\t\texpect( t.drei.hello ).to.equal( 'woot' );\n\t\t});\n\n\t\tit( 'should handle deep object copy', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\to = {\n\t\t\t\t\tdrei : {\n\t\t\t\t\t\thello: 'world'\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tbmoor.object.override( t, o, true );\n\n\t\t\to.drei.hello = 'woot';\n\n\t\t\texpect( t.drei.hello ).to.equal( 'world' );\n\t\t});\n\t});\n\t*/\n\tit( 'should allow for data to be merged', function(){\n\t\tvar t = {\n\t\t\teins : 1,\n\t\t\tzwei : {\n\t\t\t\tfoo : 1,\n\t\t\t\tbar : 2\n\t\t\t},\n\t\t\tdrei : 3\n\t\t};\n\n\t\tbmoor.object.merge( t, {\n\t\t\teins : 2,\n\t\t\tzwei : {\n\t\t\t\tfoo : 2\n\t\t\t},\n\t\t\tfier : 4\n\t\t});\n\n\t\texpect( t.eins ).to.equal( 2 );\n\t\texpect( t.zwei ).to.to.exist;\n\t\texpect( t.zwei.foo ).to.equal( 2 );\n\t\texpect( t.drei ).to.equal( 3 );\n\t\texpect( t.fier ).to.equal( 4 );\n\t});\n});\n\ndescribe('Testing the test functions', function(){\n\t// isBoolean\n\tit('should be able to test booleans', function(){\n\t\texpect( bmoor.isBoolean(true) ).to.equal( true );\n\t\texpect( bmoor.isBoolean(false) ).to.equal( true );\n\t\texpect( bmoor.isBoolean(1) ).to.equal( false );\n\t\texpect( bmoor.isBoolean(0) ).to.equal( false );\n\t});\n\t// isDefined\n\tit('should be able to test for variables being defined', function(){\n\t\tvar n = {},\n\t\t\tt;\n\n\t\texpect( bmoor.isDefined(true) ).to.equal( true );\n\t\texpect( bmoor.isDefined(false) ).to.equal( true );\n\t\texpect( bmoor.isDefined(1) ).to.equal( true );\n\t\texpect( bmoor.isDefined(0) ).to.equal( true );\n\t\texpect( bmoor.isDefined(n) ).to.equal( true );\n\t\texpect( bmoor.isDefined(t) ).to.equal( false );\n\t});\n\t// isUndefined\n\tit('should be able to test for variables being undefined', function(){\n\t\tvar n = {},\n\t\t\tt;\n\n\t\texpect( bmoor.isUndefined(true) ).to.equal( false );\n\t\texpect( bmoor.isUndefined(false) ).to.equal( false );\n\t\texpect( bmoor.isUndefined(1) ).to.equal( false );\n\t\texpect( bmoor.isUndefined(0) ).to.equal( false );\n\t\texpect( bmoor.isUndefined(n) ).to.equal( false );\n\t\texpect( bmoor.isUndefined(t) ).to.equal( true );\n\t});\n\t// isArray\n\tit('should be able to test for variables being arrays', function(){\n\t\texpect( bmoor.isArray([]) ).to.equal( true );\n\t\texpect( bmoor.isArray({}) ).to.equal( false );\n\t\texpect( bmoor.isArray(1) ).to.equal( false );\n\t\texpect( bmoor.isArray({length:0}) ).to.equal( false );\n\t\texpect( bmoor.isArray('') ).to.equal( false );\n\t});\n\t// isArrayLike\n\tit('should be able to test for variables being array like', function(){\n\t\texpect( bmoor.isArrayLike([]) ).to.equal( true );\n\t\texpect( bmoor.isArrayLike({}) ).to.equal( false );\n\t\texpect( bmoor.isArrayLike(1) ).to.equal( false );\n\t\texpect( bmoor.isArrayLike({length:0}) ).to.equal( true );\n\t\texpect( bmoor.isArrayLike('') ).to.equal( false );\n\t});\n\t// isObject\n\tit('should be able to test for variables being an object', function(){\n\t\tfunction Temp(){}\n\t\tvar t = new Temp();\n\n\t\texpect( bmoor.isObject([]) ).to.equal( true );\n\t\texpect( bmoor.isObject({}) ).to.equal( true );\n\t\texpect( bmoor.isObject(1) ).to.equal( false );\n\t\texpect( bmoor.isObject(false) ).to.equal( false );\n\t\texpect( bmoor.isObject(Temp) ).to.equal( false );\n\t\texpect( bmoor.isObject(t) ).to.equal( true );\n\t\texpect( bmoor.isObject('') ).to.equal( false );\n\t});\n\t// isFunction\n\tit('should be able to test for variables being a function', function(){\n\t\tfunction Temp(){}\n\t\tvar t = new Temp();\n\n\t\texpect( bmoor.isFunction([]) ).to.equal( false );\n\t\texpect( bmoor.isFunction({}) ).to.equal( false );\n\t\texpect( bmoor.isFunction(1) ).to.equal( false );\n\t\texpect( bmoor.isFunction(false) ).to.equal( false );\n\t\texpect( bmoor.isFunction(Temp) ).to.equal( true );\n\t\texpect( bmoor.isFunction(t) ).to.equal( false );\n\t\texpect( bmoor.isFunction('') ).to.equal( false );\n\t});\n\t// isNumber\n\tit('should be able to test for variables being a number', function(){\n\t\tfunction Temp(){}\n\t\tvar t = new Temp();\n\n\t\texpect( bmoor.isNumber([]) ).to.equal( false );\n\t\texpect( bmoor.isNumber({}) ).to.equal( false );\n\t\texpect( bmoor.isNumber(1) ).to.equal( true );\n\t\texpect( bmoor.isNumber(false) ).to.equal( false );\n\t\texpect( bmoor.isNumber(Temp) ).to.equal( false );\n\t\texpect( bmoor.isNumber(t) ).to.equal( false );\n\t\texpect( bmoor.isNumber('') ).to.equal( false );\n\t});\n\t\n\t// isString\n\tit('should be able to test for variables being a function', function(){\n\t\tfunction Temp(){}\n\t\tvar t = new Temp();\n\n\t\texpect( bmoor.isString([]) ).to.equal( false );\n\t\texpect( bmoor.isString({}) ).to.equal( false );\n\t\texpect( bmoor.isString(1) ).to.equal( false );\n\t\texpect( bmoor.isString(false) ).to.equal( false );\n\t\texpect( bmoor.isString(Temp) ).to.equal( false );\n\t\texpect( bmoor.isString(t) ).to.equal( false );\n\t\texpect( bmoor.isString('') ).to.equal( true );\n\t});\n\t\n\t// isEmpty\n\tit('should be able to test for variables being a function', function(){\n\t\tvar t;\n\n\t\texpect( bmoor.isEmpty([]) ).to.equal( true );\n\t\texpect( bmoor.isEmpty({}) ).to.equal( true );\n\t\texpect( bmoor.isEmpty(0) ).to.equal( false );\n\t\texpect( bmoor.isEmpty(t) ).to.equal( true );\n\t\texpect( bmoor.isEmpty(null) ).to.equal( false );\n\t\texpect( bmoor.isEmpty([0]) ).to.equal( false );\n\t\texpect( bmoor.isEmpty({'v':0}) ).to.equal( false );\n\t});\n});\n", "\r\nconst {expect} = require('chai');\r\n\r\ndescribe('bmoor.object', function() {\r\n\t\r\n\tconst bmoor = require('./index.js');\r\n\r\n\tdescribe('::explode', function(){\r\n\t\tit('should operate explode correctly', function(){\r\n\t\t\tvar t = {\r\n\t\t\t\t'eins.zwei': 12,\r\n\t\t\t\t'eins.drei': 13,\r\n\t\t\t\t'fier': 4\r\n\t\t\t};\r\n\r\n\t\t\texpect(bmoor.object.explode(t))\r\n\t\t\t.to.deep.equal({\r\n\t\t\t\teins: {\r\n\t\t\t\t\tzwei: 12,\r\n\t\t\t\t\tdrei: 13\r\n\t\t\t\t},\r\n\t\t\t\tfier: 4\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tit('should operate makeExploder correctly', function(){\r\n\t\t\tvar t = {\r\n\t\t\t\t\t'eins.zwei': 12,\r\n\t\t\t\t\t'eins.drei': 13,\r\n\t\t\t\t\t'fier': 4\r\n\t\t\t\t},\r\n\t\t\t\texplode = bmoor.object.makeExploder( Object.keys(t) );\r\n\r\n\t\t\texpect(explode(t))\r\n\t\t\t.to.deep.equal({\r\n\t\t\t\teins: {\r\n\t\t\t\t\tzwei: 12,\r\n\t\t\t\t\tdrei: 13\r\n\t\t\t\t},\r\n\t\t\t\tfier: 4\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n\r\n\tdescribe('::implode', function(){\r\n\t\tit('should operate correctly', function(){\r\n\t\t\tvar t = {\r\n\t\t\t\ttime: {\r\n\t\t\t\t\tstart: 99,\r\n\t\t\t\t\tstop: 100\r\n\t\t\t\t},\r\n\t\t\t\tid: 'woot',\r\n\t\t\t\tfoo: {\r\n\t\t\t\t\tbar: {\r\n\t\t\t\t\t\thello: 'world'\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tarr: [{\r\n\t\t\t\t\teins: 1,\r\n\t\t\t\t}, {\r\n\t\t\t\t\tzwei: 2\r\n\t\t\t\t}],\r\n\t\t\t\tdouble: [\r\n\t\t\t\t\t[0]\r\n\t\t\t\t]\r\n\t\t\t};\r\n\r\n\t\t\texpect(bmoor.object.implode(t))\r\n\t\t\t.to.deep.equal({\r\n\t\t\t\t'time.start': 99,\r\n\t\t\t\t'time.stop': 100,\r\n\t\t\t\t'id': 'woot',\r\n\t\t\t\t'foo.bar.hello': 'world',\r\n\t\t\t\t'arr[0].eins': 1,\r\n\t\t\t\t'arr[1].zwei': 2,\r\n\t\t\t\t'double[0][0]': 0\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tit('should operate correctly', function(){\r\n\t\t\tvar t = {\r\n\t\t\t\ttime: {\r\n\t\t\t\t\tstart: 99,\r\n\t\t\t\t\tstop: 100\r\n\t\t\t\t},\r\n\t\t\t\tid: 'woot',\r\n\t\t\t\tfoo: {\r\n\t\t\t\t\tbar: {\r\n\t\t\t\t\t\thello: 'world'\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tarr: [{\r\n\t\t\t\t\teins: 1,\r\n\t\t\t\t}, {\r\n\t\t\t\t\tzwei: 2\r\n\t\t\t\t}],\r\n\t\t\t\tdouble: [\r\n\t\t\t\t\t[0]\r\n\t\t\t\t]\r\n\t\t\t};\r\n\r\n\t\t\texpect(bmoor.object.implode(t, {skipArray: true}))\r\n\t\t\t.to.deep.equal({\r\n\t\t\t\t'time.start': 99,\r\n\t\t\t\t'time.stop': 100,\r\n\t\t\t\t'id': 'woot',\r\n\t\t\t\t'foo.bar.hello': 'world',\r\n\t\t\t\t'arr': [{\r\n\t\t\t\t\teins: 1,\r\n\t\t\t\t}, {\r\n\t\t\t\t\tzwei: 2\r\n\t\t\t\t}],\r\n\t\t\t\t'double': [\r\n\t\t\t\t\t[0]\r\n\t\t\t\t]\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tit('should operate implode correctly - with an ignore', function(){\r\n\t\t\tvar t = {\r\n\t\t\t\ttime: {\r\n\t\t\t\t\tstart: 99,\r\n\t\t\t\t\tstop: 100\r\n\t\t\t\t},\r\n\t\t\t\tid: 'woot',\r\n\t\t\t\tfoo: {\r\n\t\t\t\t\tbar: {\r\n\t\t\t\t\t\thello: 'world'\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\texpect(bmoor.object.implode(t, {\r\n\t\t\t\tignore: {\r\n\t\t\t\t\ttime:{\r\n\t\t\t\t\t\tstart:true\r\n\t\t\t\t\t},\r\n\t\t\t\t\tid: true,\r\n\t\t\t\t\tfoo: true\r\n\t\t\t\t}\r\n\t\t\t})).to.deep.equal({\r\n\t\t\t\t'time.stop': 100\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n\r\n\tdescribe('::merge', function(){\r\n\t\tit('should replace null correctly', function(){\r\n\t\t\texpect( bmoor.object.merge({\r\n\t\t\t\tfoo: null,\r\n\t\t\t\tbar: { a: 'ok'},\r\n\t\t\t\thello: {\r\n\t\t\t\t\tworld: 1,\r\n\t\t\t\t\tother: 'thing',\r\n\t\t\t\t\tarr: null\r\n\t\t\t\t},\r\n\t\t\t\tarr: [1, 2],\r\n\t\t\t\tarr2: [8, 9]\r\n\t\t\t},{\r\n\t\t\t\tfoo: 'bar',\r\n\t\t\t\tbar: null,\r\n\t\t\t\thello: {\r\n\t\t\t\t\tworld: null,\r\n\t\t\t\t\tarr: [1, 2]\r\n\t\t\t\t},\r\n\t\t\t\tarr: null,\r\n\t\t\t\tarr2: [4, 5]\r\n\t\t\t}))\r\n\t\t\t.to.deep.equal({\r\n\t\t\t\tfoo: 'bar',\r\n\t\t\t\tbar: null,\r\n\t\t\t\thello: {\r\n\t\t\t\t\tworld: null,\r\n\t\t\t\t\tother: 'thing',\r\n\t\t\t\t\tarr: [1, 2]\r\n\t\t\t\t},\r\n\t\t\t\tarr: null,\r\n\t\t\t\tarr2: [4, 5]\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n});\r\n"], "filenames": ["package.json", "src/core.js", "src/core.spec.js", "src/object.spec.js"], "buggy_code_start_loc": [3, 186, 7, 8], "buggy_code_end_loc": [4, 264, 76, 181], "fixing_code_start_loc": [3, 187, 7, 8], "fixing_code_end_loc": [4, 281, 128, 183], "type": "CWE-1321", "message": "The package bmoor before 0.8.12 are vulnerable to Prototype Pollution via the set function.", "other": {"cve": {"id": "CVE-2020-7736", "sourceIdentifier": "report@snyk.io", "published": "2020-10-02T10:15:12.903", "lastModified": "2022-12-02T19:47:02.370", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package bmoor before 0.8.12 are vulnerable to Prototype Pollution via the set function."}, {"lang": "es", "value": "El paquete bmoor versiones anteriores a 0.8.12, son vulnerables a una Contaminaci\u00f3n de Prototipo por medio de la funci\u00f3n set"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bmoor_project:bmoor:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.12", "matchCriteriaId": "A63C3882-F7B7-46B7-B07D-71FD6DF4E242"}]}]}], "references": [{"url": "https://github.com/b-heilman/bmoor/commit/7d4a086a1dc3ef11ed0b323824d02348734b7da5", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-BMOOR-598664", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/b-heilman/bmoor/commit/7d4a086a1dc3ef11ed0b323824d02348734b7da5"}}