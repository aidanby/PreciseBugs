{"buggy_code": ["<?php\ndeclare(strict_types=0);\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Lib\\Metadata\\Repository\\MetadataField;\n\n/**\n * Search Class\n * Search-related voodoo.  Beware tentacles.\n */\n\nclass Search extends playlist_object\n{\n    public $searchtype;\n    public $rules;\n    public $logic_operator = 'AND';\n    public $type           = 'public';\n    public $random         = 0;\n    public $limit          = 0;\n    public $last_count     = 0;\n    public $last_duration  = 0;\n    public $date           = 0;\n\n    public $basetypes;\n    public $types;\n\n    public $link;\n    public $f_link;\n\n    public $search_user;\n\n    private $stars;\n    private $order_by;\n\n    /**\n     * constructor\n     * @param integer $search_id\n     * @param string $searchtype\n     * @param User $user\n     */\n    public function __construct($search_id = 0, $searchtype = 'song', $user = null)\n    {\n        if ($user) {\n            $this->search_user = $user;\n        } else {\n            $this->search_user = Core::get_global('user');\n        }\n        $this->searchtype = $searchtype;\n        if ($search_id > 0) {\n            $info = $this->get_info($search_id);\n            foreach ($info as $key => $value) {\n                $this->$key = $value;\n            }\n            $this->rules = json_decode((string) $this->rules, true);\n        }\n        // workaround null dates/values\n        $this->last_count    = (int) $this->last_count;\n        $this->last_duration = (int) $this->last_duration;\n        $this->date          = time();\n\n        $this->stars = array(\n            T_('0 Stars'),\n            T_('1 Star'),\n            T_('2 Stars'),\n            T_('3 Stars'),\n            T_('4 Stars'),\n            T_('5 Stars')\n        );\n\n        $this->stars = array(\n            T_('0 Stars'),\n            T_('1 Star'),\n            T_('2 Stars'),\n            T_('3 Stars'),\n            T_('4 Stars'),\n            T_('5 Stars')\n        );\n\n        // Define our basetypes\n        $this->set_basetypes();\n\n        $this->types = array();\n        switch ($searchtype) {\n            case 'song':\n                $this->song_types();\n                $this->order_by = '`song`.`file`';\n                break;\n            case 'album':\n                $this->album_types();\n                $this->order_by = (AmpConfig::get('album_group')) ? '`album`.`name`' : '`album`.`name`, `album`.`disk`';\n                break;\n            case 'video':\n                $this->video_types();\n                $this->order_by = '`video`.`file`';\n                break;\n            case 'artist':\n                $this->artist_types();\n                $this->order_by = '`artist`.`name`';\n                break;\n            case 'playlist':\n                $this->playlist_types();\n                $this->order_by = '`playlist`.`name`';\n                break;\n            case 'label':\n                $this->label_types();\n                $this->order_by = '`label`.`name`';\n                break;\n            case 'user':\n                $this->user_types();\n                $this->order_by = '`user`.`username`';\n                break;\n        } // end switch on searchtype\n    } // end constructor\n\n    /**\n     * set_basetypes\n     *\n     * Function called during construction to set the different types and rules for search\n     */\n    private function set_basetypes()\n    {\n        $this->basetypes['numeric'][] = array(\n            'name' => 'gte',\n            'description' => T_('is greater than or equal to'),\n            'sql' => '>='\n        );\n\n        $this->basetypes['numeric'][] = array(\n            'name' => 'lte',\n            'description' => T_('is less than or equal to'),\n            'sql' => '<='\n        );\n\n        $this->basetypes['numeric'][] = array(\n            'name' => 'equal',\n            'description' => T_('equals'),\n            'sql' => '<=>'\n        );\n\n        $this->basetypes['numeric'][] = array(\n            'name' => 'ne',\n            'description' => T_('does not equal'),\n            'sql' => '<>'\n        );\n\n        $this->basetypes['numeric'][] = array(\n            'name' => 'gt',\n            'description' => T_('is greater than'),\n            'sql' => '>'\n        );\n\n        $this->basetypes['numeric'][] = array(\n            'name' => 'lt',\n            'description' => T_('is less than'),\n            'sql' => '<'\n        );\n\n        $this->basetypes['boolean'][] = array(\n            'name' => 'true',\n            'description' => T_('is true'),\n            'sql' => '1'\n        );\n\n        $this->basetypes['boolean'][] = array(\n            'name' => 'false',\n            'description' => T_('is false'),\n            'sql' => '0'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'contain',\n            'description' => T_('contains'),\n            'sql' => 'LIKE',\n            'preg_match' => array('/^/', '/$/'),\n            'preg_replace' => array('%', '%')\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'notcontain',\n            'description' => T_('does not contain'),\n            'sql' => 'NOT LIKE',\n            'preg_match' => array('/^/', '/$/'),\n            'preg_replace' => array('%', '%')\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'start',\n            'description' => T_('starts with'),\n            'sql' => 'LIKE',\n            'preg_match' => '/$/',\n            'preg_replace' => '%'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'end',\n            'description' => T_('ends with'),\n            'sql' => 'LIKE',\n            'preg_match' => '/^/',\n            'preg_replace' => '%'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'equal',\n            'description' => T_('is'),\n            'sql' => '='\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'not equal',\n            'description' => T_('is not'),\n            'sql' => '!='\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'sounds',\n            'description' => T_('sounds like'),\n            'sql' => 'SOUNDS LIKE'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'notsounds',\n            'description' => T_('does not sound like'),\n            'sql' => 'NOT SOUNDS LIKE'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'regexp',\n            'description' => T_('matches regular expression'),\n            'sql' => 'REGEXP'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'notregexp',\n            'description' => T_('does not match regular expression'),\n            'sql' => 'NOT REGEXP'\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'contain',\n            'description' => T_('contains'),\n            'sql' => 'LIKE',\n            'preg_match' => array('/^/', '/$/'),\n            'preg_replace' => array('%', '%')\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'notcontain',\n            'description' => T_('does not contain'),\n            'sql' => 'NOT LIKE',\n            'preg_match' => array('/^/', '/$/'),\n            'preg_replace' => array('%', '%')\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'start',\n            'description' => T_('starts with'),\n            'sql' => 'LIKE',\n            'preg_match' => '/$/',\n            'preg_replace' => '%'\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'end',\n            'description' => T_('ends with'),\n            'sql' => 'LIKE',\n            'preg_match' => '/^/',\n            'preg_replace' => '%'\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'equal',\n            'description' => T_('is'),\n            'sql' => '>'\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'not equal',\n            'description' => T_('is not'),\n            'sql' => '='\n        );\n\n        $this->basetypes['boolean_numeric'][] = array(\n            'name' => 'equal',\n            'description' => T_('is'),\n            'sql' => '<=>'\n        );\n\n        $this->basetypes['boolean_numeric'][] = array(\n            'name' => 'ne',\n            'description' => T_('is not'),\n            'sql' => '<>'\n        );\n\n        $this->basetypes['boolean_subsearch'][] = array(\n            'name' => 'equal',\n            'description' => T_('is'),\n            'sql' => ''\n        );\n\n        $this->basetypes['boolean_subsearch'][] = array(\n            'name' => 'ne',\n            'description' => T_('is not'),\n            'sql' => 'NOT'\n        );\n\n        $this->basetypes['date'][] = array(\n            'name' => 'lt',\n            'description' => T_('before'),\n            'sql' => '<'\n        );\n\n        $this->basetypes['date'][] = array(\n            'name' => 'gt',\n            'description' => T_('after'),\n            'sql' => '>'\n        );\n\n        $this->basetypes['days'][] = array(\n            'name' => 'lt',\n            'description' => T_('before (x) days ago'),\n            'sql' => '<'\n        );\n\n        $this->basetypes['days'][] = array(\n            'name' => 'gt',\n            'description' => T_('after (x) days ago'),\n            'sql' => '>'\n        );\n\n        $this->basetypes['recent_added'][] = array(\n            'name' => 'add',\n            'description' => T_('# songs'),\n            'sql' => '`addition_time`'\n        );\n\n        $this->basetypes['recent_updated'][] = array(\n            'name' => 'upd',\n            'description' => T_('# songs'),\n            'sql' => '`update_time`'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => 'love',\n            'description' => T_('has loved'),\n            'sql' => 'userflag'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => '5star',\n            'description' => T_('has rated 5 stars'),\n            'sql' => '`rating` = 5'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => '4star',\n            'description' => T_('has rated 4 stars'),\n            'sql' => '`rating` = 4'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => '3star',\n            'description' => T_('has rated 3 stars'),\n            'sql' => '`rating` = 3'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => '2star',\n            'description' => T_('has rated 2 stars'),\n            'sql' => '`rating` = 2'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => '1star',\n            'description' => T_('has rated 1 star'),\n            'sql' => '`rating` = 1'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => 'unrated',\n            'description' => T_('has not rated'),\n            'sql' => 'unrated'\n        );\n        $this->basetypes['multiple'] = array_merge($this->basetypes['text'], $this->basetypes['numeric']);\n    }\n\n    /**\n     * type_numeric\n     *\n     * Generic integer searches rules\n     * @param string $name\n     * @param string $label\n     * @param string $type\n     */\n    private function type_numeric($name, $label, $type = 'numeric')\n    {\n        $this->types[] = array(\n            'name' => $name,\n            'label' => $label,\n            'type' => $type,\n            'widget' => array('input', 'number')\n        );\n    }\n\n    /**\n     * type_date\n     *\n     * Generic integer searches rules\n     * @param string $name\n     * @param string $label\n     */\n    private function type_date($name, $label)\n    {\n        $this->types[] = array(\n            'name' => $name,\n            'label' => $label,\n            'type' => 'date',\n            'widget' => array('input', 'datetime-local')\n        );\n    }\n\n    /**\n     * type_text\n     *\n     * Generic text rules\n     * @param string $name\n     * @param string $label\n     */\n    private function type_text($name, $label)\n    {\n        $this->types[] = array(\n            'name' => $name,\n            'label' => $label,\n            'type' => 'text',\n            'widget' => array('input', 'text')\n        );\n    }\n\n    /**\n     * type_select\n     *\n     * Generic rule to select from a list\n     * @param string $name\n     * @param string $label\n     * @param string $type\n     * @param array $array\n     */\n    private function type_select($name, $label, $type, $array)\n    {\n        $this->types[] = array(\n            'name' => $name,\n            'label' => $label,\n            'type' => $type,\n            'widget' => array('select', $array)\n        );\n    }\n\n    /**\n     * type_boolean\n     *\n     * True or false generic searches\n     * @param string $name\n     * @param string $label\n     */\n    private function type_boolean($name, $label)\n    {\n        $this->types[] = array(\n            'name' => $name,\n            'label' => $label,\n            'type' => 'boolean',\n            'widget' => array('input', 'hidden')\n        );\n    }\n\n    /**\n     * songtypes\n     *\n     * this is where all the searchtypes for songs are defined\n     */\n    private function song_types()\n    {\n        $this->type_text('anywhere', T_('Any searchable text'));\n        $this->type_text('title', T_('Title'));\n        $this->type_text('album', T_('Album'));\n        $this->type_text('artist', T_('Song Artist'));\n        $this->type_text('album_artist', T_('Album Artist'));\n        $this->type_text('composer', T_('Composer'));\n\n        $this->type_numeric('year', T_('Year'));\n\n        if (AmpConfig::get('ratings')) {\n            $this->type_select('myrating', T_('My Rating'), 'numeric', $this->stars);\n            $this->type_select('rating', T_('Rating (Average)'), 'numeric', $this->stars);\n            $this->type_select('albumrating', T_('My Rating (Album)'), 'numeric', $this->stars);\n            $this->type_select('artistrating', T_('My Rating (Artist)'), 'numeric', $this->stars);\n        }\n        if (AmpConfig::get('userflags')) {\n            $this->type_text('favorite', T_('Favorites'));\n        }\n\n        /* HINT: Number of times object has been played */\n        $this->type_numeric('played_times', T_('# Played'));\n        /* HINT: Number of times object has been skipped */\n        $this->type_numeric('skipped_times', T_('# Skipped'));\n        /* HINT: Number of times object has been played OR skipped */\n        $this->type_numeric('played_or_skipped_times', T_('# Played or Skipped'));\n        /* HINT: Percentage of (Times Played / Times skipped) * 100 */\n        $this->type_numeric('play_skip_ratio', T_('Played/Skipped ratio'));\n        $this->type_numeric('last_play', T_('My Last Play'), 'days');\n        $this->type_numeric('last_skip', T_('My Last Skip'), 'days');\n        $this->type_numeric('last_play_or_skip', T_('My Last Play or Skip'), 'days');\n        $this->type_boolean('played', T_('Played'));\n        $this->type_boolean('myplayed', T_('Played by Me'));\n        $this->type_boolean('myplayedalbum', T_('Played by Me (Album)'));\n        $this->type_boolean('myplayedartist', T_('Played by Me (Artist)'));\n        $this->type_numeric('time', T_('Length (in minutes)'));\n\n        $this->type_text('tag', T_('Tags'));\n        $this->type_text('album_tag', T_('Album Tag'));\n        $this->type_text('artist_tag', T_('Artist Tag'));\n\n        $users = array();\n        foreach (User::get_valid_users() as $userid) {\n            $user           = new User($userid);\n            $users[$userid] = $user->username;\n        }\n        $this->type_select('other_user', T_('Another User'), 'user_numeric', $users);\n        $this->type_select('other_user_album', T_('Another User (Album)'), 'user_numeric', $users);\n        $this->type_select('other_user_artist', T_('Another User (Artist)'), 'user_numeric', $users);\n\n        $this->type_text('label', T_('Label'));\n        if (AmpConfig::get('licensing')) {\n            $licenses = array();\n            foreach (License::get_licenses() as $license_id) {\n                $license               = new License($license_id);\n                $licenses[$license_id] = $license->name;\n            }\n            $this->type_select('license', T_('Music License'), 'boolean_numeric', $licenses);\n        }\n\n        $playlists = array();\n        foreach (Playlist::get_playlists() as $playlistid) {\n            $playlist = new Playlist($playlistid);\n            $playlist->format(false);\n            $playlists[$playlistid] = $playlist->f_name;\n        }\n        $this->type_select('playlist', T_('Playlist'), 'boolean_numeric', $playlists);\n\n        $playlists = array();\n        $searches  = self::get_searches();\n        foreach ($searches as $playlistid) {\n            // Slightly different from the above so we don't instigate a vicious loop.\n            $playlists[$playlistid] = self::get_name_byid($playlistid);\n        }\n        $this->type_select('smartplaylist', T_('Smart Playlist'), 'boolean_subsearch', $playlists);\n\n        $this->type_text('playlist_name', T_('Playlist Name'));\n\n        $this->type_text('comment', T_('Comment'));\n        $this->type_text('lyrics', T_('Lyrics'));\n        $this->type_text('file', T_('Filename'));\n        $bitrate_array = array(\n            '32',\n            '40',\n            '48',\n            '56',\n            '64',\n            '80',\n            '96',\n            '112',\n            '128',\n            '160',\n            '192',\n            '224',\n            '256',\n            '320',\n            '640',\n            '1280'\n        );\n        $this->type_select('bitrate', T_('Bitrate'), 'numeric', $bitrate_array);\n        $this->type_date('added', T_('Added'));\n        $this->type_date('updated', T_('Updated'));\n\n        $this->type_numeric('recent_added', T_('Recently added'), 'recent_added');\n        $this->type_numeric('recent_updated', T_('Recently updated'), 'recent_updated');\n\n        $catalogs = array();\n        foreach (Catalog::get_catalogs() as $catid) {\n            $catalog = Catalog::create_from_id($catid);\n            $catalog->format();\n            $catalogs[$catid] = $catalog->f_name;\n        }\n        $this->type_select('catalog', T_('Catalog'), 'boolean_numeric', $catalogs);\n\n        $this->type_text('mbid', T_('MusicBrainz ID'));\n        $this->type_text('mbid_album', T_('MusicBrainz ID (Album)'));\n        $this->type_text('mbid_artist', T_('MusicBrainz ID (Artist)'));\n\n        if (AmpConfig::get('enable_custom_metadata')) {\n            $metadataFields          = array();\n            $metadataFieldRepository = new MetadataField();\n            foreach ($metadataFieldRepository->findAll() as $metadata) {\n                $metadataFields[$metadata->getId()] = $metadata->getName();\n            }\n            $this->types[] = array(\n                'name' => 'metadata',\n                'label' => T_('Metadata'),\n                'type' => 'multiple',\n                'subtypes' => $metadataFields,\n                'widget' => array('subtypes', array('input', 'text'))\n            );\n        }\n    }\n\n    /**\n     * artisttypes\n     *\n     * this is where all the searchtypes for artists are defined\n     */\n    private function artist_types()\n    {\n        $this->type_text('title', T_('Name'));\n\n        $this->type_numeric('yearformed', T_('Year'));\n        $this->type_text('placeformed', T_('Place'));\n\n        if (AmpConfig::get('ratings')) {\n            $this->type_select('myrating', T_('My Rating'), 'numeric', $this->stars);\n            $this->type_select('rating', T_('Rating (Average)'), 'numeric', $this->stars);\n        }\n\n        if (AmpConfig::get('userflags')) {\n            $this->type_text('favorite', T_('Favorites'));\n        }\n\n        /* HINT: Number of times object has been played */\n        $this->type_numeric('played_times', T_('# Played'));\n        $this->type_numeric('last_play', T_('My Last Play'), 'days');\n        $this->type_numeric('last_skip', T_('My Last Skip'), 'days');\n        $this->type_numeric('last_play_or_skip', T_('My Last Play or Skip'), 'days');\n        $this->type_boolean('played', T_('Played'));\n        $this->type_boolean('myplayed', T_('Played by Me'));\n        $this->type_numeric('time', T_('Length (in minutes)'));\n\n        $this->type_text('tag', T_('Tag'));\n\n        $users = array();\n        foreach (User::get_valid_users() as $userid) {\n            $user           = new User($userid);\n            $users[$userid] = $user->username;\n        }\n        $this->type_select('other_user', T_('Another User'), 'user_numeric', $users);\n\n        $this->type_text('mbid', T_('MusicBrainz ID'));\n\n        $this->type_boolean('has_image', T_('Local Image'));\n        $this->type_numeric('image_width', T_('Image Width'));\n        $this->type_numeric('image_height', T_('Image Height'));\n    } // artisttypes\n\n    /**\n     * albumtypes\n     *\n     * this is where all the searchtypes for albums are defined\n     */\n    private function album_types()\n    {\n        $this->type_text('title', T_('Title'));\n        $this->type_text('artist', T_('Album Artist'));\n\n        $this->type_numeric('year', T_('Year'));\n        $this->type_numeric('original_year', T_('Original Year'));\n        $this->type_text('release_type', T_('Release Type'));\n\n        if (AmpConfig::get('ratings')) {\n            $this->type_select('myrating', T_('My Rating'), 'numeric', $this->stars);\n            $this->type_select('rating', T_('Rating (Average)'), 'numeric', $this->stars);\n            $this->type_select('artistrating', T_('Rating (Artist)'), 'numeric', $this->stars);\n        }\n        if (AmpConfig::get('userflags')) {\n            $this->type_text('favorite', T_('Favorites'));\n        }\n\n        /* HINT: Number of times object has been played */\n        $this->type_numeric('played_times', T_('# Played'));\n        $this->type_numeric('last_play', T_('My Last Play'), 'days');\n        $this->type_numeric('last_skip', T_('My Last Skip'), 'days');\n        $this->type_numeric('last_play_or_skip', T_('My Last Play or Skip'), 'days');\n        $this->type_boolean('played', T_('Played'));\n        $this->type_boolean('myplayed', T_('Played by Me'));\n        $this->type_numeric('time', T_('Length (in minutes)'));\n\n        $this->type_text('tag', T_('Tag'));\n\n        $users = array();\n        foreach (User::get_valid_users() as $userid) {\n            $user           = new User($userid);\n            $users[$userid] = $user->username;\n        }\n        $this->type_select('other_user', T_('Another User'), 'user_numeric', $users);\n\n        $catalogs = array();\n        foreach (Catalog::get_catalogs() as $catid) {\n            $catalog = Catalog::create_from_id($catid);\n            $catalog->format();\n            $catalogs[$catid] = $catalog->f_name;\n        }\n        $this->type_select('catalog', T_('Catalog'), 'boolean_numeric', $catalogs);\n\n        $this->type_text('mbid', T_('MusicBrainz ID'));\n\n        $this->type_boolean('has_image', T_('Local Image'));\n        $this->type_numeric('image_width', T_('Image Width'));\n        $this->type_numeric('image_height', T_('Image Height'));\n    } // albumtypes\n\n    /**\n     * videotypes\n     *\n     * this is where all the searchtypes for videos are defined\n     */\n    private function video_types()\n    {\n        $this->type_text('file', T_('Filename'));\n    }\n\n    /**\n     * playlisttypes\n     *\n     * this is where all the searchtypes for playlists are defined\n     */\n    private function playlist_types()\n    {\n        $this->type_text('title', T_('Name'));\n    }\n\n    /**\n     * labeltypes\n     *\n     * this is where all the searchtypes for labels are defined\n     */\n    private function label_types()\n    {\n        $this->type_text('title', T_('Name'));\n        $this->type_text('category', T_('Category'));\n    }\n\n    /**\n     * usertypes\n     *\n     * this is where all the searchtypes for users are defined\n     */\n    private function user_types()\n    {\n        $this->type_text('username', T_('Username'));\n    }\n\n    /**\n     * clean_request\n     *\n     * Sanitizes raw search data\n     * @param array $data\n     * @return array\n     */\n    public static function clean_request($data)\n    {\n        $request = array();\n        foreach ($data as $key => $value) {\n            $prefix = substr($key, 0, 4);\n            $value  = trim((string) $value);\n\n            if ($prefix == 'rule' && strlen((string) $value)) {\n                $request[$key] = Dba::escape(filter_var($value, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));\n            }\n        }\n\n        // Figure out if they want an AND based search or an OR based search\n        switch ($data['operator']) {\n            case 'or':\n                $request['operator'] = 'OR';\n                break;\n            default:\n                $request['operator'] = 'AND';\n                break;\n        }\n\n        // Verify the type\n        switch ($data['type']) {\n            case 'album':\n            case 'artist':\n            case 'video':\n            case 'song':\n            case 'tag':  // for Genres\n            case 'playlist':\n            case 'label':\n            case 'user':\n                $request['type'] = $data['type'];\n                break;\n            default:\n                $request['type'] = 'song';\n                break;\n        }\n\n        return $request;\n    } // end clean_request\n\n    /**\n     * get_name_byid\n     *\n     * Returns the name of the saved search corresponding to the given ID\n     * @param string $search_id\n     * @return string\n     */\n    public static function get_name_byid($search_id)\n    {\n        $sql        = \"SELECT `name` FROM `search` WHERE `id` = '$search_id'\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_assoc($db_results);\n\n        return $row['name'];\n    }\n\n    /**\n     * get_searches\n     *\n     * Return the IDs of all saved searches accessible by the current user.\n     * @return array\n     */\n    public static function get_searches()\n    {\n        $sql = \"SELECT `id` from `search` WHERE `type`='public' OR \" .\n            \"`user`='\" . Core::get_global('user')->id . \"' ORDER BY `name`\";\n        $db_results = Dba::read($sql);\n\n        $results = array();\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * run\n     *\n     * This function actually runs the search and returns an array of the\n     * results.\n     * @param array $data\n     * @param User $user\n     * @return integer[]\n     */\n    public static function run($data, $user = null)\n    {\n        $limit  = (int) ($data['limit']);\n        $offset = (int) ($data['offset']);\n        $random = ((int) $data['random'] > 0) ? 1 : 0;\n        $data   = self::clean_request($data);\n        $search = new Search(null, $data['type'], $user);\n        unset($data['type']);\n        //debug_event(self::class, 'run: ' . print_r($data, true), 5);\n        $search->parse_rules($data);\n\n        // Generate BASE SQL\n        $limit_sql = \"\";\n        if ($limit > 0) {\n            $limit_sql = ' LIMIT ';\n            if ($offset) {\n                $limit_sql .= $offset . \",\";\n            }\n            $limit_sql .= $limit;\n        }\n\n        $search_info = $search->to_sql();\n        $sql         = $search_info['base'] . ' ' . $search_info['table_sql'];\n        if (!empty($search_info['where_sql'])) {\n            $sql .= ' WHERE ' . $search_info['where_sql'];\n        }\n        if (!empty($search_info['group_sql'])) {\n            $sql .= ' GROUP BY ' . $search_info['group_sql'];\n            if (!empty($search_info['having_sql'])) {\n                $sql .= ' HAVING ' . $search_info['having_sql'];\n            }\n        }\n        $sql .= ($random > 0) ? \" ORDER BY RAND()\" : \" ORDER BY \" . $search->order_by;\n        $sql .= ' ' . $limit_sql;\n        $sql = trim((string) $sql);\n\n        //debug_event(self::class, 'SQL get_items: ' . $sql, 5);\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int) $row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * delete\n     *\n     * Does what it says on the tin.\n     * @return boolean\n     */\n    public function delete()\n    {\n        $search_id = Dba::escape($this->id);\n        $sql       = \"DELETE FROM `search` WHERE `id` = ?\";\n        Dba::write($sql, array($search_id));\n\n        return true;\n    }\n\n    /**\n     * format\n     * Gussy up the data\n     * @param boolean $details\n     */\n    public function format($details = true)\n    {\n        parent::format($details);\n\n        $this->link   = AmpConfig::get('web_path') . '/smartplaylist.php?action=show_playlist&playlist_id=' . $this->id;\n        $this->f_link = '<a href=\"' . $this->link . '\">' . $this->f_name . '</a>';\n    }\n\n    /**\n     * get_items\n     *\n     * Return an array of the items output by our search (part of the\n     * playlist interface).\n     * @return array\n     */\n    public function get_items()\n    {\n        $results = array();\n\n        $sqltbl = $this->to_sql();\n        $sql    = $sqltbl['base'] . ' ' . $sqltbl['table_sql'];\n        if (!empty($sqltbl['where_sql'])) {\n            $sql .= ' WHERE ' . $sqltbl['where_sql'];\n        }\n        if (!empty($sqltbl['group_sql'])) {\n            $sql .= ' GROUP BY ' . $sqltbl['group_sql'];\n        }\n        if (!empty($sqltbl['having_sql'])) {\n            $sql .= ' HAVING ' . $sqltbl['having_sql'];\n        }\n\n        $sql .= ($this->random > 0) ? \" ORDER BY RAND()\" : \" ORDER BY \" . $this->order_by;\n        if ($this->limit > 0) {\n            $sql .= \" LIMIT \" . (string) ($this->limit);\n        }\n        //debug_event(self::class, 'SQL get_items: ' . $sql, 5);\n\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = array(\n                'object_id' => $row['id'],\n                'object_type' => $this->searchtype\n            );\n        }\n        $this->date = time();\n        $this->set_last(count($results), 'last_count');\n        $this->set_last(self::get_total_duration($results), 'last_duration');\n\n        return $results;\n    }\n\n    /**\n     * set_last\n     *\n     * @param integer $count\n     * @param string $column\n     */\n    private function set_last($count, $column)\n    {\n        if (in_array($column, array('last_count', 'last_duration'))) {\n            $search_id = Dba::escape($this->id);\n            $sql       = \"UPDATE `search` SET `\" . Dba::escape($column) . \"` = \" . $count . \" WHERE `id` = ?\";\n            Dba::write($sql, array($search_id));\n        }\n    }\n\n    /**\n     * get_random_items\n     *\n     * Returns a randomly sorted array (with an optional limit) of the items\n     * output by our search (part of the playlist interface)\n     * @param integer $limit\n     * @return array\n     */\n    public function get_random_items($limit = null)\n    {\n        $results = array();\n\n        $sqltbl = $this->to_sql();\n        $sql    = $sqltbl['base'] . ' ' . $sqltbl['table_sql'];\n        if (!empty($sqltbl['where_sql'])) {\n            $sql .= ' WHERE ' . $sqltbl['where_sql'];\n        }\n        $rating_filter = AmpConfig::get_rating_filter();\n        if ($rating_filter > 0 && $rating_filter <= 5 && Core::get_global('user')) {\n            $user_id = Core::get_global('user')->id;\n            if (empty($sqltbl['where_sql'])) {\n                $sql .= \" WHERE \";\n            } else {\n                $sql .= \" AND \";\n            }\n            $sql .= \"`\" . $this->searchtype . \"`.`id` NOT IN\" .\n                    \" (SELECT `object_id` FROM `rating`\" .\n                    \" WHERE `rating`.`object_type` = '\" . $this->searchtype . \"'\" .\n                    \" AND `rating`.`rating` <=\" . $rating_filter .\n                    \" AND `rating`.`user` = \" . $user_id . \")\";\n        }\n        if (!empty($sqltbl['group_sql'])) {\n            $sql .= ' GROUP BY ' . $sqltbl['group_sql'];\n        }\n        if (!empty($sqltbl['having_sql'])) {\n            $sql .= ' HAVING ' . $sqltbl['having_sql'];\n        }\n\n        $sql .= ' ORDER BY RAND()';\n        $sql .= $limit ? ' LIMIT ' . (string) ($limit) : ' ';\n        //debug_event(self::class, 'SQL get_random_items: ' . $sql, 5);\n\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = array(\n                'object_id' => $row['id'],\n                'object_type' => $this->searchtype\n            );\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_total_duration\n     * Get the total duration of all songs.\n     * @param array $songs\n     * @return integer\n     */\n    public static function get_total_duration($songs)\n    {\n        $song_ids = array();\n        foreach ($songs as $objects) {\n            $song_ids[] = (string) $objects['object_id'];\n        }\n        $idlist = '(' . implode(',', $song_ids) . ')';\n        if ($idlist == '()') {\n            return 0;\n        }\n        $sql        = \"SELECT SUM(`time`) FROM `song` WHERE `id` IN $idlist\";\n        $db_results = Dba::read($sql);\n\n        $results = Dba::fetch_row($db_results);\n\n        return (int) $results['0'];\n    } // get_total_duration\n\n    /**\n     * name_to_basetype\n     *\n     * Iterates over our array of types to find out the basetype for\n     * the passed string.\n     * @param string $name\n     * @return string|false\n     */\n    public function name_to_basetype($name)\n    {\n        foreach ($this->types as $type) {\n            //debug_event(self::class, $name . ' name_to_basetype: ' . $type['name'], 5);\n            if ($type['name'] == $name) {\n                return $type['type'];\n            }\n        }\n        debug_event(self::class, 'name_to_basetype: could not fund ' . $name . '. Check your search rules', 5);\n\n        return false;\n    }\n\n    /**\n     * parse_rules\n     *\n     * Takes an array of sanitized search data from the form and generates\n     * our real array from it.\n     * @param array $data\n     */\n    public function parse_rules($data)\n    {\n        $this->rules = array();\n        foreach ($data as $rule => $value) {\n            //debug_event(self::class, 'parse_rules: ' . $rule . ' - ' . $value, 5);\n            if ((($this->searchtype == 'artist' && $value == 'artist') || $value == 'name') && preg_match('/^rule_[0123456789]*$/', $rule)) {\n                $value = 'title';\n            }\n            if (preg_match('/^rule_(\\d+)$/', $rule, $ruleID)) {\n                $ruleID     = (string) $ruleID[1];\n                $input_rule = (string) $data['rule_' . $ruleID . '_input'];\n                $operator   = $this->basetypes[$this->name_to_basetype($value)][$data['rule_' . $ruleID . '_operator']]['name'];\n                //keep vertical bar in regular expression\n                if (in_array($operator, ['regexp', 'notregexp'])) {\n                    $input_rule = str_replace(\"|\", \"\\0\", $input_rule);\n                }\n                foreach (explode('|', $input_rule) as $input) {\n                    $this->rules[] = array(\n                        $value,\n                        $operator,\n                        in_array($operator, ['regexp', 'notregexp']) ? str_replace(\"\\0\", \"|\", $input) : $input,\n                        $data['rule_' . $ruleID . '_subtype']\n                    );\n                }\n            }\n        }\n        $this->logic_operator = $data['operator'];\n    }\n\n    /**\n     * save\n     *\n     * Save this search to the database for use as a smart playlist\n     * @return string\n     */\n    public function save()\n    {\n        // Make sure we have a unique name\n        if (! $this->name) {\n            $time_format = AmpConfig::get('custom_datetime') ? (string) AmpConfig::get('custom_datetime') : 'm/d/Y H:i:s';\n            $this->name  = Core::get_global('user')->username . ' - ' . get_datetime($time_format, time());\n        }\n        $sql        = \"SELECT `id` FROM `search` WHERE `name` = ?\";\n        $db_results = Dba::read($sql, array($this->name));\n        if (Dba::num_rows($db_results)) {\n            $this->name .= uniqid('', true);\n        }\n\n        $sql = \"INSERT INTO `search` (`name`, `type`, `user`, `rules`, `logic_operator`, `random`, `limit`) VALUES (?, ?, ?, ?, ?, ?, ?)\";\n        Dba::write($sql, array($this->name, $this->type, Core::get_global('user')->id, json_encode($this->rules), $this->logic_operator, ($this->random > 0) ? 1 : 0, $this->limit));\n        $insert_id = Dba::insert_id();\n        $this->id  = (int) $insert_id;\n\n        return $insert_id;\n    }\n\n    /**\n     * to_js\n     *\n     * Outputs the javascript necessary to re-show the current set of rules.\n     * @return string\n     */\n    public function to_js()\n    {\n        $javascript = \"\";\n        foreach ($this->rules as $rule) {\n            $javascript .= '<script>' .\n                'SearchRow.add(\"' . $rule[0] . '\",\"' .\n                $rule[1] . '\",\"' . $rule[2] . '\", \"' . $rule[3] . '\"); </script>';\n        }\n\n        return $javascript;\n    }\n\n    /**\n     * to_sql\n     *\n     * Call the appropriate real function.\n     * @return array\n     */\n    public function to_sql()\n    {\n        return call_user_func(array($this, $this->searchtype . \"_to_sql\"));\n    }\n\n    /**\n     * update\n     *\n     * This function updates the saved version with the current settings.\n     * @param array $data\n     * @return integer\n     */\n    public function update(array $data = null)\n    {\n        if ($data && is_array($data)) {\n            $this->name   = $data['name'];\n            $this->type   = $data['pl_type'];\n            $this->random = ((int) $data['random'] > 0) ? 1 : 0;\n            $this->limit  = $data['limit'];\n        }\n\n        if (!$this->id) {\n            return 0;\n        }\n\n        $sql = \"UPDATE `search` SET `name` = ?, `type` = ?, `rules` = ?, `logic_operator` = ?, `random` = ?, `limit` = ? WHERE `id` = ?\";\n        Dba::write($sql, array($this->name, $this->type, json_encode($this->rules), $this->logic_operator, $this->random, $this->limit, $this->id));\n\n        return $this->id;\n    }\n\n    /**\n     * @return mixed|void\n     */\n    public static function garbage_collection()\n    {\n    }\n\n    /**\n     * _mangle_data\n     *\n     * Private convenience function.  Mangles the input according to a set\n     * of predefined rules so that we don't have to include this logic in\n     * foo_to_sql.\n     * @param array|string $data\n     * @param string|false $type\n     * @param array $operator\n     * @return array|boolean|integer|string|string[]|null\n     */\n    private function _mangle_data($data, $type, $operator)\n    {\n        if ($operator['preg_match']) {\n            $data = preg_replace(\n                $operator['preg_match'],\n                $operator['preg_replace'],\n                $data\n            );\n        }\n\n        if ($type == 'numeric' || $type == 'days') {\n            return (int) ($data);\n        }\n\n        if ($type == 'boolean') {\n            return make_bool($data);\n        }\n\n        return $data;\n    }\n\n    /**\n     * album_to_sql\n     *\n     * Handles the generation of the SQL for album searches.\n     * @return array\n     */\n    private function album_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $userid             = $this->search_user->id;\n\n        $where       = array();\n        $table       = array();\n        $join        = array();\n        $group       = array();\n        $having      = array();\n        $join['tag'] = array();\n        $groupdisks  = AmpConfig::get('album_group');\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n            if ($groupdisks) {\n                $group[] = \"`album`.`prefix`\";\n                $group[] = \"`album`.`name`\";\n                $group[] = \"`album`.`album_artist`\";\n                $group[] = \"`album`.`mbid`\";\n                $group[] = \"`album`.`year`\";\n            } else {\n                $group[] = \"`album`.`id`\";\n                $group[] = \"`album`.`disk`\";\n            }\n\n            switch ($rule[0]) {\n                case 'title':\n                    $where[] = \"(`album`.`name` $sql_match_operator '$input' \" .\n                               \" OR LTRIM(CONCAT(COALESCE(`album`.`prefix`, ''), \" .\n                               \"' ', `album`.`name`)) $sql_match_operator '$input')\";\n                    break;\n                case 'year':\n                    $where[] = \"`album`.`\" . $rule[0] . \"` $sql_match_operator '$input'\";\n                    break;\n                case 'original_year':\n                    $where[] = \"(`album`.`original_year` $sql_match_operator '$input' OR \" .\n                        \"(`album`.`original_year` IS NULL AND `album`.`year` $sql_match_operator '$input'))\";\n                    break;\n                case 'time':\n                    $input          = $input * 60;\n                    $where[]        = \"`alength`.`time` $sql_match_operator '$input'\";\n                    $table['atime'] = \"LEFT JOIN (SELECT `album`, SUM(`time`) AS `time` FROM `song` GROUP BY `album`) \" .\n                        \"AS `alength` ON `alength`.`album`=`album`.`id` \";\n                    break;\n                case 'rating':\n                    // average ratings only\n                    $where[]          = \"`average_rating`.`avg` $sql_match_operator '$input'\";\n                    $table['average'] = \"LEFT JOIN (SELECT `object_id`, ROUND(AVG(IFNULL(`rating`.`rating`,0))) AS \" .\n                        \"`avg` FROM `rating` WHERE `rating`.`object_type`='album' GROUP BY `object_id`) AS \" .\n                        \"`average_rating` on `average_rating`.`object_id` = `album`.`id` \";\n                    break;\n                case 'favorite':\n                    $where[]  = \"(`album`.`name` $sql_match_operator '$input' OR LTRIM(CONCAT(COALESCE(`album`.`prefix`, ''), ' ', `album`.`name`)) $sql_match_operator '$input') \" .\n                                \"AND `favorite_album_$userid`.`user` = $userid \" .\n                                \"AND `favorite_album_$userid`.`object_type` = 'album'\";\n                    // flag once per user\n                    $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_album_$userid\")) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                        \"FROM `user_flag` WHERE `user` = $userid) AS `favorite_album_$userid` \" .\n                        \"ON `album`.`id`=`favorite_album_$userid`.`object_id` \" .\n                        \"AND `favorite_album_$userid`.`object_type` = 'album' \" : ' ';\n                    break;\n                case 'myrating':\n                case 'artistrating':\n                    // combine these as they all do the same thing just different tables\n                    $looking = str_replace('rating', '', $rule[0]);\n                    $column  = ($looking == 'my') ? 'id' : 'album_artist';\n                    $my_type = ($looking == 'my') ? 'album' : $looking;\n                if ($input == 0 && $sql_match_operator == '>=') {\n                    break;\n                }\n                if ($input == 0 && $sql_match_operator == '<') {\n                    $input              = -1;\n                    $sql_match_operator = '<=>';\n                }\n                if ($input == 0 && $sql_match_operator == '<>') {\n                    $input              = 1;\n                    $sql_match_operator = '>=';\n                }\n                if (($input == 0 && $sql_match_operator != '>') || ($input == 1 && $sql_match_operator == '<')) {\n                    $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL\";\n                } elseif ($sql_match_operator == '<>' || $sql_match_operator == '<' || $sql_match_operator == '<=' || $sql_match_operator == '!=') {\n                    $where[] = \"(`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input OR `rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL)\";\n                } else {\n                    $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input\";\n                }\n                // rating once per user\n                $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $userid)) ?\n                    \"LEFT JOIN (SELECT `object_id`, `object_type`, `rating` FROM `rating` \" .\n                    \"WHERE `user` = $userid AND `object_type`='$my_type') \" .\n                    \"AS `rating_\" . $my_type . \"_\" . $userid . \"` \" .\n                    \"ON `rating_\" . $my_type . \"_\" . $userid . \"`.`object_id`=`album`.`$column` \" : ' ';\n                break;\n                case 'myplayed':\n                    $column       = 'id';\n                    $my_type      = 'album';\n                    $operator_sql = ((int) $sql_match_operator == 0) ? 'IS NULL' : 'IS NOT NULL';\n                    // played once per user\n                    $table['myplayed'] .= (!strpos((string) $table['myplayed'], \"myplayed_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS \" .\n                        \"`myplayed_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `album`.`$column`=`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` $operator_sql\";\n                    break;\n                case 'last_play':\n                    $my_type = 'album';\n                    $table['last_play'] .= (!strpos((string) $table['last_play'], \"last_play_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_play_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `album`.`id`=`last_play_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_play_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`last_play_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    break;\n                case 'last_skip':\n                    $my_type = 'album';\n                    $table['last_skip'] .= (!strpos((string) $table['last_skip'], \"last_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'skip' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = 'song' \" : ' ';\n                    $where[]      = \"`last_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    $join['song'] = true;\n                    break;\n                case 'last_play_or_skip':\n                    $my_type = 'album';\n                    $table['last_play_or_skip'] .= (!strpos((string) $table['last_play_or_skip'], \"last_play_or_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` IN ('stream', 'skip') \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_play_or_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = 'song' \" : ' ';\n                    $where[]      = \"`last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    $join['song'] = true;\n                    break;\n                case 'played_times':\n                    $where[] = \"`album`.`id` IN (SELECT `object_count`.`object_id` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'album' AND `object_count`.`count_type` = 'stream' \" .\n                        \"GROUP BY `object_count`.`object_id` HAVING COUNT(*) $sql_match_operator '$input')\";\n                    break;\n                case 'release_type':\n                    $where[] = \"`album`.`release_type` $sql_match_operator '$input' \";\n                    break;\n                case 'other_user':\n                    $other_userid = $input;\n                    if ($sql_match_operator == 'userflag') {\n                        $where[] = \"`favorite_album_$other_userid`.`user` = $other_userid \" .\n                            \" AND `favorite_album_$other_userid`.`object_type` = 'album'\";\n                        // flag once per user\n                        $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_album_$other_userid\")) ?\n                            \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                            \"from `user_flag` WHERE `user` = $other_userid) AS `favorite_album_$other_userid` \" .\n                            \"ON `song`.`album`=`favorite_album_$other_userid`.`object_id` \" .\n                            \"AND `favorite_album_$other_userid`.`object_type` = 'album' \" : ' ';\n                    } else {\n                        $column  = 'id';\n                        $my_type = 'album';\n                        $where[] = \"`rating_album_\" . $other_userid . '`.' . $sql_match_operator .\n                                   \" AND `rating_album_$other_userid`.`user` = $other_userid \" .\n                                   \" AND `rating_album_$other_userid`.`object_type` = 'album'\";\n                        // rating once per user\n                        $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $userid)) ?\n                            \"LEFT JOIN `rating` AS `rating_\" . $my_type . \"_\" . $userid . \"` ON \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`object_type`='$my_type' AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`object_id`=`$my_type`.`$column` AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`user` = $userid \" : ' ';\n                    }\n                    break;\n                case 'catalog':\n                    $where[]      = \"`song`.`catalog` $sql_match_operator '$input'\";\n                    $join['song'] = true;\n                    break;\n                case 'tag':\n                    $key = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE' || $sql_match_operator == 'NOT LIKE') {\n                        $where[]           = \"`realtag_$key`.`name` $sql_match_operator '$input'\";\n                        $join['tag'][$key] = \"$sql_match_operator '$input'\";\n                    } else {\n                        $where[]           = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0\";\n                        $join['tag'][$key] = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0\";\n                    }\n                    break;\n                case 'has image':\n                case 'has_image':\n                    $where[]            = ($sql_match_operator == '1') ? \"`has_image`.`object_id` IS NOT NULL\" : \"`has_image`.`object_id` IS NULL\";\n                    $table['has_image'] = \"LEFT JOIN (SELECT `object_id` from `image` WHERE `object_type` = 'album') as `has_image` ON `album`.`id` = `has_image`.`object_id`\";\n                    break;\n                case 'image height':\n                case 'image_height':\n                case 'image width':\n                case 'image_width':\n                    $looking       = strpos($rule[0], \"image_\") ? str_replace('image_', '', $rule[0]) : str_replace('image ', '', $rule[0]);\n                    $where[]       = \"`image`.`$looking` $sql_match_operator '$input'\";\n                    $join['image'] = true;\n                    break;\n                case 'artist':\n                    $where[]         = \"(`artist`.`name` $sql_match_operator '$input' OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) $sql_match_operator '$input')\";\n                    $table['artist'] = \"LEFT JOIN `artist` ON `album`.`album_artist`=`artist`.`id`\";\n                    break;\n                case 'mbid':\n                    $where[] = \"`album`.`mbid` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype album\n        } // foreach rule\n\n        $join['song']    = $join['song'] || AmpConfig::get('catalog_disable');\n        $join['catalog'] = $join['song'] || AmpConfig::get('catalog_disable');\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        foreach ($join['tag'] as $key => $value) {\n            $table['tag_' . $key] =\n                \"LEFT JOIN (\" .\n                \"SELECT `object_id`, GROUP_CONCAT(`name`) AS `name` \" .\n                \"FROM `tag` LEFT JOIN `tag_map` \" .\n                \"ON `tag`.`id`=`tag_map`.`tag_id` \" .\n                \"WHERE `tag_map`.`object_type`='album' \" .\n                \"GROUP BY `object_id`\" .\n                \") AS `realtag_$key` \" .\n                \"ON `album`.`id`=`realtag_$key`.`object_id`\";\n        }\n        if ($join['song']) {\n            $table['0_song'] = \"LEFT JOIN `song` ON `song`.`album`=`album`.`id`\";\n\n            if ($join['catalog']) {\n                $table['catalog'] = \"LEFT JOIN `catalog` AS `catalog_se` ON `catalog_se`.`id`=`song`.`catalog`\";\n                if (!empty($where_sql)) {\n                    $where_sql .= \" AND `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                } else {\n                    $where_sql .= \" `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                }\n            }\n        }\n        if ($join['count']) {\n            $table['object_count'] = \"LEFT JOIN (SELECT `object_count`.`object_id`, MAX(`object_count`.`date`) AS \" .\n                \"`date` FROM `object_count` WHERE `object_count`.`object_type` = 'album' AND \" .\n                \"`object_count`.`user`='\" . $userid . \"' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS \" .\n                \"`object_count` ON `object_count`.`object_id`=`album`.`id`\";\n        }\n        if ($join['image']) {\n            $table['0_song'] = \"LEFT JOIN `song` ON `song`.`album`=`album`.`id` LEFT JOIN `image` ON `image`.`object_id`=`album`.`id`\";\n            $where_sql .= \" AND `image`.`object_type`='album'\";\n            $where_sql .= \" AND `image`.`size`='original'\";\n        }\n        ksort($table);\n        $table_sql  = implode(' ', $table);\n        $group_sql  = implode(',', $group);\n        $having_sql = implode(\" $sql_logic_operator \", $having);\n\n        return array(\n            'base' => ($groupdisks) ? 'SELECT MIN(`album`.`id`) AS `id` FROM `album`' : 'SELECT MIN(`album`.`id`) AS `id`, MAX(`album`.`disk`) AS `disk` FROM `album`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => $table_sql,\n            'group_sql' => $group_sql,\n            'having_sql' => $having_sql\n        );\n    }\n\n    /**\n     * artist_to_sql\n     *\n     * Handles the generation of the SQL for artist searches.\n     * @return array\n     */\n    private function artist_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $userid             = $this->search_user->id;\n\n        $where              = array();\n        $table              = array();\n        $join               = array();\n        $group              = array();\n        $having             = array();\n        $join['tag']        = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'title':\n                case 'name':\n                    $where[] = \"(`artist`.`name` $sql_match_operator '$input' \" .\n                                \" OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), \" .\n                                \"' ', `artist`.`name`)) $sql_match_operator '$input')\";\n                    break;\n                case 'yearformed':\n                    $where[] = \"`artist`.`yearformed` $sql_match_operator '$input'\";\n                    break;\n                case 'placeformed':\n                    $where[] = \"`artist`.`placeformed` $sql_match_operator '$input'\";\n                    break;\n                case 'tag':\n                    $key = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE' || $sql_match_operator == 'NOT LIKE') {\n                        $where[]           = \"`realtag_$key`.`name` $sql_match_operator '$input'\";\n                        $join['tag'][$key] = \"$sql_match_operator '$input'\";\n                    } else {\n                        $where[]           = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0\";\n                        $join['tag'][$key] = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0\";\n                    }\n                    break;\n                case 'rating':\n                    // average ratings only\n                    $where[]          = \"`average_rating`.`avg` $sql_match_operator '$input'\";\n                    $table['average'] = \"LEFT JOIN (SELECT `object_id`, ROUND(AVG(IFNULL(`rating`.`rating`,0))) AS \" .\n                        \"`avg` FROM `rating` WHERE `rating`.`object_type`='artist' GROUP BY `object_id`) AS \" .\n                        \"`average_rating` on `average_rating`.`object_id` = `artist`.`id` \";\n                    break;\n                case 'favorite':\n                    $where[] = \"(`artist`.`name` $sql_match_operator '$input'  OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) $sql_match_operator '$input') \" .\n                               \"AND `favorite_artist_$userid`.`user` = $userid \" .\n                               \"AND `favorite_artist_$userid`.`object_type` = 'artist'\";\n                    // flag once per user\n                    $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_artist_$userid\")) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                        \"FROM `user_flag` WHERE `user` = $userid) AS `favorite_artist_$userid` \" .\n                        \"ON `artist`.`id`=`favorite_artist_$userid`.`object_id` \" .\n                        \"AND `favorite_artist_$userid`.`object_type` = 'artist' \" : ' ';\n                    break;\n                case 'has image':\n                case 'has_image':\n                    $where[]            = ($sql_match_operator == '1') ? \"`has_image`.`object_id` IS NOT NULL\" : \"`has_image`.`object_id` IS NULL\";\n                    $table['has_image'] = \"LEFT JOIN (SELECT `object_id` from `image` WHERE `object_type` = 'artist') as `has_image` ON `artist`.`id` = `has_image`.`object_id`\";\n                    break;\n                case 'image height':\n                case 'image_height':\n                case 'image width':\n                case 'image_width':\n                    $looking       = strpos($rule[0], \"image_\") ? str_replace('image_', '', $rule[0]) : str_replace('image ', '', $rule[0]);\n                    $where[]       = \"`image`.`$looking` $sql_match_operator '$input'\";\n                    $join['image'] = true;\n                    break;\n                case 'myrating':\n                    // combine these as they all do the same thing just different tables\n                    $column  = 'id';\n                    $my_type = 'artist';\n                    if ($input == 0 && $sql_match_operator == '>=') {\n                        break;\n                    }\n                    if ($input == 0 && $sql_match_operator == '<') {\n                        $input              = -1;\n                        $sql_match_operator = '=';\n                    }\n                    if ($input == 0 && $sql_match_operator == '<>') {\n                        $input              = 1;\n                        $sql_match_operator = '>=';\n                    }\n                    if (($input == 0 && $sql_match_operator != '>') || ($input == 1 && $sql_match_operator == '<')) {\n                        $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL\";\n                    } elseif ($sql_match_operator == '<>' || $sql_match_operator == '<' || $sql_match_operator == '<=' || $sql_match_operator == '!=') {\n                        $where[] = \"(`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input OR `rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL)\";\n                    } else {\n                        $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input\";\n                    }\n                    // rating once per user\n                    $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `rating` FROM `rating` \" .\n                        \"WHERE `user` = $userid AND `object_type`='$my_type') \" .\n                        \"AS `rating_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `rating_\" . $my_type . \"_\" . $userid . \"`.`object_id`=`artist`.`$column` \" : ' ';\n                    break;\n                case 'myplayed':\n                    $column       = 'id';\n                    $my_type      = 'artist';\n                    $operator_sql = ((int) $sql_match_operator == 0) ? 'IS NULL' : 'IS NOT NULL';\n                    // played once per user\n                    $table['myplayed'] .= (!strpos((string) $table['myplayed'], \"myplayed_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS \" .\n                        \"`myplayed_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `artist`.`$column`=`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` $operator_sql\";\n                    break;\n                case 'last_play':\n                    $my_type = 'artist';\n                    $table['last_play'] .= (!strpos((string) $table['last_play'], \"last_play_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_play_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `artist`.`id`=`last_play_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_play_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`last_play_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    break;\n                case 'last_skip':\n                    $my_type = 'artist';\n                    $table['last_skip'] .= (!strpos((string) $table['last_skip'], \"last_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'skip' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = 'song' \" : ' ';\n                    $where[]      = \"`last_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    $join['song'] = true;\n                    break;\n                case 'last_play_or_skip':\n                    $my_type = 'artist';\n                    $table['last_play_or_skip'] .= (!strpos((string) $table['last_play_or_skip'], \"last_play_or_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` IN ('stream', 'skip') \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_play_or_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = 'song' \" : ' ';\n                    $where[]      = \"`last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    $join['song'] = true;\n                    break;\n                case 'played_times':\n                    $where[] = \"`artist`.`id` IN (SELECT `object_count`.`object_id` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'artist' AND `object_count`.`count_type` = 'stream' \" .\n                        \"GROUP BY `object_count`.`object_id` HAVING COUNT(*) $sql_match_operator '$input')\";\n                    break;\n                case 'other_user':\n                    $other_userid = $input;\n                    if ($sql_match_operator == 'userflag') {\n                        $where[] = \"`favorite_artist_$other_userid`.`user` = $other_userid \" .\n                            \" AND `favorite_artist_$other_userid`.`object_type` = 'artist'\";\n                        // flag once per user\n                        $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_artist_$other_userid\")) ?\n                            \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                            \"FROM `user_flag` WHERE `user` = $other_userid) AS `favorite_artist_$other_userid` \" .\n                            \"ON `song`.`artist`=`favorite_artist_$other_userid`.`object_id` \" .\n                            \"AND `favorite_artist_$other_userid`.`object_type` = 'artist' \" : ' ';\n                    } else {\n                        $column  = 'id';\n                        $my_type = 'artist';\n                        $where[] = \"`rating_artist_\" . $other_userid . '`.' . $sql_match_operator .\n                                   \" AND `rating_artist_$other_userid`.`user` = $other_userid \" .\n                                   \" AND `rating_artist_$other_userid`.`object_type` = 'artist'\";\n                        // rating once per user\n                        $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $userid)) ?\n                            \"LEFT JOIN `rating` AS `rating_\" . $my_type . \"_\" . $userid . \"` ON \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`object_type`='$my_type' AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`object_id`=`$my_type`.`$column` AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`user` = $userid \" : ' ';\n                    }\n                    break;\n                case 'mbid':\n                    $where[] = \"`artist`.`mbid` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype artist\n        } // foreach rule\n\n        $join['song']    = $join['song'] || AmpConfig::get('catalog_disable');\n        $join['catalog'] = AmpConfig::get('catalog_disable');\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        foreach ($join['tag'] as $key => $value) {\n            $table['tag_' . $key] =\n                \"LEFT JOIN (\" .\n                \"SELECT `object_id`, GROUP_CONCAT(`name`) AS `name` \" .\n                \"FROM `tag` LEFT JOIN `tag_map` \" .\n                \"ON `tag`.`id`=`tag_map`.`tag_id` \" .\n                \"WHERE `tag_map`.`object_type`='artist' \" .\n                \"GROUP BY `object_id`\" .\n                \") AS `realtag_$key` \" .\n                \"ON `artist`.`id`=`realtag_$key`.`object_id`\";\n        }\n\n        if ($join['song']) {\n            $table['0_song'] = \"LEFT JOIN `song` ON `song`.`artist`=`artist`.`id`\";\n\n            if ($join['catalog']) {\n                $table['catalog'] = \"LEFT JOIN `catalog` AS `catalog_se` ON `catalog_se`.`id`=`song`.`catalog`\";\n                if (!empty($where_sql)) {\n                    $where_sql .= \" AND `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                } else {\n                    $where_sql .= \" `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                }\n            }\n        }\n        if ($join['count']) {\n            $table['object_count'] = \"LEFT JOIN (SELECT `object_count`.`object_id`, MAX(`object_count`.`date`) AS \" .\n                \"`date` FROM `object_count` WHERE `object_count`.`object_type` = 'artist' AND \" .\n                \"`object_count`.`user`='\" . $userid . \"' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS \" .\n                \"`object_count` ON `object_count`.`object_id`=`artist`.`id`\";\n        }\n        if ($join['image']) {\n            $table['0_song'] = \"LEFT JOIN `song` ON `song`.`artist`=`artist`.`id` LEFT JOIN `image` ON `image`.`object_id`=`artist`.`id`\";\n            $where_sql .= \" AND `image`.`object_type`='artist'\";\n            $where_sql .= \" AND `image`.`size`='original'\";\n        }\n        ksort($table);\n        $table_sql  = implode(' ', $table);\n        $group_sql  = implode(',', $group);\n        $having_sql = implode(\" $sql_logic_operator \", $having);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`artist`.`id`), `artist`.`name` FROM `artist`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => $table_sql,\n            'group_sql' => $group_sql,\n            'having_sql' => $having_sql\n        );\n    }\n\n    /**\n     * song_to_sql\n     * Handles the generation of the SQL for song searches.\n     * @return array\n     */\n    private function song_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $userid             = $this->search_user->id;\n\n        $where       = array();\n        $table       = array();\n        $join        = array();\n        $group       = array();\n        $having      = array();\n        $join['tag'] = array();\n        $metadata    = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'anywhere':\n                    $key = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE') {\n                        $tag_string        = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($sql_match_operator == 'NOT LIKE') {\n                        $tag_string        = \"`realtag_$key`.`name` IS NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($operator['description'] == 'is') {\n                        $tag_string        = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } elseif ($operator['description'] == 'is not') {\n                        $tag_string        = \"`realtag_$key`.`name` IS NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } else {\n                        $tag_string        = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0 \";\n                        $join['tag'][$key] = \"AND find_in_set('$input', cast(`name` as char)) $sql_match_operator 0 \";\n                    }\n                    // we want AND NOT and like for this query to really exclude them\n                    if ($sql_match_operator == 'NOT LIKE' || $sql_match_operator == 'NOT' || $sql_match_operator == '!=') {\n                        $where[] = \"NOT ((`artist`.`name` LIKE '$input' OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) LIKE '$input') OR \" .\n                                   \"(`album`.`name` LIKE '$input' OR LTRIM(CONCAT(COALESCE(`album`.`prefix`, ''), ' ', `album`.`name`)) LIKE '$input') OR \" .\n                                   \"`song_data`.`comment` LIKE '$input' OR `song_data`.`label` LIKE '$input' OR `song`.`file` LIKE '$input' OR \" .\n                                   \"`song`.`title` LIKE '$input' OR NOT \" . $tag_string . ')';\n                    } else {\n                        $where[] = \"((`artist`.`name` $sql_match_operator '$input' OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) $sql_match_operator '$input') OR \" .\n                                   \"(`album`.`name` $sql_match_operator '$input' OR LTRIM(CONCAT(COALESCE(`album`.`prefix`, ''), ' ', `album`.`name`)) $sql_match_operator '$input') OR \" .\n                                   \"`song_data`.`comment` $sql_match_operator '$input' OR `song_data`.`label` $sql_match_operator '$input' OR `song`.`file` $sql_match_operator '$input' OR \" .\n                                   \"`song`.`title` $sql_match_operator '$input' OR \" . $tag_string . ')';\n                    }\n                    // join it all up\n                    $table['album']    = \"LEFT JOIN `album` ON `song`.`album`=`album`.`id`\";\n                    $table['artist']   = \"LEFT JOIN `artist` ON `song`.`artist`=`artist`.`id`\";\n                    $join['song_data'] = true;\n                    break;\n                case 'tag':\n                    $key = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE') {\n                        $where[]           = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($sql_match_operator == 'NOT LIKE') {\n                        $where[]           = \"`realtag_$key`.`name` IS NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($operator['description'] == 'is') {\n                        $where[]           = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } elseif ($operator['description'] == 'is not') {\n                        $where[]           = \"`realtag_$key`.`name` IS NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } else {\n                        $where[]           = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0 \";\n                        $join['tag'][$key] = \"AND find_in_set('$input', cast(`name` as char)) $sql_match_operator 0 \";\n                    }\n                    break;\n                case 'album_tag':\n                    $table['album'] = \"LEFT JOIN `album` ON `song`.`album`=`album`.`id`\";\n                    $key            = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE') {\n                        $where[]                 = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['album_tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($sql_match_operator == 'NOT LIKE') {\n                        $where[]                 = \"`realtag_$key`.`name` IS NULL \";\n                        $join['album_tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($operator['description'] == 'is') {\n                        $where[]                 = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['album_tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } elseif ($operator['description'] == 'is not') {\n                        $where[]                 = \"`realtag_$key`.`name` IS NULL \";\n                        $join['album_tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } else {\n                        $where[]                 = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0 \";\n                        $join['album_tag'][$key] = \"AND find_in_set('$input', cast(`name` as char)) $sql_match_operator 0 \";\n                    }\n                    break;\n                case 'artist_tag':\n                    $table['artist'] = \"LEFT JOIN `artist` ON `song`.`artist`=`artist`.`id`\";\n                    $key             = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE') {\n                        $where[]                  = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['artist_tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($sql_match_operator == 'NOT LIKE') {\n                        $where[]                  = \"`realtag_$key`.`name` IS NULL \";\n                        $join['artist_tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($operator['description'] == 'is') {\n                        $where[]                  = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['artist_tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } elseif ($operator['description'] == 'is not') {\n                        $where[]                  = \"`realtag_$key`.`name` IS NULL \";\n                        $join['artist_tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } else {\n                        $where[]                  = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0 \";\n                        $join['artist_tag'][$key] = \"AND find_in_set('$input', cast(`name` as char)) $sql_match_operator 0 \";\n                    }\n                    break;\n                case 'title':\n                    $where[] = \"`song`.`title` $sql_match_operator '$input'\";\n                    break;\n                case 'album':\n                    $where[]        = \"(`album`.`name` $sql_match_operator '$input' \" .\n                                      \" OR LTRIM(CONCAT(COALESCE(`album`.`prefix`, ''), \" .\n                                      \"' ', `album`.`name`)) $sql_match_operator '$input')\";\n                    $table['album'] = \"LEFT JOIN `album` ON `song`.`album`=`album`.`id`\";\n                    break;\n                case 'artist':\n                    $where[]         = \"(`artist`.`name` $sql_match_operator '$input' \" .\n                                       \" OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), \" .\n                                       \"' ', `artist`.`name`)) $sql_match_operator '$input')\";\n                    $table['artist'] = \"LEFT JOIN `artist` ON `song`.`artist`=`artist`.`id`\";\n                    break;\n                case 'album_artist':\n                    $where[]         = \"(`album_artist`.`name` $sql_match_operator '$input' \" .\n                        \" OR LTRIM(CONCAT(COALESCE(`album_artist`.`prefix`, ''), \" .\n                        \"' ', `album_artist`.`name`)) $sql_match_operator '$input')\";\n                    $table['album']        = \"LEFT JOIN `album` ON `song`.`album`=`album`.`id`\";\n                    $table['album_artist'] = \"LEFT JOIN `artist` AS `album_artist` ON `album`.`album_artist`=`album_artist`.`id`\";\n                    break;\n                case 'composer':\n                    $where[] = \"`song`.`composer` $sql_match_operator '$input'\";\n                    break;\n                case 'time':\n                    $input   = $input * 60;\n                    $where[] = \"`song`.`time` $sql_match_operator '$input'\";\n                    break;\n                case 'file':\n                    $where[] = \"`song`.`file` $sql_match_operator '$input'\";\n                    break;\n                case 'year':\n                    $where[] = \"`song`.`year` $sql_match_operator '$input'\";\n                    break;\n                case 'comment':\n                    $where[]           = \"`song_data`.`comment` $sql_match_operator '$input'\";\n                    $join['song_data'] = true;\n                    break;\n                case 'label':\n                    $where[]           = \"`song_data`.`label` $sql_match_operator '$input'\";\n                    $join['song_data'] = true;\n                    break;\n                case 'lyrics':\n                    $where[]           = \"`song_data`.`lyrics` $sql_match_operator '$input'\";\n                    $join['song_data'] = true;\n                    break;\n                case 'played':\n                    $where[] = \"`song`.`played` = '$sql_match_operator'\";\n                    break;\n                case 'last_play':\n                    $my_type = 'song';\n                    $table['last_play'] .= (!strpos((string) $table['last_play'], \"last_play_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_play_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_play_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_play_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`last_play_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    break;\n                case 'last_skip':\n                    $my_type = 'song';\n                    $table['last_skip'] .= (!strpos((string) $table['last_skip'], \"last_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'skip' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`last_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    break;\n                case 'last_play_or_skip':\n                    $my_type = 'song';\n                    $table['last_play_or_skip'] .= (!strpos((string) $table['play_or_skip'], \"play_or_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` IN ('stream', 'skip') \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `play_or_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    break;\n                case 'played_times':\n                    $where[] = \"`song`.`id` IN (SELECT `object_count`.`object_id` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' \" .\n                        \"GROUP BY `object_count`.`object_id` HAVING COUNT(*) $sql_match_operator '$input')\";\n                    break;\n                case 'skipped_times':\n                    $where[] = \"`song`.`id` IN (SELECT `object_count`.`object_id` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'skip' \" .\n                        \"GROUP BY `object_count`.`object_id` HAVING COUNT(*) $sql_match_operator '$input')\";\n                    break;\n                case 'played_or_skipped_times':\n                    $where[] = \"`song`.`id` IN (SELECT `object_count`.`object_id` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` IN ('stream', 'skip') \" .\n                        \"GROUP BY `object_count`.`object_id` HAVING COUNT(*) $sql_match_operator '$input')\";\n                    break;\n                case 'play_skip_ratio':\n                    $where[] = \"`song`.`id` IN (SELECT `song`.`id` FROM `song` \" .\n                        \"LEFT JOIN (SELECT COUNT(`object_id`) AS `counting`, `object_id`, `count_type` \" .\n                        \"FROM `object_count` WHERE `object_type` = 'song' AND `count_type` = 'stream' \" .\n                        \"GROUP BY `object_id`, `count_type`) AS `stream_count` on `song`.`id` = `stream_count`.`object_id`\" .\n                        \"LEFT JOIN (SELECT COUNT(`object_id`) AS `counting`, `object_id`, `count_type` \" .\n                        \"FROM `object_count` WHERE `object_type` = 'song' AND `count_type` = 'skip' \" .\n                        \"GROUP BY `object_id`, `count_type`) AS `skip_count` on `song`.`id` = `skip_count`.`object_id` \" .\n                        \"WHERE ((IFNULL(`stream_count`.`counting`, 0)/IFNULL(`skip_count`.`counting`, 0)) * 100) \" .\n                        \"$sql_match_operator '$input' GROUP BY `song`.`id`)\";\n                    break;\n                case 'myplayed':\n                case 'myplayedalbum':\n                case 'myplayedartist':\n                // combine these as they all do the same thing just different tables\n                $looking      = str_replace('myplayed', '', $rule[0]);\n                $column       = ($looking == '') ? 'id' : $looking;\n                $my_type      = ($looking == '') ? 'song' : $looking;\n                $operator_sql = ((int) $sql_match_operator == 0) ? 'IS NULL' : 'IS NOT NULL';\n                // played once per user\n                $table['myplayed'] .= (!strpos((string) $table['myplayed'], \"myplayed_\" . $my_type . \"_\" . $userid)) ?\n                    \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` FROM `object_count` \" .\n                    \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                    \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS \" .\n                    \"`myplayed_\" . $my_type . \"_\" . $userid . \"` \" .\n                    \"ON `song`.`$column`=`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                    \"AND `myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                $where[] = \"`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` $operator_sql\";\n                    break;\n                case 'bitrate':\n                    $input   = $input * 1000;\n                    $where[] = \"`song`.`bitrate` $sql_match_operator '$input'\";\n                    break;\n                case 'rating':\n                    // average ratings only\n                    $where[]          = \"`average_rating`.`avg` $sql_match_operator '$input'\";\n                    $table['average'] = \"LEFT JOIN (SELECT `object_id`, ROUND(AVG(IFNULL(`rating`.`rating`,0))) AS \" .\n                        \"`avg` FROM `rating` WHERE `rating`.`object_type`='song' GROUP BY `object_id`) AS \" .\n                        \"`average_rating` on `average_rating`.`object_id` = `song`.`id` \";\n                    break;\n                case 'favorite':\n                    $where[] = \"`song`.`title` $sql_match_operator '$input' \" .\n                               \"AND `favorite_song_$userid`.`user` = $userid \" .\n                               \"AND `favorite_song_$userid`.`object_type` = 'song'\";\n                    // flag once per user\n                    $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_song_$userid\")) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                        \"FROM `user_flag` WHERE `user` = $userid) AS `favorite_song_$userid` \" .\n                        \"ON `song`.`id`=`favorite_song_$userid`.`object_id` \" .\n                        \"AND `favorite_song_$userid`.`object_type` = 'song' \" : ' ';\n                    break;\n                case 'myrating':\n                case 'albumrating':\n                case 'artistrating':\n                    // combine these as they all do the same thing just different tables\n                    $looking = str_replace('rating', '', $rule[0]);\n                    $column  = ($looking == 'my') ? 'id' : $looking;\n                    $my_type = ($looking == 'my') ? 'song' : $looking;\n                    if ($input == 0 && $sql_match_operator == '>=') {\n                        break;\n                    }\n                    if ($input == 0 && $sql_match_operator == '<') {\n                        $input              = -1;\n                        $sql_match_operator = '=';\n                    }\n                    if ($input == 0 && $sql_match_operator == '<>') {\n                        $input              = 1;\n                        $sql_match_operator = '>=';\n                    }\n                    if (($input == 0 && $sql_match_operator != '>') || ($input == 1 && $sql_match_operator == '<')) {\n                        $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL\";\n                    } elseif ($sql_match_operator == '<>' || $sql_match_operator == '<' || $sql_match_operator == '<=' || $sql_match_operator == '!=') {\n                        $where[] = \"(`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input OR `rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL)\";\n                    } else {\n                        $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input\";\n                    }\n                    // rating once per user\n                    $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `rating` FROM `rating` \" .\n                        \"WHERE `user` = $userid AND `object_type`='$my_type') \" .\n                        \"AS `rating_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `rating_\" . $my_type . \"_\" . $userid . \"`.`object_id`=`song`.`$column` \" : ' ';\n                    break;\n                case 'catalog':\n                    $where[] = \"`song`.`catalog` $sql_match_operator '$input'\";\n                    break;\n                case 'other_user':\n                case 'other_user_album':\n                case 'other_user_artist':\n                    // combine these as they all do the same thing just different tables\n                    $looking      = str_replace('other_user_', '', $rule[0]);\n                    $column       = ($looking == 'other_user') ? 'id' : $looking;\n                    $my_type      = ($looking == 'other_user') ? 'song' : $looking;\n                    $other_userid = $input;\n                    if ($sql_match_operator == 'userflag') {\n                        $where[] = \"`favorite_\" . $my_type . \"_\" . $other_userid . \"`.`user` = $other_userid \" .\n                                   \" AND `favorite_\" . $my_type . \"_\" . $other_userid . \"`.`object_type` = '$my_type'\";\n                        // flag once per user\n                        $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_\" . $my_type . \"_\" . $other_userid . \"\")) ?\n                            \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                            \"from `user_flag` WHERE `user` = $other_userid) AS `favorite_\" . $my_type . \"_\" . $other_userid . \"` \" .\n                            \"ON `song`.`$column`=`favorite_\" . $my_type . \"_\" . $other_userid . \"`.`object_id` \" .\n                            \"AND `favorite_\" . $my_type . \"_\" . $other_userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    } else {\n                        $unrated = ($sql_match_operator == 'unrated');\n                        $where[] = ($unrated) ? \"`song`.`$column` NOT IN (SELECT `object_id` FROM `rating` WHERE `object_type` = '$my_type' AND `user` = $other_userid)\" :\n                            \"`rating_\" . $my_type . \"_\" . $other_userid . \"`.$sql_match_operator\" .\n                            \" AND `rating_\" . $my_type . \"_\" . $other_userid . \"`.`user` = $other_userid \" .\n                            \" AND `rating_\" . $my_type . \"_\" . $other_userid . \"`.`object_type` = '$my_type'\";\n                        // rating once per user\n                        $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $other_userid)) ?\n                            \"LEFT JOIN `rating` AS `rating_\" . $my_type . \"_\" . $other_userid . \"` ON \" .\n                            \"`rating_\" . $my_type . \"_\" . $other_userid . \"`.`object_type`='$my_type' AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $other_userid . \"`.`object_id`=`song`.`$column` AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $other_userid . \"`.`user` = $other_userid \" : ' ';\n                    }\n                    break;\n                case 'playlist_name':\n                    $join['playlist']      = true;\n                    $join['playlist_data'] = true;\n                    $where[]               = \"`playlist`.`name` $sql_match_operator '$input'\";\n                    break;\n                case 'playlist':\n                    $join['playlist_data'] = true;\n                    $where[]               = \"`playlist_data`.`playlist` $sql_match_operator '$input'\";\n                    break;\n                case 'smartplaylist':\n                    $subsearch    = new Search($input, 'song', $this->search_user);\n                    $subsql       = $subsearch->to_sql();\n                    $results      = $subsearch->get_items();\n                    $itemstring   = '';\n                    if (count($results) > 0) {\n                        foreach ($results as $item) {\n                            $itemstring .= ' ' . $item['object_id'] . ',';\n                        }\n                        $table['smart'] .= (!strpos((string) $table['smart'], \"smart_\" . $input)) ?\n                            \"LEFT JOIN (SELECT `id` FROM `song` \" .\n                            \"WHERE `id` $sql_match_operator IN (\" . substr($itemstring, 0, -1) . \")) \" .\n                            \"AS `smartlist_$input` ON `smartlist_$input`.`id` = `song`.`id`\" : ' ';\n                        $where[]  = \"`smartlist_$input`.`id` IS NOT NULL\";\n                        // HACK: array_merge would potentially lose tags, since it\n                        // overwrites. Save our merged tag joins in a temp variable,\n                        // even though that's ugly.\n                        $tagjoin     = array_merge($subsql['join']['tag'], $join['tag']);\n                        $join        = array_merge($subsql['join'], $join);\n                        $join['tag'] = $tagjoin;\n                    }\n                    break;\n                case 'license':\n                    $where[] = \"`song`.`license` $sql_match_operator '$input'\";\n                    break;\n                case 'added':\n                    $input   = strtotime($input);\n                    $where[] = \"`song`.`addition_time` $sql_match_operator $input\";\n                    break;\n                case 'updated':\n                    $input         = strtotime($input);\n                    $where[]       = \"`song`.`update_time` $sql_match_operator $input\";\n                    break;\n                case 'recent_added':\n                    $key                       = md5($input . $sql_match_operator);\n                    $where[]                   = \"`addition_time_$key`.`id` IS NOT NULL\";\n                    $table['addition_' . $key] = \"LEFT JOIN (SELECT `id` from `song` ORDER BY $sql_match_operator DESC LIMIT $input) as `addition_time_$key` ON `song`.`id` = `addition_time_$key`.`id`\";\n                    break;\n                case 'recent_updated':\n                    $key                     = md5($input . $sql_match_operator);\n                    $where[]                 = \"`update_time_$key`.`id` IS NOT NULL\";\n                    $table['update_' . $key] = \"LEFT JOIN (SELECT `id` from `song` ORDER BY $sql_match_operator DESC LIMIT $input) as `update_time_$key` ON `song`.`id` = `update_time_$key`.`id`\";\n                    break;\n                case 'mbid':\n                    $where[] = \"`song`.`mbid` $sql_match_operator '$input'\";\n                    break;\n                case 'mbid_album':\n                    $table['album'] = \"LEFT JOIN `album` ON `song`.`album`=`album`.`id`\";\n                    $where[]        = \"`album`.`mbid` $sql_match_operator '$input'\";\n                    break;\n                case 'mbid_artist':\n                    $table['artist'] = \"LEFT JOIN `artist` ON `song`.`artist`=`artist`.`id`\";\n                    $where[]         = \"`artist`.`mbid` $sql_match_operator '$input'\";\n                    break;\n                case 'metadata':\n                    $field = (int) $rule[3];\n                    if ($sql_match_operator === '=' && strlen($input) == 0) {\n                        $where[] = \"NOT EXISTS (SELECT NULL FROM `metadata` WHERE `metadata`.`object_id` = `song`.`id` AND `metadata`.`field` = {$field})\";\n                    } else {\n                        $parsedInput = is_numeric($input) ? $input : '\"' . $input . '\"';\n                        if (!array_key_exists($field, $metadata)) {\n                            $metadata[$field] = array();\n                        }\n                        $metadata[$field][] = \"`metadata`.`data` $sql_match_operator $parsedInput\";\n                    }\n                    break;\n                default:\n                    break;\n            } // switch on ruletype song\n        } // foreach over rules\n\n        // translate metadata queries into sql for each field\n        foreach ($metadata as $metadata_field => $metadata_queries) {\n            $metadata_sql  = \"EXISTS (SELECT NULL FROM `metadata` WHERE `metadata`.`object_id` = `song`.`id` AND `metadata`.`field` = {$metadata_field} AND (\";\n            $metadata_sql .= implode(\" $sql_logic_operator \", $metadata_queries);\n            $where[]   = $metadata_sql . '))';\n        }\n\n        $join['catalog'] = AmpConfig::get('catalog_disable');\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        // now that we know which things we want to JOIN...\n        if ($join['song_data']) {\n            $table['song_data'] = \"LEFT JOIN `song_data` ON `song`.`id`=`song_data`.`song_id`\";\n        }\n        if ($join['tag']) {\n            foreach ($join['tag'] as $key => $value) {\n                $table['tag_' . $key] =\n                    \"LEFT JOIN (\" .\n                    \"SELECT `object_id`, GROUP_CONCAT(`name`) AS `name` \" .\n                    \"FROM `tag` LEFT JOIN `tag_map` \" .\n                    \"ON `tag`.`id`=`tag_map`.`tag_id` \" .\n                    \"WHERE `tag_map`.`object_type`='song' \" .\n                    \"$value\" .\n                    \"GROUP BY `object_id`\" .\n                    \") AS `realtag_$key` \" .\n                    \"ON `song`.`id`=`realtag_$key`.`object_id`\";\n            }\n        }\n        if ($join['album_tag']) {\n            foreach ($join['album_tag'] as $key => $value) {\n                $table['tag_' . $key] =\n                    \"LEFT JOIN (\" .\n                    \"SELECT `object_id`, GROUP_CONCAT(`name`) AS `name` \" .\n                    \"FROM `tag` LEFT JOIN `tag_map` \" .\n                    \"ON `tag`.`id`=`tag_map`.`tag_id` \" .\n                    \"WHERE `tag_map`.`object_type`='album' \" .\n                    \"$value\" .\n                    \"GROUP BY `object_id`\" .\n                    \") AS `realtag_$key` \" .\n                    \"ON `album`.`id`=`realtag_$key`.`object_id`\";\n            }\n        }\n        if ($join['artist_tag']) {\n            foreach ($join['artist_tag'] as $key => $value) {\n                $table['tag_' . $key] =\n                    \"LEFT JOIN (\" .\n                    \"SELECT `object_id`, GROUP_CONCAT(`name`) AS `name` \" .\n                    \"FROM `tag` LEFT JOIN `tag_map` \" .\n                    \"ON `tag`.`id`=`tag_map`.`tag_id` \" .\n                    \"WHERE `tag_map`.`object_type`='artist' \" .\n                    \"$value\" .\n                    \"GROUP BY `object_id`\" .\n                    \") AS `realtag_$key` \" .\n                    \"ON `artist`.`id`=`realtag_$key`.`object_id`\";\n            }\n        }\n        if ($join['playlist_data']) {\n            $table['playlist_data'] = \"LEFT JOIN `playlist_data` ON `song`.`id`=`playlist_data`.`object_id` AND `playlist_data`.`object_type`='song'\";\n            if ($join['playlist']) {\n                $table['playlist'] = \"LEFT JOIN `playlist` ON `playlist_data`.`playlist`=`playlist`.`id`\";\n            }\n        }\n        if ($join['catalog']) {\n            $table['catalog'] = \"LEFT JOIN `catalog` AS `catalog_se` ON `catalog_se`.`id`=`song`.`catalog`\";\n            if (!empty($where_sql)) {\n                $where_sql .= \" AND `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n            } else {\n                $where_sql .= \" `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n            }\n        }\n        ksort($table);\n        $table_sql  = implode(' ', $table);\n        $group_sql  = implode(',', $group);\n        $having_sql = implode(\" $sql_logic_operator \", $having);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`song`.`id`), `song`.`file` FROM `song`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => $table_sql,\n            'group_sql' => $group_sql,\n            'having_sql' => $having_sql\n        );\n    }\n\n    /**\n     * video_to_sql\n     *\n     * Handles the generation of the SQL for video searches.\n     * @return array\n     */\n    private function video_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n\n        $where  = array();\n        $table  = array();\n        $join   = array();\n        $group  = array();\n        $having = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'file':\n                    $where[] = \"`video`.`file` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype\n        } // foreach rule\n\n        $join['catalog'] = AmpConfig::get('catalog_disable');\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        if ($join['catalog']) {\n            $table['catalog'] = \"LEFT JOIN `catalog` AS `catalog_se` ON `catalog_se`.`id`=`video`.`catalog`\";\n            if (!empty($where_sql)) {\n                $where_sql .= \" AND `catalog_se`.`enabled` = '1'\";\n            } else {\n                $where_sql .= \" `catalog_se`.`enabled` = '1'\";\n            }\n        }\n        ksort($table);\n        $table_sql  = implode(' ', $table);\n        $group_sql  = implode(',', $group);\n        $having_sql = implode(\" $sql_logic_operator \", $having);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`video`.`id`), `video`.`file` FROM `video`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => $table_sql,\n            'group_sql' => $group_sql,\n            'having_sql' => $having_sql\n        );\n    }\n\n    /**\n     * playlist_to_sql\n     *\n     * Handles the generation of the SQL for playlist searches.\n     * @return array\n     */\n    private function playlist_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $where              = array();\n        $table              = array();\n        $join               = array();\n        $group              = array();\n        $having             = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            $where[] = \"(`playlist`.`type` = 'public' OR `playlist`.`user`=\" . $this->search_user->id . \")\";\n\n            switch ($rule[0]) {\n                case 'title':\n                case 'name':\n                    $where[] = \"`playlist`.`name` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype\n        } // foreach rule\n\n        $join['playlist_data'] = true;\n        $join['song']          = $join['song'] || AmpConfig::get('catalog_disable');\n        $join['catalog']       = AmpConfig::get('catalog_disable');\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        if ($join['playlist_data']) {\n            $table['playlist_data'] = \"LEFT JOIN `playlist_data` ON `playlist_data`.`playlist` = `playlist`.`id`\";\n        }\n\n        if ($join['song']) {\n            $table['0_song'] = \"LEFT JOIN `song` ON `song`.`id`=`playlist_data`.`object_id`\";\n            $where_sql .= \" AND `playlist_data`.`object_type` = 'song'\";\n\n            if ($join['catalog']) {\n                $table['catalog'] = \"LEFT JOIN `catalog` AS `catalog_se` ON `catalog_se`.`id`=`song`.`catalog`\";\n                if (!empty($where_sql)) {\n                    $where_sql .= \" AND `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                } else {\n                    $where_sql .= \" `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                }\n            }\n        }\n        ksort($table);\n        $table_sql  = implode(' ', $table);\n        $group_sql  = implode(',', $group);\n        $having_sql = implode(\" $sql_logic_operator \", $having);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`playlist`.`id`), `playlist`.`name` FROM `playlist`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => $table_sql,\n            'group_sql' => $group_sql,\n            'having_sql' => $having_sql\n        );\n    }\n\n    /**\n     * label_to_sql\n     *\n     * Handles the generation of the SQL for label searches.\n     * @return array\n     */\n    private function label_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $where              = array();\n        $table              = array();\n        $join               = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'title':\n                case 'name':\n                    $where[] = \"`label`.`name` $sql_match_operator '$input'\";\n                    break;\n                case 'category':\n                    $where[] = \"`label`.`category` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype\n        } // foreach rule\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`label`.`id`), `label`.`name` FROM `label`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => '',\n            'group_sql' => '',\n            'having_sql' => ''\n        );\n    }\n\n    /**\n       * tag_to_sql\n       *\n       * Handles the generation of the SQL for tag (genre) searches.\n       * @return array\n       */\n\n    private function tag_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $where              = array();\n        $table              = array();\n        $join               = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'title':\n                case 'name':\n                    $where[] = \"`tag`.`name` $sql_match_operator '$input'\";\n                    break;\n                case 'category':\n                    $where[] = \"`tag`.`category` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype\n        } // foreach rule\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`tag`.`id`) FROM `tag`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => '',\n            'group_sql' => '',\n            'having_sql' => ''\n        );\n    }\n\n    /**\n     * user_to_sql\n     *\n     * Handles the generation of the SQL for user searches.\n     * @return array\n     */\n    private function user_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $where              = array();\n        $table              = array();\n        $join               = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'username':\n                    $where[] = \"`user`.`username` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype\n        } // foreach rule\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n        ksort($table);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`user`.`id`), `user`.`username` FROM `user`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => '',\n            'group_sql' => '',\n            'having_sql' => ''\n        );\n    }\n\n    /**\n     * year_search\n     *\n     * Build search rules for year -> year searching.\n     * @param $fromYear\n     * @param $toYear\n     * @param $size\n     * @param $offset\n     * @return array\n     */\n    public static function year_search($fromYear, $toYear, $size, $offset)\n    {\n        $search           = array();\n        $search['limit']  = $size;\n        $search['offset'] = $offset;\n        $search['type']   = \"album\";\n        $count            = 0;\n        if ($fromYear) {\n            $search['rule_' . $count . '_input']    = $fromYear;\n            $search['rule_' . $count . '_operator'] = 0;\n            $search['rule_' . $count . '']          = \"original_year\";\n            ++$count;\n        }\n        if ($toYear) {\n            $search['rule_' . $count . '_input']    = $toYear;\n            $search['rule_' . $count . '_operator'] = 1;\n            $search['rule_' . $count . '']          = \"original_year\";\n            ++$count;\n        }\n\n        return $search;\n    }\n} // end search.class\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\n$a_root = realpath(__DIR__);\nrequire_once $a_root . '/lib/init.php';\n\nUI::show_header();\n\n// Switch on the actions\nswitch ($_REQUEST['action']) {\n    case 'get_advanced':\n        $object_ids = Random::advanced($_REQUEST['type'], $_POST);\n\n        // We need to add them to the active playlist\n        if (!empty($object_ids)) {\n            foreach ($object_ids as $object_id) {\n                Core::get_global('user')->playlist->add_object($object_id, 'song');\n            }\n        }\n    case 'advanced':\n    default:\n        require_once AmpConfig::get('prefix') . UI::find_template('show_random.inc.php');\n        break;\n} // end switch\n\n// Show the Footer\nUI::show_query_stats();\nUI::show_footer();\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */ ?>\n<?php UI::show_box_top(T_('Play Random Selection'), 'box box_random'); ?>\n<form id=\"random\" method=\"post\" enctype=\"multipart/form-data\" action=\"<?php echo AmpConfig::get('web_path'); ?>/random.php?action=get_advanced&type=<?php echo Core::get_request('type') ? scrub_out(Core::get_request('type')) : 'song'; ?>\">\n<table class=\"tabledata\">\n<tr id=\"search_location\">\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_SPECIAL_CHARS) !== 'song') {\n    ?><a href=\"<?php echo AmpConfig::get('web_path'); ?>/random.php?action=advanced&type=song\"><?php echo T_('Songs'); ?></a><?php\n} else {\n        echo T_('Songs');\n    } ?></td>\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_SPECIAL_CHARS) !== 'album') {\n        ?><a href=\"<?php echo AmpConfig::get('web_path'); ?>/random.php?action=advanced&type=album\"><?php echo T_('Albums'); ?></a><?php\n    } else {\n        echo T_('Albums');\n    } ?></td>\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_SPECIAL_CHARS) !== 'artist') {\n        ?><a href=\"<?php echo AmpConfig::get('web_path'); ?>/random.php?action=advanced&type=artist\"><?php echo T_('Artists'); ?></a><?php\n    } else {\n        echo T_('Artists');\n    } ?></td>\n    <?php if (AmpConfig::get('allow_video') && Video::get_item_count('Video')) { ?>\n        <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'video') { ?>\n                <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=video\"><?php echo T_('Videos'); ?></a>\n            <?php } else {\n        echo T_('Videos');\n    } ?></td>\n    <?php } ?>\n</tr>\n</table>\n<table class=\"tabledata\">\n<tr id=\"search_item_count\">\n        <td><?php echo T_('Item Count'); ?></td>\n        <td>\n        <select name=\"random\">\n<?php\n        foreach (array(1, 5, 10, 20, 30, 50, 100, 500, 1000) as $i) {\n            echo \"\\t\\t\\t\" . '<option value=\"' . $i . '\" ' .\n                (($_POST['random'] == $i) ? 'selected=\"selected\"' : '') . '>' .\n                $i . \"</option>\\n\";\n        }\n            echo \"\\t\\t\\t\" . '<option value=\"-1\" ' .\n                (($_POST['random'] == '-1') ? 'selected=\"selected\"' : '') . '>' .\n                T_('All') . \"</option>\\n\"; ?>\n        </select>\n        </td>\n</tr>\n<tr id=\"search_length\">\n        <td><?php echo T_('Length'); ?></td>\n        <td>\n                <?php $name = 'length_' . (int) (Core::get_post('length')); ${$name} = ' selected=\"selected\"'; ?>\n                <select name=\"length\">\n<?php\n            echo \"\\t\\t\\t\" . '<option value=\"0\" ' .\n                (($_POST['length'] == 0) ? 'selected=\"selected\"' : '') . '>' .\n                T_('Unlimited') . \"</option>\\n\";\n        foreach (array(15, 30, 60, 120, 240, 480, 960) as $i) {\n            echo \"\\t\\t\\t\" . '<option value=\"' . $i . '\" ' .\n                (($_POST['length'] == $i) ? 'selected=\"selected\"' : '') . '>';\n            if ($i < 60) {\n                printf(nT_('%d minute', '%d minutes', $i), $i);\n            } else {\n                printf(nT_('%d hour', '%d hours', $i / 60), $i / 60);\n            }\n            echo \"</option>\\n\";\n        } ?>\n                </select>\n        </td>\n</tr>\n<tr id=\"search_size_limit\">\n        <td><?php echo T_('Size Limit'); ?></td>\n        <td>\n                <select name=\"size_limit\">\n<?php\n            echo \"\\t\\t\\t\" . '<option value=\"0\" ' .\n                (($_POST['size_limit'] == 0) ? 'selected=\"selected\"' : '') . '>' .\n                T_('Unlimited') . \"</option>\\n\";\n        foreach (array(64, 128, 256, 512, 1024) as $i) {\n            echo \"\\t\\t\\t\" . '<option value=\"' . $i . '\"' .\n                (($_POST['size_limit'] == $i) ? 'selected=\"selected\"' : '') . '>' .\n                UI::format_bytes($i * 1048576) . \"</option>\\n\";\n        } ?>\n                </select>\n        </td>\n</tr>\n</table>\n\n<?php require AmpConfig::get('prefix') . UI::find_template('show_rules.inc.php'); ?>\n\n<div class=\"formValidation\">\n        <input type=\"submit\" value=\"<?php echo T_('Enqueue'); ?>\" />\n</div>\n</form>\n<?php UI::show_box_bottom(); ?>\n<div id=\"browse\">\n<?php\n    if (is_array($object_ids)) {\n        $browse = new Browse();\n        $browse->set_type('song');\n        $browse->save_objects($object_ids);\n        $browse->show_objects();\n        $browse->store();\n        echo Ajax::observe('window', 'load', Ajax::action('?action=refresh_rightbar', 'playlist_refresh_load'));\n    } ?>\n</div>\n\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nif ($playlist) {\n    $logic_operator = $playlist->logic_operator;\n} else {\n    $logic_operator = Core::get_request('operator');\n}\n$logic_operator = strtolower($logic_operator); ?>\n<script src=\"<?php echo AmpConfig::get('web_path'); ?>/lib/javascript/search.js\"></script>\n<script src=\"<?php echo AmpConfig::get('web_path'); ?>/lib/javascript/search-data.php?type=<?php echo (string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) ? scrub_out((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES)) : 'song'; ?>\"></script>\n\n<?php UI::show_box_top(T_('Rules') . \"...\", 'box box_rules'); ?>\n<table class=\"tabledata\">\n<tbody id=\"searchtable\">\n    <tr id=\"rules_operator\">\n    <td><?php echo T_('Match'); ?></td>\n        <td>\n                <select name=\"operator\">\n                        <option value=\"and\" <?php if ($logic_operator == 'and') {\n    echo 'selected=\"selected\"';\n}?>><?php echo T_('all rules'); ?></option>\n                        <option value=\"or\"  <?php if ($logic_operator == 'or') {\n    echo 'selected=\"selected\"';\n}?>><?php echo T_('any rule'); ?></option>\n                </select>\n        </td>\n        </tr>\n    <tr id=\"rules_addrowbutton\">\n    <td>\n        <a id=\"addrowbutton\" href=\"javascript:void(0)\">\n            <?php echo UI::get_icon('add'); ?>\n        <?php echo T_('Add Another Rule'); ?>\n        </a>\n        <script>$('#addrowbutton').on('click', SearchRow.add);</script>\n    </td>\n    </tr>\n</tbody>\n</table>\n<?php UI::show_box_bottom(); ?>\n\n<?php\nif ($playlist) {\n    $out = $playlist->to_js();\n} else {\n    $mysearch = new Search(null, (string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));\n    $mysearch->parse_rules(Search::clean_request($_REQUEST));\n    $out = $mysearch->to_js();\n}\nif ($out) {\n    echo $out;\n} else {\n    echo '<script>SearchRow.add();</script>';\n} ?>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nUI::show_box_top(T_('Search Ampache') . \"...\", 'box box_advanced_search'); ?>\n<form id=\"search\" name=\"search\" method=\"post\" action=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=<?php echo (string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) ? scrub_out((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES)) : 'song'; ?>\" enctype=\"multipart/form-data\" style=\"Display:inline\">\n<table class=\"tabledata\">\n    <tr id=\"search_location\">\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'song') { ?>\n        <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=song\"><?php echo T_('Songs'); ?></a><?php\n    } else {\n        echo T_('Songs');\n    } ?></td>\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'album') { ?>\n        <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=album\"><?php echo T_('Albums'); ?></a><?php\n    } else {\n        echo T_('Albums');\n    } ?></td>\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'artist') { ?>\n        <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=artist\"><?php echo T_('Artists'); ?></a><?php\n    } else {\n        echo T_('Artists');\n    } ?></td>\n    <?php if (AmpConfig::get('label')) { ?>\n        <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'label') { ?>\n            <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=label\"><?php echo T_('Labels'); ?></a> <?php\n        } else {\n            echo T_('Labels');\n        } ?></td>\n    <?php } ?>\n        <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'playlist') { ?>\n            <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=playlist\"><?php echo T_('Playlists'); ?></a> <?php\n        } else {\n            echo T_('Playlists');\n        } ?></td>\n    <?php if (AmpConfig::get('allow_video') && Video::get_item_count('Video')) { ?>\n        <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'video') { ?>\n            <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=video\"><?php echo T_('Videos'); ?></a> <?php\n        } else {\n            echo T_('Videos');\n        } ?></td>\n    <?php } ?>\n    </tr>\n</table>\n<table class=\"tabledata\">\n    <tr id=\"search_max_results\">\n    <td><?php echo T_('Maximum Results'); ?></td>\n        <td>\n                <select name=\"limit\">\n                        <option value=\"0\"><?php echo T_('Unlimited'); ?></option>\n                        <option value=\"25\" <?php if ((int) $_REQUEST['limit'] == 25) {\n            echo \"selected=\\\"selected\\\"\";\n        }?>>25</option>\n                        <option value=\"50\" <?php if ((int) $_REQUEST['limit'] == 50) {\n            echo \"selected=\\\"selected\\\"\";\n        }?>>50</option>\n                        <option value=\"100\" <?php if ((int) $_REQUEST['limit'] == 100) {\n            echo \"selected=\\\"selected\\\"\";\n        }?>>100</option>\n                        <option value=\"250\" <?php if ((int) $_REQUEST['limit'] == 250) {\n            echo \"selected=\\\"selected\\\"\";\n        }?>>250</option>\n                        <option value=\"500\" <?php if ((int) $_REQUEST['limit'] == 500) {\n            echo \"selected=\\\"selected\\\"\";\n        }?>>500</option>\n                </select>\n        </td>\n    </tr>\n    <tr id=\"random_results\">\n        <td><?php echo T_('Random'); ?></td>\n        <td><input type=\"checkbox\" name=\"random\" value=\"1\" <?php if ((int) $_REQUEST['random'] == 1) {\n            echo \"checked\";\n        } ?> /></td>\n    </tr>\n</table>\n\n<?php require AmpConfig::get('prefix') . UI::find_template('show_rules.inc.php'); ?>\n\n<div class=\"formValidation\">\n            <input class=\"button\" type=\"submit\" value=\"<?php echo T_('Search'); ?>\" />&nbsp;&nbsp;\n<?php if (((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) == 'song' || ! (string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES)) && Access::check('interface', 25)) { ?>\n        <input id=\"savesearchbutton\" class=\"button\" type=\"submit\" value=\"<?php echo T_('Save as Smart Playlist'); ?>\" onClick=\"$('#hiddenaction').val('save_as_smartplaylist');\" />&nbsp;&nbsp;\n<?php\n    } ?>\n            <input type=\"hidden\" id=\"hiddenaction\" name=\"action\" value=\"search\" />\n</div>\n</form>\n<script>\n    document.getElementById('searchString').value = '';\n</script>\n<?php UI::show_box_bottom(); ?>\n"], "fixing_code": ["<?php\ndeclare(strict_types=0);\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Lib\\Metadata\\Repository\\MetadataField;\n\n/**\n * Search Class\n * Search-related voodoo.  Beware tentacles.\n */\n\nclass Search extends playlist_object\n{\n    public $searchtype;\n    public $rules;\n    public $logic_operator = 'AND';\n    public $type           = 'public';\n    public $random         = 0;\n    public $limit          = 0;\n    public $last_count     = 0;\n    public $last_duration  = 0;\n    public $date           = 0;\n\n    public $basetypes;\n    public $types;\n\n    public $link;\n    public $f_link;\n\n    public $search_user;\n\n    private $stars;\n    private $order_by;\n\n    /**\n     * constructor\n     * @param integer $search_id\n     * @param string $searchtype\n     * @param User $user\n     */\n    public function __construct($search_id = 0, $searchtype = 'song', $user = null)\n    {\n        if ($user) {\n            $this->search_user = $user;\n        } else {\n            $this->search_user = Core::get_global('user');\n        }\n        $this->searchtype = $searchtype;\n        if ($search_id > 0) {\n            $info = $this->get_info($search_id);\n            foreach ($info as $key => $value) {\n                $this->$key = $value;\n            }\n            $this->rules = json_decode((string) $this->rules, true);\n        }\n        // workaround null dates/values\n        $this->last_count    = (int) $this->last_count;\n        $this->last_duration = (int) $this->last_duration;\n        $this->date          = time();\n\n        $this->stars = array(\n            T_('0 Stars'),\n            T_('1 Star'),\n            T_('2 Stars'),\n            T_('3 Stars'),\n            T_('4 Stars'),\n            T_('5 Stars')\n        );\n\n        $this->stars = array(\n            T_('0 Stars'),\n            T_('1 Star'),\n            T_('2 Stars'),\n            T_('3 Stars'),\n            T_('4 Stars'),\n            T_('5 Stars')\n        );\n\n        // Define our basetypes\n        $this->set_basetypes();\n\n        $this->types = array();\n        switch ($searchtype) {\n            case 'song':\n                $this->song_types();\n                $this->order_by = '`song`.`file`';\n                break;\n            case 'album':\n                $this->album_types();\n                $this->order_by = (AmpConfig::get('album_group')) ? '`album`.`name`' : '`album`.`name`, `album`.`disk`';\n                break;\n            case 'video':\n                $this->video_types();\n                $this->order_by = '`video`.`file`';\n                break;\n            case 'artist':\n                $this->artist_types();\n                $this->order_by = '`artist`.`name`';\n                break;\n            case 'playlist':\n                $this->playlist_types();\n                $this->order_by = '`playlist`.`name`';\n                break;\n            case 'label':\n                $this->label_types();\n                $this->order_by = '`label`.`name`';\n                break;\n            case 'user':\n                $this->user_types();\n                $this->order_by = '`user`.`username`';\n                break;\n        } // end switch on searchtype\n    } // end constructor\n\n    /**\n     * set_basetypes\n     *\n     * Function called during construction to set the different types and rules for search\n     */\n    private function set_basetypes()\n    {\n        $this->basetypes['numeric'][] = array(\n            'name' => 'gte',\n            'description' => T_('is greater than or equal to'),\n            'sql' => '>='\n        );\n\n        $this->basetypes['numeric'][] = array(\n            'name' => 'lte',\n            'description' => T_('is less than or equal to'),\n            'sql' => '<='\n        );\n\n        $this->basetypes['numeric'][] = array(\n            'name' => 'equal',\n            'description' => T_('equals'),\n            'sql' => '<=>'\n        );\n\n        $this->basetypes['numeric'][] = array(\n            'name' => 'ne',\n            'description' => T_('does not equal'),\n            'sql' => '<>'\n        );\n\n        $this->basetypes['numeric'][] = array(\n            'name' => 'gt',\n            'description' => T_('is greater than'),\n            'sql' => '>'\n        );\n\n        $this->basetypes['numeric'][] = array(\n            'name' => 'lt',\n            'description' => T_('is less than'),\n            'sql' => '<'\n        );\n\n        $this->basetypes['boolean'][] = array(\n            'name' => 'true',\n            'description' => T_('is true'),\n            'sql' => '1'\n        );\n\n        $this->basetypes['boolean'][] = array(\n            'name' => 'false',\n            'description' => T_('is false'),\n            'sql' => '0'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'contain',\n            'description' => T_('contains'),\n            'sql' => 'LIKE',\n            'preg_match' => array('/^/', '/$/'),\n            'preg_replace' => array('%', '%')\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'notcontain',\n            'description' => T_('does not contain'),\n            'sql' => 'NOT LIKE',\n            'preg_match' => array('/^/', '/$/'),\n            'preg_replace' => array('%', '%')\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'start',\n            'description' => T_('starts with'),\n            'sql' => 'LIKE',\n            'preg_match' => '/$/',\n            'preg_replace' => '%'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'end',\n            'description' => T_('ends with'),\n            'sql' => 'LIKE',\n            'preg_match' => '/^/',\n            'preg_replace' => '%'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'equal',\n            'description' => T_('is'),\n            'sql' => '='\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'not equal',\n            'description' => T_('is not'),\n            'sql' => '!='\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'sounds',\n            'description' => T_('sounds like'),\n            'sql' => 'SOUNDS LIKE'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'notsounds',\n            'description' => T_('does not sound like'),\n            'sql' => 'NOT SOUNDS LIKE'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'regexp',\n            'description' => T_('matches regular expression'),\n            'sql' => 'REGEXP'\n        );\n\n        $this->basetypes['text'][] = array(\n            'name' => 'notregexp',\n            'description' => T_('does not match regular expression'),\n            'sql' => 'NOT REGEXP'\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'contain',\n            'description' => T_('contains'),\n            'sql' => 'LIKE',\n            'preg_match' => array('/^/', '/$/'),\n            'preg_replace' => array('%', '%')\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'notcontain',\n            'description' => T_('does not contain'),\n            'sql' => 'NOT LIKE',\n            'preg_match' => array('/^/', '/$/'),\n            'preg_replace' => array('%', '%')\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'start',\n            'description' => T_('starts with'),\n            'sql' => 'LIKE',\n            'preg_match' => '/$/',\n            'preg_replace' => '%'\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'end',\n            'description' => T_('ends with'),\n            'sql' => 'LIKE',\n            'preg_match' => '/^/',\n            'preg_replace' => '%'\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'equal',\n            'description' => T_('is'),\n            'sql' => '>'\n        );\n\n        $this->basetypes['tags'][] = array(\n            'name' => 'not equal',\n            'description' => T_('is not'),\n            'sql' => '='\n        );\n\n        $this->basetypes['boolean_numeric'][] = array(\n            'name' => 'equal',\n            'description' => T_('is'),\n            'sql' => '<=>'\n        );\n\n        $this->basetypes['boolean_numeric'][] = array(\n            'name' => 'ne',\n            'description' => T_('is not'),\n            'sql' => '<>'\n        );\n\n        $this->basetypes['boolean_subsearch'][] = array(\n            'name' => 'equal',\n            'description' => T_('is'),\n            'sql' => ''\n        );\n\n        $this->basetypes['boolean_subsearch'][] = array(\n            'name' => 'ne',\n            'description' => T_('is not'),\n            'sql' => 'NOT'\n        );\n\n        $this->basetypes['date'][] = array(\n            'name' => 'lt',\n            'description' => T_('before'),\n            'sql' => '<'\n        );\n\n        $this->basetypes['date'][] = array(\n            'name' => 'gt',\n            'description' => T_('after'),\n            'sql' => '>'\n        );\n\n        $this->basetypes['days'][] = array(\n            'name' => 'lt',\n            'description' => T_('before (x) days ago'),\n            'sql' => '<'\n        );\n\n        $this->basetypes['days'][] = array(\n            'name' => 'gt',\n            'description' => T_('after (x) days ago'),\n            'sql' => '>'\n        );\n\n        $this->basetypes['recent_added'][] = array(\n            'name' => 'add',\n            'description' => T_('# songs'),\n            'sql' => '`addition_time`'\n        );\n\n        $this->basetypes['recent_updated'][] = array(\n            'name' => 'upd',\n            'description' => T_('# songs'),\n            'sql' => '`update_time`'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => 'love',\n            'description' => T_('has loved'),\n            'sql' => 'userflag'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => '5star',\n            'description' => T_('has rated 5 stars'),\n            'sql' => '`rating` = 5'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => '4star',\n            'description' => T_('has rated 4 stars'),\n            'sql' => '`rating` = 4'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => '3star',\n            'description' => T_('has rated 3 stars'),\n            'sql' => '`rating` = 3'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => '2star',\n            'description' => T_('has rated 2 stars'),\n            'sql' => '`rating` = 2'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => '1star',\n            'description' => T_('has rated 1 star'),\n            'sql' => '`rating` = 1'\n        );\n\n        $this->basetypes['user_numeric'][] = array(\n            'name' => 'unrated',\n            'description' => T_('has not rated'),\n            'sql' => 'unrated'\n        );\n        $this->basetypes['multiple'] = array_merge($this->basetypes['text'], $this->basetypes['numeric']);\n    }\n\n    /**\n     * type_numeric\n     *\n     * Generic integer searches rules\n     * @param string $name\n     * @param string $label\n     * @param string $type\n     */\n    private function type_numeric($name, $label, $type = 'numeric')\n    {\n        $this->types[] = array(\n            'name' => $name,\n            'label' => $label,\n            'type' => $type,\n            'widget' => array('input', 'number')\n        );\n    }\n\n    /**\n     * type_date\n     *\n     * Generic integer searches rules\n     * @param string $name\n     * @param string $label\n     */\n    private function type_date($name, $label)\n    {\n        $this->types[] = array(\n            'name' => $name,\n            'label' => $label,\n            'type' => 'date',\n            'widget' => array('input', 'datetime-local')\n        );\n    }\n\n    /**\n     * type_text\n     *\n     * Generic text rules\n     * @param string $name\n     * @param string $label\n     */\n    private function type_text($name, $label)\n    {\n        $this->types[] = array(\n            'name' => $name,\n            'label' => $label,\n            'type' => 'text',\n            'widget' => array('input', 'text')\n        );\n    }\n\n    /**\n     * type_select\n     *\n     * Generic rule to select from a list\n     * @param string $name\n     * @param string $label\n     * @param string $type\n     * @param array $array\n     */\n    private function type_select($name, $label, $type, $array)\n    {\n        $this->types[] = array(\n            'name' => $name,\n            'label' => $label,\n            'type' => $type,\n            'widget' => array('select', $array)\n        );\n    }\n\n    /**\n     * type_boolean\n     *\n     * True or false generic searches\n     * @param string $name\n     * @param string $label\n     */\n    private function type_boolean($name, $label)\n    {\n        $this->types[] = array(\n            'name' => $name,\n            'label' => $label,\n            'type' => 'boolean',\n            'widget' => array('input', 'hidden')\n        );\n    }\n\n    /**\n     * songtypes\n     *\n     * this is where all the searchtypes for songs are defined\n     */\n    private function song_types()\n    {\n        $this->type_text('anywhere', T_('Any searchable text'));\n        $this->type_text('title', T_('Title'));\n        $this->type_text('album', T_('Album'));\n        $this->type_text('artist', T_('Song Artist'));\n        $this->type_text('album_artist', T_('Album Artist'));\n        $this->type_text('composer', T_('Composer'));\n\n        $this->type_numeric('year', T_('Year'));\n\n        if (AmpConfig::get('ratings')) {\n            $this->type_select('myrating', T_('My Rating'), 'numeric', $this->stars);\n            $this->type_select('rating', T_('Rating (Average)'), 'numeric', $this->stars);\n            $this->type_select('albumrating', T_('My Rating (Album)'), 'numeric', $this->stars);\n            $this->type_select('artistrating', T_('My Rating (Artist)'), 'numeric', $this->stars);\n        }\n        if (AmpConfig::get('userflags')) {\n            $this->type_text('favorite', T_('Favorites'));\n        }\n\n        /* HINT: Number of times object has been played */\n        $this->type_numeric('played_times', T_('# Played'));\n        /* HINT: Number of times object has been skipped */\n        $this->type_numeric('skipped_times', T_('# Skipped'));\n        /* HINT: Number of times object has been played OR skipped */\n        $this->type_numeric('played_or_skipped_times', T_('# Played or Skipped'));\n        /* HINT: Percentage of (Times Played / Times skipped) * 100 */\n        $this->type_numeric('play_skip_ratio', T_('Played/Skipped ratio'));\n        $this->type_numeric('last_play', T_('My Last Play'), 'days');\n        $this->type_numeric('last_skip', T_('My Last Skip'), 'days');\n        $this->type_numeric('last_play_or_skip', T_('My Last Play or Skip'), 'days');\n        $this->type_boolean('played', T_('Played'));\n        $this->type_boolean('myplayed', T_('Played by Me'));\n        $this->type_boolean('myplayedalbum', T_('Played by Me (Album)'));\n        $this->type_boolean('myplayedartist', T_('Played by Me (Artist)'));\n        $this->type_numeric('time', T_('Length (in minutes)'));\n\n        $this->type_text('tag', T_('Tags'));\n        $this->type_text('album_tag', T_('Album Tag'));\n        $this->type_text('artist_tag', T_('Artist Tag'));\n\n        $users = array();\n        foreach (User::get_valid_users() as $userid) {\n            $user           = new User($userid);\n            $users[$userid] = $user->username;\n        }\n        $this->type_select('other_user', T_('Another User'), 'user_numeric', $users);\n        $this->type_select('other_user_album', T_('Another User (Album)'), 'user_numeric', $users);\n        $this->type_select('other_user_artist', T_('Another User (Artist)'), 'user_numeric', $users);\n\n        $this->type_text('label', T_('Label'));\n        if (AmpConfig::get('licensing')) {\n            $licenses = array();\n            foreach (License::get_licenses() as $license_id) {\n                $license               = new License($license_id);\n                $licenses[$license_id] = $license->name;\n            }\n            $this->type_select('license', T_('Music License'), 'boolean_numeric', $licenses);\n        }\n\n        $playlists = array();\n        foreach (Playlist::get_playlists() as $playlistid) {\n            $playlist = new Playlist($playlistid);\n            $playlist->format(false);\n            $playlists[$playlistid] = $playlist->f_name;\n        }\n        $this->type_select('playlist', T_('Playlist'), 'boolean_numeric', $playlists);\n\n        $playlists = array();\n        $searches  = self::get_searches();\n        foreach ($searches as $playlistid) {\n            // Slightly different from the above so we don't instigate a vicious loop.\n            $playlists[$playlistid] = self::get_name_byid($playlistid);\n        }\n        $this->type_select('smartplaylist', T_('Smart Playlist'), 'boolean_subsearch', $playlists);\n\n        $this->type_text('playlist_name', T_('Playlist Name'));\n\n        $this->type_text('comment', T_('Comment'));\n        $this->type_text('lyrics', T_('Lyrics'));\n        $this->type_text('file', T_('Filename'));\n        $bitrate_array = array(\n            '32',\n            '40',\n            '48',\n            '56',\n            '64',\n            '80',\n            '96',\n            '112',\n            '128',\n            '160',\n            '192',\n            '224',\n            '256',\n            '320',\n            '640',\n            '1280'\n        );\n        $this->type_select('bitrate', T_('Bitrate'), 'numeric', $bitrate_array);\n        $this->type_date('added', T_('Added'));\n        $this->type_date('updated', T_('Updated'));\n\n        $this->type_numeric('recent_added', T_('Recently added'), 'recent_added');\n        $this->type_numeric('recent_updated', T_('Recently updated'), 'recent_updated');\n\n        $catalogs = array();\n        foreach (Catalog::get_catalogs() as $catid) {\n            $catalog = Catalog::create_from_id($catid);\n            $catalog->format();\n            $catalogs[$catid] = $catalog->f_name;\n        }\n        $this->type_select('catalog', T_('Catalog'), 'boolean_numeric', $catalogs);\n\n        $this->type_text('mbid', T_('MusicBrainz ID'));\n        $this->type_text('mbid_album', T_('MusicBrainz ID (Album)'));\n        $this->type_text('mbid_artist', T_('MusicBrainz ID (Artist)'));\n\n        if (AmpConfig::get('enable_custom_metadata')) {\n            $metadataFields          = array();\n            $metadataFieldRepository = new MetadataField();\n            foreach ($metadataFieldRepository->findAll() as $metadata) {\n                $metadataFields[$metadata->getId()] = $metadata->getName();\n            }\n            $this->types[] = array(\n                'name' => 'metadata',\n                'label' => T_('Metadata'),\n                'type' => 'multiple',\n                'subtypes' => $metadataFields,\n                'widget' => array('subtypes', array('input', 'text'))\n            );\n        }\n    }\n\n    /**\n     * artisttypes\n     *\n     * this is where all the searchtypes for artists are defined\n     */\n    private function artist_types()\n    {\n        $this->type_text('title', T_('Name'));\n\n        $this->type_numeric('yearformed', T_('Year'));\n        $this->type_text('placeformed', T_('Place'));\n\n        if (AmpConfig::get('ratings')) {\n            $this->type_select('myrating', T_('My Rating'), 'numeric', $this->stars);\n            $this->type_select('rating', T_('Rating (Average)'), 'numeric', $this->stars);\n        }\n\n        if (AmpConfig::get('userflags')) {\n            $this->type_text('favorite', T_('Favorites'));\n        }\n\n        /* HINT: Number of times object has been played */\n        $this->type_numeric('played_times', T_('# Played'));\n        $this->type_numeric('last_play', T_('My Last Play'), 'days');\n        $this->type_numeric('last_skip', T_('My Last Skip'), 'days');\n        $this->type_numeric('last_play_or_skip', T_('My Last Play or Skip'), 'days');\n        $this->type_boolean('played', T_('Played'));\n        $this->type_boolean('myplayed', T_('Played by Me'));\n        $this->type_numeric('time', T_('Length (in minutes)'));\n\n        $this->type_text('tag', T_('Tag'));\n\n        $users = array();\n        foreach (User::get_valid_users() as $userid) {\n            $user           = new User($userid);\n            $users[$userid] = $user->username;\n        }\n        $this->type_select('other_user', T_('Another User'), 'user_numeric', $users);\n\n        $this->type_text('mbid', T_('MusicBrainz ID'));\n\n        $this->type_boolean('has_image', T_('Local Image'));\n        $this->type_numeric('image_width', T_('Image Width'));\n        $this->type_numeric('image_height', T_('Image Height'));\n    } // artisttypes\n\n    /**\n     * albumtypes\n     *\n     * this is where all the searchtypes for albums are defined\n     */\n    private function album_types()\n    {\n        $this->type_text('title', T_('Title'));\n        $this->type_text('artist', T_('Album Artist'));\n\n        $this->type_numeric('year', T_('Year'));\n        $this->type_numeric('original_year', T_('Original Year'));\n        $this->type_text('release_type', T_('Release Type'));\n\n        if (AmpConfig::get('ratings')) {\n            $this->type_select('myrating', T_('My Rating'), 'numeric', $this->stars);\n            $this->type_select('rating', T_('Rating (Average)'), 'numeric', $this->stars);\n            $this->type_select('artistrating', T_('Rating (Artist)'), 'numeric', $this->stars);\n        }\n        if (AmpConfig::get('userflags')) {\n            $this->type_text('favorite', T_('Favorites'));\n        }\n\n        /* HINT: Number of times object has been played */\n        $this->type_numeric('played_times', T_('# Played'));\n        $this->type_numeric('last_play', T_('My Last Play'), 'days');\n        $this->type_numeric('last_skip', T_('My Last Skip'), 'days');\n        $this->type_numeric('last_play_or_skip', T_('My Last Play or Skip'), 'days');\n        $this->type_boolean('played', T_('Played'));\n        $this->type_boolean('myplayed', T_('Played by Me'));\n        $this->type_numeric('time', T_('Length (in minutes)'));\n\n        $this->type_text('tag', T_('Tag'));\n\n        $users = array();\n        foreach (User::get_valid_users() as $userid) {\n            $user           = new User($userid);\n            $users[$userid] = $user->username;\n        }\n        $this->type_select('other_user', T_('Another User'), 'user_numeric', $users);\n\n        $catalogs = array();\n        foreach (Catalog::get_catalogs() as $catid) {\n            $catalog = Catalog::create_from_id($catid);\n            $catalog->format();\n            $catalogs[$catid] = $catalog->f_name;\n        }\n        $this->type_select('catalog', T_('Catalog'), 'boolean_numeric', $catalogs);\n\n        $this->type_text('mbid', T_('MusicBrainz ID'));\n\n        $this->type_boolean('has_image', T_('Local Image'));\n        $this->type_numeric('image_width', T_('Image Width'));\n        $this->type_numeric('image_height', T_('Image Height'));\n    } // albumtypes\n\n    /**\n     * videotypes\n     *\n     * this is where all the searchtypes for videos are defined\n     */\n    private function video_types()\n    {\n        $this->type_text('file', T_('Filename'));\n    }\n\n    /**\n     * playlisttypes\n     *\n     * this is where all the searchtypes for playlists are defined\n     */\n    private function playlist_types()\n    {\n        $this->type_text('title', T_('Name'));\n    }\n\n    /**\n     * labeltypes\n     *\n     * this is where all the searchtypes for labels are defined\n     */\n    private function label_types()\n    {\n        $this->type_text('title', T_('Name'));\n        $this->type_text('category', T_('Category'));\n    }\n\n    /**\n     * usertypes\n     *\n     * this is where all the searchtypes for users are defined\n     */\n    private function user_types()\n    {\n        $this->type_text('username', T_('Username'));\n    }\n\n    /**\n     * clean_request\n     *\n     * Sanitizes raw search data\n     * @param array $data\n     * @return array\n     */\n    public static function clean_request($data)\n    {\n        $request = array();\n        foreach ($data as $key => $value) {\n            $prefix = substr($key, 0, 4);\n            $value  = trim((string) $value);\n\n            if ($prefix == 'rule' && strlen((string) $value)) {\n                $request[$key] = Dba::escape(filter_var($value, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));\n            }\n        }\n\n        // Figure out if they want an AND based search or an OR based search\n        switch ($data['operator']) {\n            case 'or':\n                $request['operator'] = 'OR';\n                break;\n            default:\n                $request['operator'] = 'AND';\n                break;\n        }\n\n        // Verify the type\n        switch ($data['type']) {\n            case 'album':\n            case 'artist':\n            case 'video':\n            case 'song':\n            case 'tag':  // for Genres\n            case 'playlist':\n            case 'label':\n            case 'user':\n                $request['type'] = $data['type'];\n                break;\n            default:\n                $request['type'] = 'song';\n                break;\n        }\n\n        return $request;\n    } // end clean_request\n\n    /**\n     * get_name_byid\n     *\n     * Returns the name of the saved search corresponding to the given ID\n     * @param string $search_id\n     * @return string\n     */\n    public static function get_name_byid($search_id)\n    {\n        $sql        = \"SELECT `name` FROM `search` WHERE `id` = '$search_id'\";\n        $db_results = Dba::read($sql);\n        $row        = Dba::fetch_assoc($db_results);\n\n        return $row['name'];\n    }\n\n    /**\n     * get_searches\n     *\n     * Return the IDs of all saved searches accessible by the current user.\n     * @return array\n     */\n    public static function get_searches()\n    {\n        $sql = \"SELECT `id` from `search` WHERE `type`='public' OR \" .\n            \"`user`='\" . Core::get_global('user')->id . \"' ORDER BY `name`\";\n        $db_results = Dba::read($sql);\n\n        $results = array();\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = $row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * run\n     *\n     * This function actually runs the search and returns an array of the\n     * results.\n     * @param array $data\n     * @param User $user\n     * @return integer[]\n     */\n    public static function run($data, $user = null)\n    {\n        $limit  = (int) ($data['limit']);\n        $offset = (int) ($data['offset']);\n        $random = ((int) $data['random'] > 0) ? 1 : 0;\n        $data   = self::clean_request($data);\n        $search = new Search(null, $data['type'], $user);\n        unset($data['type']);\n        //debug_event(self::class, 'run: ' . print_r($data, true), 5);\n        $search->parse_rules($data);\n\n        // Generate BASE SQL\n        $limit_sql = \"\";\n        if ($limit > 0) {\n            $limit_sql = ' LIMIT ';\n            if ($offset) {\n                $limit_sql .= $offset . \",\";\n            }\n            $limit_sql .= $limit;\n        }\n\n        $search_info = $search->to_sql();\n        $sql         = $search_info['base'] . ' ' . $search_info['table_sql'];\n        if (!empty($search_info['where_sql'])) {\n            $sql .= ' WHERE ' . $search_info['where_sql'];\n        }\n        if (!empty($search_info['group_sql'])) {\n            $sql .= ' GROUP BY ' . $search_info['group_sql'];\n            if (!empty($search_info['having_sql'])) {\n                $sql .= ' HAVING ' . $search_info['having_sql'];\n            }\n        }\n        $sql .= ($random > 0) ? \" ORDER BY RAND()\" : \" ORDER BY \" . $search->order_by;\n        $sql .= ' ' . $limit_sql;\n        $sql = trim((string) $sql);\n\n        //debug_event(self::class, 'SQL get_items: ' . $sql, 5);\n        $db_results = Dba::read($sql);\n        $results    = array();\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = (int) $row['id'];\n        }\n\n        return $results;\n    }\n\n    /**\n     * delete\n     *\n     * Does what it says on the tin.\n     * @return boolean\n     */\n    public function delete()\n    {\n        $search_id = Dba::escape($this->id);\n        $sql       = \"DELETE FROM `search` WHERE `id` = ?\";\n        Dba::write($sql, array($search_id));\n\n        return true;\n    }\n\n    /**\n     * format\n     * Gussy up the data\n     * @param boolean $details\n     */\n    public function format($details = true)\n    {\n        parent::format($details);\n\n        $this->link   = AmpConfig::get('web_path') . '/smartplaylist.php?action=show_playlist&playlist_id=' . $this->id;\n        $this->f_link = '<a href=\"' . $this->link . '\">' . $this->f_name . '</a>';\n    }\n\n    /**\n     * get_items\n     *\n     * Return an array of the items output by our search (part of the\n     * playlist interface).\n     * @return array\n     */\n    public function get_items()\n    {\n        $results = array();\n\n        $sqltbl = $this->to_sql();\n        $sql    = $sqltbl['base'] . ' ' . $sqltbl['table_sql'];\n        if (!empty($sqltbl['where_sql'])) {\n            $sql .= ' WHERE ' . $sqltbl['where_sql'];\n        }\n        if (!empty($sqltbl['group_sql'])) {\n            $sql .= ' GROUP BY ' . $sqltbl['group_sql'];\n        }\n        if (!empty($sqltbl['having_sql'])) {\n            $sql .= ' HAVING ' . $sqltbl['having_sql'];\n        }\n\n        $sql .= ($this->random > 0) ? \" ORDER BY RAND()\" : \" ORDER BY \" . $this->order_by;\n        if ($this->limit > 0) {\n            $sql .= \" LIMIT \" . (string) ($this->limit);\n        }\n        //debug_event(self::class, 'SQL get_items: ' . $sql, 5);\n\n        $db_results = Dba::read($sql);\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = array(\n                'object_id' => $row['id'],\n                'object_type' => $this->searchtype\n            );\n        }\n        $this->date = time();\n        $this->set_last(count($results), 'last_count');\n        $this->set_last(self::get_total_duration($results), 'last_duration');\n\n        return $results;\n    }\n\n    /**\n     * set_last\n     *\n     * @param integer $count\n     * @param string $column\n     */\n    private function set_last($count, $column)\n    {\n        if (in_array($column, array('last_count', 'last_duration'))) {\n            $search_id = Dba::escape($this->id);\n            $sql       = \"UPDATE `search` SET `\" . Dba::escape($column) . \"` = \" . $count . \" WHERE `id` = ?\";\n            Dba::write($sql, array($search_id));\n        }\n    }\n\n    /**\n     * get_random_items\n     *\n     * Returns a randomly sorted array (with an optional limit) of the items\n     * output by our search (part of the playlist interface)\n     * @param integer $limit\n     * @return array\n     */\n    public function get_random_items($limit = null)\n    {\n        $results = array();\n\n        $sqltbl = $this->to_sql();\n        $sql    = $sqltbl['base'] . ' ' . $sqltbl['table_sql'];\n        if (!empty($sqltbl['where_sql'])) {\n            $sql .= ' WHERE ' . $sqltbl['where_sql'];\n        }\n        $rating_filter = AmpConfig::get_rating_filter();\n        if ($rating_filter > 0 && $rating_filter <= 5 && Core::get_global('user')) {\n            $user_id = Core::get_global('user')->id;\n            if (empty($sqltbl['where_sql'])) {\n                $sql .= \" WHERE \";\n            } else {\n                $sql .= \" AND \";\n            }\n            $sql .= \"`\" . $this->searchtype . \"`.`id` NOT IN\" .\n                    \" (SELECT `object_id` FROM `rating`\" .\n                    \" WHERE `rating`.`object_type` = '\" . $this->searchtype . \"'\" .\n                    \" AND `rating`.`rating` <=\" . $rating_filter .\n                    \" AND `rating`.`user` = \" . $user_id . \")\";\n        }\n        if (!empty($sqltbl['group_sql'])) {\n            $sql .= ' GROUP BY ' . $sqltbl['group_sql'];\n        }\n        if (!empty($sqltbl['having_sql'])) {\n            $sql .= ' HAVING ' . $sqltbl['having_sql'];\n        }\n\n        $sql .= ' ORDER BY RAND()';\n        $sql .= $limit ? ' LIMIT ' . (string) ($limit) : ' ';\n        //debug_event(self::class, 'SQL get_random_items: ' . $sql, 5);\n\n        $db_results = Dba::read($sql);\n\n        while ($row = Dba::fetch_assoc($db_results)) {\n            $results[] = array(\n                'object_id' => $row['id'],\n                'object_type' => $this->searchtype\n            );\n        }\n\n        return $results;\n    }\n\n    /**\n     * get_total_duration\n     * Get the total duration of all songs.\n     * @param array $songs\n     * @return integer\n     */\n    public static function get_total_duration($songs)\n    {\n        $song_ids = array();\n        foreach ($songs as $objects) {\n            $song_ids[] = (string) $objects['object_id'];\n        }\n        $idlist = '(' . implode(',', $song_ids) . ')';\n        if ($idlist == '()') {\n            return 0;\n        }\n        $sql        = \"SELECT SUM(`time`) FROM `song` WHERE `id` IN $idlist\";\n        $db_results = Dba::read($sql);\n\n        $results = Dba::fetch_row($db_results);\n\n        return (int) $results['0'];\n    } // get_total_duration\n\n    /**\n     * name_to_basetype\n     *\n     * Iterates over our array of types to find out the basetype for\n     * the passed string.\n     * @param string $name\n     * @return string|false\n     */\n    public function name_to_basetype($name)\n    {\n        foreach ($this->types as $type) {\n            //debug_event(self::class, $name . ' name_to_basetype: ' . $type['name'], 5);\n            if ($type['name'] == $name) {\n                return $type['type'];\n            }\n        }\n        debug_event(self::class, 'name_to_basetype: could not fund ' . $name . '. Check your search rules', 5);\n\n        return false;\n    }\n\n    /**\n     * parse_rules\n     *\n     * Takes an array of sanitized search data from the form and generates\n     * our real array from it.\n     * @param array $data\n     */\n    public function parse_rules($data)\n    {\n        $this->rules = array();\n        foreach ($data as $rule => $value) {\n            //debug_event(self::class, 'parse_rules: ' . $rule . ' - ' . $value, 5);\n            if ((($this->searchtype == 'artist' && $value == 'artist') || $value == 'name') && preg_match('/^rule_[0123456789]*$/', $rule)) {\n                $value = 'title';\n            }\n            if (preg_match('/^rule_(\\d+)$/', $rule, $ruleID)) {\n                $ruleID     = (string) $ruleID[1];\n                $input_rule = (string) $data['rule_' . $ruleID . '_input'];\n                $operator   = $this->basetypes[$this->name_to_basetype($value)][$data['rule_' . $ruleID . '_operator']]['name'];\n                //keep vertical bar in regular expression\n                if (in_array($operator, ['regexp', 'notregexp'])) {\n                    $input_rule = str_replace(\"|\", \"\\0\", $input_rule);\n                }\n                foreach (explode('|', $input_rule) as $input) {\n                    $this->rules[] = array(\n                        $value,\n                        $operator,\n                        in_array($operator, ['regexp', 'notregexp']) ? str_replace(\"\\0\", \"|\", $input) : $input,\n                        $data['rule_' . $ruleID . '_subtype']\n                    );\n                }\n            }\n        }\n        $this->logic_operator = $data['operator'];\n    }\n\n    /**\n     * save\n     *\n     * Save this search to the database for use as a smart playlist\n     * @return string\n     */\n    public function save()\n    {\n        // Make sure we have a unique name\n        if (! $this->name) {\n            $time_format = AmpConfig::get('custom_datetime') ? (string) AmpConfig::get('custom_datetime') : 'm/d/Y H:i:s';\n            $this->name  = Core::get_global('user')->username . ' - ' . get_datetime($time_format, time());\n        }\n        $sql        = \"SELECT `id` FROM `search` WHERE `name` = ?\";\n        $db_results = Dba::read($sql, array($this->name));\n        if (Dba::num_rows($db_results)) {\n            $this->name .= uniqid('', true);\n        }\n\n        $sql = \"INSERT INTO `search` (`name`, `type`, `user`, `rules`, `logic_operator`, `random`, `limit`) VALUES (?, ?, ?, ?, ?, ?, ?)\";\n        Dba::write($sql, array($this->name, $this->type, Core::get_global('user')->id, json_encode($this->rules), $this->logic_operator, ($this->random > 0) ? 1 : 0, $this->limit));\n        $insert_id = Dba::insert_id();\n        $this->id  = (int) $insert_id;\n\n        return $insert_id;\n    }\n\n    /**\n     * to_js\n     *\n     * Outputs the javascript necessary to re-show the current set of rules.\n     * @return string\n     */\n    public function to_js()\n    {\n        $javascript = \"\";\n        foreach ($this->rules as $rule) {\n            $javascript .= '<script>' .\n                'SearchRow.add(\"' . $rule[0] . '\",\"' .\n                $rule[1] . '\",\"' . $rule[2] . '\", \"' . $rule[3] . '\"); </script>';\n        }\n\n        return $javascript;\n    }\n\n    /**\n     * to_sql\n     *\n     * Call the appropriate real function.\n     * @return array\n     */\n    public function to_sql()\n    {\n        return call_user_func(array($this, $this->searchtype . \"_to_sql\"));\n    }\n\n    /**\n     * update\n     *\n     * This function updates the saved version with the current settings.\n     * @param array $data\n     * @return integer\n     */\n    public function update(array $data = null)\n    {\n        if ($data && is_array($data)) {\n            $this->name   = $data['name'];\n            $this->type   = $data['pl_type'];\n            $this->random = ((int) $data['random'] > 0) ? 1 : 0;\n            $this->limit  = $data['limit'];\n        }\n\n        if (!$this->id) {\n            return 0;\n        }\n\n        $sql = \"UPDATE `search` SET `name` = ?, `type` = ?, `rules` = ?, `logic_operator` = ?, `random` = ?, `limit` = ? WHERE `id` = ?\";\n        Dba::write($sql, array($this->name, $this->type, json_encode($this->rules), $this->logic_operator, $this->random, $this->limit, $this->id));\n\n        return $this->id;\n    }\n\n    /**\n     * @return mixed|void\n     */\n    public static function garbage_collection()\n    {\n    }\n\n    /**\n     * _mangle_data\n     *\n     * Private convenience function.  Mangles the input according to a set\n     * of predefined rules so that we don't have to include this logic in\n     * foo_to_sql.\n     * @param array|string $data\n     * @param string|false $type\n     * @param array $operator\n     * @return array|boolean|integer|string|string[]|null\n     */\n    private function _mangle_data($data, $type, $operator)\n    {\n        if ($operator['preg_match']) {\n            $data = preg_replace(\n                $operator['preg_match'],\n                $operator['preg_replace'],\n                $data\n            );\n        }\n\n        if ($type == 'numeric' || $type == 'days') {\n            return (int) ($data);\n        }\n\n        if ($type == 'boolean') {\n            return make_bool($data);\n        }\n\n        return $data;\n    }\n\n    /**\n     * album_to_sql\n     *\n     * Handles the generation of the SQL for album searches.\n     * @return array\n     */\n    private function album_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $userid             = $this->search_user->id;\n\n        $where       = array();\n        $table       = array();\n        $join        = array();\n        $group       = array();\n        $having      = array();\n        $join['tag'] = array();\n        $groupdisks  = AmpConfig::get('album_group');\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n            if ($groupdisks) {\n                $group[] = \"`album`.`prefix`\";\n                $group[] = \"`album`.`name`\";\n                $group[] = \"`album`.`album_artist`\";\n                $group[] = \"`album`.`mbid`\";\n                $group[] = \"`album`.`year`\";\n            } else {\n                $group[] = \"`album`.`id`\";\n                $group[] = \"`album`.`disk`\";\n            }\n\n            switch ($rule[0]) {\n                case 'title':\n                    $where[] = \"(`album`.`name` $sql_match_operator '$input' \" .\n                               \" OR LTRIM(CONCAT(COALESCE(`album`.`prefix`, ''), \" .\n                               \"' ', `album`.`name`)) $sql_match_operator '$input')\";\n                    break;\n                case 'year':\n                    $where[] = \"`album`.`\" . $rule[0] . \"` $sql_match_operator '$input'\";\n                    break;\n                case 'original_year':\n                    $where[] = \"(`album`.`original_year` $sql_match_operator '$input' OR \" .\n                        \"(`album`.`original_year` IS NULL AND `album`.`year` $sql_match_operator '$input'))\";\n                    break;\n                case 'time':\n                    $input          = $input * 60;\n                    $where[]        = \"`alength`.`time` $sql_match_operator '$input'\";\n                    $table['atime'] = \"LEFT JOIN (SELECT `album`, SUM(`time`) AS `time` FROM `song` GROUP BY `album`) \" .\n                        \"AS `alength` ON `alength`.`album`=`album`.`id` \";\n                    break;\n                case 'rating':\n                    // average ratings only\n                    $where[]          = \"`average_rating`.`avg` $sql_match_operator '$input'\";\n                    $table['average'] = \"LEFT JOIN (SELECT `object_id`, ROUND(AVG(IFNULL(`rating`.`rating`,0))) AS \" .\n                        \"`avg` FROM `rating` WHERE `rating`.`object_type`='album' GROUP BY `object_id`) AS \" .\n                        \"`average_rating` on `average_rating`.`object_id` = `album`.`id` \";\n                    break;\n                case 'favorite':\n                    $where[]  = \"(`album`.`name` $sql_match_operator '$input' OR LTRIM(CONCAT(COALESCE(`album`.`prefix`, ''), ' ', `album`.`name`)) $sql_match_operator '$input') \" .\n                                \"AND `favorite_album_$userid`.`user` = $userid \" .\n                                \"AND `favorite_album_$userid`.`object_type` = 'album'\";\n                    // flag once per user\n                    $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_album_$userid\")) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                        \"FROM `user_flag` WHERE `user` = $userid) AS `favorite_album_$userid` \" .\n                        \"ON `album`.`id`=`favorite_album_$userid`.`object_id` \" .\n                        \"AND `favorite_album_$userid`.`object_type` = 'album' \" : ' ';\n                    break;\n                case 'myrating':\n                case 'artistrating':\n                    // combine these as they all do the same thing just different tables\n                    $looking = str_replace('rating', '', $rule[0]);\n                    $column  = ($looking == 'my') ? 'id' : 'album_artist';\n                    $my_type = ($looking == 'my') ? 'album' : $looking;\n                if ($input == 0 && $sql_match_operator == '>=') {\n                    break;\n                }\n                if ($input == 0 && $sql_match_operator == '<') {\n                    $input              = -1;\n                    $sql_match_operator = '<=>';\n                }\n                if ($input == 0 && $sql_match_operator == '<>') {\n                    $input              = 1;\n                    $sql_match_operator = '>=';\n                }\n                if (($input == 0 && $sql_match_operator != '>') || ($input == 1 && $sql_match_operator == '<')) {\n                    $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL\";\n                } elseif ($sql_match_operator == '<>' || $sql_match_operator == '<' || $sql_match_operator == '<=' || $sql_match_operator == '!=') {\n                    $where[] = \"(`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input OR `rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL)\";\n                } else {\n                    $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input\";\n                }\n                // rating once per user\n                $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $userid)) ?\n                    \"LEFT JOIN (SELECT `object_id`, `object_type`, `rating` FROM `rating` \" .\n                    \"WHERE `user` = $userid AND `object_type`='$my_type') \" .\n                    \"AS `rating_\" . $my_type . \"_\" . $userid . \"` \" .\n                    \"ON `rating_\" . $my_type . \"_\" . $userid . \"`.`object_id`=`album`.`$column` \" : ' ';\n                break;\n                case 'myplayed':\n                    $column       = 'id';\n                    $my_type      = 'album';\n                    $operator_sql = ((int) $sql_match_operator == 0) ? 'IS NULL' : 'IS NOT NULL';\n                    // played once per user\n                    $table['myplayed'] .= (!strpos((string) $table['myplayed'], \"myplayed_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS \" .\n                        \"`myplayed_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `album`.`$column`=`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` $operator_sql\";\n                    break;\n                case 'last_play':\n                    $my_type = 'album';\n                    $table['last_play'] .= (!strpos((string) $table['last_play'], \"last_play_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_play_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `album`.`id`=`last_play_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_play_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`last_play_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    break;\n                case 'last_skip':\n                    $my_type = 'album';\n                    $table['last_skip'] .= (!strpos((string) $table['last_skip'], \"last_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'skip' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = 'song' \" : ' ';\n                    $where[]      = \"`last_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    $join['song'] = true;\n                    break;\n                case 'last_play_or_skip':\n                    $my_type = 'album';\n                    $table['last_play_or_skip'] .= (!strpos((string) $table['last_play_or_skip'], \"last_play_or_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` IN ('stream', 'skip') \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_play_or_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = 'song' \" : ' ';\n                    $where[]      = \"`last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    $join['song'] = true;\n                    break;\n                case 'played_times':\n                    $where[] = \"`album`.`id` IN (SELECT `object_count`.`object_id` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'album' AND `object_count`.`count_type` = 'stream' \" .\n                        \"GROUP BY `object_count`.`object_id` HAVING COUNT(*) $sql_match_operator '$input')\";\n                    break;\n                case 'release_type':\n                    $where[] = \"`album`.`release_type` $sql_match_operator '$input' \";\n                    break;\n                case 'other_user':\n                    $other_userid = $input;\n                    if ($sql_match_operator == 'userflag') {\n                        $where[] = \"`favorite_album_$other_userid`.`user` = $other_userid \" .\n                            \" AND `favorite_album_$other_userid`.`object_type` = 'album'\";\n                        // flag once per user\n                        $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_album_$other_userid\")) ?\n                            \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                            \"from `user_flag` WHERE `user` = $other_userid) AS `favorite_album_$other_userid` \" .\n                            \"ON `song`.`album`=`favorite_album_$other_userid`.`object_id` \" .\n                            \"AND `favorite_album_$other_userid`.`object_type` = 'album' \" : ' ';\n                    } else {\n                        $column  = 'id';\n                        $my_type = 'album';\n                        $where[] = \"`rating_album_\" . $other_userid . '`.' . $sql_match_operator .\n                                   \" AND `rating_album_$other_userid`.`user` = $other_userid \" .\n                                   \" AND `rating_album_$other_userid`.`object_type` = 'album'\";\n                        // rating once per user\n                        $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $userid)) ?\n                            \"LEFT JOIN `rating` AS `rating_\" . $my_type . \"_\" . $userid . \"` ON \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`object_type`='$my_type' AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`object_id`=`$my_type`.`$column` AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`user` = $userid \" : ' ';\n                    }\n                    break;\n                case 'catalog':\n                    $where[]      = \"`song`.`catalog` $sql_match_operator '$input'\";\n                    $join['song'] = true;\n                    break;\n                case 'tag':\n                    $key = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE' || $sql_match_operator == 'NOT LIKE') {\n                        $where[]           = \"`realtag_$key`.`name` $sql_match_operator '$input'\";\n                        $join['tag'][$key] = \"$sql_match_operator '$input'\";\n                    } else {\n                        $where[]           = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0\";\n                        $join['tag'][$key] = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0\";\n                    }\n                    break;\n                case 'has image':\n                case 'has_image':\n                    $where[]            = ($sql_match_operator == '1') ? \"`has_image`.`object_id` IS NOT NULL\" : \"`has_image`.`object_id` IS NULL\";\n                    $table['has_image'] = \"LEFT JOIN (SELECT `object_id` from `image` WHERE `object_type` = 'album') as `has_image` ON `album`.`id` = `has_image`.`object_id`\";\n                    break;\n                case 'image height':\n                case 'image_height':\n                case 'image width':\n                case 'image_width':\n                    $looking       = strpos($rule[0], \"image_\") ? str_replace('image_', '', $rule[0]) : str_replace('image ', '', $rule[0]);\n                    $where[]       = \"`image`.`$looking` $sql_match_operator '$input'\";\n                    $join['image'] = true;\n                    break;\n                case 'artist':\n                    $where[]         = \"(`artist`.`name` $sql_match_operator '$input' OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) $sql_match_operator '$input')\";\n                    $table['artist'] = \"LEFT JOIN `artist` ON `album`.`album_artist`=`artist`.`id`\";\n                    break;\n                case 'mbid':\n                    $where[] = \"`album`.`mbid` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype album\n        } // foreach rule\n\n        $join['song']    = $join['song'] || AmpConfig::get('catalog_disable');\n        $join['catalog'] = $join['song'] || AmpConfig::get('catalog_disable');\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        foreach ($join['tag'] as $key => $value) {\n            $table['tag_' . $key] =\n                \"LEFT JOIN (\" .\n                \"SELECT `object_id`, GROUP_CONCAT(`name`) AS `name` \" .\n                \"FROM `tag` LEFT JOIN `tag_map` \" .\n                \"ON `tag`.`id`=`tag_map`.`tag_id` \" .\n                \"WHERE `tag_map`.`object_type`='album' \" .\n                \"GROUP BY `object_id`\" .\n                \") AS `realtag_$key` \" .\n                \"ON `album`.`id`=`realtag_$key`.`object_id`\";\n        }\n        if ($join['song']) {\n            $table['0_song'] = \"LEFT JOIN `song` ON `song`.`album`=`album`.`id`\";\n\n            if ($join['catalog']) {\n                $table['catalog'] = \"LEFT JOIN `catalog` AS `catalog_se` ON `catalog_se`.`id`=`song`.`catalog`\";\n                if (!empty($where_sql)) {\n                    $where_sql .= \" AND `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                } else {\n                    $where_sql .= \" `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                }\n            }\n        }\n        if ($join['count']) {\n            $table['object_count'] = \"LEFT JOIN (SELECT `object_count`.`object_id`, MAX(`object_count`.`date`) AS \" .\n                \"`date` FROM `object_count` WHERE `object_count`.`object_type` = 'album' AND \" .\n                \"`object_count`.`user`='\" . $userid . \"' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS \" .\n                \"`object_count` ON `object_count`.`object_id`=`album`.`id`\";\n        }\n        if ($join['image']) {\n            $table['0_song'] = \"LEFT JOIN `song` ON `song`.`album`=`album`.`id` LEFT JOIN `image` ON `image`.`object_id`=`album`.`id`\";\n            $where_sql .= \" AND `image`.`object_type`='album'\";\n            $where_sql .= \" AND `image`.`size`='original'\";\n        }\n        ksort($table);\n        $table_sql  = implode(' ', $table);\n        $group_sql  = implode(',', $group);\n        $having_sql = implode(\" $sql_logic_operator \", $having);\n\n        return array(\n            'base' => ($groupdisks) ? 'SELECT MIN(`album`.`id`) AS `id` FROM `album`' : 'SELECT MIN(`album`.`id`) AS `id`, MAX(`album`.`disk`) AS `disk` FROM `album`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => $table_sql,\n            'group_sql' => $group_sql,\n            'having_sql' => $having_sql\n        );\n    }\n\n    /**\n     * artist_to_sql\n     *\n     * Handles the generation of the SQL for artist searches.\n     * @return array\n     */\n    private function artist_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $userid             = $this->search_user->id;\n\n        $where              = array();\n        $table              = array();\n        $join               = array();\n        $group              = array();\n        $having             = array();\n        $join['tag']        = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'title':\n                case 'name':\n                    $where[] = \"(`artist`.`name` $sql_match_operator '$input' \" .\n                                \" OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), \" .\n                                \"' ', `artist`.`name`)) $sql_match_operator '$input')\";\n                    break;\n                case 'yearformed':\n                    $where[] = \"`artist`.`yearformed` $sql_match_operator '$input'\";\n                    break;\n                case 'placeformed':\n                    $where[] = \"`artist`.`placeformed` $sql_match_operator '$input'\";\n                    break;\n                case 'tag':\n                    $key = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE' || $sql_match_operator == 'NOT LIKE') {\n                        $where[]           = \"`realtag_$key`.`name` $sql_match_operator '$input'\";\n                        $join['tag'][$key] = \"$sql_match_operator '$input'\";\n                    } else {\n                        $where[]           = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0\";\n                        $join['tag'][$key] = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0\";\n                    }\n                    break;\n                case 'rating':\n                    // average ratings only\n                    $where[]          = \"`average_rating`.`avg` $sql_match_operator '$input'\";\n                    $table['average'] = \"LEFT JOIN (SELECT `object_id`, ROUND(AVG(IFNULL(`rating`.`rating`,0))) AS \" .\n                        \"`avg` FROM `rating` WHERE `rating`.`object_type`='artist' GROUP BY `object_id`) AS \" .\n                        \"`average_rating` on `average_rating`.`object_id` = `artist`.`id` \";\n                    break;\n                case 'favorite':\n                    $where[] = \"(`artist`.`name` $sql_match_operator '$input'  OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) $sql_match_operator '$input') \" .\n                               \"AND `favorite_artist_$userid`.`user` = $userid \" .\n                               \"AND `favorite_artist_$userid`.`object_type` = 'artist'\";\n                    // flag once per user\n                    $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_artist_$userid\")) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                        \"FROM `user_flag` WHERE `user` = $userid) AS `favorite_artist_$userid` \" .\n                        \"ON `artist`.`id`=`favorite_artist_$userid`.`object_id` \" .\n                        \"AND `favorite_artist_$userid`.`object_type` = 'artist' \" : ' ';\n                    break;\n                case 'has image':\n                case 'has_image':\n                    $where[]            = ($sql_match_operator == '1') ? \"`has_image`.`object_id` IS NOT NULL\" : \"`has_image`.`object_id` IS NULL\";\n                    $table['has_image'] = \"LEFT JOIN (SELECT `object_id` from `image` WHERE `object_type` = 'artist') as `has_image` ON `artist`.`id` = `has_image`.`object_id`\";\n                    break;\n                case 'image height':\n                case 'image_height':\n                case 'image width':\n                case 'image_width':\n                    $looking       = strpos($rule[0], \"image_\") ? str_replace('image_', '', $rule[0]) : str_replace('image ', '', $rule[0]);\n                    $where[]       = \"`image`.`$looking` $sql_match_operator '$input'\";\n                    $join['image'] = true;\n                    break;\n                case 'myrating':\n                    // combine these as they all do the same thing just different tables\n                    $column  = 'id';\n                    $my_type = 'artist';\n                    if ($input == 0 && $sql_match_operator == '>=') {\n                        break;\n                    }\n                    if ($input == 0 && $sql_match_operator == '<') {\n                        $input              = -1;\n                        $sql_match_operator = '=';\n                    }\n                    if ($input == 0 && $sql_match_operator == '<>') {\n                        $input              = 1;\n                        $sql_match_operator = '>=';\n                    }\n                    if (($input == 0 && $sql_match_operator != '>') || ($input == 1 && $sql_match_operator == '<')) {\n                        $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL\";\n                    } elseif ($sql_match_operator == '<>' || $sql_match_operator == '<' || $sql_match_operator == '<=' || $sql_match_operator == '!=') {\n                        $where[] = \"(`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input OR `rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL)\";\n                    } else {\n                        $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input\";\n                    }\n                    // rating once per user\n                    $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `rating` FROM `rating` \" .\n                        \"WHERE `user` = $userid AND `object_type`='$my_type') \" .\n                        \"AS `rating_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `rating_\" . $my_type . \"_\" . $userid . \"`.`object_id`=`artist`.`$column` \" : ' ';\n                    break;\n                case 'myplayed':\n                    $column       = 'id';\n                    $my_type      = 'artist';\n                    $operator_sql = ((int) $sql_match_operator == 0) ? 'IS NULL' : 'IS NOT NULL';\n                    // played once per user\n                    $table['myplayed'] .= (!strpos((string) $table['myplayed'], \"myplayed_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS \" .\n                        \"`myplayed_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `artist`.`$column`=`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` $operator_sql\";\n                    break;\n                case 'last_play':\n                    $my_type = 'artist';\n                    $table['last_play'] .= (!strpos((string) $table['last_play'], \"last_play_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_play_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `artist`.`id`=`last_play_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_play_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`last_play_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    break;\n                case 'last_skip':\n                    $my_type = 'artist';\n                    $table['last_skip'] .= (!strpos((string) $table['last_skip'], \"last_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'skip' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = 'song' \" : ' ';\n                    $where[]      = \"`last_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    $join['song'] = true;\n                    break;\n                case 'last_play_or_skip':\n                    $my_type = 'artist';\n                    $table['last_play_or_skip'] .= (!strpos((string) $table['last_play_or_skip'], \"last_play_or_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` IN ('stream', 'skip') \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_play_or_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = 'song' \" : ' ';\n                    $where[]      = \"`last_play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    $join['song'] = true;\n                    break;\n                case 'played_times':\n                    $where[] = \"`artist`.`id` IN (SELECT `object_count`.`object_id` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'artist' AND `object_count`.`count_type` = 'stream' \" .\n                        \"GROUP BY `object_count`.`object_id` HAVING COUNT(*) $sql_match_operator '$input')\";\n                    break;\n                case 'other_user':\n                    $other_userid = $input;\n                    if ($sql_match_operator == 'userflag') {\n                        $where[] = \"`favorite_artist_$other_userid`.`user` = $other_userid \" .\n                            \" AND `favorite_artist_$other_userid`.`object_type` = 'artist'\";\n                        // flag once per user\n                        $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_artist_$other_userid\")) ?\n                            \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                            \"FROM `user_flag` WHERE `user` = $other_userid) AS `favorite_artist_$other_userid` \" .\n                            \"ON `song`.`artist`=`favorite_artist_$other_userid`.`object_id` \" .\n                            \"AND `favorite_artist_$other_userid`.`object_type` = 'artist' \" : ' ';\n                    } else {\n                        $column  = 'id';\n                        $my_type = 'artist';\n                        $where[] = \"`rating_artist_\" . $other_userid . '`.' . $sql_match_operator .\n                                   \" AND `rating_artist_$other_userid`.`user` = $other_userid \" .\n                                   \" AND `rating_artist_$other_userid`.`object_type` = 'artist'\";\n                        // rating once per user\n                        $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $userid)) ?\n                            \"LEFT JOIN `rating` AS `rating_\" . $my_type . \"_\" . $userid . \"` ON \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`object_type`='$my_type' AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`object_id`=`$my_type`.`$column` AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $userid . \"`.`user` = $userid \" : ' ';\n                    }\n                    break;\n                case 'mbid':\n                    $where[] = \"`artist`.`mbid` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype artist\n        } // foreach rule\n\n        $join['song']    = $join['song'] || AmpConfig::get('catalog_disable');\n        $join['catalog'] = AmpConfig::get('catalog_disable');\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        foreach ($join['tag'] as $key => $value) {\n            $table['tag_' . $key] =\n                \"LEFT JOIN (\" .\n                \"SELECT `object_id`, GROUP_CONCAT(`name`) AS `name` \" .\n                \"FROM `tag` LEFT JOIN `tag_map` \" .\n                \"ON `tag`.`id`=`tag_map`.`tag_id` \" .\n                \"WHERE `tag_map`.`object_type`='artist' \" .\n                \"GROUP BY `object_id`\" .\n                \") AS `realtag_$key` \" .\n                \"ON `artist`.`id`=`realtag_$key`.`object_id`\";\n        }\n\n        if ($join['song']) {\n            $table['0_song'] = \"LEFT JOIN `song` ON `song`.`artist`=`artist`.`id`\";\n\n            if ($join['catalog']) {\n                $table['catalog'] = \"LEFT JOIN `catalog` AS `catalog_se` ON `catalog_se`.`id`=`song`.`catalog`\";\n                if (!empty($where_sql)) {\n                    $where_sql .= \" AND `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                } else {\n                    $where_sql .= \" `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                }\n            }\n        }\n        if ($join['count']) {\n            $table['object_count'] = \"LEFT JOIN (SELECT `object_count`.`object_id`, MAX(`object_count`.`date`) AS \" .\n                \"`date` FROM `object_count` WHERE `object_count`.`object_type` = 'artist' AND \" .\n                \"`object_count`.`user`='\" . $userid . \"' AND `object_count`.`count_type` = 'stream' GROUP BY `object_count`.`object_id`) AS \" .\n                \"`object_count` ON `object_count`.`object_id`=`artist`.`id`\";\n        }\n        if ($join['image']) {\n            $table['0_song'] = \"LEFT JOIN `song` ON `song`.`artist`=`artist`.`id` LEFT JOIN `image` ON `image`.`object_id`=`artist`.`id`\";\n            $where_sql .= \" AND `image`.`object_type`='artist'\";\n            $where_sql .= \" AND `image`.`size`='original'\";\n        }\n        ksort($table);\n        $table_sql  = implode(' ', $table);\n        $group_sql  = implode(',', $group);\n        $having_sql = implode(\" $sql_logic_operator \", $having);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`artist`.`id`), `artist`.`name` FROM `artist`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => $table_sql,\n            'group_sql' => $group_sql,\n            'having_sql' => $having_sql\n        );\n    }\n\n    /**\n     * song_to_sql\n     * Handles the generation of the SQL for song searches.\n     * @return array\n     */\n    private function song_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $userid             = $this->search_user->id;\n\n        $where       = array();\n        $table       = array();\n        $join        = array();\n        $group       = array();\n        $having      = array();\n        $join['tag'] = array();\n        $metadata    = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'anywhere':\n                    $key = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE') {\n                        $tag_string        = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($sql_match_operator == 'NOT LIKE') {\n                        $tag_string        = \"`realtag_$key`.`name` IS NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($operator['description'] == 'is') {\n                        $tag_string        = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } elseif ($operator['description'] == 'is not') {\n                        $tag_string        = \"`realtag_$key`.`name` IS NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } else {\n                        $tag_string        = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0 \";\n                        $join['tag'][$key] = \"AND find_in_set('$input', cast(`name` as char)) $sql_match_operator 0 \";\n                    }\n                    // we want AND NOT and like for this query to really exclude them\n                    if ($sql_match_operator == 'NOT LIKE' || $sql_match_operator == 'NOT' || $sql_match_operator == '!=') {\n                        $where[] = \"NOT ((`artist`.`name` LIKE '$input' OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) LIKE '$input') OR \" .\n                                   \"(`album`.`name` LIKE '$input' OR LTRIM(CONCAT(COALESCE(`album`.`prefix`, ''), ' ', `album`.`name`)) LIKE '$input') OR \" .\n                                   \"`song_data`.`comment` LIKE '$input' OR `song_data`.`label` LIKE '$input' OR `song`.`file` LIKE '$input' OR \" .\n                                   \"`song`.`title` LIKE '$input' OR NOT \" . $tag_string . ')';\n                    } else {\n                        $where[] = \"((`artist`.`name` $sql_match_operator '$input' OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), ' ', `artist`.`name`)) $sql_match_operator '$input') OR \" .\n                                   \"(`album`.`name` $sql_match_operator '$input' OR LTRIM(CONCAT(COALESCE(`album`.`prefix`, ''), ' ', `album`.`name`)) $sql_match_operator '$input') OR \" .\n                                   \"`song_data`.`comment` $sql_match_operator '$input' OR `song_data`.`label` $sql_match_operator '$input' OR `song`.`file` $sql_match_operator '$input' OR \" .\n                                   \"`song`.`title` $sql_match_operator '$input' OR \" . $tag_string . ')';\n                    }\n                    // join it all up\n                    $table['album']    = \"LEFT JOIN `album` ON `song`.`album`=`album`.`id`\";\n                    $table['artist']   = \"LEFT JOIN `artist` ON `song`.`artist`=`artist`.`id`\";\n                    $join['song_data'] = true;\n                    break;\n                case 'tag':\n                    $key = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE') {\n                        $where[]           = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($sql_match_operator == 'NOT LIKE') {\n                        $where[]           = \"`realtag_$key`.`name` IS NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($operator['description'] == 'is') {\n                        $where[]           = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } elseif ($operator['description'] == 'is not') {\n                        $where[]           = \"`realtag_$key`.`name` IS NULL \";\n                        $join['tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } else {\n                        $where[]           = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0 \";\n                        $join['tag'][$key] = \"AND find_in_set('$input', cast(`name` as char)) $sql_match_operator 0 \";\n                    }\n                    break;\n                case 'album_tag':\n                    $table['album'] = \"LEFT JOIN `album` ON `song`.`album`=`album`.`id`\";\n                    $key            = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE') {\n                        $where[]                 = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['album_tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($sql_match_operator == 'NOT LIKE') {\n                        $where[]                 = \"`realtag_$key`.`name` IS NULL \";\n                        $join['album_tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($operator['description'] == 'is') {\n                        $where[]                 = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['album_tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } elseif ($operator['description'] == 'is not') {\n                        $where[]                 = \"`realtag_$key`.`name` IS NULL \";\n                        $join['album_tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } else {\n                        $where[]                 = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0 \";\n                        $join['album_tag'][$key] = \"AND find_in_set('$input', cast(`name` as char)) $sql_match_operator 0 \";\n                    }\n                    break;\n                case 'artist_tag':\n                    $table['artist'] = \"LEFT JOIN `artist` ON `song`.`artist`=`artist`.`id`\";\n                    $key             = md5($input . $sql_match_operator);\n                    if ($sql_match_operator == 'LIKE') {\n                        $where[]                  = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['artist_tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($sql_match_operator == 'NOT LIKE') {\n                        $where[]                  = \"`realtag_$key`.`name` IS NULL \";\n                        $join['artist_tag'][$key] = \"AND `tag`.`name` LIKE '$input' \";\n                    } elseif ($operator['description'] == 'is') {\n                        $where[]                  = \"`realtag_$key`.`name` IS NOT NULL \";\n                        $join['artist_tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } elseif ($operator['description'] == 'is not') {\n                        $where[]                  = \"`realtag_$key`.`name` IS NULL \";\n                        $join['artist_tag'][$key] = \"AND `tag`.`name` = '$input' \";\n                    } else {\n                        $where[]                  = \"find_in_set('$input', cast(`realtag_$key`.`name` as char)) $sql_match_operator 0 \";\n                        $join['artist_tag'][$key] = \"AND find_in_set('$input', cast(`name` as char)) $sql_match_operator 0 \";\n                    }\n                    break;\n                case 'title':\n                    $where[] = \"`song`.`title` $sql_match_operator '$input'\";\n                    break;\n                case 'album':\n                    $where[]        = \"(`album`.`name` $sql_match_operator '$input' \" .\n                                      \" OR LTRIM(CONCAT(COALESCE(`album`.`prefix`, ''), \" .\n                                      \"' ', `album`.`name`)) $sql_match_operator '$input')\";\n                    $table['album'] = \"LEFT JOIN `album` ON `song`.`album`=`album`.`id`\";\n                    break;\n                case 'artist':\n                    $where[]         = \"(`artist`.`name` $sql_match_operator '$input' \" .\n                                       \" OR LTRIM(CONCAT(COALESCE(`artist`.`prefix`, ''), \" .\n                                       \"' ', `artist`.`name`)) $sql_match_operator '$input')\";\n                    $table['artist'] = \"LEFT JOIN `artist` ON `song`.`artist`=`artist`.`id`\";\n                    break;\n                case 'album_artist':\n                    $where[]         = \"(`album_artist`.`name` $sql_match_operator '$input' \" .\n                        \" OR LTRIM(CONCAT(COALESCE(`album_artist`.`prefix`, ''), \" .\n                        \"' ', `album_artist`.`name`)) $sql_match_operator '$input')\";\n                    $table['album']        = \"LEFT JOIN `album` ON `song`.`album`=`album`.`id`\";\n                    $table['album_artist'] = \"LEFT JOIN `artist` AS `album_artist` ON `album`.`album_artist`=`album_artist`.`id`\";\n                    break;\n                case 'composer':\n                    $where[] = \"`song`.`composer` $sql_match_operator '$input'\";\n                    break;\n                case 'time':\n                    $input   = $input * 60;\n                    $where[] = \"`song`.`time` $sql_match_operator '$input'\";\n                    break;\n                case 'file':\n                    $where[] = \"`song`.`file` $sql_match_operator '$input'\";\n                    break;\n                case 'year':\n                    $where[] = \"`song`.`year` $sql_match_operator '$input'\";\n                    break;\n                case 'comment':\n                    $where[]           = \"`song_data`.`comment` $sql_match_operator '$input'\";\n                    $join['song_data'] = true;\n                    break;\n                case 'label':\n                    $where[]           = \"`song_data`.`label` $sql_match_operator '$input'\";\n                    $join['song_data'] = true;\n                    break;\n                case 'lyrics':\n                    $where[]           = \"`song_data`.`lyrics` $sql_match_operator '$input'\";\n                    $join['song_data'] = true;\n                    break;\n                case 'played':\n                    $where[] = \"`song`.`played` = '$sql_match_operator'\";\n                    break;\n                case 'last_play':\n                    $my_type = 'song';\n                    $table['last_play'] .= (!strpos((string) $table['last_play'], \"last_play_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_play_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_play_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_play_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`last_play_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    break;\n                case 'last_skip':\n                    $my_type = 'song';\n                    $table['last_skip'] .= (!strpos((string) $table['last_skip'], \"last_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'skip' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `last_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `last_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`last_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    break;\n                case 'last_play_or_skip':\n                    $my_type = 'song';\n                    $table['last_play_or_skip'] .= (!strpos((string) $table['play_or_skip'], \"play_or_skip_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user`, MAX(`date`) AS `date` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` IN ('stream', 'skip') \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS `play_or_skip_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`id`=`play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`play_or_skip_\" . $my_type . \"_\" . $userid . \"`.`date` $sql_match_operator (UNIX_TIMESTAMP() - ($input * 86400))\";\n                    break;\n                case 'played_times':\n                    $where[] = \"`song`.`id` IN (SELECT `object_count`.`object_id` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'stream' \" .\n                        \"GROUP BY `object_count`.`object_id` HAVING COUNT(*) $sql_match_operator '$input')\";\n                    break;\n                case 'skipped_times':\n                    $where[] = \"`song`.`id` IN (SELECT `object_count`.`object_id` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` = 'skip' \" .\n                        \"GROUP BY `object_count`.`object_id` HAVING COUNT(*) $sql_match_operator '$input')\";\n                    break;\n                case 'played_or_skipped_times':\n                    $where[] = \"`song`.`id` IN (SELECT `object_count`.`object_id` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = 'song' AND `object_count`.`count_type` IN ('stream', 'skip') \" .\n                        \"GROUP BY `object_count`.`object_id` HAVING COUNT(*) $sql_match_operator '$input')\";\n                    break;\n                case 'play_skip_ratio':\n                    $where[] = \"`song`.`id` IN (SELECT `song`.`id` FROM `song` \" .\n                        \"LEFT JOIN (SELECT COUNT(`object_id`) AS `counting`, `object_id`, `count_type` \" .\n                        \"FROM `object_count` WHERE `object_type` = 'song' AND `count_type` = 'stream' \" .\n                        \"GROUP BY `object_id`, `count_type`) AS `stream_count` on `song`.`id` = `stream_count`.`object_id`\" .\n                        \"LEFT JOIN (SELECT COUNT(`object_id`) AS `counting`, `object_id`, `count_type` \" .\n                        \"FROM `object_count` WHERE `object_type` = 'song' AND `count_type` = 'skip' \" .\n                        \"GROUP BY `object_id`, `count_type`) AS `skip_count` on `song`.`id` = `skip_count`.`object_id` \" .\n                        \"WHERE ((IFNULL(`stream_count`.`counting`, 0)/IFNULL(`skip_count`.`counting`, 0)) * 100) \" .\n                        \"$sql_match_operator '$input' GROUP BY `song`.`id`)\";\n                    break;\n                case 'myplayed':\n                case 'myplayedalbum':\n                case 'myplayedartist':\n                    // combine these as they all do the same thing just different tables\n                    $looking      = str_replace('myplayed', '', $rule[0]);\n                    $column       = ($looking == '') ? 'id' : $looking;\n                    $my_type      = ($looking == '') ? 'song' : $looking;\n                    $operator_sql = ((int) $sql_match_operator == 0) ? 'IS NULL' : 'IS NOT NULL';\n                    // played once per user\n                    $table['myplayed'] .= (!strpos((string) $table['myplayed'], \"myplayed_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` FROM `object_count` \" .\n                        \"WHERE `object_count`.`object_type` = '$my_type' AND `object_count`.`count_type` = 'stream' \" .\n                        \"AND `object_count`.`user`=$userid GROUP BY `object_id`, `object_type`, `user`) AS \" .\n                        \"`myplayed_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `song`.`$column`=`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` \" .\n                        \"AND `myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    $where[] = \"`myplayed_\" . $my_type . \"_\" . $userid . \"`.`object_id` $operator_sql\";\n                    break;\n                case 'bitrate':\n                    $input   = $input * 1000;\n                    $where[] = \"`song`.`bitrate` $sql_match_operator '$input'\";\n                    break;\n                case 'rating':\n                    // average ratings only\n                    $where[]          = \"`average_rating`.`avg` $sql_match_operator '$input'\";\n                    $table['average'] = \"LEFT JOIN (SELECT `object_id`, ROUND(AVG(IFNULL(`rating`.`rating`,0))) AS \" .\n                        \"`avg` FROM `rating` WHERE `rating`.`object_type`='song' GROUP BY `object_id`) AS \" .\n                        \"`average_rating` on `average_rating`.`object_id` = `song`.`id` \";\n                    break;\n                case 'favorite':\n                    $where[] = \"`song`.`title` $sql_match_operator '$input' \" .\n                               \"AND `favorite_song_$userid`.`user` = $userid \" .\n                               \"AND `favorite_song_$userid`.`object_type` = 'song'\";\n                    // flag once per user\n                    $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_song_$userid\")) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                        \"FROM `user_flag` WHERE `user` = $userid) AS `favorite_song_$userid` \" .\n                        \"ON `song`.`id`=`favorite_song_$userid`.`object_id` \" .\n                        \"AND `favorite_song_$userid`.`object_type` = 'song' \" : ' ';\n                    break;\n                case 'myrating':\n                case 'albumrating':\n                case 'artistrating':\n                    // combine these as they all do the same thing just different tables\n                    $looking = str_replace('rating', '', $rule[0]);\n                    $column  = ($looking == 'my') ? 'id' : $looking;\n                    $my_type = ($looking == 'my') ? 'song' : $looking;\n                    if ($input == 0 && $sql_match_operator == '>=') {\n                        break;\n                    }\n                    if ($input == 0 && $sql_match_operator == '<') {\n                        $input              = -1;\n                        $sql_match_operator = '=';\n                    }\n                    if ($input == 0 && $sql_match_operator == '<>') {\n                        $input              = 1;\n                        $sql_match_operator = '>=';\n                    }\n                    if (($input == 0 && $sql_match_operator != '>') || ($input == 1 && $sql_match_operator == '<')) {\n                        $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL\";\n                    } elseif ($sql_match_operator == '<>' || $sql_match_operator == '<' || $sql_match_operator == '<=' || $sql_match_operator == '!=') {\n                        $where[] = \"(`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input OR `rating_\" . $my_type . \"_\" . $userid . \"`.`rating` IS NULL)\";\n                    } else {\n                        $where[] = \"`rating_\" . $my_type . \"_\" . $userid . \"`.`rating` $sql_match_operator $input\";\n                    }\n                    // rating once per user\n                    $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $userid)) ?\n                        \"LEFT JOIN (SELECT `object_id`, `object_type`, `rating` FROM `rating` \" .\n                        \"WHERE `user` = $userid AND `object_type`='$my_type') \" .\n                        \"AS `rating_\" . $my_type . \"_\" . $userid . \"` \" .\n                        \"ON `rating_\" . $my_type . \"_\" . $userid . \"`.`object_id`=`song`.`$column` \" : ' ';\n                    break;\n                case 'catalog':\n                    $where[] = \"`song`.`catalog` $sql_match_operator '$input'\";\n                    break;\n                case 'other_user':\n                case 'other_user_album':\n                case 'other_user_artist':\n                    // combine these as they all do the same thing just different tables\n                    $looking      = str_replace('other_user_', '', $rule[0]);\n                    $column       = ($looking == 'other_user') ? 'id' : $looking;\n                    $my_type      = ($looking == 'other_user') ? 'song' : $looking;\n                    $other_userid = $input;\n                    if ($sql_match_operator == 'userflag') {\n                        $where[] = \"`favorite_\" . $my_type . \"_\" . $other_userid . \"`.`user` = $other_userid \" .\n                                   \" AND `favorite_\" . $my_type . \"_\" . $other_userid . \"`.`object_type` = '$my_type'\";\n                        // flag once per user\n                        $table['favorite'] .= (!strpos((string) $table['favorite'], \"favorite_\" . $my_type . \"_\" . $other_userid . \"\")) ?\n                            \"LEFT JOIN (SELECT `object_id`, `object_type`, `user` \" .\n                            \"from `user_flag` WHERE `user` = $other_userid) AS `favorite_\" . $my_type . \"_\" . $other_userid . \"` \" .\n                            \"ON `song`.`$column`=`favorite_\" . $my_type . \"_\" . $other_userid . \"`.`object_id` \" .\n                            \"AND `favorite_\" . $my_type . \"_\" . $other_userid . \"`.`object_type` = '$my_type' \" : ' ';\n                    } else {\n                        $unrated = ($sql_match_operator == 'unrated');\n                        $where[] = ($unrated) ? \"`song`.`$column` NOT IN (SELECT `object_id` FROM `rating` WHERE `object_type` = '$my_type' AND `user` = $other_userid)\" :\n                            \"`rating_\" . $my_type . \"_\" . $other_userid . \"`.$sql_match_operator\" .\n                            \" AND `rating_\" . $my_type . \"_\" . $other_userid . \"`.`user` = $other_userid \" .\n                            \" AND `rating_\" . $my_type . \"_\" . $other_userid . \"`.`object_type` = '$my_type'\";\n                        // rating once per user\n                        $table['rating'] .= (!strpos((string) $table['rating'], \"rating_\" . $my_type . \"_\" . $other_userid)) ?\n                            \"LEFT JOIN `rating` AS `rating_\" . $my_type . \"_\" . $other_userid . \"` ON \" .\n                            \"`rating_\" . $my_type . \"_\" . $other_userid . \"`.`object_type`='$my_type' AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $other_userid . \"`.`object_id`=`song`.`$column` AND \" .\n                            \"`rating_\" . $my_type . \"_\" . $other_userid . \"`.`user` = $other_userid \" : ' ';\n                    }\n                    break;\n                case 'playlist_name':\n                    $join['playlist']      = true;\n                    $join['playlist_data'] = true;\n                    $where[]               = \"`playlist`.`name` $sql_match_operator '$input'\";\n                    break;\n                case 'playlist':\n                    $join['playlist_data'] = true;\n                    $where[]               = \"`playlist_data`.`playlist` $sql_match_operator '$input'\";\n                    break;\n                case 'smartplaylist':\n                    $subsearch    = new Search($input, 'song', $this->search_user);\n                    $subsql       = $subsearch->to_sql();\n                    $results      = $subsearch->get_items();\n                    $itemstring   = '';\n                    if (count($results) > 0) {\n                        foreach ($results as $item) {\n                            $itemstring .= ' ' . $item['object_id'] . ',';\n                        }\n                        $table['smart'] .= (!strpos((string) $table['smart'], \"smart_\" . $input)) ?\n                            \"LEFT JOIN (SELECT `id` FROM `song` \" .\n                            \"WHERE `id` $sql_match_operator IN (\" . substr($itemstring, 0, -1) . \")) \" .\n                            \"AS `smartlist_$input` ON `smartlist_$input`.`id` = `song`.`id`\" : ' ';\n                        $where[]  = \"`smartlist_$input`.`id` IS NOT NULL\";\n                        // HACK: array_merge would potentially lose tags, since it\n                        // overwrites. Save our merged tag joins in a temp variable,\n                        // even though that's ugly.\n                        $tagjoin     = array_merge($subsql['join']['tag'], $join['tag']);\n                        $join        = array_merge($subsql['join'], $join);\n                        $join['tag'] = $tagjoin;\n                    }\n                    break;\n                case 'license':\n                    $where[] = \"`song`.`license` $sql_match_operator '$input'\";\n                    break;\n                case 'added':\n                    $input   = strtotime($input);\n                    $where[] = \"`song`.`addition_time` $sql_match_operator $input\";\n                    break;\n                case 'updated':\n                    $input         = strtotime($input);\n                    $where[]       = \"`song`.`update_time` $sql_match_operator $input\";\n                    break;\n                case 'recent_added':\n                    $key                       = md5($input . $sql_match_operator);\n                    $where[]                   = \"`addition_time_$key`.`id` IS NOT NULL\";\n                    $table['addition_' . $key] = \"LEFT JOIN (SELECT `id` from `song` ORDER BY $sql_match_operator DESC LIMIT $input) as `addition_time_$key` ON `song`.`id` = `addition_time_$key`.`id`\";\n                    break;\n                case 'recent_updated':\n                    $key                     = md5($input . $sql_match_operator);\n                    $where[]                 = \"`update_time_$key`.`id` IS NOT NULL\";\n                    $table['update_' . $key] = \"LEFT JOIN (SELECT `id` from `song` ORDER BY $sql_match_operator DESC LIMIT $input) as `update_time_$key` ON `song`.`id` = `update_time_$key`.`id`\";\n                    break;\n                case 'mbid':\n                    $where[] = \"`song`.`mbid` $sql_match_operator '$input'\";\n                    break;\n                case 'mbid_album':\n                    $table['album'] = \"LEFT JOIN `album` ON `song`.`album`=`album`.`id`\";\n                    $where[]        = \"`album`.`mbid` $sql_match_operator '$input'\";\n                    break;\n                case 'mbid_artist':\n                    $table['artist'] = \"LEFT JOIN `artist` ON `song`.`artist`=`artist`.`id`\";\n                    $where[]         = \"`artist`.`mbid` $sql_match_operator '$input'\";\n                    break;\n                case 'metadata':\n                    $field = (int) $rule[3];\n                    if ($sql_match_operator === '=' && strlen($input) == 0) {\n                        $where[] = \"NOT EXISTS (SELECT NULL FROM `metadata` WHERE `metadata`.`object_id` = `song`.`id` AND `metadata`.`field` = {$field})\";\n                    } else {\n                        $parsedInput = is_numeric($input) ? $input : '\"' . $input . '\"';\n                        if (!array_key_exists($field, $metadata)) {\n                            $metadata[$field] = array();\n                        }\n                        $metadata[$field][] = \"`metadata`.`data` $sql_match_operator $parsedInput\";\n                    }\n                    break;\n                default:\n                    break;\n            } // switch on ruletype song\n        } // foreach over rules\n\n        // translate metadata queries into sql for each field\n        foreach ($metadata as $metadata_field => $metadata_queries) {\n            $metadata_sql  = \"EXISTS (SELECT NULL FROM `metadata` WHERE `metadata`.`object_id` = `song`.`id` AND `metadata`.`field` = {$metadata_field} AND (\";\n            $metadata_sql .= implode(\" $sql_logic_operator \", $metadata_queries);\n            $where[]   = $metadata_sql . '))';\n        }\n\n        $join['catalog'] = AmpConfig::get('catalog_disable');\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        // now that we know which things we want to JOIN...\n        if ($join['song_data']) {\n            $table['song_data'] = \"LEFT JOIN `song_data` ON `song`.`id`=`song_data`.`song_id`\";\n        }\n        if ($join['tag']) {\n            foreach ($join['tag'] as $key => $value) {\n                $table['tag_' . $key] =\n                    \"LEFT JOIN (\" .\n                    \"SELECT `object_id`, GROUP_CONCAT(`name`) AS `name` \" .\n                    \"FROM `tag` LEFT JOIN `tag_map` \" .\n                    \"ON `tag`.`id`=`tag_map`.`tag_id` \" .\n                    \"WHERE `tag_map`.`object_type`='song' \" .\n                    \"$value\" .\n                    \"GROUP BY `object_id`\" .\n                    \") AS `realtag_$key` \" .\n                    \"ON `song`.`id`=`realtag_$key`.`object_id`\";\n            }\n        }\n        if ($join['album_tag']) {\n            foreach ($join['album_tag'] as $key => $value) {\n                $table['tag_' . $key] =\n                    \"LEFT JOIN (\" .\n                    \"SELECT `object_id`, GROUP_CONCAT(`name`) AS `name` \" .\n                    \"FROM `tag` LEFT JOIN `tag_map` \" .\n                    \"ON `tag`.`id`=`tag_map`.`tag_id` \" .\n                    \"WHERE `tag_map`.`object_type`='album' \" .\n                    \"$value\" .\n                    \"GROUP BY `object_id`\" .\n                    \") AS `realtag_$key` \" .\n                    \"ON `album`.`id`=`realtag_$key`.`object_id`\";\n            }\n        }\n        if ($join['artist_tag']) {\n            foreach ($join['artist_tag'] as $key => $value) {\n                $table['tag_' . $key] =\n                    \"LEFT JOIN (\" .\n                    \"SELECT `object_id`, GROUP_CONCAT(`name`) AS `name` \" .\n                    \"FROM `tag` LEFT JOIN `tag_map` \" .\n                    \"ON `tag`.`id`=`tag_map`.`tag_id` \" .\n                    \"WHERE `tag_map`.`object_type`='artist' \" .\n                    \"$value\" .\n                    \"GROUP BY `object_id`\" .\n                    \") AS `realtag_$key` \" .\n                    \"ON `artist`.`id`=`realtag_$key`.`object_id`\";\n            }\n        }\n        if ($join['playlist_data']) {\n            $table['playlist_data'] = \"LEFT JOIN `playlist_data` ON `song`.`id`=`playlist_data`.`object_id` AND `playlist_data`.`object_type`='song'\";\n            if ($join['playlist']) {\n                $table['playlist'] = \"LEFT JOIN `playlist` ON `playlist_data`.`playlist`=`playlist`.`id`\";\n            }\n        }\n        if ($join['catalog']) {\n            $table['catalog'] = \"LEFT JOIN `catalog` AS `catalog_se` ON `catalog_se`.`id`=`song`.`catalog`\";\n            if (!empty($where_sql)) {\n                $where_sql .= \" AND `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n            } else {\n                $where_sql .= \" `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n            }\n        }\n        ksort($table);\n        $table_sql  = implode(' ', $table);\n        $group_sql  = implode(',', $group);\n        $having_sql = implode(\" $sql_logic_operator \", $having);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`song`.`id`), `song`.`file` FROM `song`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => $table_sql,\n            'group_sql' => $group_sql,\n            'having_sql' => $having_sql\n        );\n    }\n\n    /**\n     * video_to_sql\n     *\n     * Handles the generation of the SQL for video searches.\n     * @return array\n     */\n    private function video_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n\n        $where  = array();\n        $table  = array();\n        $join   = array();\n        $group  = array();\n        $having = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'file':\n                    $where[] = \"`video`.`file` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype\n        } // foreach rule\n\n        $join['catalog'] = AmpConfig::get('catalog_disable');\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        if ($join['catalog']) {\n            $table['catalog'] = \"LEFT JOIN `catalog` AS `catalog_se` ON `catalog_se`.`id`=`video`.`catalog`\";\n            if (!empty($where_sql)) {\n                $where_sql .= \" AND `catalog_se`.`enabled` = '1'\";\n            } else {\n                $where_sql .= \" `catalog_se`.`enabled` = '1'\";\n            }\n        }\n        ksort($table);\n        $table_sql  = implode(' ', $table);\n        $group_sql  = implode(',', $group);\n        $having_sql = implode(\" $sql_logic_operator \", $having);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`video`.`id`), `video`.`file` FROM `video`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => $table_sql,\n            'group_sql' => $group_sql,\n            'having_sql' => $having_sql\n        );\n    }\n\n    /**\n     * playlist_to_sql\n     *\n     * Handles the generation of the SQL for playlist searches.\n     * @return array\n     */\n    private function playlist_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $where              = array();\n        $table              = array();\n        $join               = array();\n        $group              = array();\n        $having             = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            $where[] = \"(`playlist`.`type` = 'public' OR `playlist`.`user`=\" . $this->search_user->id . \")\";\n\n            switch ($rule[0]) {\n                case 'title':\n                case 'name':\n                    $where[] = \"`playlist`.`name` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype\n        } // foreach rule\n\n        $join['playlist_data'] = true;\n        $join['song']          = $join['song'] || AmpConfig::get('catalog_disable');\n        $join['catalog']       = AmpConfig::get('catalog_disable');\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        if ($join['playlist_data']) {\n            $table['playlist_data'] = \"LEFT JOIN `playlist_data` ON `playlist_data`.`playlist` = `playlist`.`id`\";\n        }\n\n        if ($join['song']) {\n            $table['0_song'] = \"LEFT JOIN `song` ON `song`.`id`=`playlist_data`.`object_id`\";\n            $where_sql .= \" AND `playlist_data`.`object_type` = 'song'\";\n\n            if ($join['catalog']) {\n                $table['catalog'] = \"LEFT JOIN `catalog` AS `catalog_se` ON `catalog_se`.`id`=`song`.`catalog`\";\n                if (!empty($where_sql)) {\n                    $where_sql .= \" AND `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                } else {\n                    $where_sql .= \" `catalog_se`.`enabled` = '1' AND `song`.`enabled` = 1\";\n                }\n            }\n        }\n        ksort($table);\n        $table_sql  = implode(' ', $table);\n        $group_sql  = implode(',', $group);\n        $having_sql = implode(\" $sql_logic_operator \", $having);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`playlist`.`id`), `playlist`.`name` FROM `playlist`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => $table_sql,\n            'group_sql' => $group_sql,\n            'having_sql' => $having_sql\n        );\n    }\n\n    /**\n     * label_to_sql\n     *\n     * Handles the generation of the SQL for label searches.\n     * @return array\n     */\n    private function label_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $where              = array();\n        $table              = array();\n        $join               = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'title':\n                case 'name':\n                    $where[] = \"`label`.`name` $sql_match_operator '$input'\";\n                    break;\n                case 'category':\n                    $where[] = \"`label`.`category` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype\n        } // foreach rule\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`label`.`id`), `label`.`name` FROM `label`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => '',\n            'group_sql' => '',\n            'having_sql' => ''\n        );\n    }\n\n    /**\n       * tag_to_sql\n       *\n       * Handles the generation of the SQL for tag (genre) searches.\n       * @return array\n       */\n\n    private function tag_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $where              = array();\n        $table              = array();\n        $join               = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'title':\n                case 'name':\n                    $where[] = \"`tag`.`name` $sql_match_operator '$input'\";\n                    break;\n                case 'category':\n                    $where[] = \"`tag`.`category` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype\n        } // foreach rule\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`tag`.`id`) FROM `tag`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => '',\n            'group_sql' => '',\n            'having_sql' => ''\n        );\n    }\n\n    /**\n     * user_to_sql\n     *\n     * Handles the generation of the SQL for user searches.\n     * @return array\n     */\n    private function user_to_sql()\n    {\n        $sql_logic_operator = $this->logic_operator;\n        $where              = array();\n        $table              = array();\n        $join               = array();\n\n        foreach ($this->rules as $rule) {\n            $type     = $this->name_to_basetype($rule[0]);\n            $operator = array();\n            if (!$type) {\n                return array();\n            }\n            foreach ($this->basetypes[$type] as $op) {\n                if ($op['name'] == $rule[1]) {\n                    $operator = $op;\n                    break;\n                }\n            }\n            $raw_input          = $this->_mangle_data($rule[2], $type, $operator);\n            $input              = filter_var($raw_input, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);\n            $sql_match_operator = $operator['sql'];\n\n            switch ($rule[0]) {\n                case 'username':\n                    $where[] = \"`user`.`username` $sql_match_operator '$input'\";\n                    break;\n                default:\n                    break;\n            } // switch on ruletype\n        } // foreach rule\n\n        $where_sql = implode(\" $sql_logic_operator \", $where);\n        ksort($table);\n\n        return array(\n            'base' => 'SELECT DISTINCT(`user`.`id`), `user`.`username` FROM `user`',\n            'join' => $join,\n            'where' => $where,\n            'where_sql' => $where_sql,\n            'table' => $table,\n            'table_sql' => '',\n            'group_sql' => '',\n            'having_sql' => ''\n        );\n    }\n\n    /**\n     * year_search\n     *\n     * Build search rules for year -> year searching.\n     * @param $fromYear\n     * @param $toYear\n     * @param $size\n     * @param $offset\n     * @return array\n     */\n    public static function year_search($fromYear, $toYear, $size, $offset)\n    {\n        $search           = array();\n        $search['limit']  = $size;\n        $search['offset'] = $offset;\n        $search['type']   = \"album\";\n        $count            = 0;\n        if ($fromYear) {\n            $search['rule_' . $count . '_input']    = $fromYear;\n            $search['rule_' . $count . '_operator'] = 0;\n            $search['rule_' . $count . '']          = \"original_year\";\n            ++$count;\n        }\n        if ($toYear) {\n            $search['rule_' . $count . '_input']    = $toYear;\n            $search['rule_' . $count . '_operator'] = 1;\n            $search['rule_' . $count . '']          = \"original_year\";\n            ++$count;\n        }\n\n        return $search;\n    }\n} // end search.class\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\n$a_root = realpath(__DIR__);\nrequire_once $a_root . '/lib/init.php';\n\nUI::show_header();\n\n// Switch on the actions\nswitch ($_REQUEST['action']) {\n    case 'get_advanced':\n        $object_ids = Random::advanced(filter_input(INPUT_GET, 'type', FILTER_SANITIZE_SPECIAL_CHARS), $_POST);\n\n        // We need to add them to the active playlist\n        if (!empty($object_ids)) {\n            foreach ($object_ids as $object_id) {\n                Core::get_global('user')->playlist->add_object($object_id, 'song');\n            }\n        }\n    case 'advanced':\n    default:\n        require_once AmpConfig::get('prefix') . UI::find_template('show_random.inc.php');\n        break;\n} // end switch\n\n// Show the Footer\nUI::show_query_stats();\nUI::show_footer();\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */ ?>\n<?php UI::show_box_top(T_('Play Random Selection'), 'box box_random'); ?>\n<form id=\"random\" method=\"post\" enctype=\"multipart/form-data\" action=\"<?php echo AmpConfig::get('web_path'); ?>/random.php?action=get_advanced&type=<?php echo (string) scrub_out(filter_input(INPUT_GET, 'type', FILTER_SANITIZE_SPECIAL_CHARS)) ?: 'song'; ?>\">\n<table class=\"tabledata\">\n<tr id=\"search_location\">\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_SPECIAL_CHARS) !== 'song') {\n    ?><a href=\"<?php echo AmpConfig::get('web_path'); ?>/random.php?action=advanced&type=song\"><?php echo T_('Songs'); ?></a><?php\n} else {\n        echo T_('Songs');\n    } ?></td>\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_SPECIAL_CHARS) !== 'album') {\n        ?><a href=\"<?php echo AmpConfig::get('web_path'); ?>/random.php?action=advanced&type=album\"><?php echo T_('Albums'); ?></a><?php\n    } else {\n        echo T_('Albums');\n    } ?></td>\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_SPECIAL_CHARS) !== 'artist') {\n        ?><a href=\"<?php echo AmpConfig::get('web_path'); ?>/random.php?action=advanced&type=artist\"><?php echo T_('Artists'); ?></a><?php\n    } else {\n        echo T_('Artists');\n    } ?></td>\n    <?php if (AmpConfig::get('allow_video') && Video::get_item_count('Video')) { ?>\n        <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'video') { ?>\n                <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=video\"><?php echo T_('Videos'); ?></a>\n            <?php } else {\n        echo T_('Videos');\n    } ?></td>\n    <?php } ?>\n</tr>\n</table>\n<table class=\"tabledata\">\n<tr id=\"search_item_count\">\n        <td><?php echo T_('Item Count'); ?></td>\n        <td>\n        <select name=\"random\">\n<?php\n        foreach (array(1, 5, 10, 20, 30, 50, 100, 500, 1000) as $i) {\n            echo \"\\t\\t\\t\" . '<option value=\"' . $i . '\" ' .\n                (($_POST['random'] == $i) ? 'selected=\"selected\"' : '') . '>' .\n                $i . \"</option>\\n\";\n        }\n            echo \"\\t\\t\\t\" . '<option value=\"-1\" ' .\n                (($_POST['random'] == '-1') ? 'selected=\"selected\"' : '') . '>' .\n                T_('All') . \"</option>\\n\"; ?>\n        </select>\n        </td>\n</tr>\n<tr id=\"search_length\">\n        <td><?php echo T_('Length'); ?></td>\n        <td>\n                <?php $name = 'length_' . (int) (Core::get_post('length')); ${$name} = ' selected=\"selected\"'; ?>\n                <select name=\"length\">\n<?php\n            echo \"\\t\\t\\t\" . '<option value=\"0\" ' .\n                (($_POST['length'] == 0) ? 'selected=\"selected\"' : '') . '>' .\n                T_('Unlimited') . \"</option>\\n\";\n        foreach (array(15, 30, 60, 120, 240, 480, 960) as $i) {\n            echo \"\\t\\t\\t\" . '<option value=\"' . $i . '\" ' .\n                (($_POST['length'] == $i) ? 'selected=\"selected\"' : '') . '>';\n            if ($i < 60) {\n                printf(nT_('%d minute', '%d minutes', $i), $i);\n            } else {\n                printf(nT_('%d hour', '%d hours', $i / 60), $i / 60);\n            }\n            echo \"</option>\\n\";\n        } ?>\n                </select>\n        </td>\n</tr>\n<tr id=\"search_size_limit\">\n        <td><?php echo T_('Size Limit'); ?></td>\n        <td>\n                <select name=\"size_limit\">\n<?php\n            echo \"\\t\\t\\t\" . '<option value=\"0\" ' .\n                (($_POST['size_limit'] == 0) ? 'selected=\"selected\"' : '') . '>' .\n                T_('Unlimited') . \"</option>\\n\";\n        foreach (array(64, 128, 256, 512, 1024) as $i) {\n            echo \"\\t\\t\\t\" . '<option value=\"' . $i . '\"' .\n                (($_POST['size_limit'] == $i) ? 'selected=\"selected\"' : '') . '>' .\n                UI::format_bytes($i * 1048576) . \"</option>\\n\";\n        } ?>\n                </select>\n        </td>\n</tr>\n</table>\n\n<?php require AmpConfig::get('prefix') . UI::find_template('show_rules.inc.php'); ?>\n\n<div class=\"formValidation\">\n        <input type=\"submit\" value=\"<?php echo T_('Enqueue'); ?>\" />\n</div>\n</form>\n<?php UI::show_box_bottom(); ?>\n<div id=\"browse\">\n<?php\n    if (is_array($object_ids)) {\n        $browse = new Browse();\n        $browse->set_type('song');\n        $browse->save_objects($object_ids);\n        $browse->show_objects();\n        $browse->store();\n        echo Ajax::observe('window', 'load', Ajax::action('?action=refresh_rightbar', 'playlist_refresh_load'));\n    } ?>\n</div>\n\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nif ($playlist) {\n    $logic_operator = $playlist->logic_operator;\n} else {\n    $logic_operator = Core::get_request('operator');\n}\n$logic_operator = strtolower($logic_operator); ?>\n<script src=\"<?php echo AmpConfig::get('web_path'); ?>/lib/javascript/search.js\"></script>\n<script src=\"<?php echo AmpConfig::get('web_path'); ?>/lib/javascript/search-data.php?type=<?php echo (string) scrub_out(filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES)) ?: 'song'; ?>\"></script>\n\n<?php UI::show_box_top(T_('Rules') . \"...\", 'box box_rules'); ?>\n<table class=\"tabledata\">\n<tbody id=\"searchtable\">\n    <tr id=\"rules_operator\">\n    <td><?php echo T_('Match'); ?></td>\n        <td>\n                <select name=\"operator\">\n                        <option value=\"and\" <?php if ($logic_operator == 'and') {\n    echo 'selected=\"selected\"';\n}?>><?php echo T_('all rules'); ?></option>\n                        <option value=\"or\"  <?php if ($logic_operator == 'or') {\n    echo 'selected=\"selected\"';\n}?>><?php echo T_('any rule'); ?></option>\n                </select>\n        </td>\n        </tr>\n    <tr id=\"rules_addrowbutton\">\n    <td>\n        <a id=\"addrowbutton\" href=\"javascript:void(0)\">\n            <?php echo UI::get_icon('add'); ?>\n        <?php echo T_('Add Another Rule'); ?>\n        </a>\n        <script>$('#addrowbutton').on('click', SearchRow.add);</script>\n    </td>\n    </tr>\n</tbody>\n</table>\n<?php UI::show_box_bottom(); ?>\n\n<?php\nif ($playlist) {\n    $out = $playlist->to_js();\n} else {\n    $mysearch = new Search(null, (string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));\n    $mysearch->parse_rules(Search::clean_request($_REQUEST));\n    $out = $mysearch->to_js();\n}\nif ($out) {\n    echo $out;\n} else {\n    echo '<script>SearchRow.add();</script>';\n} ?>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2020 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nUI::show_box_top(T_('Search Ampache') . \"...\", 'box box_advanced_search'); ?>\n<form id=\"search\" name=\"search\" method=\"post\" action=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=<?php echo (string) scrub_out(filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES)) ?: 'song'; ?>\" enctype=\"multipart/form-data\" style=\"Display:inline\">\n<table class=\"tabledata\">\n    <tr id=\"search_location\">\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'song') { ?>\n        <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=song\"><?php echo T_('Songs'); ?></a><?php\n    } else {\n        echo T_('Songs');\n    } ?></td>\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'album') { ?>\n        <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=album\"><?php echo T_('Albums'); ?></a><?php\n    } else {\n        echo T_('Albums');\n    } ?></td>\n    <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'artist') { ?>\n        <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=artist\"><?php echo T_('Artists'); ?></a><?php\n    } else {\n        echo T_('Artists');\n    } ?></td>\n    <?php if (AmpConfig::get('label')) { ?>\n        <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'label') { ?>\n            <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=label\"><?php echo T_('Labels'); ?></a> <?php\n        } else {\n            echo T_('Labels');\n        } ?></td>\n    <?php } ?>\n        <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'playlist') { ?>\n            <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=playlist\"><?php echo T_('Playlists'); ?></a> <?php\n        } else {\n            echo T_('Playlists');\n        } ?></td>\n    <?php if (AmpConfig::get('allow_video') && Video::get_item_count('Video')) { ?>\n        <td><?php if ((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) !== 'video') { ?>\n            <a href=\"<?php echo AmpConfig::get('web_path'); ?>/search.php?type=video\"><?php echo T_('Videos'); ?></a> <?php\n        } else {\n            echo T_('Videos');\n        } ?></td>\n    <?php } ?>\n    </tr>\n</table>\n<table class=\"tabledata\">\n    <tr id=\"search_max_results\">\n    <td><?php echo T_('Maximum Results'); ?></td>\n        <td>\n                <select name=\"limit\">\n                        <option value=\"0\"><?php echo T_('Unlimited'); ?></option>\n                        <option value=\"25\" <?php if ((int) $_REQUEST['limit'] == 25) {\n            echo \"selected=\\\"selected\\\"\";\n        }?>>25</option>\n                        <option value=\"50\" <?php if ((int) $_REQUEST['limit'] == 50) {\n            echo \"selected=\\\"selected\\\"\";\n        }?>>50</option>\n                        <option value=\"100\" <?php if ((int) $_REQUEST['limit'] == 100) {\n            echo \"selected=\\\"selected\\\"\";\n        }?>>100</option>\n                        <option value=\"250\" <?php if ((int) $_REQUEST['limit'] == 250) {\n            echo \"selected=\\\"selected\\\"\";\n        }?>>250</option>\n                        <option value=\"500\" <?php if ((int) $_REQUEST['limit'] == 500) {\n            echo \"selected=\\\"selected\\\"\";\n        }?>>500</option>\n                </select>\n        </td>\n    </tr>\n    <tr id=\"random_results\">\n        <td><?php echo T_('Random'); ?></td>\n        <td><input type=\"checkbox\" name=\"random\" value=\"1\" <?php if ((int) $_REQUEST['random'] == 1) {\n            echo \"checked\";\n        } ?> /></td>\n    </tr>\n</table>\n\n<?php require AmpConfig::get('prefix') . UI::find_template('show_rules.inc.php'); ?>\n\n<div class=\"formValidation\">\n            <input class=\"button\" type=\"submit\" value=\"<?php echo T_('Search'); ?>\" />&nbsp;&nbsp;\n<?php if (((string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES) == 'song' || ! (string) filter_input(INPUT_GET, 'type', FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES)) && Access::check('interface', 25)) { ?>\n        <input id=\"savesearchbutton\" class=\"button\" type=\"submit\" value=\"<?php echo T_('Save as Smart Playlist'); ?>\" onClick=\"$('#hiddenaction').val('save_as_smartplaylist');\" />&nbsp;&nbsp;\n<?php\n    } ?>\n            <input type=\"hidden\" id=\"hiddenaction\" name=\"action\" value=\"search\" />\n</div>\n</form>\n<script>\n    document.getElementById('searchString').value = '';\n</script>\n<?php UI::show_box_bottom(); ?>\n"], "filenames": ["lib/class/search.class.php", "random.php", "templates/show_random.inc.php", "templates/show_rules.inc.php", "templates/show_search_form.inc.php"], "buggy_code_start_loc": [2042, 31, 23, 30, 24], "buggy_code_end_loc": [2056, 32, 24, 31, 25], "fixing_code_start_loc": [2042, 31, 23, 30, 24], "fixing_code_end_loc": [2056, 32, 24, 31, 25], "type": "CWE-79", "message": "Ampache is an open source web based audio/video streaming application and file manager. Due to a lack of input filtering versions 4.x.y are vulnerable to code injection in random.php. The attack requires user authentication to access the random.php page unless the site is running in demo mode. This issue has been resolved in 4.4.3.", "other": {"cve": {"id": "CVE-2021-32644", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-22T18:15:08.077", "lastModified": "2021-06-29T16:02:42.527", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ampache is an open source web based audio/video streaming application and file manager. Due to a lack of input filtering versions 4.x.y are vulnerable to code injection in random.php. The attack requires user authentication to access the random.php page unless the site is running in demo mode. This issue has been resolved in 4.4.3."}, {"lang": "es", "value": "Ampache es una aplicaci\u00f3n de streaming de audio/v\u00eddeo de c\u00f3digo abierto y un gestor de archivos. Debido a una falta de filtrado de entrada, las versiones 4.x.y son vulnerables a una inyecci\u00f3n de c\u00f3digo en el archivo random.php. El ataque requiere una autentificaci\u00f3n del usuario para acceder a la p\u00e1gina random.php a menos que el sitio se este ejecutando en modo demo. Este problema ha sido resuelto en versi\u00f3n 4.4.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ampache:ampache:4.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "A7C0883A-CBC7-4C94-A748-CB94CA3D0B45"}]}]}], "references": [{"url": "https://github.com/ampache/ampache/commit/c9453841e1b517a1660c3da1efd1fe5d623c93a5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ampache/ampache/security/advisories/GHSA-vqpj-xgw2-r54q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ampache/ampache/commit/c9453841e1b517a1660c3da1efd1fe5d623c93a5"}}