{"buggy_code": ["/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/Masterminds/semver/v3\"\n\t\"github.com/pkg/errors\"\n\t\"sigs.k8s.io/yaml\"\n\n\t\"helm.sh/helm/v3/internal/fileutil\"\n\t\"helm.sh/helm/v3/internal/urlutil\"\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chart/loader\"\n\t\"helm.sh/helm/v3/pkg/provenance\"\n)\n\nvar indexPath = \"index.yaml\"\n\n// APIVersionV1 is the v1 API version for index and repository files.\nconst APIVersionV1 = \"v1\"\n\nvar (\n\t// ErrNoAPIVersion indicates that an API version was not specified.\n\tErrNoAPIVersion = errors.New(\"no API version specified\")\n\t// ErrNoChartVersion indicates that a chart with the given version is not found.\n\tErrNoChartVersion = errors.New(\"no chart version found\")\n\t// ErrNoChartName indicates that a chart with the given name is not found.\n\tErrNoChartName = errors.New(\"no chart name found\")\n\t// ErrEmptyIndexYaml indicates that the content of index.yaml is empty.\n\tErrEmptyIndexYaml = errors.New(\"empty index.yaml file\")\n)\n\n// ChartVersions is a list of versioned chart references.\n// Implements a sorter on Version.\ntype ChartVersions []*ChartVersion\n\n// Len returns the length.\nfunc (c ChartVersions) Len() int { return len(c) }\n\n// Swap swaps the position of two items in the versions slice.\nfunc (c ChartVersions) Swap(i, j int) { c[i], c[j] = c[j], c[i] }\n\n// Less returns true if the version of entry a is less than the version of entry b.\nfunc (c ChartVersions) Less(a, b int) bool {\n\t// Failed parse pushes to the back.\n\ti, err := semver.NewVersion(c[a].Version)\n\tif err != nil {\n\t\treturn true\n\t}\n\tj, err := semver.NewVersion(c[b].Version)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn i.LessThan(j)\n}\n\n// IndexFile represents the index file in a chart repository\ntype IndexFile struct {\n\t// This is used ONLY for validation against chartmuseum's index files and is discarded after validation.\n\tServerInfo map[string]interface{}   `json:\"serverInfo,omitempty\"`\n\tAPIVersion string                   `json:\"apiVersion\"`\n\tGenerated  time.Time                `json:\"generated\"`\n\tEntries    map[string]ChartVersions `json:\"entries\"`\n\tPublicKeys []string                 `json:\"publicKeys,omitempty\"`\n\n\t// Annotations are additional mappings uninterpreted by Helm. They are made available for\n\t// other applications to add information to the index file.\n\tAnnotations map[string]string `json:\"annotations,omitempty\"`\n}\n\n// NewIndexFile initializes an index.\nfunc NewIndexFile() *IndexFile {\n\treturn &IndexFile{\n\t\tAPIVersion: APIVersionV1,\n\t\tGenerated:  time.Now(),\n\t\tEntries:    map[string]ChartVersions{},\n\t\tPublicKeys: []string{},\n\t}\n}\n\n// LoadIndexFile takes a file at the given path and returns an IndexFile object\nfunc LoadIndexFile(path string) (*IndexFile, error) {\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ti, err := loadIndex(b, path)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error loading %s\", path)\n\t}\n\treturn i, nil\n}\n\n// MustAdd adds a file to the index\n// This can leave the index in an unsorted state\nfunc (i IndexFile) MustAdd(md *chart.Metadata, filename, baseURL, digest string) error {\n\tif md.APIVersion == \"\" {\n\t\tmd.APIVersion = chart.APIVersionV1\n\t}\n\tif err := md.Validate(); err != nil {\n\t\treturn errors.Wrapf(err, \"validate failed for %s\", filename)\n\t}\n\n\tu := filename\n\tif baseURL != \"\" {\n\t\t_, file := filepath.Split(filename)\n\t\tvar err error\n\t\tu, err = urlutil.URLJoin(baseURL, file)\n\t\tif err != nil {\n\t\t\tu = path.Join(baseURL, file)\n\t\t}\n\t}\n\tcr := &ChartVersion{\n\t\tURLs:     []string{u},\n\t\tMetadata: md,\n\t\tDigest:   digest,\n\t\tCreated:  time.Now(),\n\t}\n\tee := i.Entries[md.Name]\n\ti.Entries[md.Name] = append(ee, cr)\n\treturn nil\n}\n\n// Add adds a file to the index and logs an error.\n//\n// Deprecated: Use index.MustAdd instead.\nfunc (i IndexFile) Add(md *chart.Metadata, filename, baseURL, digest string) {\n\tif err := i.MustAdd(md, filename, baseURL, digest); err != nil {\n\t\tlog.Printf(\"skipping loading invalid entry for chart %q %q from %s: %s\", md.Name, md.Version, filename, err)\n\t}\n}\n\n// Has returns true if the index has an entry for a chart with the given name and exact version.\nfunc (i IndexFile) Has(name, version string) bool {\n\t_, err := i.Get(name, version)\n\treturn err == nil\n}\n\n// SortEntries sorts the entries by version in descending order.\n//\n// In canonical form, the individual version records should be sorted so that\n// the most recent release for every version is in the 0th slot in the\n// Entries.ChartVersions array. That way, tooling can predict the newest\n// version without needing to parse SemVers.\nfunc (i IndexFile) SortEntries() {\n\tfor _, versions := range i.Entries {\n\t\tsort.Sort(sort.Reverse(versions))\n\t}\n}\n\n// Get returns the ChartVersion for the given name.\n//\n// If version is empty, this will return the chart with the latest stable version,\n// prerelease versions will be skipped.\nfunc (i IndexFile) Get(name, version string) (*ChartVersion, error) {\n\tvs, ok := i.Entries[name]\n\tif !ok {\n\t\treturn nil, ErrNoChartName\n\t}\n\tif len(vs) == 0 {\n\t\treturn nil, ErrNoChartVersion\n\t}\n\n\tvar constraint *semver.Constraints\n\tif version == \"\" {\n\t\tconstraint, _ = semver.NewConstraint(\"*\")\n\t} else {\n\t\tvar err error\n\t\tconstraint, err = semver.NewConstraint(version)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// when customer input exact version, check whether have exact match one first\n\tif len(version) != 0 {\n\t\tfor _, ver := range vs {\n\t\t\tif version == ver.Version {\n\t\t\t\treturn ver, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, ver := range vs {\n\t\ttest, err := semver.NewVersion(ver.Version)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif constraint.Check(test) {\n\t\t\treturn ver, nil\n\t\t}\n\t}\n\treturn nil, errors.Errorf(\"no chart version found for %s-%s\", name, version)\n}\n\n// WriteFile writes an index file to the given destination path.\n//\n// The mode on the file is set to 'mode'.\nfunc (i IndexFile) WriteFile(dest string, mode os.FileMode) error {\n\tb, err := yaml.Marshal(i)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn fileutil.AtomicWriteFile(dest, bytes.NewReader(b), mode)\n}\n\n// Merge merges the given index file into this index.\n//\n// This merges by name and version.\n//\n// If one of the entries in the given index does _not_ already exist, it is added.\n// In all other cases, the existing record is preserved.\n//\n// This can leave the index in an unsorted state\nfunc (i *IndexFile) Merge(f *IndexFile) {\n\tfor _, cvs := range f.Entries {\n\t\tfor _, cv := range cvs {\n\t\t\tif !i.Has(cv.Name, cv.Version) {\n\t\t\t\te := i.Entries[cv.Name]\n\t\t\t\ti.Entries[cv.Name] = append(e, cv)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ChartVersion represents a chart entry in the IndexFile\ntype ChartVersion struct {\n\t*chart.Metadata\n\tURLs    []string  `json:\"urls\"`\n\tCreated time.Time `json:\"created,omitempty\"`\n\tRemoved bool      `json:\"removed,omitempty\"`\n\tDigest  string    `json:\"digest,omitempty\"`\n\n\t// ChecksumDeprecated is deprecated in Helm 3, and therefore ignored. Helm 3 replaced\n\t// this with Digest. However, with a strict YAML parser enabled, a field must be\n\t// present on the struct for backwards compatibility.\n\tChecksumDeprecated string `json:\"checksum,omitempty\"`\n\n\t// EngineDeprecated is deprecated in Helm 3, and therefore ignored. However, with a strict\n\t// YAML parser enabled, this field must be present.\n\tEngineDeprecated string `json:\"engine,omitempty\"`\n\n\t// TillerVersionDeprecated is deprecated in Helm 3, and therefore ignored. However, with a strict\n\t// YAML parser enabled, this field must be present.\n\tTillerVersionDeprecated string `json:\"tillerVersion,omitempty\"`\n\n\t// URLDeprecated is deprecated in Helm 3, superseded by URLs. It is ignored. However,\n\t// with a strict YAML parser enabled, this must be present on the struct.\n\tURLDeprecated string `json:\"url,omitempty\"`\n}\n\n// IndexDirectory reads a (flat) directory and generates an index.\n//\n// It indexes only charts that have been packaged (*.tgz).\n//\n// The index returned will be in an unsorted state\nfunc IndexDirectory(dir, baseURL string) (*IndexFile, error) {\n\tarchives, err := filepath.Glob(filepath.Join(dir, \"*.tgz\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmoreArchives, err := filepath.Glob(filepath.Join(dir, \"**/*.tgz\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tarchives = append(archives, moreArchives...)\n\n\tindex := NewIndexFile()\n\tfor _, arch := range archives {\n\t\tfname, err := filepath.Rel(dir, arch)\n\t\tif err != nil {\n\t\t\treturn index, err\n\t\t}\n\n\t\tvar parentDir string\n\t\tparentDir, fname = filepath.Split(fname)\n\t\t// filepath.Split appends an extra slash to the end of parentDir. We want to strip that out.\n\t\tparentDir = strings.TrimSuffix(parentDir, string(os.PathSeparator))\n\t\tparentURL, err := urlutil.URLJoin(baseURL, parentDir)\n\t\tif err != nil {\n\t\t\tparentURL = path.Join(baseURL, parentDir)\n\t\t}\n\n\t\tc, err := loader.Load(arch)\n\t\tif err != nil {\n\t\t\t// Assume this is not a chart.\n\t\t\tcontinue\n\t\t}\n\t\thash, err := provenance.DigestFile(arch)\n\t\tif err != nil {\n\t\t\treturn index, err\n\t\t}\n\t\tif err := index.MustAdd(c.Metadata, fname, parentURL, hash); err != nil {\n\t\t\treturn index, errors.Wrapf(err, \"failed adding to %s to index\", fname)\n\t\t}\n\t}\n\treturn index, nil\n}\n\n// loadIndex loads an index file and does minimal validity checking.\n//\n// The source parameter is only used for logging.\n// This will fail if API Version is not set (ErrNoAPIVersion) or if the unmarshal fails.\nfunc loadIndex(data []byte, source string) (*IndexFile, error) {\n\ti := &IndexFile{}\n\n\tif len(data) == 0 {\n\t\treturn i, ErrEmptyIndexYaml\n\t}\n\n\tif err := yaml.UnmarshalStrict(data, i); err != nil {\n\t\treturn i, err\n\t}\n\n\tfor name, cvs := range i.Entries {\n\t\tfor idx := len(cvs) - 1; idx >= 0; idx-- {\n\t\t\tif cvs[idx].APIVersion == \"\" {\n\t\t\t\tcvs[idx].APIVersion = chart.APIVersionV1\n\t\t\t}\n\t\t\tif err := cvs[idx].Validate(); err != nil {\n\t\t\t\tlog.Printf(\"skipping loading invalid entry for chart %q %q from %s: %s\", name, cvs[idx].Version, source, err)\n\t\t\t\tcvs = append(cvs[:idx], cvs[idx+1:]...)\n\t\t\t}\n\t\t}\n\t}\n\ti.SortEntries()\n\tif i.APIVersion == \"\" {\n\t\treturn i, ErrNoAPIVersion\n\t}\n\treturn i, nil\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/cli\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/helmpath\"\n)\n\nconst (\n\ttestfile            = \"testdata/local-index.yaml\"\n\tannotationstestfile = \"testdata/local-index-annotations.yaml\"\n\tchartmuseumtestfile = \"testdata/chartmuseum-index.yaml\"\n\tunorderedTestfile   = \"testdata/local-index-unordered.yaml\"\n\ttestRepo            = \"test-repo\"\n\tindexWithDuplicates = `\napiVersion: v1\nentries:\n  nginx:\n    - urls:\n        - https://charts.helm.sh/stable/nginx-0.2.0.tgz\n      name: nginx\n      description: string\n      version: 0.2.0\n      home: https://github.com/something/else\n      digest: \"sha256:1234567890abcdef\"\n  nginx:\n    - urls:\n        - https://charts.helm.sh/stable/alpine-1.0.0.tgz\n        - http://storage2.googleapis.com/kubernetes-charts/alpine-1.0.0.tgz\n      name: alpine\n      description: string\n      version: 1.0.0\n      home: https://github.com/something\n      digest: \"sha256:1234567890abcdef\"\n`\n)\n\nfunc TestIndexFile(t *testing.T) {\n\ti := NewIndexFile()\n\tfor _, x := range []struct {\n\t\tmd       *chart.Metadata\n\t\tfilename string\n\t\tbaseURL  string\n\t\tdigest   string\n\t}{\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"cutter\", Version: \"0.1.1\"}, \"cutter-0.1.1.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"cutter\", Version: \"0.1.0\"}, \"cutter-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"cutter\", Version: \"0.2.0\"}, \"cutter-0.2.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"setter\", Version: \"0.1.9+alpha\"}, \"setter-0.1.9+alpha.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"setter\", Version: \"0.1.9+beta\"}, \"setter-0.1.9+beta.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t} {\n\t\tif err := i.MustAdd(x.md, x.filename, x.baseURL, x.digest); err != nil {\n\t\t\tt.Errorf(\"unexpected error adding to index: %s\", err)\n\t\t}\n\t}\n\n\ti.SortEntries()\n\n\tif i.APIVersion != APIVersionV1 {\n\t\tt.Error(\"Expected API version v1\")\n\t}\n\n\tif len(i.Entries) != 3 {\n\t\tt.Errorf(\"Expected 3 charts. Got %d\", len(i.Entries))\n\t}\n\n\tif i.Entries[\"clipper\"][0].Name != \"clipper\" {\n\t\tt.Errorf(\"Expected clipper, got %s\", i.Entries[\"clipper\"][0].Name)\n\t}\n\n\tif len(i.Entries[\"cutter\"]) != 3 {\n\t\tt.Error(\"Expected three cutters.\")\n\t}\n\n\t// Test that the sort worked. 0.2 should be at the first index for Cutter.\n\tif v := i.Entries[\"cutter\"][0].Version; v != \"0.2.0\" {\n\t\tt.Errorf(\"Unexpected first version: %s\", v)\n\t}\n\n\tcv, err := i.Get(\"setter\", \"0.1.9\")\n\tif err == nil && !strings.Contains(cv.Metadata.Version, \"0.1.9\") {\n\t\tt.Errorf(\"Unexpected version: %s\", cv.Metadata.Version)\n\t}\n\n\tcv, err = i.Get(\"setter\", \"0.1.9+alpha\")\n\tif err != nil || cv.Metadata.Version != \"0.1.9+alpha\" {\n\t\tt.Errorf(\"Expected version: 0.1.9+alpha\")\n\t}\n}\n\nfunc TestLoadIndex(t *testing.T) {\n\n\ttests := []struct {\n\t\tName     string\n\t\tFilename string\n\t}{\n\t\t{\n\t\t\tName:     \"regular index file\",\n\t\t\tFilename: testfile,\n\t\t},\n\t\t{\n\t\t\tName:     \"chartmuseum index file\",\n\t\t\tFilename: chartmuseumtestfile,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\ttc := tc\n\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ti, err := LoadIndexFile(tc.Filename)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tverifyLocalIndex(t, i)\n\t\t})\n\t}\n}\n\n// TestLoadIndex_Duplicates is a regression to make sure that we don't non-deterministically allow duplicate packages.\nfunc TestLoadIndex_Duplicates(t *testing.T) {\n\tif _, err := loadIndex([]byte(indexWithDuplicates), \"indexWithDuplicates\"); err == nil {\n\t\tt.Errorf(\"Expected an error when duplicate entries are present\")\n\t}\n}\n\nfunc TestLoadIndex_Empty(t *testing.T) {\n\tif _, err := loadIndex([]byte(\"\"), \"indexWithEmpty\"); err == nil {\n\t\tt.Errorf(\"Expected an error when index.yaml is empty.\")\n\t}\n}\n\nfunc TestLoadIndexFileAnnotations(t *testing.T) {\n\ti, err := LoadIndexFile(annotationstestfile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tverifyLocalIndex(t, i)\n\n\tif len(i.Annotations) != 1 {\n\t\tt.Fatalf(\"Expected 1 annotation but got %d\", len(i.Annotations))\n\t}\n\tif i.Annotations[\"helm.sh/test\"] != \"foo bar\" {\n\t\tt.Error(\"Did not get expected value for helm.sh/test annotation\")\n\t}\n}\n\nfunc TestLoadUnorderedIndex(t *testing.T) {\n\ti, err := LoadIndexFile(unorderedTestfile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tverifyLocalIndex(t, i)\n}\n\nfunc TestMerge(t *testing.T) {\n\tind1 := NewIndexFile()\n\n\tif err := ind1.MustAdd(&chart.Metadata{APIVersion: \"v2\", Name: \"dreadnought\", Version: \"0.1.0\"}, \"dreadnought-0.1.0.tgz\", \"http://example.com\", \"aaaa\"); err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tind2 := NewIndexFile()\n\n\tfor _, x := range []struct {\n\t\tmd       *chart.Metadata\n\t\tfilename string\n\t\tbaseURL  string\n\t\tdigest   string\n\t}{\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"dreadnought\", Version: \"0.2.0\"}, \"dreadnought-0.2.0.tgz\", \"http://example.com\", \"aaaabbbb\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"doughnut\", Version: \"0.2.0\"}, \"doughnut-0.2.0.tgz\", \"http://example.com\", \"ccccbbbb\"},\n\t} {\n\t\tif err := ind2.MustAdd(x.md, x.filename, x.baseURL, x.digest); err != nil {\n\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t}\n\t}\n\n\tind1.Merge(ind2)\n\n\tif len(ind1.Entries) != 2 {\n\t\tt.Errorf(\"Expected 2 entries, got %d\", len(ind1.Entries))\n\t}\n\n\tvs := ind1.Entries[\"dreadnought\"]\n\tif len(vs) != 2 {\n\t\tt.Errorf(\"Expected 2 versions, got %d\", len(vs))\n\t}\n\n\tif v := vs[1]; v.Version != \"0.2.0\" {\n\t\tt.Errorf(\"Expected %q version to be 0.2.0, got %s\", v.Name, v.Version)\n\t}\n\n}\n\nfunc TestDownloadIndexFile(t *testing.T) {\n\tt.Run(\"should  download index file\", func(t *testing.T) {\n\t\tsrv, err := startLocalServerForTests(nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer srv.Close()\n\n\t\tr, err := NewChartRepository(&Entry{\n\t\t\tName: testRepo,\n\t\t\tURL:  srv.URL,\n\t\t}, getter.All(&cli.EnvSettings{}))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Problem creating chart repository from %s: %v\", testRepo, err)\n\t\t}\n\n\t\tidx, err := r.DownloadIndexFile()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to download index file to %s: %#v\", idx, err)\n\t\t}\n\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created index file: %#v\", err)\n\t\t}\n\n\t\ti, err := LoadIndexFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Index %q failed to parse: %s\", testfile, err)\n\t\t}\n\t\tverifyLocalIndex(t, i)\n\n\t\t// Check that charts file is also created\n\t\tidx = filepath.Join(r.CachePath, helmpath.CacheChartsFile(r.Config.Name))\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created charts file: %#v\", err)\n\t\t}\n\n\t\tb, err := ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading charts file: %#v\", err)\n\t\t}\n\t\tverifyLocalChartsFile(t, b, i)\n\t})\n\n\tt.Run(\"should not decode the path in the repo url while downloading index\", func(t *testing.T) {\n\t\tchartRepoURLPath := \"/some%2Fpath/test\"\n\t\tfileBytes, err := ioutil.ReadFile(\"testdata/local-index.yaml\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.URL.RawPath == chartRepoURLPath+\"/index.yaml\" {\n\t\t\t\tw.Write(fileBytes)\n\t\t\t}\n\t\t})\n\t\tsrv, err := startLocalServerForTests(handler)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer srv.Close()\n\n\t\tr, err := NewChartRepository(&Entry{\n\t\t\tName: testRepo,\n\t\t\tURL:  srv.URL + chartRepoURLPath,\n\t\t}, getter.All(&cli.EnvSettings{}))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Problem creating chart repository from %s: %v\", testRepo, err)\n\t\t}\n\n\t\tidx, err := r.DownloadIndexFile()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to download index file to %s: %#v\", idx, err)\n\t\t}\n\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created index file: %#v\", err)\n\t\t}\n\n\t\ti, err := LoadIndexFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Index %q failed to parse: %s\", testfile, err)\n\t\t}\n\t\tverifyLocalIndex(t, i)\n\n\t\t// Check that charts file is also created\n\t\tidx = filepath.Join(r.CachePath, helmpath.CacheChartsFile(r.Config.Name))\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created charts file: %#v\", err)\n\t\t}\n\n\t\tb, err := ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading charts file: %#v\", err)\n\t\t}\n\t\tverifyLocalChartsFile(t, b, i)\n\t})\n}\n\nfunc verifyLocalIndex(t *testing.T, i *IndexFile) {\n\tnumEntries := len(i.Entries)\n\tif numEntries != 3 {\n\t\tt.Errorf(\"Expected 3 entries in index file but got %d\", numEntries)\n\t}\n\n\talpine, ok := i.Entries[\"alpine\"]\n\tif !ok {\n\t\tt.Fatalf(\"'alpine' section not found.\")\n\t}\n\n\tif l := len(alpine); l != 1 {\n\t\tt.Fatalf(\"'alpine' should have 1 chart, got %d\", l)\n\t}\n\n\tnginx, ok := i.Entries[\"nginx\"]\n\tif !ok || len(nginx) != 2 {\n\t\tt.Fatalf(\"Expected 2 nginx entries\")\n\t}\n\n\texpects := []*ChartVersion{\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tAPIVersion:  \"v2\",\n\t\t\t\tName:        \"alpine\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"1.0.0\",\n\t\t\t\tKeywords:    []string{\"linux\", \"alpine\", \"small\", \"sumtin\"},\n\t\t\t\tHome:        \"https://github.com/something\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://charts.helm.sh/stable/alpine-1.0.0.tgz\",\n\t\t\t\t\"http://storage2.googleapis.com/kubernetes-charts/alpine-1.0.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tAPIVersion:  \"v2\",\n\t\t\t\tName:        \"nginx\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"0.2.0\",\n\t\t\t\tKeywords:    []string{\"popular\", \"web server\", \"proxy\"},\n\t\t\t\tHome:        \"https://github.com/something/else\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://charts.helm.sh/stable/nginx-0.2.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tAPIVersion:  \"v2\",\n\t\t\t\tName:        \"nginx\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"0.1.0\",\n\t\t\t\tKeywords:    []string{\"popular\", \"web server\", \"proxy\"},\n\t\t\t\tHome:        \"https://github.com/something\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://charts.helm.sh/stable/nginx-0.1.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t}\n\ttests := []*ChartVersion{alpine[0], nginx[0], nginx[1]}\n\n\tfor i, tt := range tests {\n\t\texpect := expects[i]\n\t\tif tt.Name != expect.Name {\n\t\t\tt.Errorf(\"Expected name %q, got %q\", expect.Name, tt.Name)\n\t\t}\n\t\tif tt.Description != expect.Description {\n\t\t\tt.Errorf(\"Expected description %q, got %q\", expect.Description, tt.Description)\n\t\t}\n\t\tif tt.Version != expect.Version {\n\t\t\tt.Errorf(\"Expected version %q, got %q\", expect.Version, tt.Version)\n\t\t}\n\t\tif tt.Digest != expect.Digest {\n\t\t\tt.Errorf(\"Expected digest %q, got %q\", expect.Digest, tt.Digest)\n\t\t}\n\t\tif tt.Home != expect.Home {\n\t\t\tt.Errorf(\"Expected home %q, got %q\", expect.Home, tt.Home)\n\t\t}\n\n\t\tfor i, url := range tt.URLs {\n\t\t\tif url != expect.URLs[i] {\n\t\t\t\tt.Errorf(\"Expected URL %q, got %q\", expect.URLs[i], url)\n\t\t\t}\n\t\t}\n\t\tfor i, kw := range tt.Keywords {\n\t\t\tif kw != expect.Keywords[i] {\n\t\t\t\tt.Errorf(\"Expected keywords %q, got %q\", expect.Keywords[i], kw)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc verifyLocalChartsFile(t *testing.T, chartsContent []byte, indexContent *IndexFile) {\n\tvar expected, real []string\n\tfor chart := range indexContent.Entries {\n\t\texpected = append(expected, chart)\n\t}\n\tsort.Strings(expected)\n\n\tscanner := bufio.NewScanner(bytes.NewReader(chartsContent))\n\tfor scanner.Scan() {\n\t\treal = append(real, scanner.Text())\n\t}\n\tsort.Strings(real)\n\n\tif strings.Join(expected, \" \") != strings.Join(real, \" \") {\n\t\tt.Errorf(\"Cached charts file content unexpected. Expected:\\n%s\\ngot:\\n%s\", expected, real)\n\t}\n}\n\nfunc TestIndexDirectory(t *testing.T) {\n\tdir := \"testdata/repository\"\n\tindex, err := IndexDirectory(dir, \"http://localhost:8080\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif l := len(index.Entries); l != 3 {\n\t\tt.Fatalf(\"Expected 3 entries, got %d\", l)\n\t}\n\n\t// Other things test the entry generation more thoroughly. We just test a\n\t// few fields.\n\n\tcorpus := []struct{ chartName, downloadLink string }{\n\t\t{\"frobnitz\", \"http://localhost:8080/frobnitz-1.2.3.tgz\"},\n\t\t{\"zarthal\", \"http://localhost:8080/universe/zarthal-1.0.0.tgz\"},\n\t}\n\n\tfor _, test := range corpus {\n\t\tcname := test.chartName\n\t\tfrobs, ok := index.Entries[cname]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"Could not read chart %s\", cname)\n\t\t}\n\n\t\tfrob := frobs[0]\n\t\tif frob.Digest == \"\" {\n\t\t\tt.Errorf(\"Missing digest of file %s.\", frob.Name)\n\t\t}\n\t\tif frob.URLs[0] != test.downloadLink {\n\t\t\tt.Errorf(\"Unexpected URLs: %v\", frob.URLs)\n\t\t}\n\t\tif frob.Name != cname {\n\t\t\tt.Errorf(\"Expected %q, got %q\", cname, frob.Name)\n\t\t}\n\t}\n}\n\nfunc TestIndexAdd(t *testing.T) {\n\ti := NewIndexFile()\n\n\tfor _, x := range []struct {\n\t\tmd       *chart.Metadata\n\t\tfilename string\n\t\tbaseURL  string\n\t\tdigest   string\n\t}{\n\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"alpine\", Version: \"0.1.0\"}, \"/home/charts/alpine-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"deis\", Version: \"0.1.0\"}, \"/home/charts/deis-0.1.0.tgz\", \"http://example.com/charts/\", \"sha256:1234567890\"},\n\t} {\n\t\tif err := i.MustAdd(x.md, x.filename, x.baseURL, x.digest); err != nil {\n\t\t\tt.Errorf(\"unexpected error adding to index: %s\", err)\n\t\t}\n\t}\n\n\tif i.Entries[\"clipper\"][0].URLs[0] != \"http://example.com/charts/clipper-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/clipper-0.1.0.tgz, got %s\", i.Entries[\"clipper\"][0].URLs[0])\n\t}\n\tif i.Entries[\"alpine\"][0].URLs[0] != \"http://example.com/charts/alpine-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/alpine-0.1.0.tgz, got %s\", i.Entries[\"alpine\"][0].URLs[0])\n\t}\n\tif i.Entries[\"deis\"][0].URLs[0] != \"http://example.com/charts/deis-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/deis-0.1.0.tgz, got %s\", i.Entries[\"deis\"][0].URLs[0])\n\t}\n\n\t// test error condition\n\tif err := i.MustAdd(&chart.Metadata{}, \"error-0.1.0.tgz\", \"\", \"\"); err == nil {\n\t\tt.Fatal(\"expected error adding to index\")\n\t}\n}\n\nfunc TestIndexWrite(t *testing.T) {\n\ti := NewIndexFile()\n\tif err := i.MustAdd(&chart.Metadata{APIVersion: \"v2\", Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\"); err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tdir := t.TempDir()\n\ttestpath := filepath.Join(dir, \"test\")\n\ti.WriteFile(testpath, 0600)\n\n\tgot, err := ioutil.ReadFile(testpath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !strings.Contains(string(got), \"clipper-0.1.0.tgz\") {\n\t\tt.Fatal(\"Index files doesn't contain expected content\")\n\t}\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo // import \"helm.sh/helm/v3/pkg/repo\"\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"sigs.k8s.io/yaml\"\n)\n\n// File represents the repositories.yaml file\ntype File struct {\n\tAPIVersion   string    `json:\"apiVersion\"`\n\tGenerated    time.Time `json:\"generated\"`\n\tRepositories []*Entry  `json:\"repositories\"`\n}\n\n// NewFile generates an empty repositories file.\n//\n// Generated and APIVersion are automatically set.\nfunc NewFile() *File {\n\treturn &File{\n\t\tAPIVersion:   APIVersionV1,\n\t\tGenerated:    time.Now(),\n\t\tRepositories: []*Entry{},\n\t}\n}\n\n// LoadFile takes a file at the given path and returns a File object\nfunc LoadFile(path string) (*File, error) {\n\tr := new(File)\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn r, errors.Wrapf(err, \"couldn't load repositories file (%s)\", path)\n\t}\n\n\terr = yaml.Unmarshal(b, r)\n\treturn r, err\n}\n\n// Add adds one or more repo entries to a repo file.\nfunc (r *File) Add(re ...*Entry) {\n\tr.Repositories = append(r.Repositories, re...)\n}\n\n// Update attempts to replace one or more repo entries in a repo file. If an\n// entry with the same name doesn't exist in the repo file it will add it.\nfunc (r *File) Update(re ...*Entry) {\n\tfor _, target := range re {\n\t\tr.update(target)\n\t}\n}\n\nfunc (r *File) update(e *Entry) {\n\tfor j, repo := range r.Repositories {\n\t\tif repo.Name == e.Name {\n\t\t\tr.Repositories[j] = e\n\t\t\treturn\n\t\t}\n\t}\n\tr.Add(e)\n}\n\n// Has returns true if the given name is already a repository name.\nfunc (r *File) Has(name string) bool {\n\tentry := r.Get(name)\n\treturn entry != nil\n}\n\n// Get returns an entry with the given name if it exists, otherwise returns nil\nfunc (r *File) Get(name string) *Entry {\n\tfor _, entry := range r.Repositories {\n\t\tif entry.Name == name {\n\t\t\treturn entry\n\t\t}\n\t}\n\treturn nil\n}\n\n// Remove removes the entry from the list of repositories.\nfunc (r *File) Remove(name string) bool {\n\tcp := []*Entry{}\n\tfound := false\n\tfor _, rf := range r.Repositories {\n\t\tif rf.Name == name {\n\t\t\tfound = true\n\t\t\tcontinue\n\t\t}\n\t\tcp = append(cp, rf)\n\t}\n\tr.Repositories = cp\n\treturn found\n}\n\n// WriteFile writes a repositories file to the given path.\nfunc (r *File) WriteFile(path string, perm os.FileMode) error {\n\tdata, err := yaml.Marshal(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(path, data, perm)\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n)\n\nconst testRepositoriesFile = \"testdata/repositories.yaml\"\n\nfunc TestFile(t *testing.T) {\n\trf := NewFile()\n\trf.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t)\n\n\tif len(rf.Repositories) != 2 {\n\t\tt.Fatal(\"Expected 2 repositories\")\n\t}\n\n\tif rf.Has(\"nosuchrepo\") {\n\t\tt.Error(\"Found nonexistent repo\")\n\t}\n\tif !rf.Has(\"incubator\") {\n\t\tt.Error(\"incubator repo is missing\")\n\t}\n\n\tstable := rf.Repositories[0]\n\tif stable.Name != \"stable\" {\n\t\tt.Error(\"stable is not named stable\")\n\t}\n\tif stable.URL != \"https://example.com/stable/charts\" {\n\t\tt.Error(\"Wrong URL for stable\")\n\t}\n}\n\nfunc TestNewFile(t *testing.T) {\n\texpects := NewFile()\n\texpects.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t)\n\n\tfile, err := LoadFile(testRepositoriesFile)\n\tif err != nil {\n\t\tt.Errorf(\"%q could not be loaded: %s\", testRepositoriesFile, err)\n\t}\n\n\tif len(expects.Repositories) != len(file.Repositories) {\n\t\tt.Fatalf(\"Unexpected repo data: %#v\", file.Repositories)\n\t}\n\n\tfor i, expect := range expects.Repositories {\n\t\tgot := file.Repositories[i]\n\t\tif expect.Name != got.Name {\n\t\t\tt.Errorf(\"Expected name %q, got %q\", expect.Name, got.Name)\n\t\t}\n\t\tif expect.URL != got.URL {\n\t\t\tt.Errorf(\"Expected url %q, got %q\", expect.URL, got.URL)\n\t\t}\n\t}\n}\n\nfunc TestRepoFile_Get(t *testing.T) {\n\trepo := NewFile()\n\trepo.Add(\n\t\t&Entry{\n\t\t\tName: \"first\",\n\t\t\tURL:  \"https://example.com/first\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"second\",\n\t\t\tURL:  \"https://example.com/second\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"third\",\n\t\t\tURL:  \"https://example.com/third\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"fourth\",\n\t\t\tURL:  \"https://example.com/fourth\",\n\t\t},\n\t)\n\n\tname := \"second\"\n\n\tentry := repo.Get(name)\n\tif entry == nil {\n\t\tt.Fatalf(\"Expected repo entry %q to be found\", name)\n\t}\n\n\tif entry.URL != \"https://example.com/second\" {\n\t\tt.Errorf(\"Expected repo URL to be %q but got %q\", \"https://example.com/second\", entry.URL)\n\t}\n\n\tentry = repo.Get(\"nonexistent\")\n\tif entry != nil {\n\t\tt.Errorf(\"Got unexpected entry %+v\", entry)\n\t}\n}\n\nfunc TestRemoveRepository(t *testing.T) {\n\tsampleRepository := NewFile()\n\tsampleRepository.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t)\n\n\tremoveRepository := \"stable\"\n\tfound := sampleRepository.Remove(removeRepository)\n\tif !found {\n\t\tt.Errorf(\"expected repository %s not found\", removeRepository)\n\t}\n\n\tfound = sampleRepository.Has(removeRepository)\n\tif found {\n\t\tt.Errorf(\"repository %s not deleted\", removeRepository)\n\t}\n}\n\nfunc TestUpdateRepository(t *testing.T) {\n\tsampleRepository := NewFile()\n\tsampleRepository.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t)\n\tnewRepoName := \"sample\"\n\tsampleRepository.Update(&Entry{Name: newRepoName,\n\t\tURL: \"https://example.com/sample\",\n\t})\n\n\tif !sampleRepository.Has(newRepoName) {\n\t\tt.Errorf(\"expected repository %s not found\", newRepoName)\n\t}\n\trepoCount := len(sampleRepository.Repositories)\n\n\tsampleRepository.Update(&Entry{Name: newRepoName,\n\t\tURL: \"https://example.com/sample\",\n\t})\n\n\tif repoCount != len(sampleRepository.Repositories) {\n\t\tt.Errorf(\"invalid number of repositories found %d, expected number of repositories %d\", len(sampleRepository.Repositories), repoCount)\n\t}\n}\n\nfunc TestWriteFile(t *testing.T) {\n\tsampleRepository := NewFile()\n\tsampleRepository.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t)\n\n\tfile, err := ioutil.TempFile(\"\", \"helm-repo\")\n\tif err != nil {\n\t\tt.Errorf(\"failed to create test-file (%v)\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\tif err := sampleRepository.WriteFile(file.Name(), 0644); err != nil {\n\t\tt.Errorf(\"failed to write file (%v)\", err)\n\t}\n\n\trepos, err := LoadFile(file.Name())\n\tif err != nil {\n\t\tt.Errorf(\"failed to load file (%v)\", err)\n\t}\n\tfor _, repo := range sampleRepository.Repositories {\n\t\tif !repos.Has(repo.Name) {\n\t\t\tt.Errorf(\"expected repository %s not found\", repo.Name)\n\t\t}\n\t}\n}\n\nfunc TestRepoNotExists(t *testing.T) {\n\tif _, err := LoadFile(\"/this/path/does/not/exist.yaml\"); err == nil {\n\t\tt.Errorf(\"expected err to be non-nil when path does not exist\")\n\t} else if !strings.Contains(err.Error(), \"couldn't load repositories file\") {\n\t\tt.Errorf(\"expected prompt `couldn't load repositories file`\")\n\t}\n}\n"], "fixing_code": ["/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/Masterminds/semver/v3\"\n\t\"github.com/pkg/errors\"\n\t\"sigs.k8s.io/yaml\"\n\n\t\"helm.sh/helm/v3/internal/fileutil\"\n\t\"helm.sh/helm/v3/internal/urlutil\"\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chart/loader\"\n\t\"helm.sh/helm/v3/pkg/provenance\"\n)\n\nvar indexPath = \"index.yaml\"\n\n// APIVersionV1 is the v1 API version for index and repository files.\nconst APIVersionV1 = \"v1\"\n\nvar (\n\t// ErrNoAPIVersion indicates that an API version was not specified.\n\tErrNoAPIVersion = errors.New(\"no API version specified\")\n\t// ErrNoChartVersion indicates that a chart with the given version is not found.\n\tErrNoChartVersion = errors.New(\"no chart version found\")\n\t// ErrNoChartName indicates that a chart with the given name is not found.\n\tErrNoChartName = errors.New(\"no chart name found\")\n\t// ErrEmptyIndexYaml indicates that the content of index.yaml is empty.\n\tErrEmptyIndexYaml = errors.New(\"empty index.yaml file\")\n)\n\n// ChartVersions is a list of versioned chart references.\n// Implements a sorter on Version.\ntype ChartVersions []*ChartVersion\n\n// Len returns the length.\nfunc (c ChartVersions) Len() int { return len(c) }\n\n// Swap swaps the position of two items in the versions slice.\nfunc (c ChartVersions) Swap(i, j int) { c[i], c[j] = c[j], c[i] }\n\n// Less returns true if the version of entry a is less than the version of entry b.\nfunc (c ChartVersions) Less(a, b int) bool {\n\t// Failed parse pushes to the back.\n\ti, err := semver.NewVersion(c[a].Version)\n\tif err != nil {\n\t\treturn true\n\t}\n\tj, err := semver.NewVersion(c[b].Version)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn i.LessThan(j)\n}\n\n// IndexFile represents the index file in a chart repository\ntype IndexFile struct {\n\t// This is used ONLY for validation against chartmuseum's index files and is discarded after validation.\n\tServerInfo map[string]interface{}   `json:\"serverInfo,omitempty\"`\n\tAPIVersion string                   `json:\"apiVersion\"`\n\tGenerated  time.Time                `json:\"generated\"`\n\tEntries    map[string]ChartVersions `json:\"entries\"`\n\tPublicKeys []string                 `json:\"publicKeys,omitempty\"`\n\n\t// Annotations are additional mappings uninterpreted by Helm. They are made available for\n\t// other applications to add information to the index file.\n\tAnnotations map[string]string `json:\"annotations,omitempty\"`\n}\n\n// NewIndexFile initializes an index.\nfunc NewIndexFile() *IndexFile {\n\treturn &IndexFile{\n\t\tAPIVersion: APIVersionV1,\n\t\tGenerated:  time.Now(),\n\t\tEntries:    map[string]ChartVersions{},\n\t\tPublicKeys: []string{},\n\t}\n}\n\n// LoadIndexFile takes a file at the given path and returns an IndexFile object\nfunc LoadIndexFile(path string) (*IndexFile, error) {\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ti, err := loadIndex(b, path)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error loading %s\", path)\n\t}\n\treturn i, nil\n}\n\n// MustAdd adds a file to the index\n// This can leave the index in an unsorted state\nfunc (i IndexFile) MustAdd(md *chart.Metadata, filename, baseURL, digest string) error {\n\tif i.Entries == nil {\n\t\treturn errors.New(\"entries not initialized\")\n\t}\n\n\tif md.APIVersion == \"\" {\n\t\tmd.APIVersion = chart.APIVersionV1\n\t}\n\tif err := md.Validate(); err != nil {\n\t\treturn errors.Wrapf(err, \"validate failed for %s\", filename)\n\t}\n\n\tu := filename\n\tif baseURL != \"\" {\n\t\t_, file := filepath.Split(filename)\n\t\tvar err error\n\t\tu, err = urlutil.URLJoin(baseURL, file)\n\t\tif err != nil {\n\t\t\tu = path.Join(baseURL, file)\n\t\t}\n\t}\n\tcr := &ChartVersion{\n\t\tURLs:     []string{u},\n\t\tMetadata: md,\n\t\tDigest:   digest,\n\t\tCreated:  time.Now(),\n\t}\n\tee := i.Entries[md.Name]\n\ti.Entries[md.Name] = append(ee, cr)\n\treturn nil\n}\n\n// Add adds a file to the index and logs an error.\n//\n// Deprecated: Use index.MustAdd instead.\nfunc (i IndexFile) Add(md *chart.Metadata, filename, baseURL, digest string) {\n\tif err := i.MustAdd(md, filename, baseURL, digest); err != nil {\n\t\tlog.Printf(\"skipping loading invalid entry for chart %q %q from %s: %s\", md.Name, md.Version, filename, err)\n\t}\n}\n\n// Has returns true if the index has an entry for a chart with the given name and exact version.\nfunc (i IndexFile) Has(name, version string) bool {\n\t_, err := i.Get(name, version)\n\treturn err == nil\n}\n\n// SortEntries sorts the entries by version in descending order.\n//\n// In canonical form, the individual version records should be sorted so that\n// the most recent release for every version is in the 0th slot in the\n// Entries.ChartVersions array. That way, tooling can predict the newest\n// version without needing to parse SemVers.\nfunc (i IndexFile) SortEntries() {\n\tfor _, versions := range i.Entries {\n\t\tsort.Sort(sort.Reverse(versions))\n\t}\n}\n\n// Get returns the ChartVersion for the given name.\n//\n// If version is empty, this will return the chart with the latest stable version,\n// prerelease versions will be skipped.\nfunc (i IndexFile) Get(name, version string) (*ChartVersion, error) {\n\tvs, ok := i.Entries[name]\n\tif !ok {\n\t\treturn nil, ErrNoChartName\n\t}\n\tif len(vs) == 0 {\n\t\treturn nil, ErrNoChartVersion\n\t}\n\n\tvar constraint *semver.Constraints\n\tif version == \"\" {\n\t\tconstraint, _ = semver.NewConstraint(\"*\")\n\t} else {\n\t\tvar err error\n\t\tconstraint, err = semver.NewConstraint(version)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// when customer input exact version, check whether have exact match one first\n\tif len(version) != 0 {\n\t\tfor _, ver := range vs {\n\t\t\tif version == ver.Version {\n\t\t\t\treturn ver, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, ver := range vs {\n\t\ttest, err := semver.NewVersion(ver.Version)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif constraint.Check(test) {\n\t\t\treturn ver, nil\n\t\t}\n\t}\n\treturn nil, errors.Errorf(\"no chart version found for %s-%s\", name, version)\n}\n\n// WriteFile writes an index file to the given destination path.\n//\n// The mode on the file is set to 'mode'.\nfunc (i IndexFile) WriteFile(dest string, mode os.FileMode) error {\n\tb, err := yaml.Marshal(i)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn fileutil.AtomicWriteFile(dest, bytes.NewReader(b), mode)\n}\n\n// Merge merges the given index file into this index.\n//\n// This merges by name and version.\n//\n// If one of the entries in the given index does _not_ already exist, it is added.\n// In all other cases, the existing record is preserved.\n//\n// This can leave the index in an unsorted state\nfunc (i *IndexFile) Merge(f *IndexFile) {\n\tfor _, cvs := range f.Entries {\n\t\tfor _, cv := range cvs {\n\t\t\tif !i.Has(cv.Name, cv.Version) {\n\t\t\t\te := i.Entries[cv.Name]\n\t\t\t\ti.Entries[cv.Name] = append(e, cv)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ChartVersion represents a chart entry in the IndexFile\ntype ChartVersion struct {\n\t*chart.Metadata\n\tURLs    []string  `json:\"urls\"`\n\tCreated time.Time `json:\"created,omitempty\"`\n\tRemoved bool      `json:\"removed,omitempty\"`\n\tDigest  string    `json:\"digest,omitempty\"`\n\n\t// ChecksumDeprecated is deprecated in Helm 3, and therefore ignored. Helm 3 replaced\n\t// this with Digest. However, with a strict YAML parser enabled, a field must be\n\t// present on the struct for backwards compatibility.\n\tChecksumDeprecated string `json:\"checksum,omitempty\"`\n\n\t// EngineDeprecated is deprecated in Helm 3, and therefore ignored. However, with a strict\n\t// YAML parser enabled, this field must be present.\n\tEngineDeprecated string `json:\"engine,omitempty\"`\n\n\t// TillerVersionDeprecated is deprecated in Helm 3, and therefore ignored. However, with a strict\n\t// YAML parser enabled, this field must be present.\n\tTillerVersionDeprecated string `json:\"tillerVersion,omitempty\"`\n\n\t// URLDeprecated is deprecated in Helm 3, superseded by URLs. It is ignored. However,\n\t// with a strict YAML parser enabled, this must be present on the struct.\n\tURLDeprecated string `json:\"url,omitempty\"`\n}\n\n// IndexDirectory reads a (flat) directory and generates an index.\n//\n// It indexes only charts that have been packaged (*.tgz).\n//\n// The index returned will be in an unsorted state\nfunc IndexDirectory(dir, baseURL string) (*IndexFile, error) {\n\tarchives, err := filepath.Glob(filepath.Join(dir, \"*.tgz\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmoreArchives, err := filepath.Glob(filepath.Join(dir, \"**/*.tgz\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tarchives = append(archives, moreArchives...)\n\n\tindex := NewIndexFile()\n\tfor _, arch := range archives {\n\t\tfname, err := filepath.Rel(dir, arch)\n\t\tif err != nil {\n\t\t\treturn index, err\n\t\t}\n\n\t\tvar parentDir string\n\t\tparentDir, fname = filepath.Split(fname)\n\t\t// filepath.Split appends an extra slash to the end of parentDir. We want to strip that out.\n\t\tparentDir = strings.TrimSuffix(parentDir, string(os.PathSeparator))\n\t\tparentURL, err := urlutil.URLJoin(baseURL, parentDir)\n\t\tif err != nil {\n\t\t\tparentURL = path.Join(baseURL, parentDir)\n\t\t}\n\n\t\tc, err := loader.Load(arch)\n\t\tif err != nil {\n\t\t\t// Assume this is not a chart.\n\t\t\tcontinue\n\t\t}\n\t\thash, err := provenance.DigestFile(arch)\n\t\tif err != nil {\n\t\t\treturn index, err\n\t\t}\n\t\tif err := index.MustAdd(c.Metadata, fname, parentURL, hash); err != nil {\n\t\t\treturn index, errors.Wrapf(err, \"failed adding to %s to index\", fname)\n\t\t}\n\t}\n\treturn index, nil\n}\n\n// loadIndex loads an index file and does minimal validity checking.\n//\n// The source parameter is only used for logging.\n// This will fail if API Version is not set (ErrNoAPIVersion) or if the unmarshal fails.\nfunc loadIndex(data []byte, source string) (*IndexFile, error) {\n\ti := &IndexFile{}\n\n\tif len(data) == 0 {\n\t\treturn i, ErrEmptyIndexYaml\n\t}\n\n\tif err := yaml.UnmarshalStrict(data, i); err != nil {\n\t\treturn i, err\n\t}\n\n\tfor name, cvs := range i.Entries {\n\t\tfor idx := len(cvs) - 1; idx >= 0; idx-- {\n\t\t\tif cvs[idx] == nil {\n\t\t\t\tlog.Printf(\"skipping loading invalid entry for chart %q from %s: empty entry\", name, source)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif cvs[idx].APIVersion == \"\" {\n\t\t\t\tcvs[idx].APIVersion = chart.APIVersionV1\n\t\t\t}\n\t\t\tif err := cvs[idx].Validate(); err != nil {\n\t\t\t\tlog.Printf(\"skipping loading invalid entry for chart %q %q from %s: %s\", name, cvs[idx].Version, source, err)\n\t\t\t\tcvs = append(cvs[:idx], cvs[idx+1:]...)\n\t\t\t}\n\t\t}\n\t}\n\ti.SortEntries()\n\tif i.APIVersion == \"\" {\n\t\treturn i, ErrNoAPIVersion\n\t}\n\treturn i, nil\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/cli\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/helmpath\"\n)\n\nconst (\n\ttestfile            = \"testdata/local-index.yaml\"\n\tannotationstestfile = \"testdata/local-index-annotations.yaml\"\n\tchartmuseumtestfile = \"testdata/chartmuseum-index.yaml\"\n\tunorderedTestfile   = \"testdata/local-index-unordered.yaml\"\n\ttestRepo            = \"test-repo\"\n\tindexWithDuplicates = `\napiVersion: v1\nentries:\n  nginx:\n    - urls:\n        - https://charts.helm.sh/stable/nginx-0.2.0.tgz\n      name: nginx\n      description: string\n      version: 0.2.0\n      home: https://github.com/something/else\n      digest: \"sha256:1234567890abcdef\"\n  nginx:\n    - urls:\n        - https://charts.helm.sh/stable/alpine-1.0.0.tgz\n        - http://storage2.googleapis.com/kubernetes-charts/alpine-1.0.0.tgz\n      name: alpine\n      description: string\n      version: 1.0.0\n      home: https://github.com/something\n      digest: \"sha256:1234567890abcdef\"\n`\n\tindexWithEmptyEntry = `\napiVersion: v1\nentries:\n  grafana:\n  - apiVersion: v2\n    name: grafana\n  foo:\n  -\n`\n)\n\nfunc TestIndexFile(t *testing.T) {\n\ti := NewIndexFile()\n\tfor _, x := range []struct {\n\t\tmd       *chart.Metadata\n\t\tfilename string\n\t\tbaseURL  string\n\t\tdigest   string\n\t}{\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"cutter\", Version: \"0.1.1\"}, \"cutter-0.1.1.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"cutter\", Version: \"0.1.0\"}, \"cutter-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"cutter\", Version: \"0.2.0\"}, \"cutter-0.2.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"setter\", Version: \"0.1.9+alpha\"}, \"setter-0.1.9+alpha.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"setter\", Version: \"0.1.9+beta\"}, \"setter-0.1.9+beta.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t} {\n\t\tif err := i.MustAdd(x.md, x.filename, x.baseURL, x.digest); err != nil {\n\t\t\tt.Errorf(\"unexpected error adding to index: %s\", err)\n\t\t}\n\t}\n\n\ti.SortEntries()\n\n\tif i.APIVersion != APIVersionV1 {\n\t\tt.Error(\"Expected API version v1\")\n\t}\n\n\tif len(i.Entries) != 3 {\n\t\tt.Errorf(\"Expected 3 charts. Got %d\", len(i.Entries))\n\t}\n\n\tif i.Entries[\"clipper\"][0].Name != \"clipper\" {\n\t\tt.Errorf(\"Expected clipper, got %s\", i.Entries[\"clipper\"][0].Name)\n\t}\n\n\tif len(i.Entries[\"cutter\"]) != 3 {\n\t\tt.Error(\"Expected three cutters.\")\n\t}\n\n\t// Test that the sort worked. 0.2 should be at the first index for Cutter.\n\tif v := i.Entries[\"cutter\"][0].Version; v != \"0.2.0\" {\n\t\tt.Errorf(\"Unexpected first version: %s\", v)\n\t}\n\n\tcv, err := i.Get(\"setter\", \"0.1.9\")\n\tif err == nil && !strings.Contains(cv.Metadata.Version, \"0.1.9\") {\n\t\tt.Errorf(\"Unexpected version: %s\", cv.Metadata.Version)\n\t}\n\n\tcv, err = i.Get(\"setter\", \"0.1.9+alpha\")\n\tif err != nil || cv.Metadata.Version != \"0.1.9+alpha\" {\n\t\tt.Errorf(\"Expected version: 0.1.9+alpha\")\n\t}\n}\n\nfunc TestLoadIndex(t *testing.T) {\n\n\ttests := []struct {\n\t\tName     string\n\t\tFilename string\n\t}{\n\t\t{\n\t\t\tName:     \"regular index file\",\n\t\t\tFilename: testfile,\n\t\t},\n\t\t{\n\t\t\tName:     \"chartmuseum index file\",\n\t\t\tFilename: chartmuseumtestfile,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\ttc := tc\n\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ti, err := LoadIndexFile(tc.Filename)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tverifyLocalIndex(t, i)\n\t\t})\n\t}\n}\n\n// TestLoadIndex_Duplicates is a regression to make sure that we don't non-deterministically allow duplicate packages.\nfunc TestLoadIndex_Duplicates(t *testing.T) {\n\tif _, err := loadIndex([]byte(indexWithDuplicates), \"indexWithDuplicates\"); err == nil {\n\t\tt.Errorf(\"Expected an error when duplicate entries are present\")\n\t}\n}\n\nfunc TestLoadIndex_EmptyEntry(t *testing.T) {\n\tif _, err := loadIndex([]byte(indexWithEmptyEntry), \"indexWithEmptyEntry\"); err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err)\n\t}\n}\n\nfunc TestLoadIndex_Empty(t *testing.T) {\n\tif _, err := loadIndex([]byte(\"\"), \"indexWithEmpty\"); err == nil {\n\t\tt.Errorf(\"Expected an error when index.yaml is empty.\")\n\t}\n}\n\nfunc TestLoadIndexFileAnnotations(t *testing.T) {\n\ti, err := LoadIndexFile(annotationstestfile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tverifyLocalIndex(t, i)\n\n\tif len(i.Annotations) != 1 {\n\t\tt.Fatalf(\"Expected 1 annotation but got %d\", len(i.Annotations))\n\t}\n\tif i.Annotations[\"helm.sh/test\"] != \"foo bar\" {\n\t\tt.Error(\"Did not get expected value for helm.sh/test annotation\")\n\t}\n}\n\nfunc TestLoadUnorderedIndex(t *testing.T) {\n\ti, err := LoadIndexFile(unorderedTestfile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tverifyLocalIndex(t, i)\n}\n\nfunc TestMerge(t *testing.T) {\n\tind1 := NewIndexFile()\n\n\tif err := ind1.MustAdd(&chart.Metadata{APIVersion: \"v2\", Name: \"dreadnought\", Version: \"0.1.0\"}, \"dreadnought-0.1.0.tgz\", \"http://example.com\", \"aaaa\"); err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tind2 := NewIndexFile()\n\n\tfor _, x := range []struct {\n\t\tmd       *chart.Metadata\n\t\tfilename string\n\t\tbaseURL  string\n\t\tdigest   string\n\t}{\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"dreadnought\", Version: \"0.2.0\"}, \"dreadnought-0.2.0.tgz\", \"http://example.com\", \"aaaabbbb\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"doughnut\", Version: \"0.2.0\"}, \"doughnut-0.2.0.tgz\", \"http://example.com\", \"ccccbbbb\"},\n\t} {\n\t\tif err := ind2.MustAdd(x.md, x.filename, x.baseURL, x.digest); err != nil {\n\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t}\n\t}\n\n\tind1.Merge(ind2)\n\n\tif len(ind1.Entries) != 2 {\n\t\tt.Errorf(\"Expected 2 entries, got %d\", len(ind1.Entries))\n\t}\n\n\tvs := ind1.Entries[\"dreadnought\"]\n\tif len(vs) != 2 {\n\t\tt.Errorf(\"Expected 2 versions, got %d\", len(vs))\n\t}\n\n\tif v := vs[1]; v.Version != \"0.2.0\" {\n\t\tt.Errorf(\"Expected %q version to be 0.2.0, got %s\", v.Name, v.Version)\n\t}\n\n}\n\nfunc TestDownloadIndexFile(t *testing.T) {\n\tt.Run(\"should  download index file\", func(t *testing.T) {\n\t\tsrv, err := startLocalServerForTests(nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer srv.Close()\n\n\t\tr, err := NewChartRepository(&Entry{\n\t\t\tName: testRepo,\n\t\t\tURL:  srv.URL,\n\t\t}, getter.All(&cli.EnvSettings{}))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Problem creating chart repository from %s: %v\", testRepo, err)\n\t\t}\n\n\t\tidx, err := r.DownloadIndexFile()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to download index file to %s: %#v\", idx, err)\n\t\t}\n\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created index file: %#v\", err)\n\t\t}\n\n\t\ti, err := LoadIndexFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Index %q failed to parse: %s\", testfile, err)\n\t\t}\n\t\tverifyLocalIndex(t, i)\n\n\t\t// Check that charts file is also created\n\t\tidx = filepath.Join(r.CachePath, helmpath.CacheChartsFile(r.Config.Name))\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created charts file: %#v\", err)\n\t\t}\n\n\t\tb, err := ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading charts file: %#v\", err)\n\t\t}\n\t\tverifyLocalChartsFile(t, b, i)\n\t})\n\n\tt.Run(\"should not decode the path in the repo url while downloading index\", func(t *testing.T) {\n\t\tchartRepoURLPath := \"/some%2Fpath/test\"\n\t\tfileBytes, err := ioutil.ReadFile(\"testdata/local-index.yaml\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.URL.RawPath == chartRepoURLPath+\"/index.yaml\" {\n\t\t\t\tw.Write(fileBytes)\n\t\t\t}\n\t\t})\n\t\tsrv, err := startLocalServerForTests(handler)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer srv.Close()\n\n\t\tr, err := NewChartRepository(&Entry{\n\t\t\tName: testRepo,\n\t\t\tURL:  srv.URL + chartRepoURLPath,\n\t\t}, getter.All(&cli.EnvSettings{}))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Problem creating chart repository from %s: %v\", testRepo, err)\n\t\t}\n\n\t\tidx, err := r.DownloadIndexFile()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to download index file to %s: %#v\", idx, err)\n\t\t}\n\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created index file: %#v\", err)\n\t\t}\n\n\t\ti, err := LoadIndexFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Index %q failed to parse: %s\", testfile, err)\n\t\t}\n\t\tverifyLocalIndex(t, i)\n\n\t\t// Check that charts file is also created\n\t\tidx = filepath.Join(r.CachePath, helmpath.CacheChartsFile(r.Config.Name))\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created charts file: %#v\", err)\n\t\t}\n\n\t\tb, err := ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading charts file: %#v\", err)\n\t\t}\n\t\tverifyLocalChartsFile(t, b, i)\n\t})\n}\n\nfunc verifyLocalIndex(t *testing.T, i *IndexFile) {\n\tnumEntries := len(i.Entries)\n\tif numEntries != 3 {\n\t\tt.Errorf(\"Expected 3 entries in index file but got %d\", numEntries)\n\t}\n\n\talpine, ok := i.Entries[\"alpine\"]\n\tif !ok {\n\t\tt.Fatalf(\"'alpine' section not found.\")\n\t}\n\n\tif l := len(alpine); l != 1 {\n\t\tt.Fatalf(\"'alpine' should have 1 chart, got %d\", l)\n\t}\n\n\tnginx, ok := i.Entries[\"nginx\"]\n\tif !ok || len(nginx) != 2 {\n\t\tt.Fatalf(\"Expected 2 nginx entries\")\n\t}\n\n\texpects := []*ChartVersion{\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tAPIVersion:  \"v2\",\n\t\t\t\tName:        \"alpine\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"1.0.0\",\n\t\t\t\tKeywords:    []string{\"linux\", \"alpine\", \"small\", \"sumtin\"},\n\t\t\t\tHome:        \"https://github.com/something\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://charts.helm.sh/stable/alpine-1.0.0.tgz\",\n\t\t\t\t\"http://storage2.googleapis.com/kubernetes-charts/alpine-1.0.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tAPIVersion:  \"v2\",\n\t\t\t\tName:        \"nginx\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"0.2.0\",\n\t\t\t\tKeywords:    []string{\"popular\", \"web server\", \"proxy\"},\n\t\t\t\tHome:        \"https://github.com/something/else\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://charts.helm.sh/stable/nginx-0.2.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tAPIVersion:  \"v2\",\n\t\t\t\tName:        \"nginx\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"0.1.0\",\n\t\t\t\tKeywords:    []string{\"popular\", \"web server\", \"proxy\"},\n\t\t\t\tHome:        \"https://github.com/something\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://charts.helm.sh/stable/nginx-0.1.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t}\n\ttests := []*ChartVersion{alpine[0], nginx[0], nginx[1]}\n\n\tfor i, tt := range tests {\n\t\texpect := expects[i]\n\t\tif tt.Name != expect.Name {\n\t\t\tt.Errorf(\"Expected name %q, got %q\", expect.Name, tt.Name)\n\t\t}\n\t\tif tt.Description != expect.Description {\n\t\t\tt.Errorf(\"Expected description %q, got %q\", expect.Description, tt.Description)\n\t\t}\n\t\tif tt.Version != expect.Version {\n\t\t\tt.Errorf(\"Expected version %q, got %q\", expect.Version, tt.Version)\n\t\t}\n\t\tif tt.Digest != expect.Digest {\n\t\t\tt.Errorf(\"Expected digest %q, got %q\", expect.Digest, tt.Digest)\n\t\t}\n\t\tif tt.Home != expect.Home {\n\t\t\tt.Errorf(\"Expected home %q, got %q\", expect.Home, tt.Home)\n\t\t}\n\n\t\tfor i, url := range tt.URLs {\n\t\t\tif url != expect.URLs[i] {\n\t\t\t\tt.Errorf(\"Expected URL %q, got %q\", expect.URLs[i], url)\n\t\t\t}\n\t\t}\n\t\tfor i, kw := range tt.Keywords {\n\t\t\tif kw != expect.Keywords[i] {\n\t\t\t\tt.Errorf(\"Expected keywords %q, got %q\", expect.Keywords[i], kw)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc verifyLocalChartsFile(t *testing.T, chartsContent []byte, indexContent *IndexFile) {\n\tvar expected, real []string\n\tfor chart := range indexContent.Entries {\n\t\texpected = append(expected, chart)\n\t}\n\tsort.Strings(expected)\n\n\tscanner := bufio.NewScanner(bytes.NewReader(chartsContent))\n\tfor scanner.Scan() {\n\t\treal = append(real, scanner.Text())\n\t}\n\tsort.Strings(real)\n\n\tif strings.Join(expected, \" \") != strings.Join(real, \" \") {\n\t\tt.Errorf(\"Cached charts file content unexpected. Expected:\\n%s\\ngot:\\n%s\", expected, real)\n\t}\n}\n\nfunc TestIndexDirectory(t *testing.T) {\n\tdir := \"testdata/repository\"\n\tindex, err := IndexDirectory(dir, \"http://localhost:8080\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif l := len(index.Entries); l != 3 {\n\t\tt.Fatalf(\"Expected 3 entries, got %d\", l)\n\t}\n\n\t// Other things test the entry generation more thoroughly. We just test a\n\t// few fields.\n\n\tcorpus := []struct{ chartName, downloadLink string }{\n\t\t{\"frobnitz\", \"http://localhost:8080/frobnitz-1.2.3.tgz\"},\n\t\t{\"zarthal\", \"http://localhost:8080/universe/zarthal-1.0.0.tgz\"},\n\t}\n\n\tfor _, test := range corpus {\n\t\tcname := test.chartName\n\t\tfrobs, ok := index.Entries[cname]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"Could not read chart %s\", cname)\n\t\t}\n\n\t\tfrob := frobs[0]\n\t\tif frob.Digest == \"\" {\n\t\t\tt.Errorf(\"Missing digest of file %s.\", frob.Name)\n\t\t}\n\t\tif frob.URLs[0] != test.downloadLink {\n\t\t\tt.Errorf(\"Unexpected URLs: %v\", frob.URLs)\n\t\t}\n\t\tif frob.Name != cname {\n\t\t\tt.Errorf(\"Expected %q, got %q\", cname, frob.Name)\n\t\t}\n\t}\n}\n\nfunc TestIndexAdd(t *testing.T) {\n\ti := NewIndexFile()\n\n\tfor _, x := range []struct {\n\t\tmd       *chart.Metadata\n\t\tfilename string\n\t\tbaseURL  string\n\t\tdigest   string\n\t}{\n\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"alpine\", Version: \"0.1.0\"}, \"/home/charts/alpine-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\"},\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \"deis\", Version: \"0.1.0\"}, \"/home/charts/deis-0.1.0.tgz\", \"http://example.com/charts/\", \"sha256:1234567890\"},\n\t} {\n\t\tif err := i.MustAdd(x.md, x.filename, x.baseURL, x.digest); err != nil {\n\t\t\tt.Errorf(\"unexpected error adding to index: %s\", err)\n\t\t}\n\t}\n\n\tif i.Entries[\"clipper\"][0].URLs[0] != \"http://example.com/charts/clipper-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/clipper-0.1.0.tgz, got %s\", i.Entries[\"clipper\"][0].URLs[0])\n\t}\n\tif i.Entries[\"alpine\"][0].URLs[0] != \"http://example.com/charts/alpine-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/alpine-0.1.0.tgz, got %s\", i.Entries[\"alpine\"][0].URLs[0])\n\t}\n\tif i.Entries[\"deis\"][0].URLs[0] != \"http://example.com/charts/deis-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/deis-0.1.0.tgz, got %s\", i.Entries[\"deis\"][0].URLs[0])\n\t}\n\n\t// test error condition\n\tif err := i.MustAdd(&chart.Metadata{}, \"error-0.1.0.tgz\", \"\", \"\"); err == nil {\n\t\tt.Fatal(\"expected error adding to index\")\n\t}\n}\n\nfunc TestIndexWrite(t *testing.T) {\n\ti := NewIndexFile()\n\tif err := i.MustAdd(&chart.Metadata{APIVersion: \"v2\", Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\"); err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tdir := t.TempDir()\n\ttestpath := filepath.Join(dir, \"test\")\n\ti.WriteFile(testpath, 0600)\n\n\tgot, err := ioutil.ReadFile(testpath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !strings.Contains(string(got), \"clipper-0.1.0.tgz\") {\n\t\tt.Fatal(\"Index files doesn't contain expected content\")\n\t}\n}\n\nfunc TestAddFileIndexEntriesNil(t *testing.T) {\n\ti := NewIndexFile()\n\ti.APIVersion = chart.APIVersionV1\n\ti.Entries = nil\n\tfor _, x := range []struct {\n\t\tmd       *chart.Metadata\n\t\tfilename string\n\t\tbaseURL  string\n\t\tdigest   string\n\t}{\n\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \" \", Version: \"8033-5.apinie+s.r\"}, \"setter-0.1.9+beta.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n\t} {\n\t\tif err := i.MustAdd(x.md, x.filename, x.baseURL, x.digest); err == nil {\n\t\t\tt.Errorf(\"expected err to be non-nil when entries not initialized\")\n\t\t}\n\t}\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo // import \"helm.sh/helm/v3/pkg/repo\"\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"sigs.k8s.io/yaml\"\n)\n\n// File represents the repositories.yaml file\ntype File struct {\n\tAPIVersion   string    `json:\"apiVersion\"`\n\tGenerated    time.Time `json:\"generated\"`\n\tRepositories []*Entry  `json:\"repositories\"`\n}\n\n// NewFile generates an empty repositories file.\n//\n// Generated and APIVersion are automatically set.\nfunc NewFile() *File {\n\treturn &File{\n\t\tAPIVersion:   APIVersionV1,\n\t\tGenerated:    time.Now(),\n\t\tRepositories: []*Entry{},\n\t}\n}\n\n// LoadFile takes a file at the given path and returns a File object\nfunc LoadFile(path string) (*File, error) {\n\tr := new(File)\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn r, errors.Wrapf(err, \"couldn't load repositories file (%s)\", path)\n\t}\n\n\terr = yaml.Unmarshal(b, r)\n\treturn r, err\n}\n\n// Add adds one or more repo entries to a repo file.\nfunc (r *File) Add(re ...*Entry) {\n\tr.Repositories = append(r.Repositories, re...)\n}\n\n// Update attempts to replace one or more repo entries in a repo file. If an\n// entry with the same name doesn't exist in the repo file it will add it.\nfunc (r *File) Update(re ...*Entry) {\n\tfor _, target := range re {\n\t\tr.update(target)\n\t}\n}\n\nfunc (r *File) update(e *Entry) {\n\tfor j, repo := range r.Repositories {\n\t\tif repo.Name == e.Name {\n\t\t\tr.Repositories[j] = e\n\t\t\treturn\n\t\t}\n\t}\n\tr.Add(e)\n}\n\n// Has returns true if the given name is already a repository name.\nfunc (r *File) Has(name string) bool {\n\tentry := r.Get(name)\n\treturn entry != nil\n}\n\n// Get returns an entry with the given name if it exists, otherwise returns nil\nfunc (r *File) Get(name string) *Entry {\n\tfor _, entry := range r.Repositories {\n\t\tif entry.Name == name {\n\t\t\treturn entry\n\t\t}\n\t}\n\treturn nil\n}\n\n// Remove removes the entry from the list of repositories.\nfunc (r *File) Remove(name string) bool {\n\tcp := []*Entry{}\n\tfound := false\n\tfor _, rf := range r.Repositories {\n\t\tif rf == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif rf.Name == name {\n\t\t\tfound = true\n\t\t\tcontinue\n\t\t}\n\t\tcp = append(cp, rf)\n\t}\n\tr.Repositories = cp\n\treturn found\n}\n\n// WriteFile writes a repositories file to the given path.\nfunc (r *File) WriteFile(path string, perm os.FileMode) error {\n\tdata, err := yaml.Marshal(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(path, data, perm)\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n)\n\nconst testRepositoriesFile = \"testdata/repositories.yaml\"\n\nfunc TestFile(t *testing.T) {\n\trf := NewFile()\n\trf.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t)\n\n\tif len(rf.Repositories) != 2 {\n\t\tt.Fatal(\"Expected 2 repositories\")\n\t}\n\n\tif rf.Has(\"nosuchrepo\") {\n\t\tt.Error(\"Found nonexistent repo\")\n\t}\n\tif !rf.Has(\"incubator\") {\n\t\tt.Error(\"incubator repo is missing\")\n\t}\n\n\tstable := rf.Repositories[0]\n\tif stable.Name != \"stable\" {\n\t\tt.Error(\"stable is not named stable\")\n\t}\n\tif stable.URL != \"https://example.com/stable/charts\" {\n\t\tt.Error(\"Wrong URL for stable\")\n\t}\n}\n\nfunc TestNewFile(t *testing.T) {\n\texpects := NewFile()\n\texpects.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t)\n\n\tfile, err := LoadFile(testRepositoriesFile)\n\tif err != nil {\n\t\tt.Errorf(\"%q could not be loaded: %s\", testRepositoriesFile, err)\n\t}\n\n\tif len(expects.Repositories) != len(file.Repositories) {\n\t\tt.Fatalf(\"Unexpected repo data: %#v\", file.Repositories)\n\t}\n\n\tfor i, expect := range expects.Repositories {\n\t\tgot := file.Repositories[i]\n\t\tif expect.Name != got.Name {\n\t\t\tt.Errorf(\"Expected name %q, got %q\", expect.Name, got.Name)\n\t\t}\n\t\tif expect.URL != got.URL {\n\t\t\tt.Errorf(\"Expected url %q, got %q\", expect.URL, got.URL)\n\t\t}\n\t}\n}\n\nfunc TestRepoFile_Get(t *testing.T) {\n\trepo := NewFile()\n\trepo.Add(\n\t\t&Entry{\n\t\t\tName: \"first\",\n\t\t\tURL:  \"https://example.com/first\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"second\",\n\t\t\tURL:  \"https://example.com/second\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"third\",\n\t\t\tURL:  \"https://example.com/third\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"fourth\",\n\t\t\tURL:  \"https://example.com/fourth\",\n\t\t},\n\t)\n\n\tname := \"second\"\n\n\tentry := repo.Get(name)\n\tif entry == nil {\n\t\tt.Fatalf(\"Expected repo entry %q to be found\", name)\n\t}\n\n\tif entry.URL != \"https://example.com/second\" {\n\t\tt.Errorf(\"Expected repo URL to be %q but got %q\", \"https://example.com/second\", entry.URL)\n\t}\n\n\tentry = repo.Get(\"nonexistent\")\n\tif entry != nil {\n\t\tt.Errorf(\"Got unexpected entry %+v\", entry)\n\t}\n}\n\nfunc TestRemoveRepository(t *testing.T) {\n\tsampleRepository := NewFile()\n\tsampleRepository.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t)\n\n\tremoveRepository := \"stable\"\n\tfound := sampleRepository.Remove(removeRepository)\n\tif !found {\n\t\tt.Errorf(\"expected repository %s not found\", removeRepository)\n\t}\n\n\tfound = sampleRepository.Has(removeRepository)\n\tif found {\n\t\tt.Errorf(\"repository %s not deleted\", removeRepository)\n\t}\n}\n\nfunc TestUpdateRepository(t *testing.T) {\n\tsampleRepository := NewFile()\n\tsampleRepository.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t)\n\tnewRepoName := \"sample\"\n\tsampleRepository.Update(&Entry{Name: newRepoName,\n\t\tURL: \"https://example.com/sample\",\n\t})\n\n\tif !sampleRepository.Has(newRepoName) {\n\t\tt.Errorf(\"expected repository %s not found\", newRepoName)\n\t}\n\trepoCount := len(sampleRepository.Repositories)\n\n\tsampleRepository.Update(&Entry{Name: newRepoName,\n\t\tURL: \"https://example.com/sample\",\n\t})\n\n\tif repoCount != len(sampleRepository.Repositories) {\n\t\tt.Errorf(\"invalid number of repositories found %d, expected number of repositories %d\", len(sampleRepository.Repositories), repoCount)\n\t}\n}\n\nfunc TestWriteFile(t *testing.T) {\n\tsampleRepository := NewFile()\n\tsampleRepository.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t)\n\n\tfile, err := ioutil.TempFile(\"\", \"helm-repo\")\n\tif err != nil {\n\t\tt.Errorf(\"failed to create test-file (%v)\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\tif err := sampleRepository.WriteFile(file.Name(), 0644); err != nil {\n\t\tt.Errorf(\"failed to write file (%v)\", err)\n\t}\n\n\trepos, err := LoadFile(file.Name())\n\tif err != nil {\n\t\tt.Errorf(\"failed to load file (%v)\", err)\n\t}\n\tfor _, repo := range sampleRepository.Repositories {\n\t\tif !repos.Has(repo.Name) {\n\t\t\tt.Errorf(\"expected repository %s not found\", repo.Name)\n\t\t}\n\t}\n}\n\nfunc TestRepoNotExists(t *testing.T) {\n\tif _, err := LoadFile(\"/this/path/does/not/exist.yaml\"); err == nil {\n\t\tt.Errorf(\"expected err to be non-nil when path does not exist\")\n\t} else if !strings.Contains(err.Error(), \"couldn't load repositories file\") {\n\t\tt.Errorf(\"expected prompt `couldn't load repositories file`\")\n\t}\n}\n\nfunc TestRemoveRepositoryInvalidEntries(t *testing.T) {\n\tsampleRepository := NewFile()\n\tsampleRepository.Add(\n\t\t&Entry{\n\t\t\tName: \"stable\",\n\t\t\tURL:  \"https://example.com/stable/charts\",\n\t\t},\n\t\t&Entry{\n\t\t\tName: \"incubator\",\n\t\t\tURL:  \"https://example.com/incubator\",\n\t\t},\n\t\t&Entry{},\n\t\tnil,\n\t\t&Entry{\n\t\t\tName: \"test\",\n\t\t\tURL:  \"https://example.com/test\",\n\t\t},\n\t)\n\n\tremoveRepository := \"stable\"\n\tfound := sampleRepository.Remove(removeRepository)\n\tif !found {\n\t\tt.Errorf(\"expected repository %s not found\", removeRepository)\n\t}\n\n\tfound = sampleRepository.Has(removeRepository)\n\tif found {\n\t\tt.Errorf(\"repository %s not deleted\", removeRepository)\n\t}\n}\n"], "filenames": ["pkg/repo/index.go", "pkg/repo/index_test.go", "pkg/repo/repo.go", "pkg/repo/repo_test.go"], "buggy_code_start_loc": [120, 62, 102, 227], "buggy_code_end_loc": [341, 528, 102, 227], "fixing_code_start_loc": [121, 63, 103, 228], "fixing_code_end_loc": [350, 562, 106, 259], "type": "CWE-476", "message": "Helm is a tool for managing Charts, pre-configured Kubernetes resources. Versions prior to 3.10.3 are subject to NULL Pointer Dereference in the _repo_package. The _repo_ package contains a handler that processes the index file of a repository. For example, the Helm client adds references to chart repositories where charts are managed. The _repo_ package parses the index file of the repository and loads it into structures Go can work with. Some index files can cause array data structures to be created causing a memory violation. Applications that use the _repo_ package in the Helm SDK to parse an index file can suffer a Denial of Service when that input causes a panic that cannot be recovered from. The Helm Client will panic with an index file that causes a memory violation panic. Helm is not a long running service so the panic will not affect future uses of the Helm client. This issue has been patched in 3.10.3. SDK users can validate index files that are correctly formatted before passing them to the _repo_ functions.", "other": {"cve": {"id": "CVE-2022-23525", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-15T19:15:17.027", "lastModified": "2022-12-20T15:56:37.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Helm is a tool for managing Charts, pre-configured Kubernetes resources. Versions prior to 3.10.3 are subject to NULL Pointer Dereference in the _repo_package. The _repo_ package contains a handler that processes the index file of a repository. For example, the Helm client adds references to chart repositories where charts are managed. The _repo_ package parses the index file of the repository and loads it into structures Go can work with. Some index files can cause array data structures to be created causing a memory violation. Applications that use the _repo_ package in the Helm SDK to parse an index file can suffer a Denial of Service when that input causes a panic that cannot be recovered from. The Helm Client will panic with an index file that causes a memory violation panic. Helm is not a long running service so the panic will not affect future uses of the Helm client. This issue has been patched in 3.10.3. SDK users can validate index files that are correctly formatted before passing them to the _repo_ functions."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:helm:helm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.10.3", "matchCriteriaId": "135AAD77-267A-4119-877F-60195A002775"}]}]}], "references": [{"url": "https://github.com/helm/helm/commit/638ebffbc2e445156f3978f02fd83d9af1e56f5b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/helm/helm/security/advisories/GHSA-53c4-hhmh-vw5q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/helm/helm/commit/638ebffbc2e445156f3978f02fd83d9af1e56f5b"}}