{"buggy_code": ["require 'strscan'\n\nmodule WebSocket\n  class Extensions\n\n    class Parser\n      TOKEN    = /([!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+)/\n      NOTOKEN  = /([^!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z])/\n      QUOTED   = /\"((?:\\\\[\\x00-\\x7f]|[^\\x00-\\x08\\x0a-\\x1f\\x7f\"])*)\"/\n      PARAM    = %r{#{ TOKEN.source }(?:=(?:#{ TOKEN.source }|#{ QUOTED.source }))?}\n      EXT      = %r{#{ TOKEN.source }(?: *; *#{ PARAM.source })*}\n      EXT_LIST = %r{^#{ EXT.source }(?: *, *#{ EXT.source })*$}\n      NUMBER   = /^-?(0|[1-9][0-9]*)(\\.[0-9]+)?$/\n\n      ParseError = Class.new(ArgumentError)\n\n      def self.parse_header(header)\n        offers = Offers.new\n        return offers if header == '' or header.nil?\n\n        unless header =~ EXT_LIST\n          raise ParseError, \"Invalid Sec-WebSocket-Extensions header: #{ header }\"\n        end\n\n        scanner = StringScanner.new(header)\n        value   = scanner.scan(EXT)\n\n        until value.nil?\n          params = value.scan(PARAM)\n          name   = params.shift.first\n          offer  = {}\n\n          params.each do |key, unquoted, quoted|\n            if unquoted\n              data = unquoted\n            elsif quoted\n              data = quoted.gsub(/\\\\/, '')\n            else\n              data = true\n            end\n            if data != true and data =~ NUMBER\n              data = data =~ /\\./ ? data.to_f : data.to_i(10)\n            end\n\n            if offer.has_key?(key)\n              offer[key] = [*offer[key]] + [data]\n            else\n              offer[key] = data\n            end\n          end\n\n          offers.push(name, offer)\n\n          scanner.scan(/ *, */)\n          value = scanner.scan(EXT)\n        end\n        offers\n      end\n\n      def self.serialize_params(name, params)\n        values = []\n\n        print = lambda do |key, value|\n          case value\n          when Array   then value.each { |v| print[key, v] }\n          when true    then values.push(key)\n          when Numeric then values.push(key + '=' + value.to_s)\n          else\n            if value =~ NOTOKEN\n              values.push(key + '=\"' + value.gsub(/\"/, '\\\"') + '\"')\n            else\n              values.push(key + '=' + value)\n            end\n          end\n        end\n\n        params.keys.sort.each { |key| print[key, params[key]] }\n\n        ([name] + values).join('; ')\n      end\n    end\n\n    class Offers\n      def initialize\n        @by_name  = {}\n        @in_order = []\n      end\n\n      def push(name, params)\n        @by_name[name] ||= []\n        @by_name[name].push(params)\n        @in_order.push(:name => name, :params => params)\n      end\n\n      def each_offer(&block)\n        @in_order.each do |offer|\n          block.call(offer[:name], offer[:params])\n        end\n      end\n\n      def by_name(name)\n        @by_name[name] || []\n      end\n\n      def to_a\n        @in_order.dup\n      end\n    end\n\n  end\nend\n", "require \"spec_helper\"\n\ndescribe WebSocket::Extensions::Parser do\n  describe :parse_header do\n    def parse(string)\n      WebSocket::Extensions::Parser.parse_header(string).to_a\n    end\n\n    it \"parses an empty header\" do\n      expect(parse '').to eq []\n    end\n\n    it \"parses a missing header\" do\n      expect(parse nil).to eq []\n    end\n\n    it \"raises on invalid input\" do\n      expect { parse 'a,' }.to raise_error(WebSocket::Extensions::Parser::ParseError)\n    end\n\n    it \"parses one offer with no params\" do\n      expect(parse 'a').to eq [\n        { :name => \"a\", :params => {} }\n      ]\n    end\n\n    it \"parses two offers with no params\" do\n      expect(parse 'a, b').to eq [\n        { :name => \"a\", :params => {} }, { :name => \"b\", :params => {} }\n      ]\n    end\n\n    it \"parses a duplicate offer name\" do\n      expect(parse 'a, a').to eq [\n        { :name => \"a\", :params => {} },\n        { :name => \"a\", :params => {} }\n      ]\n    end\n\n    it \"parses a flag\" do\n      expect(parse 'a; b').to eq [\n        { :name => \"a\", :params => { \"b\" => true } }\n      ]\n    end\n\n    it \"parses an unquoted param\" do\n      expect(parse 'a; b=1').to eq [\n        { :name => \"a\", :params => { \"b\" => 1 } }\n      ]\n    end\n\n    it \"parses a quoted param\" do\n      expect(parse 'a; b=\"hi, \\\"there\"').to eq [\n        { :name => \"a\", :params => { \"b\" => 'hi, \"there' } }\n      ]\n    end\n\n    it \"parses multiple params\" do\n      expect(parse 'a; b; c=1; d=\"hi\"').to eq [\n        { :name => \"a\", :params => { \"b\" => true, \"c\" => 1, \"d\" => \"hi\" } }\n      ]\n    end\n\n    it \"parses duplicate params\" do\n      expect(parse 'a; b; c=1; b=\"hi\"').to eq [\n        { :name => \"a\", :params => { \"b\" => [true, \"hi\"], \"c\" => 1 } }\n      ]\n    end\n\n    it \"parses multiple complex offers\" do\n      expect(parse 'a; b=1, c, b; d, c; e=\"hi, there\"; e, a; b').to eq [\n        { :name => \"a\", :params => { \"b\" => 1 } },\n        { :name => \"c\", :params => {} },\n        { :name => \"b\", :params => { \"d\" => true } },\n        { :name => \"c\", :params => { \"e\" => ['hi, there', true] } },\n        { :name => \"a\", :params => { \"b\" => true } }\n      ]\n    end\n  end\n\n  describe :serialize_params do\n    def serialize(name, params)\n      WebSocket::Extensions::Parser.serialize_params(name, params)\n    end\n\n    it \"serializes empty params\" do\n      expect(serialize \"a\", {}).to eq 'a'\n    end\n\n    it \"serializes a flag\" do\n      expect(serialize \"a\", \"b\" => true).to eq 'a; b'\n    end\n\n    it \"serializes an unquoted param\" do\n      expect(serialize \"a\", \"b\" => 42).to eq 'a; b=42'\n    end\n\n    it \"serializes a quoted param\" do\n      expect(serialize \"a\", \"b\" => \"hi, there\").to eq 'a; b=\"hi, there\"'\n    end\n\n    it \"serializes multiple params\" do\n      expect(serialize \"a\", \"b\" => true, \"c\" => 1, \"d\" => \"hi\").to eq 'a; b; c=1; d=hi'\n    end\n\n    it \"serializes duplicate params\" do\n      expect(serialize \"a\", \"b\" => [true, \"hi\"], \"c\" => 1).to eq 'a; b; b=hi; c=1'\n    end\n  end\nend\n"], "fixing_code": ["require 'strscan'\n\nmodule WebSocket\n  class Extensions\n\n    class Parser\n      TOKEN    = /([!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+)/\n      NOTOKEN  = /([^!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z])/\n      QUOTED   = /\"((?:\\\\[\\x00-\\x7f]|[^\\x00-\\x08\\x0a-\\x1f\\x7f\"\\\\])*)\"/\n      PARAM    = %r{#{ TOKEN.source }(?:=(?:#{ TOKEN.source }|#{ QUOTED.source }))?}\n      EXT      = %r{#{ TOKEN.source }(?: *; *#{ PARAM.source })*}\n      EXT_LIST = %r{^#{ EXT.source }(?: *, *#{ EXT.source })*$}\n      NUMBER   = /^-?(0|[1-9][0-9]*)(\\.[0-9]+)?$/\n\n      ParseError = Class.new(ArgumentError)\n\n      def self.parse_header(header)\n        offers = Offers.new\n        return offers if header == '' or header.nil?\n\n        unless header =~ EXT_LIST\n          raise ParseError, \"Invalid Sec-WebSocket-Extensions header: #{ header }\"\n        end\n\n        scanner = StringScanner.new(header)\n        value   = scanner.scan(EXT)\n\n        until value.nil?\n          params = value.scan(PARAM)\n          name   = params.shift.first\n          offer  = {}\n\n          params.each do |key, unquoted, quoted|\n            if unquoted\n              data = unquoted\n            elsif quoted\n              data = quoted.gsub(/\\\\/, '')\n            else\n              data = true\n            end\n            if data != true and data =~ NUMBER\n              data = data =~ /\\./ ? data.to_f : data.to_i(10)\n            end\n\n            if offer.has_key?(key)\n              offer[key] = [*offer[key]] + [data]\n            else\n              offer[key] = data\n            end\n          end\n\n          offers.push(name, offer)\n\n          scanner.scan(/ *, */)\n          value = scanner.scan(EXT)\n        end\n        offers\n      end\n\n      def self.serialize_params(name, params)\n        values = []\n\n        print = lambda do |key, value|\n          case value\n          when Array   then value.each { |v| print[key, v] }\n          when true    then values.push(key)\n          when Numeric then values.push(key + '=' + value.to_s)\n          else\n            if value =~ NOTOKEN\n              values.push(key + '=\"' + value.gsub(/\"/, '\\\"') + '\"')\n            else\n              values.push(key + '=' + value)\n            end\n          end\n        end\n\n        params.keys.sort.each { |key| print[key, params[key]] }\n\n        ([name] + values).join('; ')\n      end\n    end\n\n    class Offers\n      def initialize\n        @by_name  = {}\n        @in_order = []\n      end\n\n      def push(name, params)\n        @by_name[name] ||= []\n        @by_name[name].push(params)\n        @in_order.push(:name => name, :params => params)\n      end\n\n      def each_offer(&block)\n        @in_order.each do |offer|\n          block.call(offer[:name], offer[:params])\n        end\n      end\n\n      def by_name(name)\n        @by_name[name] || []\n      end\n\n      def to_a\n        @in_order.dup\n      end\n    end\n\n  end\nend\n", "require \"spec_helper\"\n\ndescribe WebSocket::Extensions::Parser do\n  describe :parse_header do\n    def parse(string)\n      WebSocket::Extensions::Parser.parse_header(string).to_a\n    end\n\n    it \"parses an empty header\" do\n      expect(parse '').to eq []\n    end\n\n    it \"parses a missing header\" do\n      expect(parse nil).to eq []\n    end\n\n    it \"raises on invalid input\" do\n      expect { parse 'a,' }.to raise_error(WebSocket::Extensions::Parser::ParseError)\n    end\n\n    it \"parses one offer with no params\" do\n      expect(parse 'a').to eq [\n        { :name => \"a\", :params => {} }\n      ]\n    end\n\n    it \"parses two offers with no params\" do\n      expect(parse 'a, b').to eq [\n        { :name => \"a\", :params => {} }, { :name => \"b\", :params => {} }\n      ]\n    end\n\n    it \"parses a duplicate offer name\" do\n      expect(parse 'a, a').to eq [\n        { :name => \"a\", :params => {} },\n        { :name => \"a\", :params => {} }\n      ]\n    end\n\n    it \"parses a flag\" do\n      expect(parse 'a; b').to eq [\n        { :name => \"a\", :params => { \"b\" => true } }\n      ]\n    end\n\n    it \"parses an unquoted param\" do\n      expect(parse 'a; b=1').to eq [\n        { :name => \"a\", :params => { \"b\" => 1 } }\n      ]\n    end\n\n    it \"parses a quoted param\" do\n      expect(parse 'a; b=\"hi, \\\"there\"').to eq [\n        { :name => \"a\", :params => { \"b\" => 'hi, \"there' } }\n      ]\n    end\n\n    it \"parses multiple params\" do\n      expect(parse 'a; b; c=1; d=\"hi\"').to eq [\n        { :name => \"a\", :params => { \"b\" => true, \"c\" => 1, \"d\" => \"hi\" } }\n      ]\n    end\n\n    it \"parses duplicate params\" do\n      expect(parse 'a; b; c=1; b=\"hi\"').to eq [\n        { :name => \"a\", :params => { \"b\" => [true, \"hi\"], \"c\" => 1 } }\n      ]\n    end\n\n    it \"parses multiple complex offers\" do\n      expect(parse 'a; b=1, c, b; d, c; e=\"hi, there\"; e, a; b').to eq [\n        { :name => \"a\", :params => { \"b\" => 1 } },\n        { :name => \"c\", :params => {} },\n        { :name => \"b\", :params => { \"d\" => true } },\n        { :name => \"c\", :params => { \"e\" => ['hi, there', true] } },\n        { :name => \"a\", :params => { \"b\" => true } }\n      ]\n    end\n\n    it \"rejects a string missing its closing quote\" do\n      expect {\n        parse \"foo; bar=\\\"fooa\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\"\n      }.to raise_error(WebSocket::Extensions::Parser::ParseError)\n    end\n  end\n\n  describe :serialize_params do\n    def serialize(name, params)\n      WebSocket::Extensions::Parser.serialize_params(name, params)\n    end\n\n    it \"serializes empty params\" do\n      expect(serialize \"a\", {}).to eq 'a'\n    end\n\n    it \"serializes a flag\" do\n      expect(serialize \"a\", \"b\" => true).to eq 'a; b'\n    end\n\n    it \"serializes an unquoted param\" do\n      expect(serialize \"a\", \"b\" => 42).to eq 'a; b=42'\n    end\n\n    it \"serializes a quoted param\" do\n      expect(serialize \"a\", \"b\" => \"hi, there\").to eq 'a; b=\"hi, there\"'\n    end\n\n    it \"serializes multiple params\" do\n      expect(serialize \"a\", \"b\" => true, \"c\" => 1, \"d\" => \"hi\").to eq 'a; b; c=1; d=hi'\n    end\n\n    it \"serializes duplicate params\" do\n      expect(serialize \"a\", \"b\" => [true, \"hi\"], \"c\" => 1).to eq 'a; b; b=hi; c=1'\n    end\n  end\nend\n"], "filenames": ["lib/websocket/extensions/parser.rb", "spec/websocket/extensions/parser_spec.rb"], "buggy_code_start_loc": [9, 78], "buggy_code_end_loc": [10, 78], "fixing_code_start_loc": [9, 79], "fixing_code_end_loc": [10, 85], "type": "NVD-CWE-Other", "message": "websocket-extensions ruby module prior to 0.1.5 allows Denial of Service (DoS) via Regex Backtracking. The extension parser may take quadratic time when parsing a header containing an unclosed string parameter value whose content is a repeating two-byte sequence of a backslash and some other character. This could be abused by an attacker to conduct Regex Denial Of Service (ReDoS) on a single-threaded server by providing a malicious payload with the Sec-WebSocket-Extensions header.", "other": {"cve": {"id": "CVE-2020-7663", "sourceIdentifier": "report@snyk.io", "published": "2020-06-02T19:15:12.467", "lastModified": "2023-01-20T18:22:53.047", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "websocket-extensions ruby module prior to 0.1.5 allows Denial of Service (DoS) via Regex Backtracking. The extension parser may take quadratic time when parsing a header containing an unclosed string parameter value whose content is a repeating two-byte sequence of a backslash and some other character. This could be abused by an attacker to conduct Regex Denial Of Service (ReDoS) on a single-threaded server by providing a malicious payload with the Sec-WebSocket-Extensions header."}, {"lang": "es", "value": "El m\u00f3dulo de ruby websocket-extensions versiones anteriores a 0.1.5, permite una denegaci\u00f3n de servicio (DoS) por medio de Regex Backtracking. El analizador de extensiones puede tomar un tiempo cuadr\u00e1tico cuando analiza un encabezado que contiene un valor de par\u00e1metro de cadena no cerrado cuyo contenido es una secuencia repetitiva de dos bytes de una barra diagonal inversa y alg\u00fan otro car\u00e1cter. Esto podr\u00eda ser abusado por un atacante para conducir una Denegaci\u00f3n de Servicio de Regex (ReDoS) en un servidor de un subproceso \u00fanico al proporcionar una carga \u00fatil maliciosa con el encabezado Sec-WebSocket-Extensions."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:websocket-extensions_project:websocket-extensions:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "0.1.5", "matchCriteriaId": "709E45F8-F7E2-434B-8D0D-E9AF4E9C52FA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "https://blog.jcoglan.com/2020/06/02/redos-vulnerability-in-websocket-extensions", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/faye/websocket-extensions-ruby/commit/aa156a439da681361ed6f53f1a8131892418838b", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/faye/websocket-extensions-ruby/security/advisories/GHSA-g6wq-qcwm-j5g2", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00031.html", "source": "report@snyk.io", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-RUBY-WEBSOCKETEXTENSIONS-570830", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4502-1/", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/faye/websocket-extensions-ruby/commit/aa156a439da681361ed6f53f1a8131892418838b"}}