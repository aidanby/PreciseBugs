{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Mediated virtual PCI display host device driver\n *\n * Emulate enough of qemu stdvga to make bochs-drm.ko happy.  That is\n * basically the vram memory bar and the bochs dispi interface vbe\n * registers in the mmio register bar.\tSpecifically it does *not*\n * include any legacy vga stuff.  Device looks a lot like \"qemu -device\n * secondary-vga\".\n *\n *   (c) Gerd Hoffmann <kraxel@redhat.com>\n *\n * based on mtty driver which is:\n *   Copyright (c) 2016, NVIDIA CORPORATION. All rights reserved.\n *\t Author: Neo Jia <cjia@nvidia.com>\n *\t\t Kirti Wankhede <kwankhede@nvidia.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/cdev.h>\n#include <linux/vfio.h>\n#include <linux/iommu.h>\n#include <linux/sysfs.h>\n#include <linux/mdev.h>\n#include <linux/pci.h>\n#include <linux/dma-buf.h>\n#include <linux/highmem.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_rect.h>\n#include <drm/drm_modeset_lock.h>\n#include <drm/drm_property.h>\n#include <drm/drm_plane.h>\n\n\n#define VBE_DISPI_INDEX_ID\t\t0x0\n#define VBE_DISPI_INDEX_XRES\t\t0x1\n#define VBE_DISPI_INDEX_YRES\t\t0x2\n#define VBE_DISPI_INDEX_BPP\t\t0x3\n#define VBE_DISPI_INDEX_ENABLE\t\t0x4\n#define VBE_DISPI_INDEX_BANK\t\t0x5\n#define VBE_DISPI_INDEX_VIRT_WIDTH\t0x6\n#define VBE_DISPI_INDEX_VIRT_HEIGHT\t0x7\n#define VBE_DISPI_INDEX_X_OFFSET\t0x8\n#define VBE_DISPI_INDEX_Y_OFFSET\t0x9\n#define VBE_DISPI_INDEX_VIDEO_MEMORY_64K 0xa\n#define VBE_DISPI_INDEX_COUNT\t\t0xb\n\n#define VBE_DISPI_ID0\t\t\t0xB0C0\n#define VBE_DISPI_ID1\t\t\t0xB0C1\n#define VBE_DISPI_ID2\t\t\t0xB0C2\n#define VBE_DISPI_ID3\t\t\t0xB0C3\n#define VBE_DISPI_ID4\t\t\t0xB0C4\n#define VBE_DISPI_ID5\t\t\t0xB0C5\n\n#define VBE_DISPI_DISABLED\t\t0x00\n#define VBE_DISPI_ENABLED\t\t0x01\n#define VBE_DISPI_GETCAPS\t\t0x02\n#define VBE_DISPI_8BIT_DAC\t\t0x20\n#define VBE_DISPI_LFB_ENABLED\t\t0x40\n#define VBE_DISPI_NOCLEARMEM\t\t0x80\n\n\n#define MBOCHS_NAME\t\t  \"mbochs\"\n#define MBOCHS_CLASS_NAME\t  \"mbochs\"\n\n#define MBOCHS_EDID_REGION_INDEX  VFIO_PCI_NUM_REGIONS\n#define MBOCHS_NUM_REGIONS        (MBOCHS_EDID_REGION_INDEX+1)\n\n#define MBOCHS_CONFIG_SPACE_SIZE  0xff\n#define MBOCHS_MMIO_BAR_OFFSET\t  PAGE_SIZE\n#define MBOCHS_MMIO_BAR_SIZE\t  PAGE_SIZE\n#define MBOCHS_EDID_OFFSET\t  (MBOCHS_MMIO_BAR_OFFSET +\t\\\n\t\t\t\t   MBOCHS_MMIO_BAR_SIZE)\n#define MBOCHS_EDID_SIZE\t  PAGE_SIZE\n#define MBOCHS_MEMORY_BAR_OFFSET  (MBOCHS_EDID_OFFSET + \\\n\t\t\t\t   MBOCHS_EDID_SIZE)\n\n#define MBOCHS_EDID_BLOB_OFFSET   (MBOCHS_EDID_SIZE/2)\n\n#define STORE_LE16(addr, val)\t(*(u16 *)addr = val)\n#define STORE_LE32(addr, val)\t(*(u32 *)addr = val)\n\n\nMODULE_LICENSE(\"GPL v2\");\n\nstatic int max_mbytes = 256;\nmodule_param_named(count, max_mbytes, int, 0444);\nMODULE_PARM_DESC(mem, \"megabytes available to \" MBOCHS_NAME \" devices\");\n\n\n#define MBOCHS_TYPE_1 \"small\"\n#define MBOCHS_TYPE_2 \"medium\"\n#define MBOCHS_TYPE_3 \"large\"\n\nstatic const struct mbochs_type {\n\tconst char *name;\n\tu32 mbytes;\n\tu32 max_x;\n\tu32 max_y;\n} mbochs_types[] = {\n\t{\n\t\t.name\t= MBOCHS_CLASS_NAME \"-\" MBOCHS_TYPE_1,\n\t\t.mbytes = 4,\n\t\t.max_x  = 800,\n\t\t.max_y  = 600,\n\t}, {\n\t\t.name\t= MBOCHS_CLASS_NAME \"-\" MBOCHS_TYPE_2,\n\t\t.mbytes = 16,\n\t\t.max_x  = 1920,\n\t\t.max_y  = 1440,\n\t}, {\n\t\t.name\t= MBOCHS_CLASS_NAME \"-\" MBOCHS_TYPE_3,\n\t\t.mbytes = 64,\n\t\t.max_x  = 0,\n\t\t.max_y  = 0,\n\t},\n};\n\n\nstatic dev_t\t\tmbochs_devt;\nstatic struct class\t*mbochs_class;\nstatic struct cdev\tmbochs_cdev;\nstatic struct device\tmbochs_dev;\nstatic int\t\tmbochs_used_mbytes;\nstatic const struct vfio_device_ops mbochs_dev_ops;\n\nstruct vfio_region_info_ext {\n\tstruct vfio_region_info          base;\n\tstruct vfio_region_info_cap_type type;\n};\n\nstruct mbochs_mode {\n\tu32 drm_format;\n\tu32 bytepp;\n\tu32 width;\n\tu32 height;\n\tu32 stride;\n\tu32 __pad;\n\tu64 offset;\n\tu64 size;\n};\n\nstruct mbochs_dmabuf {\n\tstruct mbochs_mode mode;\n\tu32 id;\n\tstruct page **pages;\n\tpgoff_t pagecount;\n\tstruct dma_buf *buf;\n\tstruct mdev_state *mdev_state;\n\tstruct list_head next;\n\tbool unlinked;\n};\n\n/* State of each mdev device */\nstruct mdev_state {\n\tstruct vfio_device vdev;\n\tu8 *vconfig;\n\tu64 bar_mask[3];\n\tu32 memory_bar_mask;\n\tstruct mutex ops_lock;\n\tstruct mdev_device *mdev;\n\n\tconst struct mbochs_type *type;\n\tu16 vbe[VBE_DISPI_INDEX_COUNT];\n\tu64 memsize;\n\tstruct page **pages;\n\tpgoff_t pagecount;\n\tstruct vfio_region_gfx_edid edid_regs;\n\tu8 edid_blob[0x400];\n\n\tstruct list_head dmabufs;\n\tu32 active_id;\n\tu32 next_id;\n};\n\nstatic const char *vbe_name_list[VBE_DISPI_INDEX_COUNT] = {\n\t[VBE_DISPI_INDEX_ID]               = \"id\",\n\t[VBE_DISPI_INDEX_XRES]             = \"xres\",\n\t[VBE_DISPI_INDEX_YRES]             = \"yres\",\n\t[VBE_DISPI_INDEX_BPP]              = \"bpp\",\n\t[VBE_DISPI_INDEX_ENABLE]           = \"enable\",\n\t[VBE_DISPI_INDEX_BANK]             = \"bank\",\n\t[VBE_DISPI_INDEX_VIRT_WIDTH]       = \"virt-width\",\n\t[VBE_DISPI_INDEX_VIRT_HEIGHT]      = \"virt-height\",\n\t[VBE_DISPI_INDEX_X_OFFSET]         = \"x-offset\",\n\t[VBE_DISPI_INDEX_Y_OFFSET]         = \"y-offset\",\n\t[VBE_DISPI_INDEX_VIDEO_MEMORY_64K] = \"video-mem\",\n};\n\nstatic const char *vbe_name(u32 index)\n{\n\tif (index < ARRAY_SIZE(vbe_name_list))\n\t\treturn vbe_name_list[index];\n\treturn \"(invalid)\";\n}\n\nstatic struct page *__mbochs_get_page(struct mdev_state *mdev_state,\n\t\t\t\t      pgoff_t pgoff);\nstatic struct page *mbochs_get_page(struct mdev_state *mdev_state,\n\t\t\t\t    pgoff_t pgoff);\n\nstatic void mbochs_create_config_space(struct mdev_state *mdev_state)\n{\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_VENDOR_ID],\n\t\t   0x1234);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_DEVICE_ID],\n\t\t   0x1111);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_SUBSYSTEM_VENDOR_ID],\n\t\t   PCI_SUBVENDOR_ID_REDHAT_QUMRANET);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_SUBSYSTEM_ID],\n\t\t   PCI_SUBDEVICE_ID_QEMU);\n\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_COMMAND],\n\t\t   PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_CLASS_DEVICE],\n\t\t   PCI_CLASS_DISPLAY_OTHER);\n\tmdev_state->vconfig[PCI_CLASS_REVISION] =  0x01;\n\n\tSTORE_LE32((u32 *) &mdev_state->vconfig[PCI_BASE_ADDRESS_0],\n\t\t   PCI_BASE_ADDRESS_SPACE_MEMORY |\n\t\t   PCI_BASE_ADDRESS_MEM_TYPE_32\t |\n\t\t   PCI_BASE_ADDRESS_MEM_PREFETCH);\n\tmdev_state->bar_mask[0] = ~(mdev_state->memsize) + 1;\n\n\tSTORE_LE32((u32 *) &mdev_state->vconfig[PCI_BASE_ADDRESS_2],\n\t\t   PCI_BASE_ADDRESS_SPACE_MEMORY |\n\t\t   PCI_BASE_ADDRESS_MEM_TYPE_32);\n\tmdev_state->bar_mask[2] = ~(MBOCHS_MMIO_BAR_SIZE) + 1;\n}\n\nstatic int mbochs_check_framebuffer(struct mdev_state *mdev_state,\n\t\t\t\t    struct mbochs_mode *mode)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tu16 *vbe = mdev_state->vbe;\n\tu32 virt_width;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tif (!(vbe[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED))\n\t\tgoto nofb;\n\n\tmemset(mode, 0, sizeof(*mode));\n\tswitch (vbe[VBE_DISPI_INDEX_BPP]) {\n\tcase 32:\n\t\tmode->drm_format = DRM_FORMAT_XRGB8888;\n\t\tmode->bytepp = 4;\n\t\tbreak;\n\tdefault:\n\t\tdev_info_ratelimited(dev, \"%s: bpp %d not supported\\n\",\n\t\t\t\t     __func__, vbe[VBE_DISPI_INDEX_BPP]);\n\t\tgoto nofb;\n\t}\n\n\tmode->width  = vbe[VBE_DISPI_INDEX_XRES];\n\tmode->height = vbe[VBE_DISPI_INDEX_YRES];\n\tvirt_width  = vbe[VBE_DISPI_INDEX_VIRT_WIDTH];\n\tif (virt_width < mode->width)\n\t\tvirt_width = mode->width;\n\tmode->stride = virt_width * mode->bytepp;\n\tmode->size   = (u64)mode->stride * mode->height;\n\tmode->offset = ((u64)vbe[VBE_DISPI_INDEX_X_OFFSET] * mode->bytepp +\n\t\t       (u64)vbe[VBE_DISPI_INDEX_Y_OFFSET] * mode->stride);\n\n\tif (mode->width < 64 || mode->height < 64) {\n\t\tdev_info_ratelimited(dev, \"%s: invalid resolution %dx%d\\n\",\n\t\t\t\t     __func__, mode->width, mode->height);\n\t\tgoto nofb;\n\t}\n\tif (mode->offset + mode->size > mdev_state->memsize) {\n\t\tdev_info_ratelimited(dev, \"%s: framebuffer memory overflow\\n\",\n\t\t\t\t     __func__);\n\t\tgoto nofb;\n\t}\n\n\treturn 0;\n\nnofb:\n\tmemset(mode, 0, sizeof(*mode));\n\treturn -EINVAL;\n}\n\nstatic bool mbochs_modes_equal(struct mbochs_mode *mode1,\n\t\t\t       struct mbochs_mode *mode2)\n{\n\treturn memcmp(mode1, mode2, sizeof(struct mbochs_mode)) == 0;\n}\n\nstatic void handle_pci_cfg_write(struct mdev_state *mdev_state, u16 offset,\n\t\t\t\t char *buf, u32 count)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tint index = (offset - PCI_BASE_ADDRESS_0) / 0x04;\n\tu32 cfg_addr;\n\n\tswitch (offset) {\n\tcase PCI_BASE_ADDRESS_0:\n\tcase PCI_BASE_ADDRESS_2:\n\t\tcfg_addr = *(u32 *)buf;\n\n\t\tif (cfg_addr == 0xffffffff) {\n\t\t\tcfg_addr = (cfg_addr & mdev_state->bar_mask[index]);\n\t\t} else {\n\t\t\tcfg_addr &= PCI_BASE_ADDRESS_MEM_MASK;\n\t\t\tif (cfg_addr)\n\t\t\t\tdev_info(dev, \"BAR #%d @ 0x%x\\n\",\n\t\t\t\t\t index, cfg_addr);\n\t\t}\n\n\t\tcfg_addr |= (mdev_state->vconfig[offset] &\n\t\t\t     ~PCI_BASE_ADDRESS_MEM_MASK);\n\t\tSTORE_LE32(&mdev_state->vconfig[offset], cfg_addr);\n\t\tbreak;\n\t}\n}\n\nstatic void handle_mmio_write(struct mdev_state *mdev_state, u16 offset,\n\t\t\t      char *buf, u32 count)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tint index;\n\tu16 reg16;\n\n\tswitch (offset) {\n\tcase 0x400 ... 0x41f: /* vga ioports remapped */\n\t\tgoto unhandled;\n\tcase 0x500 ... 0x515: /* bochs dispi interface */\n\t\tif (count != 2)\n\t\t\tgoto unhandled;\n\t\tindex = (offset - 0x500) / 2;\n\t\treg16 = *(u16 *)buf;\n\t\tif (index < ARRAY_SIZE(mdev_state->vbe))\n\t\t\tmdev_state->vbe[index] = reg16;\n\t\tdev_dbg(dev, \"%s: vbe write %d = %d (%s)\\n\",\n\t\t\t__func__, index, reg16, vbe_name(index));\n\t\tbreak;\n\tcase 0x600 ... 0x607: /* qemu extended regs */\n\t\tgoto unhandled;\n\tdefault:\nunhandled:\n\t\tdev_dbg(dev, \"%s: @0x%03x, count %d (unhandled)\\n\",\n\t\t\t__func__, offset, count);\n\t\tbreak;\n\t}\n}\n\nstatic void handle_mmio_read(struct mdev_state *mdev_state, u16 offset,\n\t\t\t     char *buf, u32 count)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tstruct vfio_region_gfx_edid *edid;\n\tu16 reg16 = 0;\n\tint index;\n\n\tswitch (offset) {\n\tcase 0x000 ... 0x3ff: /* edid block */\n\t\tedid = &mdev_state->edid_regs;\n\t\tif (edid->link_state != VFIO_DEVICE_GFX_LINK_STATE_UP ||\n\t\t    offset >= edid->edid_size) {\n\t\t\tmemset(buf, 0, count);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(buf, mdev_state->edid_blob + offset, count);\n\t\tbreak;\n\tcase 0x500 ... 0x515: /* bochs dispi interface */\n\t\tif (count != 2)\n\t\t\tgoto unhandled;\n\t\tindex = (offset - 0x500) / 2;\n\t\tif (index < ARRAY_SIZE(mdev_state->vbe))\n\t\t\treg16 = mdev_state->vbe[index];\n\t\tdev_dbg(dev, \"%s: vbe read %d = %d (%s)\\n\",\n\t\t\t__func__, index, reg16, vbe_name(index));\n\t\t*(u16 *)buf = reg16;\n\t\tbreak;\n\tdefault:\nunhandled:\n\t\tdev_dbg(dev, \"%s: @0x%03x, count %d (unhandled)\\n\",\n\t\t\t__func__, offset, count);\n\t\tmemset(buf, 0, count);\n\t\tbreak;\n\t}\n}\n\nstatic void handle_edid_regs(struct mdev_state *mdev_state, u16 offset,\n\t\t\t     char *buf, u32 count, bool is_write)\n{\n\tchar *regs = (void *)&mdev_state->edid_regs;\n\n\tif (offset + count > sizeof(mdev_state->edid_regs))\n\t\treturn;\n\tif (count != 4)\n\t\treturn;\n\tif (offset % 4)\n\t\treturn;\n\n\tif (is_write) {\n\t\tswitch (offset) {\n\t\tcase offsetof(struct vfio_region_gfx_edid, link_state):\n\t\tcase offsetof(struct vfio_region_gfx_edid, edid_size):\n\t\t\tmemcpy(regs + offset, buf, count);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* read-only regs */\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmemcpy(buf, regs + offset, count);\n\t}\n}\n\nstatic void handle_edid_blob(struct mdev_state *mdev_state, u16 offset,\n\t\t\t     char *buf, u32 count, bool is_write)\n{\n\tif (offset + count > mdev_state->edid_regs.edid_max_size)\n\t\treturn;\n\tif (is_write)\n\t\tmemcpy(mdev_state->edid_blob + offset, buf, count);\n\telse\n\t\tmemcpy(buf, mdev_state->edid_blob + offset, count);\n}\n\nstatic ssize_t mdev_access(struct mdev_state *mdev_state, char *buf,\n\t\t\t   size_t count, loff_t pos, bool is_write)\n{\n\tstruct page *pg;\n\tloff_t poff;\n\tchar *map;\n\tint ret = 0;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tif (pos < MBOCHS_CONFIG_SPACE_SIZE) {\n\t\tif (is_write)\n\t\t\thandle_pci_cfg_write(mdev_state, pos, buf, count);\n\t\telse\n\t\t\tmemcpy(buf, (mdev_state->vconfig + pos), count);\n\n\t} else if (pos >= MBOCHS_MMIO_BAR_OFFSET &&\n\t\t   pos + count <= (MBOCHS_MMIO_BAR_OFFSET +\n\t\t\t\t   MBOCHS_MMIO_BAR_SIZE)) {\n\t\tpos -= MBOCHS_MMIO_BAR_OFFSET;\n\t\tif (is_write)\n\t\t\thandle_mmio_write(mdev_state, pos, buf, count);\n\t\telse\n\t\t\thandle_mmio_read(mdev_state, pos, buf, count);\n\n\t} else if (pos >= MBOCHS_EDID_OFFSET &&\n\t\t   pos + count <= (MBOCHS_EDID_OFFSET +\n\t\t\t\t   MBOCHS_EDID_SIZE)) {\n\t\tpos -= MBOCHS_EDID_OFFSET;\n\t\tif (pos < MBOCHS_EDID_BLOB_OFFSET) {\n\t\t\thandle_edid_regs(mdev_state, pos, buf, count, is_write);\n\t\t} else {\n\t\t\tpos -= MBOCHS_EDID_BLOB_OFFSET;\n\t\t\thandle_edid_blob(mdev_state, pos, buf, count, is_write);\n\t\t}\n\n\t} else if (pos >= MBOCHS_MEMORY_BAR_OFFSET &&\n\t\t   pos + count <=\n\t\t   MBOCHS_MEMORY_BAR_OFFSET + mdev_state->memsize) {\n\t\tpos -= MBOCHS_MMIO_BAR_OFFSET;\n\t\tpoff = pos & ~PAGE_MASK;\n\t\tpg = __mbochs_get_page(mdev_state, pos >> PAGE_SHIFT);\n\t\tmap = kmap(pg);\n\t\tif (is_write)\n\t\t\tmemcpy(map + poff, buf, count);\n\t\telse\n\t\t\tmemcpy(buf, map + poff, count);\n\t\tkunmap(pg);\n\t\tput_page(pg);\n\n\t} else {\n\t\tdev_dbg(mdev_state->vdev.dev, \"%s: %s @0x%llx (unhandled)\\n\",\n\t\t\t__func__, is_write ? \"WR\" : \"RD\", pos);\n\t\tret = -1;\n\t\tgoto accessfailed;\n\t}\n\n\tret = count;\n\n\naccessfailed:\n\tmutex_unlock(&mdev_state->ops_lock);\n\n\treturn ret;\n}\n\nstatic int mbochs_reset(struct mdev_state *mdev_state)\n{\n\tu32 size64k = mdev_state->memsize / (64 * 1024);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mdev_state->vbe); i++)\n\t\tmdev_state->vbe[i] = 0;\n\tmdev_state->vbe[VBE_DISPI_INDEX_ID] = VBE_DISPI_ID5;\n\tmdev_state->vbe[VBE_DISPI_INDEX_VIDEO_MEMORY_64K] = size64k;\n\treturn 0;\n}\n\nstatic int mbochs_probe(struct mdev_device *mdev)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\n\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)\n\t\treturn -ENOMEM;\n\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\treturn -ENOMEM;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\n\tmbochs_used_mbytes += type->mbytes;\n\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\n\nerr_mem:\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n\treturn ret;\n}\n\nstatic void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\n\tmbochs_used_mbytes -= mdev_state->type->mbytes;\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}\n\nstatic ssize_t mbochs_read(struct vfio_device *vdev, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tunsigned int done = 0;\n\tint ret;\n\n\twhile (count) {\n\t\tsize_t filled;\n\n\t\tif (count >= 4 && !(*ppos % 4)) {\n\t\t\tu32 val;\n\n\t\t\tret =  mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t   *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 4;\n\t\t} else if (count >= 2 && !(*ppos % 2)) {\n\t\t\tu16 val;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 val;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 1;\n\t\t}\n\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\t*ppos += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\n\nread_err:\n\treturn -EFAULT;\n}\n\nstatic ssize_t mbochs_write(struct vfio_device *vdev, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tunsigned int done = 0;\n\tint ret;\n\n\twhile (count) {\n\t\tsize_t filled;\n\n\t\tif (count >= 4 && !(*ppos % 4)) {\n\t\t\tu32 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 4;\n\t\t} else if (count >= 2 && !(*ppos % 2)) {\n\t\t\tu16 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 1;\n\t\t}\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\t*ppos += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\nwrite_err:\n\treturn -EFAULT;\n}\n\nstatic struct page *__mbochs_get_page(struct mdev_state *mdev_state,\n\t\t\t\t      pgoff_t pgoff)\n{\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tif (!mdev_state->pages[pgoff]) {\n\t\tmdev_state->pages[pgoff] =\n\t\t\talloc_pages(GFP_HIGHUSER | __GFP_ZERO, 0);\n\t\tif (!mdev_state->pages[pgoff])\n\t\t\treturn NULL;\n\t}\n\n\tget_page(mdev_state->pages[pgoff]);\n\treturn mdev_state->pages[pgoff];\n}\n\nstatic struct page *mbochs_get_page(struct mdev_state *mdev_state,\n\t\t\t\t    pgoff_t pgoff)\n{\n\tstruct page *page;\n\n\tif (WARN_ON(pgoff >= mdev_state->pagecount))\n\t\treturn NULL;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\tpage = __mbochs_get_page(mdev_state, pgoff);\n\tmutex_unlock(&mdev_state->ops_lock);\n\n\treturn page;\n}\n\nstatic void mbochs_put_pages(struct mdev_state *mdev_state)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tint i, count = 0;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tfor (i = 0; i < mdev_state->pagecount; i++) {\n\t\tif (!mdev_state->pages[i])\n\t\t\tcontinue;\n\t\tput_page(mdev_state->pages[i]);\n\t\tmdev_state->pages[i] = NULL;\n\t\tcount++;\n\t}\n\tdev_dbg(dev, \"%s: %d pages released\\n\", __func__, count);\n}\n\nstatic vm_fault_t mbochs_region_vm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mdev_state *mdev_state = vma->vm_private_data;\n\tpgoff_t page_offset = (vmf->address - vma->vm_start) >> PAGE_SHIFT;\n\n\tif (page_offset >= mdev_state->pagecount)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tvmf->page = mbochs_get_page(mdev_state, page_offset);\n\tif (!vmf->page)\n\t\treturn VM_FAULT_SIGBUS;\n\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct mbochs_region_vm_ops = {\n\t.fault = mbochs_region_vm_fault,\n};\n\nstatic int mbochs_mmap(struct vfio_device *vdev, struct vm_area_struct *vma)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\n\tif (vma->vm_pgoff != MBOCHS_MEMORY_BAR_OFFSET >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif (vma->vm_end - vma->vm_start > mdev_state->memsize)\n\t\treturn -EINVAL;\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &mbochs_region_vm_ops;\n\tvma->vm_private_data = mdev_state;\n\treturn 0;\n}\n\nstatic vm_fault_t mbochs_dmabuf_vm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mbochs_dmabuf *dmabuf = vma->vm_private_data;\n\n\tif (WARN_ON(vmf->pgoff >= dmabuf->pagecount))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tvmf->page = dmabuf->pages[vmf->pgoff];\n\tget_page(vmf->page);\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct mbochs_dmabuf_vm_ops = {\n\t.fault = mbochs_dmabuf_vm_fault,\n};\n\nstatic int mbochs_mmap_dmabuf(struct dma_buf *buf, struct vm_area_struct *vma)\n{\n\tstruct mbochs_dmabuf *dmabuf = buf->priv;\n\tstruct device *dev = mdev_dev(dmabuf->mdev_state->mdev);\n\n\tdev_dbg(dev, \"%s: %d\\n\", __func__, dmabuf->id);\n\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &mbochs_dmabuf_vm_ops;\n\tvma->vm_private_data = dmabuf;\n\treturn 0;\n}\n\nstatic void mbochs_print_dmabuf(struct mbochs_dmabuf *dmabuf,\n\t\t\t\tconst char *prefix)\n{\n\tstruct device *dev = mdev_dev(dmabuf->mdev_state->mdev);\n\tu32 fourcc = dmabuf->mode.drm_format;\n\n\tdev_dbg(dev, \"%s/%d: %c%c%c%c, %dx%d, stride %d, off 0x%llx, size 0x%llx, pages %ld\\n\",\n\t\tprefix, dmabuf->id,\n\t\tfourcc ? ((fourcc >>  0) & 0xff) : '-',\n\t\tfourcc ? ((fourcc >>  8) & 0xff) : '-',\n\t\tfourcc ? ((fourcc >> 16) & 0xff) : '-',\n\t\tfourcc ? ((fourcc >> 24) & 0xff) : '-',\n\t\tdmabuf->mode.width, dmabuf->mode.height, dmabuf->mode.stride,\n\t\tdmabuf->mode.offset, dmabuf->mode.size, dmabuf->pagecount);\n}\n\nstatic struct sg_table *mbochs_map_dmabuf(struct dma_buf_attachment *at,\n\t\t\t\t\t  enum dma_data_direction direction)\n{\n\tstruct mbochs_dmabuf *dmabuf = at->dmabuf->priv;\n\tstruct device *dev = mdev_dev(dmabuf->mdev_state->mdev);\n\tstruct sg_table *sg;\n\n\tdev_dbg(dev, \"%s: %d\\n\", __func__, dmabuf->id);\n\n\tsg = kzalloc(sizeof(*sg), GFP_KERNEL);\n\tif (!sg)\n\t\tgoto err1;\n\tif (sg_alloc_table_from_pages(sg, dmabuf->pages, dmabuf->pagecount,\n\t\t\t\t      0, dmabuf->mode.size, GFP_KERNEL) < 0)\n\t\tgoto err2;\n\tif (dma_map_sgtable(at->dev, sg, direction, 0))\n\t\tgoto err3;\n\n\treturn sg;\n\nerr3:\n\tsg_free_table(sg);\nerr2:\n\tkfree(sg);\nerr1:\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void mbochs_unmap_dmabuf(struct dma_buf_attachment *at,\n\t\t\t\tstruct sg_table *sg,\n\t\t\t\tenum dma_data_direction direction)\n{\n\tstruct mbochs_dmabuf *dmabuf = at->dmabuf->priv;\n\tstruct device *dev = mdev_dev(dmabuf->mdev_state->mdev);\n\n\tdev_dbg(dev, \"%s: %d\\n\", __func__, dmabuf->id);\n\n\tdma_unmap_sgtable(at->dev, sg, direction, 0);\n\tsg_free_table(sg);\n\tkfree(sg);\n}\n\nstatic void mbochs_release_dmabuf(struct dma_buf *buf)\n{\n\tstruct mbochs_dmabuf *dmabuf = buf->priv;\n\tstruct mdev_state *mdev_state = dmabuf->mdev_state;\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tpgoff_t pg;\n\n\tdev_dbg(dev, \"%s: %d\\n\", __func__, dmabuf->id);\n\n\tfor (pg = 0; pg < dmabuf->pagecount; pg++)\n\t\tput_page(dmabuf->pages[pg]);\n\n\tmutex_lock(&mdev_state->ops_lock);\n\tdmabuf->buf = NULL;\n\tif (dmabuf->unlinked)\n\t\tkfree(dmabuf);\n\tmutex_unlock(&mdev_state->ops_lock);\n}\n\nstatic struct dma_buf_ops mbochs_dmabuf_ops = {\n\t.map_dma_buf\t  = mbochs_map_dmabuf,\n\t.unmap_dma_buf\t  = mbochs_unmap_dmabuf,\n\t.release\t  = mbochs_release_dmabuf,\n\t.mmap\t\t  = mbochs_mmap_dmabuf,\n};\n\nstatic struct mbochs_dmabuf *mbochs_dmabuf_alloc(struct mdev_state *mdev_state,\n\t\t\t\t\t\t struct mbochs_mode *mode)\n{\n\tstruct mbochs_dmabuf *dmabuf;\n\tpgoff_t page_offset, pg;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tdmabuf = kzalloc(sizeof(struct mbochs_dmabuf), GFP_KERNEL);\n\tif (!dmabuf)\n\t\treturn NULL;\n\n\tdmabuf->mode = *mode;\n\tdmabuf->id = mdev_state->next_id++;\n\tdmabuf->pagecount = DIV_ROUND_UP(mode->size, PAGE_SIZE);\n\tdmabuf->pages = kcalloc(dmabuf->pagecount, sizeof(struct page *),\n\t\t\t\tGFP_KERNEL);\n\tif (!dmabuf->pages)\n\t\tgoto err_free_dmabuf;\n\n\tpage_offset = dmabuf->mode.offset >> PAGE_SHIFT;\n\tfor (pg = 0; pg < dmabuf->pagecount; pg++) {\n\t\tdmabuf->pages[pg] = __mbochs_get_page(mdev_state,\n\t\t\t\t\t\t      page_offset + pg);\n\t\tif (!dmabuf->pages[pg])\n\t\t\tgoto err_free_pages;\n\t}\n\n\tdmabuf->mdev_state = mdev_state;\n\tlist_add(&dmabuf->next, &mdev_state->dmabufs);\n\n\tmbochs_print_dmabuf(dmabuf, __func__);\n\treturn dmabuf;\n\nerr_free_pages:\n\twhile (pg > 0)\n\t\tput_page(dmabuf->pages[--pg]);\n\tkfree(dmabuf->pages);\nerr_free_dmabuf:\n\tkfree(dmabuf);\n\treturn NULL;\n}\n\nstatic struct mbochs_dmabuf *\nmbochs_dmabuf_find_by_mode(struct mdev_state *mdev_state,\n\t\t\t   struct mbochs_mode *mode)\n{\n\tstruct mbochs_dmabuf *dmabuf;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tlist_for_each_entry(dmabuf, &mdev_state->dmabufs, next)\n\t\tif (mbochs_modes_equal(&dmabuf->mode, mode))\n\t\t\treturn dmabuf;\n\n\treturn NULL;\n}\n\nstatic struct mbochs_dmabuf *\nmbochs_dmabuf_find_by_id(struct mdev_state *mdev_state, u32 id)\n{\n\tstruct mbochs_dmabuf *dmabuf;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tlist_for_each_entry(dmabuf, &mdev_state->dmabufs, next)\n\t\tif (dmabuf->id == id)\n\t\t\treturn dmabuf;\n\n\treturn NULL;\n}\n\nstatic int mbochs_dmabuf_export(struct mbochs_dmabuf *dmabuf)\n{\n\tstruct mdev_state *mdev_state = dmabuf->mdev_state;\n\tstruct device *dev = mdev_state->vdev.dev;\n\tDEFINE_DMA_BUF_EXPORT_INFO(exp_info);\n\tstruct dma_buf *buf;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tif (!IS_ALIGNED(dmabuf->mode.offset, PAGE_SIZE)) {\n\t\tdev_info_ratelimited(dev, \"%s: framebuffer not page-aligned\\n\",\n\t\t\t\t     __func__);\n\t\treturn -EINVAL;\n\t}\n\n\texp_info.ops = &mbochs_dmabuf_ops;\n\texp_info.size = dmabuf->mode.size;\n\texp_info.priv = dmabuf;\n\n\tbuf = dma_buf_export(&exp_info);\n\tif (IS_ERR(buf)) {\n\t\tdev_info_ratelimited(dev, \"%s: dma_buf_export failed: %ld\\n\",\n\t\t\t\t     __func__, PTR_ERR(buf));\n\t\treturn PTR_ERR(buf);\n\t}\n\n\tdmabuf->buf = buf;\n\tdev_dbg(dev, \"%s: %d\\n\", __func__, dmabuf->id);\n\treturn 0;\n}\n\nstatic int mbochs_get_region_info(struct mdev_state *mdev_state,\n\t\t\t\t  struct vfio_region_info_ext *ext)\n{\n\tstruct vfio_region_info *region_info = &ext->base;\n\n\tif (region_info->index >= MBOCHS_NUM_REGIONS)\n\t\treturn -EINVAL;\n\n\tswitch (region_info->index) {\n\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\tregion_info->offset = 0;\n\t\tregion_info->size   = MBOCHS_CONFIG_SPACE_SIZE;\n\t\tregion_info->flags  = (VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_WRITE);\n\t\tbreak;\n\tcase VFIO_PCI_BAR0_REGION_INDEX:\n\t\tregion_info->offset = MBOCHS_MEMORY_BAR_OFFSET;\n\t\tregion_info->size   = mdev_state->memsize;\n\t\tregion_info->flags  = (VFIO_REGION_INFO_FLAG_READ  |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_WRITE |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_MMAP);\n\t\tbreak;\n\tcase VFIO_PCI_BAR2_REGION_INDEX:\n\t\tregion_info->offset = MBOCHS_MMIO_BAR_OFFSET;\n\t\tregion_info->size   = MBOCHS_MMIO_BAR_SIZE;\n\t\tregion_info->flags  = (VFIO_REGION_INFO_FLAG_READ  |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_WRITE);\n\t\tbreak;\n\tcase MBOCHS_EDID_REGION_INDEX:\n\t\text->base.argsz = sizeof(*ext);\n\t\text->base.offset = MBOCHS_EDID_OFFSET;\n\t\text->base.size = MBOCHS_EDID_SIZE;\n\t\text->base.flags = (VFIO_REGION_INFO_FLAG_READ  |\n\t\t\t\t   VFIO_REGION_INFO_FLAG_WRITE |\n\t\t\t\t   VFIO_REGION_INFO_FLAG_CAPS);\n\t\text->base.cap_offset = offsetof(typeof(*ext), type);\n\t\text->type.header.id = VFIO_REGION_INFO_CAP_TYPE;\n\t\text->type.header.version = 1;\n\t\text->type.header.next = 0;\n\t\text->type.type = VFIO_REGION_TYPE_GFX;\n\t\text->type.subtype = VFIO_REGION_SUBTYPE_GFX_EDID;\n\t\tbreak;\n\tdefault:\n\t\tregion_info->size   = 0;\n\t\tregion_info->offset = 0;\n\t\tregion_info->flags  = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int mbochs_get_irq_info(struct vfio_irq_info *irq_info)\n{\n\tirq_info->count = 0;\n\treturn 0;\n}\n\nstatic int mbochs_get_device_info(struct vfio_device_info *dev_info)\n{\n\tdev_info->flags = VFIO_DEVICE_FLAGS_PCI;\n\tdev_info->num_regions = MBOCHS_NUM_REGIONS;\n\tdev_info->num_irqs = VFIO_PCI_NUM_IRQS;\n\treturn 0;\n}\n\nstatic int mbochs_query_gfx_plane(struct mdev_state *mdev_state,\n\t\t\t\t  struct vfio_device_gfx_plane_info *plane)\n{\n\tstruct mbochs_dmabuf *dmabuf;\n\tstruct mbochs_mode mode;\n\tint ret;\n\n\tif (plane->flags & VFIO_GFX_PLANE_TYPE_PROBE) {\n\t\tif (plane->flags == (VFIO_GFX_PLANE_TYPE_PROBE |\n\t\t\t\t     VFIO_GFX_PLANE_TYPE_DMABUF))\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\n\tif (plane->flags != VFIO_GFX_PLANE_TYPE_DMABUF)\n\t\treturn -EINVAL;\n\n\tplane->drm_format_mod = 0;\n\tplane->x_pos\t      = 0;\n\tplane->y_pos\t      = 0;\n\tplane->x_hot\t      = 0;\n\tplane->y_hot\t      = 0;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tret = -EINVAL;\n\tif (plane->drm_plane_type == DRM_PLANE_TYPE_PRIMARY)\n\t\tret = mbochs_check_framebuffer(mdev_state, &mode);\n\tif (ret < 0) {\n\t\tplane->drm_format     = 0;\n\t\tplane->width\t      = 0;\n\t\tplane->height\t      = 0;\n\t\tplane->stride\t      = 0;\n\t\tplane->size\t      = 0;\n\t\tplane->dmabuf_id      = 0;\n\t\tgoto done;\n\t}\n\n\tdmabuf = mbochs_dmabuf_find_by_mode(mdev_state, &mode);\n\tif (!dmabuf)\n\t\tmbochs_dmabuf_alloc(mdev_state, &mode);\n\tif (!dmabuf) {\n\t\tmutex_unlock(&mdev_state->ops_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tplane->drm_format     = dmabuf->mode.drm_format;\n\tplane->width\t      = dmabuf->mode.width;\n\tplane->height\t      = dmabuf->mode.height;\n\tplane->stride\t      = dmabuf->mode.stride;\n\tplane->size\t      = dmabuf->mode.size;\n\tplane->dmabuf_id      = dmabuf->id;\n\ndone:\n\tif (plane->drm_plane_type == DRM_PLANE_TYPE_PRIMARY &&\n\t    mdev_state->active_id != plane->dmabuf_id) {\n\t\tdev_dbg(mdev_state->vdev.dev, \"%s: primary: %d => %d\\n\",\n\t\t\t__func__, mdev_state->active_id, plane->dmabuf_id);\n\t\tmdev_state->active_id = plane->dmabuf_id;\n\t}\n\tmutex_unlock(&mdev_state->ops_lock);\n\treturn 0;\n}\n\nstatic int mbochs_get_gfx_dmabuf(struct mdev_state *mdev_state, u32 id)\n{\n\tstruct mbochs_dmabuf *dmabuf;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tdmabuf = mbochs_dmabuf_find_by_id(mdev_state, id);\n\tif (!dmabuf) {\n\t\tmutex_unlock(&mdev_state->ops_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tif (!dmabuf->buf)\n\t\tmbochs_dmabuf_export(dmabuf);\n\n\tmutex_unlock(&mdev_state->ops_lock);\n\n\tif (!dmabuf->buf)\n\t\treturn -EINVAL;\n\n\treturn dma_buf_fd(dmabuf->buf, 0);\n}\n\nstatic long mbochs_ioctl(struct vfio_device *vdev, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tint ret = 0;\n\tunsigned long minsz, outsz;\n\n\tswitch (cmd) {\n\tcase VFIO_DEVICE_GET_INFO:\n\t{\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = mbochs_get_device_info(&info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase VFIO_DEVICE_GET_REGION_INFO:\n\t{\n\t\tstruct vfio_region_info_ext info;\n\n\t\tminsz = offsetofend(typeof(info), base.offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\toutsz = info.base.argsz;\n\t\tif (outsz < minsz)\n\t\t\treturn -EINVAL;\n\t\tif (outsz > sizeof(info))\n\t\t\treturn -EINVAL;\n\n\t\tret = mbochs_get_region_info(mdev_state, &info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &info, outsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase VFIO_DEVICE_GET_IRQ_INFO:\n\t{\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif ((info.argsz < minsz) ||\n\t\t    (info.index >= VFIO_PCI_NUM_IRQS))\n\t\t\treturn -EINVAL;\n\n\t\tret = mbochs_get_irq_info(&info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase VFIO_DEVICE_QUERY_GFX_PLANE:\n\t{\n\t\tstruct vfio_device_gfx_plane_info plane;\n\n\t\tminsz = offsetofend(struct vfio_device_gfx_plane_info,\n\t\t\t\t    region_index);\n\n\t\tif (copy_from_user(&plane, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (plane.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = mbochs_query_gfx_plane(mdev_state, &plane);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &plane, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase VFIO_DEVICE_GET_GFX_DMABUF:\n\t{\n\t\tu32 dmabuf_id;\n\n\t\tif (get_user(dmabuf_id, (__u32 __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\treturn mbochs_get_gfx_dmabuf(mdev_state, dmabuf_id);\n\t}\n\n\tcase VFIO_DEVICE_SET_IRQS:\n\t\treturn -EINVAL;\n\n\tcase VFIO_DEVICE_RESET:\n\t\treturn mbochs_reset(mdev_state);\n\t}\n\treturn -ENOTTY;\n}\n\nstatic int mbochs_open(struct vfio_device *vdev)\n{\n\treturn 0;\n}\n\nstatic void mbochs_close(struct vfio_device *vdev)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tstruct mbochs_dmabuf *dmabuf, *tmp;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tlist_for_each_entry_safe(dmabuf, tmp, &mdev_state->dmabufs, next) {\n\t\tlist_del(&dmabuf->next);\n\t\tif (dmabuf->buf) {\n\t\t\t/* free in mbochs_release_dmabuf() */\n\t\t\tdmabuf->unlinked = true;\n\t\t} else {\n\t\t\tkfree(dmabuf);\n\t\t}\n\t}\n\tmbochs_put_pages(mdev_state);\n\n\tmutex_unlock(&mdev_state->ops_lock);\n}\n\nstatic ssize_t\nmemory_show(struct device *dev, struct device_attribute *attr,\n\t    char *buf)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d MB\\n\", mdev_state->type->mbytes);\n}\nstatic DEVICE_ATTR_RO(memory);\n\nstatic struct attribute *mdev_dev_attrs[] = {\n\t&dev_attr_memory.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mdev_dev_group = {\n\t.name  = \"vendor\",\n\t.attrs = mdev_dev_attrs,\n};\n\nstatic const struct attribute_group *mdev_dev_groups[] = {\n\t&mdev_dev_group,\n\tNULL,\n};\n\nstatic ssize_t name_show(struct mdev_type *mtype,\n\t\t\t struct mdev_type_attribute *attr, char *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\n\treturn sprintf(buf, \"%s\\n\", type->name);\n}\nstatic MDEV_TYPE_ATTR_RO(name);\n\nstatic ssize_t description_show(struct mdev_type *mtype,\n\t\t\t\tstruct mdev_type_attribute *attr, char *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\n\treturn sprintf(buf, \"virtual display, %d MB video memory\\n\",\n\t\t       type ? type->mbytes  : 0);\n}\nstatic MDEV_TYPE_ATTR_RO(description);\n\nstatic ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\n\treturn sprintf(buf, \"%d\\n\", count);\n}\nstatic MDEV_TYPE_ATTR_RO(available_instances);\n\nstatic ssize_t device_api_show(struct mdev_type *mtype,\n\t\t\t       struct mdev_type_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", VFIO_DEVICE_API_PCI_STRING);\n}\nstatic MDEV_TYPE_ATTR_RO(device_api);\n\nstatic struct attribute *mdev_types_attrs[] = {\n\t&mdev_type_attr_name.attr,\n\t&mdev_type_attr_description.attr,\n\t&mdev_type_attr_device_api.attr,\n\t&mdev_type_attr_available_instances.attr,\n\tNULL,\n};\n\nstatic struct attribute_group mdev_type_group1 = {\n\t.name  = MBOCHS_TYPE_1,\n\t.attrs = mdev_types_attrs,\n};\n\nstatic struct attribute_group mdev_type_group2 = {\n\t.name  = MBOCHS_TYPE_2,\n\t.attrs = mdev_types_attrs,\n};\n\nstatic struct attribute_group mdev_type_group3 = {\n\t.name  = MBOCHS_TYPE_3,\n\t.attrs = mdev_types_attrs,\n};\n\nstatic struct attribute_group *mdev_type_groups[] = {\n\t&mdev_type_group1,\n\t&mdev_type_group2,\n\t&mdev_type_group3,\n\tNULL,\n};\n\nstatic const struct vfio_device_ops mbochs_dev_ops = {\n\t.open = mbochs_open,\n\t.release = mbochs_close,\n\t.read = mbochs_read,\n\t.write = mbochs_write,\n\t.ioctl = mbochs_ioctl,\n\t.mmap = mbochs_mmap,\n};\n\nstatic struct mdev_driver mbochs_driver = {\n\t.driver = {\n\t\t.name = \"mbochs\",\n\t\t.owner = THIS_MODULE,\n\t\t.mod_name = KBUILD_MODNAME,\n\t\t.dev_groups = mdev_dev_groups,\n\t},\n\t.probe = mbochs_probe,\n\t.remove\t= mbochs_remove,\n};\n\nstatic const struct mdev_parent_ops mdev_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.device_driver\t\t= &mbochs_driver,\n\t.supported_type_groups\t= mdev_type_groups,\n};\n\nstatic const struct file_operations vd_fops = {\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void mbochs_device_release(struct device *dev)\n{\n\t/* nothing */\n}\n\nstatic int __init mbochs_dev_init(void)\n{\n\tint ret = 0;\n\n\tret = alloc_chrdev_region(&mbochs_devt, 0, MINORMASK + 1, MBOCHS_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"Error: failed to register mbochs_dev, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcdev_init(&mbochs_cdev, &vd_fops);\n\tcdev_add(&mbochs_cdev, mbochs_devt, MINORMASK + 1);\n\tpr_info(\"%s: major %d\\n\", __func__, MAJOR(mbochs_devt));\n\n\tret = mdev_register_driver(&mbochs_driver);\n\tif (ret)\n\t\tgoto err_cdev;\n\n\tmbochs_class = class_create(THIS_MODULE, MBOCHS_CLASS_NAME);\n\tif (IS_ERR(mbochs_class)) {\n\t\tpr_err(\"Error: failed to register mbochs_dev class\\n\");\n\t\tret = PTR_ERR(mbochs_class);\n\t\tgoto err_driver;\n\t}\n\tmbochs_dev.class = mbochs_class;\n\tmbochs_dev.release = mbochs_device_release;\n\tdev_set_name(&mbochs_dev, \"%s\", MBOCHS_NAME);\n\n\tret = device_register(&mbochs_dev);\n\tif (ret)\n\t\tgoto err_class;\n\n\tret = mdev_register_device(&mbochs_dev, &mdev_fops);\n\tif (ret)\n\t\tgoto err_device;\n\n\treturn 0;\n\nerr_device:\n\tdevice_unregister(&mbochs_dev);\nerr_class:\n\tclass_destroy(mbochs_class);\nerr_driver:\n\tmdev_unregister_driver(&mbochs_driver);\nerr_cdev:\n\tcdev_del(&mbochs_cdev);\n\tunregister_chrdev_region(mbochs_devt, MINORMASK + 1);\n\treturn ret;\n}\n\nstatic void __exit mbochs_dev_exit(void)\n{\n\tmbochs_dev.bus = NULL;\n\tmdev_unregister_device(&mbochs_dev);\n\n\tdevice_unregister(&mbochs_dev);\n\tmdev_unregister_driver(&mbochs_driver);\n\tcdev_del(&mbochs_cdev);\n\tunregister_chrdev_region(mbochs_devt, MINORMASK + 1);\n\tclass_destroy(mbochs_class);\n\tmbochs_class = NULL;\n}\n\nmodule_init(mbochs_dev_init)\nmodule_exit(mbochs_dev_exit)\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Mediated virtual PCI display host device driver\n *\n * Emulate enough of qemu stdvga to make bochs-drm.ko happy.  That is\n * basically the vram memory bar and the bochs dispi interface vbe\n * registers in the mmio register bar.\tSpecifically it does *not*\n * include any legacy vga stuff.  Device looks a lot like \"qemu -device\n * secondary-vga\".\n *\n *   (c) Gerd Hoffmann <kraxel@redhat.com>\n *\n * based on mtty driver which is:\n *   Copyright (c) 2016, NVIDIA CORPORATION. All rights reserved.\n *\t Author: Neo Jia <cjia@nvidia.com>\n *\t\t Kirti Wankhede <kwankhede@nvidia.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/cdev.h>\n#include <linux/vfio.h>\n#include <linux/iommu.h>\n#include <linux/sysfs.h>\n#include <linux/mdev.h>\n#include <linux/pci.h>\n#include <linux/dma-buf.h>\n#include <linux/highmem.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_rect.h>\n#include <drm/drm_modeset_lock.h>\n#include <drm/drm_property.h>\n#include <drm/drm_plane.h>\n\n\n#define VBE_DISPI_INDEX_ID\t\t0x0\n#define VBE_DISPI_INDEX_XRES\t\t0x1\n#define VBE_DISPI_INDEX_YRES\t\t0x2\n#define VBE_DISPI_INDEX_BPP\t\t0x3\n#define VBE_DISPI_INDEX_ENABLE\t\t0x4\n#define VBE_DISPI_INDEX_BANK\t\t0x5\n#define VBE_DISPI_INDEX_VIRT_WIDTH\t0x6\n#define VBE_DISPI_INDEX_VIRT_HEIGHT\t0x7\n#define VBE_DISPI_INDEX_X_OFFSET\t0x8\n#define VBE_DISPI_INDEX_Y_OFFSET\t0x9\n#define VBE_DISPI_INDEX_VIDEO_MEMORY_64K 0xa\n#define VBE_DISPI_INDEX_COUNT\t\t0xb\n\n#define VBE_DISPI_ID0\t\t\t0xB0C0\n#define VBE_DISPI_ID1\t\t\t0xB0C1\n#define VBE_DISPI_ID2\t\t\t0xB0C2\n#define VBE_DISPI_ID3\t\t\t0xB0C3\n#define VBE_DISPI_ID4\t\t\t0xB0C4\n#define VBE_DISPI_ID5\t\t\t0xB0C5\n\n#define VBE_DISPI_DISABLED\t\t0x00\n#define VBE_DISPI_ENABLED\t\t0x01\n#define VBE_DISPI_GETCAPS\t\t0x02\n#define VBE_DISPI_8BIT_DAC\t\t0x20\n#define VBE_DISPI_LFB_ENABLED\t\t0x40\n#define VBE_DISPI_NOCLEARMEM\t\t0x80\n\n\n#define MBOCHS_NAME\t\t  \"mbochs\"\n#define MBOCHS_CLASS_NAME\t  \"mbochs\"\n\n#define MBOCHS_EDID_REGION_INDEX  VFIO_PCI_NUM_REGIONS\n#define MBOCHS_NUM_REGIONS        (MBOCHS_EDID_REGION_INDEX+1)\n\n#define MBOCHS_CONFIG_SPACE_SIZE  0xff\n#define MBOCHS_MMIO_BAR_OFFSET\t  PAGE_SIZE\n#define MBOCHS_MMIO_BAR_SIZE\t  PAGE_SIZE\n#define MBOCHS_EDID_OFFSET\t  (MBOCHS_MMIO_BAR_OFFSET +\t\\\n\t\t\t\t   MBOCHS_MMIO_BAR_SIZE)\n#define MBOCHS_EDID_SIZE\t  PAGE_SIZE\n#define MBOCHS_MEMORY_BAR_OFFSET  (MBOCHS_EDID_OFFSET + \\\n\t\t\t\t   MBOCHS_EDID_SIZE)\n\n#define MBOCHS_EDID_BLOB_OFFSET   (MBOCHS_EDID_SIZE/2)\n\n#define STORE_LE16(addr, val)\t(*(u16 *)addr = val)\n#define STORE_LE32(addr, val)\t(*(u32 *)addr = val)\n\n\nMODULE_LICENSE(\"GPL v2\");\n\nstatic int max_mbytes = 256;\nmodule_param_named(count, max_mbytes, int, 0444);\nMODULE_PARM_DESC(mem, \"megabytes available to \" MBOCHS_NAME \" devices\");\n\n\n#define MBOCHS_TYPE_1 \"small\"\n#define MBOCHS_TYPE_2 \"medium\"\n#define MBOCHS_TYPE_3 \"large\"\n\nstatic const struct mbochs_type {\n\tconst char *name;\n\tu32 mbytes;\n\tu32 max_x;\n\tu32 max_y;\n} mbochs_types[] = {\n\t{\n\t\t.name\t= MBOCHS_CLASS_NAME \"-\" MBOCHS_TYPE_1,\n\t\t.mbytes = 4,\n\t\t.max_x  = 800,\n\t\t.max_y  = 600,\n\t}, {\n\t\t.name\t= MBOCHS_CLASS_NAME \"-\" MBOCHS_TYPE_2,\n\t\t.mbytes = 16,\n\t\t.max_x  = 1920,\n\t\t.max_y  = 1440,\n\t}, {\n\t\t.name\t= MBOCHS_CLASS_NAME \"-\" MBOCHS_TYPE_3,\n\t\t.mbytes = 64,\n\t\t.max_x  = 0,\n\t\t.max_y  = 0,\n\t},\n};\n\n\nstatic dev_t\t\tmbochs_devt;\nstatic struct class\t*mbochs_class;\nstatic struct cdev\tmbochs_cdev;\nstatic struct device\tmbochs_dev;\nstatic atomic_t mbochs_avail_mbytes;\nstatic const struct vfio_device_ops mbochs_dev_ops;\n\nstruct vfio_region_info_ext {\n\tstruct vfio_region_info          base;\n\tstruct vfio_region_info_cap_type type;\n};\n\nstruct mbochs_mode {\n\tu32 drm_format;\n\tu32 bytepp;\n\tu32 width;\n\tu32 height;\n\tu32 stride;\n\tu32 __pad;\n\tu64 offset;\n\tu64 size;\n};\n\nstruct mbochs_dmabuf {\n\tstruct mbochs_mode mode;\n\tu32 id;\n\tstruct page **pages;\n\tpgoff_t pagecount;\n\tstruct dma_buf *buf;\n\tstruct mdev_state *mdev_state;\n\tstruct list_head next;\n\tbool unlinked;\n};\n\n/* State of each mdev device */\nstruct mdev_state {\n\tstruct vfio_device vdev;\n\tu8 *vconfig;\n\tu64 bar_mask[3];\n\tu32 memory_bar_mask;\n\tstruct mutex ops_lock;\n\tstruct mdev_device *mdev;\n\n\tconst struct mbochs_type *type;\n\tu16 vbe[VBE_DISPI_INDEX_COUNT];\n\tu64 memsize;\n\tstruct page **pages;\n\tpgoff_t pagecount;\n\tstruct vfio_region_gfx_edid edid_regs;\n\tu8 edid_blob[0x400];\n\n\tstruct list_head dmabufs;\n\tu32 active_id;\n\tu32 next_id;\n};\n\nstatic const char *vbe_name_list[VBE_DISPI_INDEX_COUNT] = {\n\t[VBE_DISPI_INDEX_ID]               = \"id\",\n\t[VBE_DISPI_INDEX_XRES]             = \"xres\",\n\t[VBE_DISPI_INDEX_YRES]             = \"yres\",\n\t[VBE_DISPI_INDEX_BPP]              = \"bpp\",\n\t[VBE_DISPI_INDEX_ENABLE]           = \"enable\",\n\t[VBE_DISPI_INDEX_BANK]             = \"bank\",\n\t[VBE_DISPI_INDEX_VIRT_WIDTH]       = \"virt-width\",\n\t[VBE_DISPI_INDEX_VIRT_HEIGHT]      = \"virt-height\",\n\t[VBE_DISPI_INDEX_X_OFFSET]         = \"x-offset\",\n\t[VBE_DISPI_INDEX_Y_OFFSET]         = \"y-offset\",\n\t[VBE_DISPI_INDEX_VIDEO_MEMORY_64K] = \"video-mem\",\n};\n\nstatic const char *vbe_name(u32 index)\n{\n\tif (index < ARRAY_SIZE(vbe_name_list))\n\t\treturn vbe_name_list[index];\n\treturn \"(invalid)\";\n}\n\nstatic struct page *__mbochs_get_page(struct mdev_state *mdev_state,\n\t\t\t\t      pgoff_t pgoff);\nstatic struct page *mbochs_get_page(struct mdev_state *mdev_state,\n\t\t\t\t    pgoff_t pgoff);\n\nstatic void mbochs_create_config_space(struct mdev_state *mdev_state)\n{\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_VENDOR_ID],\n\t\t   0x1234);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_DEVICE_ID],\n\t\t   0x1111);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_SUBSYSTEM_VENDOR_ID],\n\t\t   PCI_SUBVENDOR_ID_REDHAT_QUMRANET);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_SUBSYSTEM_ID],\n\t\t   PCI_SUBDEVICE_ID_QEMU);\n\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_COMMAND],\n\t\t   PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_CLASS_DEVICE],\n\t\t   PCI_CLASS_DISPLAY_OTHER);\n\tmdev_state->vconfig[PCI_CLASS_REVISION] =  0x01;\n\n\tSTORE_LE32((u32 *) &mdev_state->vconfig[PCI_BASE_ADDRESS_0],\n\t\t   PCI_BASE_ADDRESS_SPACE_MEMORY |\n\t\t   PCI_BASE_ADDRESS_MEM_TYPE_32\t |\n\t\t   PCI_BASE_ADDRESS_MEM_PREFETCH);\n\tmdev_state->bar_mask[0] = ~(mdev_state->memsize) + 1;\n\n\tSTORE_LE32((u32 *) &mdev_state->vconfig[PCI_BASE_ADDRESS_2],\n\t\t   PCI_BASE_ADDRESS_SPACE_MEMORY |\n\t\t   PCI_BASE_ADDRESS_MEM_TYPE_32);\n\tmdev_state->bar_mask[2] = ~(MBOCHS_MMIO_BAR_SIZE) + 1;\n}\n\nstatic int mbochs_check_framebuffer(struct mdev_state *mdev_state,\n\t\t\t\t    struct mbochs_mode *mode)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tu16 *vbe = mdev_state->vbe;\n\tu32 virt_width;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tif (!(vbe[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED))\n\t\tgoto nofb;\n\n\tmemset(mode, 0, sizeof(*mode));\n\tswitch (vbe[VBE_DISPI_INDEX_BPP]) {\n\tcase 32:\n\t\tmode->drm_format = DRM_FORMAT_XRGB8888;\n\t\tmode->bytepp = 4;\n\t\tbreak;\n\tdefault:\n\t\tdev_info_ratelimited(dev, \"%s: bpp %d not supported\\n\",\n\t\t\t\t     __func__, vbe[VBE_DISPI_INDEX_BPP]);\n\t\tgoto nofb;\n\t}\n\n\tmode->width  = vbe[VBE_DISPI_INDEX_XRES];\n\tmode->height = vbe[VBE_DISPI_INDEX_YRES];\n\tvirt_width  = vbe[VBE_DISPI_INDEX_VIRT_WIDTH];\n\tif (virt_width < mode->width)\n\t\tvirt_width = mode->width;\n\tmode->stride = virt_width * mode->bytepp;\n\tmode->size   = (u64)mode->stride * mode->height;\n\tmode->offset = ((u64)vbe[VBE_DISPI_INDEX_X_OFFSET] * mode->bytepp +\n\t\t       (u64)vbe[VBE_DISPI_INDEX_Y_OFFSET] * mode->stride);\n\n\tif (mode->width < 64 || mode->height < 64) {\n\t\tdev_info_ratelimited(dev, \"%s: invalid resolution %dx%d\\n\",\n\t\t\t\t     __func__, mode->width, mode->height);\n\t\tgoto nofb;\n\t}\n\tif (mode->offset + mode->size > mdev_state->memsize) {\n\t\tdev_info_ratelimited(dev, \"%s: framebuffer memory overflow\\n\",\n\t\t\t\t     __func__);\n\t\tgoto nofb;\n\t}\n\n\treturn 0;\n\nnofb:\n\tmemset(mode, 0, sizeof(*mode));\n\treturn -EINVAL;\n}\n\nstatic bool mbochs_modes_equal(struct mbochs_mode *mode1,\n\t\t\t       struct mbochs_mode *mode2)\n{\n\treturn memcmp(mode1, mode2, sizeof(struct mbochs_mode)) == 0;\n}\n\nstatic void handle_pci_cfg_write(struct mdev_state *mdev_state, u16 offset,\n\t\t\t\t char *buf, u32 count)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tint index = (offset - PCI_BASE_ADDRESS_0) / 0x04;\n\tu32 cfg_addr;\n\n\tswitch (offset) {\n\tcase PCI_BASE_ADDRESS_0:\n\tcase PCI_BASE_ADDRESS_2:\n\t\tcfg_addr = *(u32 *)buf;\n\n\t\tif (cfg_addr == 0xffffffff) {\n\t\t\tcfg_addr = (cfg_addr & mdev_state->bar_mask[index]);\n\t\t} else {\n\t\t\tcfg_addr &= PCI_BASE_ADDRESS_MEM_MASK;\n\t\t\tif (cfg_addr)\n\t\t\t\tdev_info(dev, \"BAR #%d @ 0x%x\\n\",\n\t\t\t\t\t index, cfg_addr);\n\t\t}\n\n\t\tcfg_addr |= (mdev_state->vconfig[offset] &\n\t\t\t     ~PCI_BASE_ADDRESS_MEM_MASK);\n\t\tSTORE_LE32(&mdev_state->vconfig[offset], cfg_addr);\n\t\tbreak;\n\t}\n}\n\nstatic void handle_mmio_write(struct mdev_state *mdev_state, u16 offset,\n\t\t\t      char *buf, u32 count)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tint index;\n\tu16 reg16;\n\n\tswitch (offset) {\n\tcase 0x400 ... 0x41f: /* vga ioports remapped */\n\t\tgoto unhandled;\n\tcase 0x500 ... 0x515: /* bochs dispi interface */\n\t\tif (count != 2)\n\t\t\tgoto unhandled;\n\t\tindex = (offset - 0x500) / 2;\n\t\treg16 = *(u16 *)buf;\n\t\tif (index < ARRAY_SIZE(mdev_state->vbe))\n\t\t\tmdev_state->vbe[index] = reg16;\n\t\tdev_dbg(dev, \"%s: vbe write %d = %d (%s)\\n\",\n\t\t\t__func__, index, reg16, vbe_name(index));\n\t\tbreak;\n\tcase 0x600 ... 0x607: /* qemu extended regs */\n\t\tgoto unhandled;\n\tdefault:\nunhandled:\n\t\tdev_dbg(dev, \"%s: @0x%03x, count %d (unhandled)\\n\",\n\t\t\t__func__, offset, count);\n\t\tbreak;\n\t}\n}\n\nstatic void handle_mmio_read(struct mdev_state *mdev_state, u16 offset,\n\t\t\t     char *buf, u32 count)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tstruct vfio_region_gfx_edid *edid;\n\tu16 reg16 = 0;\n\tint index;\n\n\tswitch (offset) {\n\tcase 0x000 ... 0x3ff: /* edid block */\n\t\tedid = &mdev_state->edid_regs;\n\t\tif (edid->link_state != VFIO_DEVICE_GFX_LINK_STATE_UP ||\n\t\t    offset >= edid->edid_size) {\n\t\t\tmemset(buf, 0, count);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(buf, mdev_state->edid_blob + offset, count);\n\t\tbreak;\n\tcase 0x500 ... 0x515: /* bochs dispi interface */\n\t\tif (count != 2)\n\t\t\tgoto unhandled;\n\t\tindex = (offset - 0x500) / 2;\n\t\tif (index < ARRAY_SIZE(mdev_state->vbe))\n\t\t\treg16 = mdev_state->vbe[index];\n\t\tdev_dbg(dev, \"%s: vbe read %d = %d (%s)\\n\",\n\t\t\t__func__, index, reg16, vbe_name(index));\n\t\t*(u16 *)buf = reg16;\n\t\tbreak;\n\tdefault:\nunhandled:\n\t\tdev_dbg(dev, \"%s: @0x%03x, count %d (unhandled)\\n\",\n\t\t\t__func__, offset, count);\n\t\tmemset(buf, 0, count);\n\t\tbreak;\n\t}\n}\n\nstatic void handle_edid_regs(struct mdev_state *mdev_state, u16 offset,\n\t\t\t     char *buf, u32 count, bool is_write)\n{\n\tchar *regs = (void *)&mdev_state->edid_regs;\n\n\tif (offset + count > sizeof(mdev_state->edid_regs))\n\t\treturn;\n\tif (count != 4)\n\t\treturn;\n\tif (offset % 4)\n\t\treturn;\n\n\tif (is_write) {\n\t\tswitch (offset) {\n\t\tcase offsetof(struct vfio_region_gfx_edid, link_state):\n\t\tcase offsetof(struct vfio_region_gfx_edid, edid_size):\n\t\t\tmemcpy(regs + offset, buf, count);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* read-only regs */\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmemcpy(buf, regs + offset, count);\n\t}\n}\n\nstatic void handle_edid_blob(struct mdev_state *mdev_state, u16 offset,\n\t\t\t     char *buf, u32 count, bool is_write)\n{\n\tif (offset + count > mdev_state->edid_regs.edid_max_size)\n\t\treturn;\n\tif (is_write)\n\t\tmemcpy(mdev_state->edid_blob + offset, buf, count);\n\telse\n\t\tmemcpy(buf, mdev_state->edid_blob + offset, count);\n}\n\nstatic ssize_t mdev_access(struct mdev_state *mdev_state, char *buf,\n\t\t\t   size_t count, loff_t pos, bool is_write)\n{\n\tstruct page *pg;\n\tloff_t poff;\n\tchar *map;\n\tint ret = 0;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tif (pos < MBOCHS_CONFIG_SPACE_SIZE) {\n\t\tif (is_write)\n\t\t\thandle_pci_cfg_write(mdev_state, pos, buf, count);\n\t\telse\n\t\t\tmemcpy(buf, (mdev_state->vconfig + pos), count);\n\n\t} else if (pos >= MBOCHS_MMIO_BAR_OFFSET &&\n\t\t   pos + count <= (MBOCHS_MMIO_BAR_OFFSET +\n\t\t\t\t   MBOCHS_MMIO_BAR_SIZE)) {\n\t\tpos -= MBOCHS_MMIO_BAR_OFFSET;\n\t\tif (is_write)\n\t\t\thandle_mmio_write(mdev_state, pos, buf, count);\n\t\telse\n\t\t\thandle_mmio_read(mdev_state, pos, buf, count);\n\n\t} else if (pos >= MBOCHS_EDID_OFFSET &&\n\t\t   pos + count <= (MBOCHS_EDID_OFFSET +\n\t\t\t\t   MBOCHS_EDID_SIZE)) {\n\t\tpos -= MBOCHS_EDID_OFFSET;\n\t\tif (pos < MBOCHS_EDID_BLOB_OFFSET) {\n\t\t\thandle_edid_regs(mdev_state, pos, buf, count, is_write);\n\t\t} else {\n\t\t\tpos -= MBOCHS_EDID_BLOB_OFFSET;\n\t\t\thandle_edid_blob(mdev_state, pos, buf, count, is_write);\n\t\t}\n\n\t} else if (pos >= MBOCHS_MEMORY_BAR_OFFSET &&\n\t\t   pos + count <=\n\t\t   MBOCHS_MEMORY_BAR_OFFSET + mdev_state->memsize) {\n\t\tpos -= MBOCHS_MMIO_BAR_OFFSET;\n\t\tpoff = pos & ~PAGE_MASK;\n\t\tpg = __mbochs_get_page(mdev_state, pos >> PAGE_SHIFT);\n\t\tmap = kmap(pg);\n\t\tif (is_write)\n\t\t\tmemcpy(map + poff, buf, count);\n\t\telse\n\t\t\tmemcpy(buf, map + poff, count);\n\t\tkunmap(pg);\n\t\tput_page(pg);\n\n\t} else {\n\t\tdev_dbg(mdev_state->vdev.dev, \"%s: %s @0x%llx (unhandled)\\n\",\n\t\t\t__func__, is_write ? \"WR\" : \"RD\", pos);\n\t\tret = -1;\n\t\tgoto accessfailed;\n\t}\n\n\tret = count;\n\n\naccessfailed:\n\tmutex_unlock(&mdev_state->ops_lock);\n\n\treturn ret;\n}\n\nstatic int mbochs_reset(struct mdev_state *mdev_state)\n{\n\tu32 size64k = mdev_state->memsize / (64 * 1024);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mdev_state->vbe); i++)\n\t\tmdev_state->vbe[i] = 0;\n\tmdev_state->vbe[VBE_DISPI_INDEX_ID] = VBE_DISPI_ID5;\n\tmdev_state->vbe[VBE_DISPI_INDEX_VIDEO_MEMORY_64K] = size64k;\n\treturn 0;\n}\n\nstatic int mbochs_probe(struct mdev_device *mdev)\n{\n\tint avail_mbytes = atomic_read(&mbochs_avail_mbytes);\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\n\tdo {\n\t\tif (avail_mbytes < type->mbytes)\n\t\t\treturn -ENOSPC;\n\t} while (!atomic_try_cmpxchg(&mbochs_avail_mbytes, &avail_mbytes,\n\t\t\t\t     avail_mbytes - type->mbytes));\n\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\tgoto err_avail;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\nerr_mem:\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\nerr_avail:\n\tatomic_add(type->mbytes, &mbochs_avail_mbytes);\n\treturn ret;\n}\n\nstatic void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tatomic_add(mdev_state->type->mbytes, &mbochs_avail_mbytes);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}\n\nstatic ssize_t mbochs_read(struct vfio_device *vdev, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tunsigned int done = 0;\n\tint ret;\n\n\twhile (count) {\n\t\tsize_t filled;\n\n\t\tif (count >= 4 && !(*ppos % 4)) {\n\t\t\tu32 val;\n\n\t\t\tret =  mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t   *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 4;\n\t\t} else if (count >= 2 && !(*ppos % 2)) {\n\t\t\tu16 val;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 val;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 1;\n\t\t}\n\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\t*ppos += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\n\nread_err:\n\treturn -EFAULT;\n}\n\nstatic ssize_t mbochs_write(struct vfio_device *vdev, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tunsigned int done = 0;\n\tint ret;\n\n\twhile (count) {\n\t\tsize_t filled;\n\n\t\tif (count >= 4 && !(*ppos % 4)) {\n\t\t\tu32 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 4;\n\t\t} else if (count >= 2 && !(*ppos % 2)) {\n\t\t\tu16 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 1;\n\t\t}\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\t*ppos += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\nwrite_err:\n\treturn -EFAULT;\n}\n\nstatic struct page *__mbochs_get_page(struct mdev_state *mdev_state,\n\t\t\t\t      pgoff_t pgoff)\n{\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tif (!mdev_state->pages[pgoff]) {\n\t\tmdev_state->pages[pgoff] =\n\t\t\talloc_pages(GFP_HIGHUSER | __GFP_ZERO, 0);\n\t\tif (!mdev_state->pages[pgoff])\n\t\t\treturn NULL;\n\t}\n\n\tget_page(mdev_state->pages[pgoff]);\n\treturn mdev_state->pages[pgoff];\n}\n\nstatic struct page *mbochs_get_page(struct mdev_state *mdev_state,\n\t\t\t\t    pgoff_t pgoff)\n{\n\tstruct page *page;\n\n\tif (WARN_ON(pgoff >= mdev_state->pagecount))\n\t\treturn NULL;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\tpage = __mbochs_get_page(mdev_state, pgoff);\n\tmutex_unlock(&mdev_state->ops_lock);\n\n\treturn page;\n}\n\nstatic void mbochs_put_pages(struct mdev_state *mdev_state)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tint i, count = 0;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tfor (i = 0; i < mdev_state->pagecount; i++) {\n\t\tif (!mdev_state->pages[i])\n\t\t\tcontinue;\n\t\tput_page(mdev_state->pages[i]);\n\t\tmdev_state->pages[i] = NULL;\n\t\tcount++;\n\t}\n\tdev_dbg(dev, \"%s: %d pages released\\n\", __func__, count);\n}\n\nstatic vm_fault_t mbochs_region_vm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mdev_state *mdev_state = vma->vm_private_data;\n\tpgoff_t page_offset = (vmf->address - vma->vm_start) >> PAGE_SHIFT;\n\n\tif (page_offset >= mdev_state->pagecount)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tvmf->page = mbochs_get_page(mdev_state, page_offset);\n\tif (!vmf->page)\n\t\treturn VM_FAULT_SIGBUS;\n\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct mbochs_region_vm_ops = {\n\t.fault = mbochs_region_vm_fault,\n};\n\nstatic int mbochs_mmap(struct vfio_device *vdev, struct vm_area_struct *vma)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\n\tif (vma->vm_pgoff != MBOCHS_MEMORY_BAR_OFFSET >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif (vma->vm_end - vma->vm_start > mdev_state->memsize)\n\t\treturn -EINVAL;\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &mbochs_region_vm_ops;\n\tvma->vm_private_data = mdev_state;\n\treturn 0;\n}\n\nstatic vm_fault_t mbochs_dmabuf_vm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mbochs_dmabuf *dmabuf = vma->vm_private_data;\n\n\tif (WARN_ON(vmf->pgoff >= dmabuf->pagecount))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tvmf->page = dmabuf->pages[vmf->pgoff];\n\tget_page(vmf->page);\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct mbochs_dmabuf_vm_ops = {\n\t.fault = mbochs_dmabuf_vm_fault,\n};\n\nstatic int mbochs_mmap_dmabuf(struct dma_buf *buf, struct vm_area_struct *vma)\n{\n\tstruct mbochs_dmabuf *dmabuf = buf->priv;\n\tstruct device *dev = mdev_dev(dmabuf->mdev_state->mdev);\n\n\tdev_dbg(dev, \"%s: %d\\n\", __func__, dmabuf->id);\n\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &mbochs_dmabuf_vm_ops;\n\tvma->vm_private_data = dmabuf;\n\treturn 0;\n}\n\nstatic void mbochs_print_dmabuf(struct mbochs_dmabuf *dmabuf,\n\t\t\t\tconst char *prefix)\n{\n\tstruct device *dev = mdev_dev(dmabuf->mdev_state->mdev);\n\tu32 fourcc = dmabuf->mode.drm_format;\n\n\tdev_dbg(dev, \"%s/%d: %c%c%c%c, %dx%d, stride %d, off 0x%llx, size 0x%llx, pages %ld\\n\",\n\t\tprefix, dmabuf->id,\n\t\tfourcc ? ((fourcc >>  0) & 0xff) : '-',\n\t\tfourcc ? ((fourcc >>  8) & 0xff) : '-',\n\t\tfourcc ? ((fourcc >> 16) & 0xff) : '-',\n\t\tfourcc ? ((fourcc >> 24) & 0xff) : '-',\n\t\tdmabuf->mode.width, dmabuf->mode.height, dmabuf->mode.stride,\n\t\tdmabuf->mode.offset, dmabuf->mode.size, dmabuf->pagecount);\n}\n\nstatic struct sg_table *mbochs_map_dmabuf(struct dma_buf_attachment *at,\n\t\t\t\t\t  enum dma_data_direction direction)\n{\n\tstruct mbochs_dmabuf *dmabuf = at->dmabuf->priv;\n\tstruct device *dev = mdev_dev(dmabuf->mdev_state->mdev);\n\tstruct sg_table *sg;\n\n\tdev_dbg(dev, \"%s: %d\\n\", __func__, dmabuf->id);\n\n\tsg = kzalloc(sizeof(*sg), GFP_KERNEL);\n\tif (!sg)\n\t\tgoto err1;\n\tif (sg_alloc_table_from_pages(sg, dmabuf->pages, dmabuf->pagecount,\n\t\t\t\t      0, dmabuf->mode.size, GFP_KERNEL) < 0)\n\t\tgoto err2;\n\tif (dma_map_sgtable(at->dev, sg, direction, 0))\n\t\tgoto err3;\n\n\treturn sg;\n\nerr3:\n\tsg_free_table(sg);\nerr2:\n\tkfree(sg);\nerr1:\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void mbochs_unmap_dmabuf(struct dma_buf_attachment *at,\n\t\t\t\tstruct sg_table *sg,\n\t\t\t\tenum dma_data_direction direction)\n{\n\tstruct mbochs_dmabuf *dmabuf = at->dmabuf->priv;\n\tstruct device *dev = mdev_dev(dmabuf->mdev_state->mdev);\n\n\tdev_dbg(dev, \"%s: %d\\n\", __func__, dmabuf->id);\n\n\tdma_unmap_sgtable(at->dev, sg, direction, 0);\n\tsg_free_table(sg);\n\tkfree(sg);\n}\n\nstatic void mbochs_release_dmabuf(struct dma_buf *buf)\n{\n\tstruct mbochs_dmabuf *dmabuf = buf->priv;\n\tstruct mdev_state *mdev_state = dmabuf->mdev_state;\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tpgoff_t pg;\n\n\tdev_dbg(dev, \"%s: %d\\n\", __func__, dmabuf->id);\n\n\tfor (pg = 0; pg < dmabuf->pagecount; pg++)\n\t\tput_page(dmabuf->pages[pg]);\n\n\tmutex_lock(&mdev_state->ops_lock);\n\tdmabuf->buf = NULL;\n\tif (dmabuf->unlinked)\n\t\tkfree(dmabuf);\n\tmutex_unlock(&mdev_state->ops_lock);\n}\n\nstatic struct dma_buf_ops mbochs_dmabuf_ops = {\n\t.map_dma_buf\t  = mbochs_map_dmabuf,\n\t.unmap_dma_buf\t  = mbochs_unmap_dmabuf,\n\t.release\t  = mbochs_release_dmabuf,\n\t.mmap\t\t  = mbochs_mmap_dmabuf,\n};\n\nstatic struct mbochs_dmabuf *mbochs_dmabuf_alloc(struct mdev_state *mdev_state,\n\t\t\t\t\t\t struct mbochs_mode *mode)\n{\n\tstruct mbochs_dmabuf *dmabuf;\n\tpgoff_t page_offset, pg;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tdmabuf = kzalloc(sizeof(struct mbochs_dmabuf), GFP_KERNEL);\n\tif (!dmabuf)\n\t\treturn NULL;\n\n\tdmabuf->mode = *mode;\n\tdmabuf->id = mdev_state->next_id++;\n\tdmabuf->pagecount = DIV_ROUND_UP(mode->size, PAGE_SIZE);\n\tdmabuf->pages = kcalloc(dmabuf->pagecount, sizeof(struct page *),\n\t\t\t\tGFP_KERNEL);\n\tif (!dmabuf->pages)\n\t\tgoto err_free_dmabuf;\n\n\tpage_offset = dmabuf->mode.offset >> PAGE_SHIFT;\n\tfor (pg = 0; pg < dmabuf->pagecount; pg++) {\n\t\tdmabuf->pages[pg] = __mbochs_get_page(mdev_state,\n\t\t\t\t\t\t      page_offset + pg);\n\t\tif (!dmabuf->pages[pg])\n\t\t\tgoto err_free_pages;\n\t}\n\n\tdmabuf->mdev_state = mdev_state;\n\tlist_add(&dmabuf->next, &mdev_state->dmabufs);\n\n\tmbochs_print_dmabuf(dmabuf, __func__);\n\treturn dmabuf;\n\nerr_free_pages:\n\twhile (pg > 0)\n\t\tput_page(dmabuf->pages[--pg]);\n\tkfree(dmabuf->pages);\nerr_free_dmabuf:\n\tkfree(dmabuf);\n\treturn NULL;\n}\n\nstatic struct mbochs_dmabuf *\nmbochs_dmabuf_find_by_mode(struct mdev_state *mdev_state,\n\t\t\t   struct mbochs_mode *mode)\n{\n\tstruct mbochs_dmabuf *dmabuf;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tlist_for_each_entry(dmabuf, &mdev_state->dmabufs, next)\n\t\tif (mbochs_modes_equal(&dmabuf->mode, mode))\n\t\t\treturn dmabuf;\n\n\treturn NULL;\n}\n\nstatic struct mbochs_dmabuf *\nmbochs_dmabuf_find_by_id(struct mdev_state *mdev_state, u32 id)\n{\n\tstruct mbochs_dmabuf *dmabuf;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tlist_for_each_entry(dmabuf, &mdev_state->dmabufs, next)\n\t\tif (dmabuf->id == id)\n\t\t\treturn dmabuf;\n\n\treturn NULL;\n}\n\nstatic int mbochs_dmabuf_export(struct mbochs_dmabuf *dmabuf)\n{\n\tstruct mdev_state *mdev_state = dmabuf->mdev_state;\n\tstruct device *dev = mdev_state->vdev.dev;\n\tDEFINE_DMA_BUF_EXPORT_INFO(exp_info);\n\tstruct dma_buf *buf;\n\n\tWARN_ON(!mutex_is_locked(&mdev_state->ops_lock));\n\n\tif (!IS_ALIGNED(dmabuf->mode.offset, PAGE_SIZE)) {\n\t\tdev_info_ratelimited(dev, \"%s: framebuffer not page-aligned\\n\",\n\t\t\t\t     __func__);\n\t\treturn -EINVAL;\n\t}\n\n\texp_info.ops = &mbochs_dmabuf_ops;\n\texp_info.size = dmabuf->mode.size;\n\texp_info.priv = dmabuf;\n\n\tbuf = dma_buf_export(&exp_info);\n\tif (IS_ERR(buf)) {\n\t\tdev_info_ratelimited(dev, \"%s: dma_buf_export failed: %ld\\n\",\n\t\t\t\t     __func__, PTR_ERR(buf));\n\t\treturn PTR_ERR(buf);\n\t}\n\n\tdmabuf->buf = buf;\n\tdev_dbg(dev, \"%s: %d\\n\", __func__, dmabuf->id);\n\treturn 0;\n}\n\nstatic int mbochs_get_region_info(struct mdev_state *mdev_state,\n\t\t\t\t  struct vfio_region_info_ext *ext)\n{\n\tstruct vfio_region_info *region_info = &ext->base;\n\n\tif (region_info->index >= MBOCHS_NUM_REGIONS)\n\t\treturn -EINVAL;\n\n\tswitch (region_info->index) {\n\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\tregion_info->offset = 0;\n\t\tregion_info->size   = MBOCHS_CONFIG_SPACE_SIZE;\n\t\tregion_info->flags  = (VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_WRITE);\n\t\tbreak;\n\tcase VFIO_PCI_BAR0_REGION_INDEX:\n\t\tregion_info->offset = MBOCHS_MEMORY_BAR_OFFSET;\n\t\tregion_info->size   = mdev_state->memsize;\n\t\tregion_info->flags  = (VFIO_REGION_INFO_FLAG_READ  |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_WRITE |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_MMAP);\n\t\tbreak;\n\tcase VFIO_PCI_BAR2_REGION_INDEX:\n\t\tregion_info->offset = MBOCHS_MMIO_BAR_OFFSET;\n\t\tregion_info->size   = MBOCHS_MMIO_BAR_SIZE;\n\t\tregion_info->flags  = (VFIO_REGION_INFO_FLAG_READ  |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_WRITE);\n\t\tbreak;\n\tcase MBOCHS_EDID_REGION_INDEX:\n\t\text->base.argsz = sizeof(*ext);\n\t\text->base.offset = MBOCHS_EDID_OFFSET;\n\t\text->base.size = MBOCHS_EDID_SIZE;\n\t\text->base.flags = (VFIO_REGION_INFO_FLAG_READ  |\n\t\t\t\t   VFIO_REGION_INFO_FLAG_WRITE |\n\t\t\t\t   VFIO_REGION_INFO_FLAG_CAPS);\n\t\text->base.cap_offset = offsetof(typeof(*ext), type);\n\t\text->type.header.id = VFIO_REGION_INFO_CAP_TYPE;\n\t\text->type.header.version = 1;\n\t\text->type.header.next = 0;\n\t\text->type.type = VFIO_REGION_TYPE_GFX;\n\t\text->type.subtype = VFIO_REGION_SUBTYPE_GFX_EDID;\n\t\tbreak;\n\tdefault:\n\t\tregion_info->size   = 0;\n\t\tregion_info->offset = 0;\n\t\tregion_info->flags  = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int mbochs_get_irq_info(struct vfio_irq_info *irq_info)\n{\n\tirq_info->count = 0;\n\treturn 0;\n}\n\nstatic int mbochs_get_device_info(struct vfio_device_info *dev_info)\n{\n\tdev_info->flags = VFIO_DEVICE_FLAGS_PCI;\n\tdev_info->num_regions = MBOCHS_NUM_REGIONS;\n\tdev_info->num_irqs = VFIO_PCI_NUM_IRQS;\n\treturn 0;\n}\n\nstatic int mbochs_query_gfx_plane(struct mdev_state *mdev_state,\n\t\t\t\t  struct vfio_device_gfx_plane_info *plane)\n{\n\tstruct mbochs_dmabuf *dmabuf;\n\tstruct mbochs_mode mode;\n\tint ret;\n\n\tif (plane->flags & VFIO_GFX_PLANE_TYPE_PROBE) {\n\t\tif (plane->flags == (VFIO_GFX_PLANE_TYPE_PROBE |\n\t\t\t\t     VFIO_GFX_PLANE_TYPE_DMABUF))\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\n\tif (plane->flags != VFIO_GFX_PLANE_TYPE_DMABUF)\n\t\treturn -EINVAL;\n\n\tplane->drm_format_mod = 0;\n\tplane->x_pos\t      = 0;\n\tplane->y_pos\t      = 0;\n\tplane->x_hot\t      = 0;\n\tplane->y_hot\t      = 0;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tret = -EINVAL;\n\tif (plane->drm_plane_type == DRM_PLANE_TYPE_PRIMARY)\n\t\tret = mbochs_check_framebuffer(mdev_state, &mode);\n\tif (ret < 0) {\n\t\tplane->drm_format     = 0;\n\t\tplane->width\t      = 0;\n\t\tplane->height\t      = 0;\n\t\tplane->stride\t      = 0;\n\t\tplane->size\t      = 0;\n\t\tplane->dmabuf_id      = 0;\n\t\tgoto done;\n\t}\n\n\tdmabuf = mbochs_dmabuf_find_by_mode(mdev_state, &mode);\n\tif (!dmabuf)\n\t\tmbochs_dmabuf_alloc(mdev_state, &mode);\n\tif (!dmabuf) {\n\t\tmutex_unlock(&mdev_state->ops_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tplane->drm_format     = dmabuf->mode.drm_format;\n\tplane->width\t      = dmabuf->mode.width;\n\tplane->height\t      = dmabuf->mode.height;\n\tplane->stride\t      = dmabuf->mode.stride;\n\tplane->size\t      = dmabuf->mode.size;\n\tplane->dmabuf_id      = dmabuf->id;\n\ndone:\n\tif (plane->drm_plane_type == DRM_PLANE_TYPE_PRIMARY &&\n\t    mdev_state->active_id != plane->dmabuf_id) {\n\t\tdev_dbg(mdev_state->vdev.dev, \"%s: primary: %d => %d\\n\",\n\t\t\t__func__, mdev_state->active_id, plane->dmabuf_id);\n\t\tmdev_state->active_id = plane->dmabuf_id;\n\t}\n\tmutex_unlock(&mdev_state->ops_lock);\n\treturn 0;\n}\n\nstatic int mbochs_get_gfx_dmabuf(struct mdev_state *mdev_state, u32 id)\n{\n\tstruct mbochs_dmabuf *dmabuf;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tdmabuf = mbochs_dmabuf_find_by_id(mdev_state, id);\n\tif (!dmabuf) {\n\t\tmutex_unlock(&mdev_state->ops_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tif (!dmabuf->buf)\n\t\tmbochs_dmabuf_export(dmabuf);\n\n\tmutex_unlock(&mdev_state->ops_lock);\n\n\tif (!dmabuf->buf)\n\t\treturn -EINVAL;\n\n\treturn dma_buf_fd(dmabuf->buf, 0);\n}\n\nstatic long mbochs_ioctl(struct vfio_device *vdev, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tint ret = 0;\n\tunsigned long minsz, outsz;\n\n\tswitch (cmd) {\n\tcase VFIO_DEVICE_GET_INFO:\n\t{\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = mbochs_get_device_info(&info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase VFIO_DEVICE_GET_REGION_INFO:\n\t{\n\t\tstruct vfio_region_info_ext info;\n\n\t\tminsz = offsetofend(typeof(info), base.offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\toutsz = info.base.argsz;\n\t\tif (outsz < minsz)\n\t\t\treturn -EINVAL;\n\t\tif (outsz > sizeof(info))\n\t\t\treturn -EINVAL;\n\n\t\tret = mbochs_get_region_info(mdev_state, &info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &info, outsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase VFIO_DEVICE_GET_IRQ_INFO:\n\t{\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif ((info.argsz < minsz) ||\n\t\t    (info.index >= VFIO_PCI_NUM_IRQS))\n\t\t\treturn -EINVAL;\n\n\t\tret = mbochs_get_irq_info(&info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase VFIO_DEVICE_QUERY_GFX_PLANE:\n\t{\n\t\tstruct vfio_device_gfx_plane_info plane;\n\n\t\tminsz = offsetofend(struct vfio_device_gfx_plane_info,\n\t\t\t\t    region_index);\n\n\t\tif (copy_from_user(&plane, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (plane.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = mbochs_query_gfx_plane(mdev_state, &plane);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &plane, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase VFIO_DEVICE_GET_GFX_DMABUF:\n\t{\n\t\tu32 dmabuf_id;\n\n\t\tif (get_user(dmabuf_id, (__u32 __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\treturn mbochs_get_gfx_dmabuf(mdev_state, dmabuf_id);\n\t}\n\n\tcase VFIO_DEVICE_SET_IRQS:\n\t\treturn -EINVAL;\n\n\tcase VFIO_DEVICE_RESET:\n\t\treturn mbochs_reset(mdev_state);\n\t}\n\treturn -ENOTTY;\n}\n\nstatic int mbochs_open(struct vfio_device *vdev)\n{\n\treturn 0;\n}\n\nstatic void mbochs_close(struct vfio_device *vdev)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tstruct mbochs_dmabuf *dmabuf, *tmp;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tlist_for_each_entry_safe(dmabuf, tmp, &mdev_state->dmabufs, next) {\n\t\tlist_del(&dmabuf->next);\n\t\tif (dmabuf->buf) {\n\t\t\t/* free in mbochs_release_dmabuf() */\n\t\t\tdmabuf->unlinked = true;\n\t\t} else {\n\t\t\tkfree(dmabuf);\n\t\t}\n\t}\n\tmbochs_put_pages(mdev_state);\n\n\tmutex_unlock(&mdev_state->ops_lock);\n}\n\nstatic ssize_t\nmemory_show(struct device *dev, struct device_attribute *attr,\n\t    char *buf)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d MB\\n\", mdev_state->type->mbytes);\n}\nstatic DEVICE_ATTR_RO(memory);\n\nstatic struct attribute *mdev_dev_attrs[] = {\n\t&dev_attr_memory.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mdev_dev_group = {\n\t.name  = \"vendor\",\n\t.attrs = mdev_dev_attrs,\n};\n\nstatic const struct attribute_group *mdev_dev_groups[] = {\n\t&mdev_dev_group,\n\tNULL,\n};\n\nstatic ssize_t name_show(struct mdev_type *mtype,\n\t\t\t struct mdev_type_attribute *attr, char *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\n\treturn sprintf(buf, \"%s\\n\", type->name);\n}\nstatic MDEV_TYPE_ATTR_RO(name);\n\nstatic ssize_t description_show(struct mdev_type *mtype,\n\t\t\t\tstruct mdev_type_attribute *attr, char *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\n\treturn sprintf(buf, \"virtual display, %d MB video memory\\n\",\n\t\t       type ? type->mbytes  : 0);\n}\nstatic MDEV_TYPE_ATTR_RO(description);\n\nstatic ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = atomic_read(&mbochs_avail_mbytes) / type->mbytes;\n\n\treturn sprintf(buf, \"%d\\n\", count);\n}\nstatic MDEV_TYPE_ATTR_RO(available_instances);\n\nstatic ssize_t device_api_show(struct mdev_type *mtype,\n\t\t\t       struct mdev_type_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", VFIO_DEVICE_API_PCI_STRING);\n}\nstatic MDEV_TYPE_ATTR_RO(device_api);\n\nstatic struct attribute *mdev_types_attrs[] = {\n\t&mdev_type_attr_name.attr,\n\t&mdev_type_attr_description.attr,\n\t&mdev_type_attr_device_api.attr,\n\t&mdev_type_attr_available_instances.attr,\n\tNULL,\n};\n\nstatic struct attribute_group mdev_type_group1 = {\n\t.name  = MBOCHS_TYPE_1,\n\t.attrs = mdev_types_attrs,\n};\n\nstatic struct attribute_group mdev_type_group2 = {\n\t.name  = MBOCHS_TYPE_2,\n\t.attrs = mdev_types_attrs,\n};\n\nstatic struct attribute_group mdev_type_group3 = {\n\t.name  = MBOCHS_TYPE_3,\n\t.attrs = mdev_types_attrs,\n};\n\nstatic struct attribute_group *mdev_type_groups[] = {\n\t&mdev_type_group1,\n\t&mdev_type_group2,\n\t&mdev_type_group3,\n\tNULL,\n};\n\nstatic const struct vfio_device_ops mbochs_dev_ops = {\n\t.open = mbochs_open,\n\t.release = mbochs_close,\n\t.read = mbochs_read,\n\t.write = mbochs_write,\n\t.ioctl = mbochs_ioctl,\n\t.mmap = mbochs_mmap,\n};\n\nstatic struct mdev_driver mbochs_driver = {\n\t.driver = {\n\t\t.name = \"mbochs\",\n\t\t.owner = THIS_MODULE,\n\t\t.mod_name = KBUILD_MODNAME,\n\t\t.dev_groups = mdev_dev_groups,\n\t},\n\t.probe = mbochs_probe,\n\t.remove\t= mbochs_remove,\n};\n\nstatic const struct mdev_parent_ops mdev_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.device_driver\t\t= &mbochs_driver,\n\t.supported_type_groups\t= mdev_type_groups,\n};\n\nstatic const struct file_operations vd_fops = {\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void mbochs_device_release(struct device *dev)\n{\n\t/* nothing */\n}\n\nstatic int __init mbochs_dev_init(void)\n{\n\tint ret = 0;\n\n\tatomic_set(&mbochs_avail_mbytes, max_mbytes);\n\n\tret = alloc_chrdev_region(&mbochs_devt, 0, MINORMASK + 1, MBOCHS_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"Error: failed to register mbochs_dev, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcdev_init(&mbochs_cdev, &vd_fops);\n\tcdev_add(&mbochs_cdev, mbochs_devt, MINORMASK + 1);\n\tpr_info(\"%s: major %d\\n\", __func__, MAJOR(mbochs_devt));\n\n\tret = mdev_register_driver(&mbochs_driver);\n\tif (ret)\n\t\tgoto err_cdev;\n\n\tmbochs_class = class_create(THIS_MODULE, MBOCHS_CLASS_NAME);\n\tif (IS_ERR(mbochs_class)) {\n\t\tpr_err(\"Error: failed to register mbochs_dev class\\n\");\n\t\tret = PTR_ERR(mbochs_class);\n\t\tgoto err_driver;\n\t}\n\tmbochs_dev.class = mbochs_class;\n\tmbochs_dev.release = mbochs_device_release;\n\tdev_set_name(&mbochs_dev, \"%s\", MBOCHS_NAME);\n\n\tret = device_register(&mbochs_dev);\n\tif (ret)\n\t\tgoto err_class;\n\n\tret = mdev_register_device(&mbochs_dev, &mdev_fops);\n\tif (ret)\n\t\tgoto err_device;\n\n\treturn 0;\n\nerr_device:\n\tdevice_unregister(&mbochs_dev);\nerr_class:\n\tclass_destroy(mbochs_class);\nerr_driver:\n\tmdev_unregister_driver(&mbochs_driver);\nerr_cdev:\n\tcdev_del(&mbochs_cdev);\n\tunregister_chrdev_region(mbochs_devt, MINORMASK + 1);\n\treturn ret;\n}\n\nstatic void __exit mbochs_dev_exit(void)\n{\n\tmbochs_dev.bus = NULL;\n\tmdev_unregister_device(&mbochs_dev);\n\n\tdevice_unregister(&mbochs_dev);\n\tmdev_unregister_driver(&mbochs_driver);\n\tcdev_del(&mbochs_cdev);\n\tunregister_chrdev_region(mbochs_devt, MINORMASK + 1);\n\tclass_destroy(mbochs_class);\n\tmbochs_class = NULL;\n}\n\nmodule_init(mbochs_dev_init)\nmodule_exit(mbochs_dev_exit)\n"], "filenames": ["samples/vfio-mdev/mbochs.c"], "buggy_code_start_loc": [132], "buggy_code_end_loc": [1434], "fixing_code_start_loc": [132], "fixing_code_end_loc": [1441], "type": "CWE-401", "message": "A flaw was found in the Linux kernel. A memory leak problem was found in mbochs_ioctl in samples/vfio-mdev/mbochs.c in Virtual Function I/O (VFIO) Mediated devices. This flaw could allow a local attacker to leak internal kernel information.", "other": {"cve": {"id": "CVE-2021-3736", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T16:15:09.687", "lastModified": "2022-08-25T02:28:54.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the Linux kernel. A memory leak problem was found in mbochs_ioctl in samples/vfio-mdev/mbochs.c in Virtual Function I/O (VFIO) Mediated devices. This flaw could allow a local attacker to leak internal kernel information."}, {"lang": "es", "value": "Se ha encontrado un fallo en el kernel de Linux. Se encontr\u00f3 un problema de p\u00e9rdida de memoria en la funci\u00f3n mbochs_ioctl en el archivo samples/vfio-mdev/mbochs.c en dispositivos mediados por Virtual Function I/O (VFIO). Este fallo podr\u00eda permitir a un atacante local filtrar informaci\u00f3n interna del kernel."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.14.20", "matchCriteriaId": "BBD585C2-3F95-4E2A-BD16-33C3A6211557"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-3736", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1995570", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/de5494af4815a4c9328536c72741229b7de88e7f", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/de5494af4815a4c9328536c72741229b7de88e7f"}}