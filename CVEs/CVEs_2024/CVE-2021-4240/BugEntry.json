{"buggy_code": ["<?php\n\n/**\n * PHP Server Monitor\n * Monitor your servers and websites.\n *\n * This file is part of PHP Server Monitor.\n * PHP Server Monitor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PHP Server Monitor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with PHP Server Monitor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @package     phpservermon\n * @author      Pepijn Over <pep@mailbox.org>\n * @copyright   Copyright (c) 2008-2017 Pepijn Over <pep@mailbox.org>\n * @license     http://www.gnu.org/licenses/gpl.txt GNU GPL v3\n * @version     Release: @package_version@\n * @link        http://www.phpservermonitor.org/\n * @since       phpservermon 3.0.0\n **/\n\n/**\n * Current PSM version\n */\ndefine('PSM_VERSION', '3.6.0.beta2');\n\n/**\n * URL to check for updates. Will not be checked if turned off on config page.\n * @see psm_update_available()\n */\ndefine('PSM_UPDATE_URL', 'https://api.github.com/repos/phpservermon/phpservermon/releases/latest');\n\n/**\n * Default update interval (1 day). Only applicable when updates are enabled.\n * @see psm_update_available()\n */\ndefine('PSM_UPDATE_INTERVAL', 1 * 24 * 60 * 60);\n\n/**\n * Configuration for: Hashing strength\n * This is the place where you define the strength of your password hashing/salting\n *\n * To make password encryption very safe and future-proof, the PHP 5.5 hashing/salting functions\n * come with a clever so called COST FACTOR. This number defines the base-2 logarithm of the rounds of hashing,\n * something like 2^12 if your cost factor is 12. By the way, 2^12 would be 4096 rounds of hashing, doubling the\n * round with each increase of the cost factor and therefore doubling the CPU power it needs.\n * Currently, in 2013, the developers of this functions have chosen a cost factor of 10, which fits most standard\n * server setups. When time goes by and server power becomes much more powerful, it might be useful to increase\n * the cost factor, to make the password hashing one step more secure. Have a look here\n * (@see https://github.com/panique/php-login/wiki/Which-hashing-&-salting-algorithm-should-be-used-%3F)\n * in the BLOWFISH benchmark table to get an idea how this factor behaves. For most people this is irrelevant,\n * but after some years this might be very very useful to keep the encryption of your database up to date.\n *\n * Remember: Every time a user registers or tries to log in (!) this calculation will be done.\n * Don't change this if you don't know what you do.\n *\n * To get more information about the best cost factor please have a look here\n * @see http://stackoverflow.com/q/4443476/1114320\n *\n * This constant will be used in the login and the registration class.\n */\ndefine('PSM_LOGIN_HASH_COST_FACTOR', '10');\n\n/**\n * Configuration for: Cookies\n * Please note: The COOKIE_DOMAIN needs the domain where your app is,\n * in a format like this: .mydomain.com\n * Note the . in front of the domain. No www, no http, no slash here!\n * For local development .127.0.0.1 or .localhost is fine, but when deploying you should\n * change this to your real domain, like '.mydomain.com' ! The leading dot makes the cookie available for\n * sub-domains too.\n * @see http://stackoverflow.com/q/9618217/1114320\n * @see http://www.php.net/manual/en/function.setcookie.php\n *\n * COOKIE_RUNTIME: How long should a cookie be valid ? 1209600 seconds = 2 weeks\n * COOKIE_DOMAIN: The domain where the cookie is valid for, like '.mydomain.com'\n * COOKIE_SECRET_KEY: Put a random value here to make your app more secure. When changed, all cookies are reset.\n */\ndefine('PSM_LOGIN_COOKIE_RUNTIME', 1209600);\ndefine('PSM_LOGIN_COOKIE_DOMAIN', null);\ndefine('PSM_LOGIN_COOKIE_SECRET_KEY', '4w900de52e3ap7y77y8675jy6c594286');\n\n/**\n * Number of seconds the reset link is valid after sending it to the user.\n */\ndefine('PSM_LOGIN_RESET_RUNTIME', 3600);\n\n/**\n * Number of seconds the cron is supposedly dead and we will run another cron anyway. Set to 0 to disable.\n */\ndefine('PSM_CRON_TIMEOUT', 600);\n\n/**\n * Default timeout in seconds for curl requests (can be overwritten per-server).\n */\ndefine('PSM_CURL_TIMEOUT', 10);\n\n/**\n * Clone URL for the Pushover.net service.\n */\ndefine('PSM_PUSHOVER_CLONE_URL', 'https://pushover.net/apps/clone/php_server_monitor');\n\n/**\n * Get chat id for Telegram service.\n */\ndefine('PSM_TELEGRAM_GET_ID_URL', 'https://telegram.me/cid_bot');\n\n/**\n * By defining the PSM_BASE_URL, you will force the psm_build_url() to use this.\n * Useful for cronjobs if it cannot be auto-detected.\n */\n//define('PSM_BASE_URL', null);\n\nif (!defined('PSM_MODULE_DEFAULT')) {\n    /**\n     * Default theme\n     */\n    define('PSM_THEME', 'default');\n\n    /**\n     * Default module (if none given or invalid one)\n     */\n    define('PSM_MODULE_DEFAULT', 'server_status');\n}\n\nif (defined('PSM_JABBER_FORCE_TLS') === false) {\n    define('PSM_JABBER_FORCE_TLS', true);\n}\nif (defined('PSM_JABBER_AUTH_TYPE') === false) {\n    // possible values: PLAIN, X-OAUTH2, DIGEST-MD5, CRAM-MD5, SCRAM-SHA-1, ANONYMOUS, EXTERNAL\n    define('PSM_JABBER_AUTH_TYPE', 'PLAIN'); // default just plain because of google for example :(\n}\nif (defined('PSM_JABBER_DEBUG_LEVEL') === false) {\n    // possible values: ERROR, WARNING, NOTICE, INFO, DEBUG\n    define('PSM_JABBER_DEBUG_LEVEL', JAXLLogger::WARNING);\n}\n", "<?php\n\n/**\n * PHP Server Monitor\n * Monitor your servers and websites.\n *\n * This file is part of PHP Server Monitor.\n * PHP Server Monitor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PHP Server Monitor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with PHP Server Monitor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @package     phpservermon\n * @author      Panique <https://github.com/panique/php-login-advanced/>\n * @author      Pepijn Over <pep@mailbox.org>\n * @copyright   Copyright (c) 2008-2017 Pepijn Over <pep@mailbox.org>\n * @license     http://www.gnu.org/licenses/gpl.txt GNU GPL v3\n * @version     Release: @package_version@\n * @link        http://www.phpservermonitor.org/\n * @since       phpservermon 3.0.0\n **/\n\nnamespace psm\\Service;\n\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n/**\n * This is a heavily modified version of the php-login-advanced project by Panique.\n *\n * It uses the Session classes from the Symfony HttpFoundation component.\n *\n * @author Panique\n * @author Pepijn Over\n * @link http://www.php-login.net\n * @link https://github.com/panique/php-login-advanced/\n * @license http://opensource.org/licenses/MIT MIT License\n */\nclass User\n{\n\n    /**\n     * The database connection\n     * @var \\PDO $db_connection\n     */\n    protected $db_connection = null;\n\n    /**\n     * Local cache of user data\n     * @var array $user_data\n     */\n    protected $user_data = array();\n\n    /**\n     * Session object\n     * @var \\Symfony\\Component\\HttpFoundation\\Session\\Session $session\n     */\n    protected $session;\n\n    /**\n     * Current user id\n     * @var int $user_id\n     */\n    protected $user_id;\n\n    /**\n     *Current user preferences\n     * @var array $user_preferences\n     */\n    protected $user_preferences;\n\n    /**\n     * The user's login status\n     * @var boolean $user_is_logged_in\n     */\n    protected $user_is_logged_in = false;\n\n    /**\n     * Open a new user service\n     *\n     * @param \\psm\\Service\\Database $db\n     * @param \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface $session if NULL, one will be created\n     */\n    public function __construct(Database $db, SessionInterface $session = null)\n    {\n        $this->db_connection = $db->pdo();\n\n        if (!psm_is_cli()) {\n            if ($session == null) {\n                $session = new Session();\n                $session->start();\n            }\n            $this->session = $session;\n\n            if (PSM_PUBLIC === true && PSM_PUBLIC_PAGE === true) {\n                $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n                    PSM_DB_PREFIX . 'users WHERE user_name = :user_name and level = :level');\n                $query_user->bindValue(':user_name', \"__PUBLIC__\", \\PDO::PARAM_STR);\n                $query_user->bindValue(':level', PSM_USER_ANONYMOUS, \\PDO::PARAM_STR);\n                $query_user->execute();\n\n                // get result row (as an object)\n                $this->setUserLoggedIn($query_user->fetchObject()->user_id);\n            }\n\n            if ((!defined('PSM_INSTALL') || !PSM_INSTALL)) {\n                // check the possible login actions:\n                // 1. login via session data (happens each time user opens a page on your php project AFTER\n                // he has successfully logged in via the login form)\n                // 2. login via cookie\n\n                // if user has an active session on the server\n                if (!$this->loginWithSessionData()) {\n                    $this->loginWithCookieData();\n                }\n            }\n        }\n    }\n\n    /**\n     * Get user by id, or get current user.\n     * @param int $user_id if null it will attempt current user id\n     * @param boolean $flush if TRUE it will query db regardless of whether we already have the data\n     * @return object|boolean FALSE if user not found, object otherwise\n     */\n    public function getUser($user_id = null, $flush = false)\n    {\n        if ($user_id == null) {\n            if (!$this->isUserLoggedIn()) {\n                return false;\n            } else {\n                $user_id = $this->getUserId();\n            }\n        }\n\n        if (!isset($this->user_data[$user_id]) || $flush) {\n            $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n                PSM_DB_PREFIX . 'users WHERE user_id = :user_id');\n            $query_user->bindValue(':user_id', $user_id, \\PDO::PARAM_INT);\n            $query_user->execute();\n            // get result row (as an object)\n            $this->user_data[$user_id] = $query_user->fetchObject();\n        }\n        return $this->user_data[$user_id];\n    }\n\n    /**\n     * Search into database for the user data of user_name specified as parameter\n     * @return object|boolean user data as an object if existing user\n     */\n    public function getUserByUsername($user_name)\n    {\n        // database query, getting all the info of the selected user\n        $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n            PSM_DB_PREFIX . 'users WHERE user_name = :user_name');\n        $query_user->bindValue(':user_name', $user_name, \\PDO::PARAM_STR);\n        $query_user->execute();\n        // get result row (as an object)\n        return $query_user->fetchObject();\n    }\n\n    /**\n     * Logs in with SESSION data.\n     *\n     * @return boolean\n     */\n    protected function loginWithSessionData()\n    {\n        if (!$this->session->has('user_id')) {\n            return false;\n        }\n        $user = $this->getUser($this->session->get('user_id'));\n\n        if (!empty($user)) {\n            $this->setUserLoggedIn($user->user_id);\n            return true;\n        } else {\n            // user no longer exists in database\n            // call logout to clean up session vars\n            $this->doLogout();\n            return false;\n        }\n    }\n\n    /**\n     * Logs in via the Cookie\n     * @return bool success state of cookie login\n     */\n    private function loginWithCookieData()\n    {\n        if (isset($_COOKIE['rememberme'])) {\n            // extract data from the cookie\n            list($user_id, $token, $hash) = explode('_', $_COOKIE['rememberme']);\n            // check cookie hash validity\n            if ($hash == hash('sha256', $user_id . '_' . $token . PSM_LOGIN_COOKIE_SECRET_KEY) && !empty($token)) {\n                // cookie looks good, try to select corresponding user\n                // get real token from database (and all other data)\n                $user = $this->getUser($user_id);\n\n                if (!empty($user) && $token === $user->rememberme_token) {\n                    $this->setUserLoggedIn($user->user_id, true);\n\n                    // Cookie token usable only once\n                    $this->newRememberMeCookie();\n                    return true;\n                }\n            }\n            // call logout to remove invalid cookie\n            $this->doLogout();\n        }\n        return false;\n    }\n\n    /**\n     * Logs in with the data provided in $_POST, coming from the login form\n     * @param string $user_name\n     * @param string $user_password\n     * @param boolean $user_rememberme\n     * @return boolean\n     */\n    public function loginWithPostData($user_name, $user_password, $user_rememberme = false)\n    {\n        $user_name = trim($user_name);\n        $user_password = trim($user_password);\n        $ldapauthstatus = false;\n\n        if (empty($user_name) && empty($user_password)) {\n            return false;\n        }\n\n        $dirauthconfig = psm_get_conf('dirauth_status');\n        \n        // LDAP auth enabled\n        if ($dirauthconfig === '1') {\n            $ldaplibpath = realpath(\n                PSM_PATH_SRC . '..' . DIRECTORY_SEPARATOR .\n                'vendor' . DIRECTORY_SEPARATOR .\n                'viharm' . DIRECTORY_SEPARATOR .\n                'psm-ldap-auth' . DIRECTORY_SEPARATOR .\n                'psmldapauth.php'\n            );\n            // If the library is found\n            if ($ldaplibpath) {\n                // Delegate the authentication to the PsmLDAPauth module.\n                // If LDAP auth fails or if library not found, fall back to native auth\n                include_once($ldaplibpath);\n                $ldapauthstatus = psmldapauth($user_name, $user_password, $GLOBALS['sm_config'], $this->db_connection);\n            }\n        }\n\n        $user = $this->getUserByUsername($user_name);\n\n        // Authenticated\n        if ($ldapauthstatus === true) {\n          // Remove password to prevent it from being saved in the DB.\n          // Otherwise, user may still be authenticated if LDAP is disabled later.\n          $user_password = null;\n          @fn_Debug('Authenticated', $user);\n        } else {\n\n          // using PHP 5.5's password_verify() function to check if the provided passwords\n          // fits to the hash of that user's password\n          if (!isset($user->user_id)) {\n              password_verify($user_password, 'dummy_call_against_timing');\n              return false;\n          } elseif (!password_verify($user_password, $user->password)) {\n              return false;\n          }\n        } // not authenticated\n\n        $this->setUserLoggedIn($user->user_id, true);\n\n        // if user has check the \"remember me\" checkbox, then generate token and write cookie\n        if ($user_rememberme) {\n            $this->newRememberMeCookie();\n        }\n\n        // recalculate the user's password hash\n        // DELETE this if-block if you like, it only exists to recalculate\n        // users's hashes when you provide a cost factor,\n        // by default the script will use a cost factor of 10 and never change it.\n        // check if the have defined a cost factor in config/hashing.php\n        if (defined('PSM_LOGIN_HASH_COST_FACTOR')) {\n            // check if the hash needs to be rehashed\n            if (password_needs_rehash($user->password, PASSWORD_DEFAULT, array('cost' => PSM_LOGIN_HASH_COST_FACTOR))) {\n                $this->changePassword($user->user_id, $user_password);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Set the user logged in\n     * @param int $user_id\n     * @param boolean $regenerate regenerate session id against session fixation?\n     */\n    protected function setUserLoggedIn($user_id, $regenerate = false)\n    {\n        if ($regenerate) {\n            $this->session->invalidate();\n        }\n        $this->session->set('user_id', $user_id);\n        $this->session->set('user_logged_in', 1);\n\n        // declare user id, set the login status to true\n        $this->user_id = $user_id;\n        $this->user_is_logged_in = true;\n    }\n\n    /**\n     * Create all data needed for remember me cookie connection on client and server side\n     */\n    protected function newRememberMeCookie()\n    {\n        // generate 64 char random string and store it in current user data\n        $random_token_string = hash('sha256', random_bytes(64));\n        $sth = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET rememberme_token = :user_rememberme_token WHERE user_id = :user_id');\n        $sth->execute(array(':user_rememberme_token' => $random_token_string, ':user_id' => $this->getUserId()));\n\n        // generate cookie string that consists of userid, randomstring and combined hash of both\n        $cookie_string_first_part = $this->getUserId() . '_' . $random_token_string;\n        $cookie_string_hash = hash('sha256', $cookie_string_first_part . PSM_LOGIN_COOKIE_SECRET_KEY);\n        $cookie_string = $cookie_string_first_part . '_' . $cookie_string_hash;\n\n        // set cookie\n        setcookie('rememberme', $cookie_string, time() + PSM_LOGIN_COOKIE_RUNTIME, \"/\", PSM_LOGIN_COOKIE_DOMAIN);\n    }\n\n    /**\n     * Delete all data needed for remember me cookie connection on client and server side\n     */\n    protected function deleteRememberMeCookie()\n    {\n        // Reset rememberme token\n        if ($this->session->has('user_id')) {\n            $sth = $this->db_connection->prepare('UPDATE ' .\n                PSM_DB_PREFIX . 'users SET rememberme_token = NULL WHERE user_id = :user_id');\n            $sth->execute(array(':user_id' => $this->session->get('user_id')));\n        }\n\n        // set the rememberme-cookie to ten years ago (3600sec * 365 days * 10).\n        // that's obivously the best practice to kill a cookie via php\n        // @see http://stackoverflow.com/a/686166/1114320\n        setcookie('rememberme', false, time() - (3600 * 3650), '/', PSM_LOGIN_COOKIE_DOMAIN);\n    }\n\n    /**\n     * Perform the logout, resetting the session\n     */\n    public function doLogout()\n    {\n        $this->deleteRememberMeCookie();\n\n        $this->session->clear();\n        $this->session->invalidate();\n\n        $this->user_is_logged_in = false;\n    }\n\n    /**\n     * Simply return the current state of the user's login\n     * @return bool user's login status\n     */\n    public function isUserLoggedIn()\n    {\n        return $this->user_is_logged_in;\n    }\n\n    /**\n     * Sets a random token into the database (that will verify the user when he/she comes back via the link\n     * in the email) and returns it\n     * @param int $user_id\n     * @return string|boolean FALSE on error, string otherwise\n     */\n    public function generatePasswordResetToken($user_id)\n    {\n        $user_id = intval($user_id);\n\n        if ($user_id == 0) {\n            return false;\n        }\n        // generate timestamp (to see when exactly the user (or an attacker) requested the password reset mail)\n        $temporary_timestamp = time();\n        // generate random hash for email password reset verification (40 char string)\n        $user_password_reset_hash = sha1(uniqid(mt_rand(), true));\n\n        $query_update = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET password_reset_hash = :user_password_reset_hash,\n            password_reset_timestamp = :user_password_reset_timestamp\n            WHERE user_id = :user_id');\n        $query_update->bindValue(':user_password_reset_hash', $user_password_reset_hash, \\PDO::PARAM_STR);\n        $query_update->bindValue(':user_password_reset_timestamp', $temporary_timestamp, \\PDO::PARAM_INT);\n        $query_update->bindValue(':user_id', $user_id, \\PDO::PARAM_INT);\n        $query_update->execute();\n\n        // check if exactly one row was successfully changed:\n        if ($query_update->rowCount() == 1) {\n            return $user_password_reset_hash;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Checks if the verification string in the account verification mail is valid and matches to the user.\n     *\n     * Please note it is valid for 1 hour.\n     * @param int $user_id\n     * @param string $token\n     * @return boolean\n     */\n    public function verifyPasswordResetToken($user_id, $token)\n    {\n        $user_id = intval($user_id);\n\n        if (empty($user_id) || empty($token)) {\n            return false;\n        }\n        $user = $this->getUser($user_id);\n\n        if (isset($user->user_id) && $user->password_reset_hash == $token) {\n            $runtime = (defined('PSM_LOGIN_RESET_RUNTIME')) ? PSM_LOGIN_RESET_RUNTIME : 3600;\n            $timestamp_max_interval = time() - $runtime;\n\n            if ($user->password_reset_timestamp > $timestamp_max_interval) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Change the password of a user\n     * @param int|\\PDOStatement $user_id\n     * @param string $password\n     * @return boolean TRUE on success, FALSE on failure\n     */\n    public function changePassword($user_id, $password)\n    {\n        $user_id = intval($user_id);\n\n        if (empty($user_id) || empty($password)) {\n            return false;\n        }\n        // now it gets a little bit crazy: check if we have a constant\n        // PSM_LOGIN_HASH_COST_FACTOR defined (in src/includes/psmconfig.inc.php),\n        // if so: put the value into $hash_cost_factor, if not, make $hash_cost_factor = null\n        $hash_cost_factor = (defined('PSM_LOGIN_HASH_COST_FACTOR') ? PSM_LOGIN_HASH_COST_FACTOR : null);\n\n        // crypt the user's password with the PHP 5.5's password_hash() function, results in a 60 character hash string\n        // the PASSWORD_DEFAULT constant is defined by the PHP 5.5,\n        // or if you are using PHP 5.3/5.4, by the password hashing\n        // compatibility library. the third parameter looks a little bit shitty, but that's how those PHP 5.5 functions\n        // want the parameter: as an array with, currently only used with 'cost' => XX.\n        $user_password_hash = password_hash($password, PASSWORD_DEFAULT, array('cost' => $hash_cost_factor));\n\n        // write users new hash into database\n        $query_update = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET password = :user_password_hash,\n\t\t\t\tpassword_reset_hash = NULL, password_reset_timestamp = NULL\n\t\t\t\tWHERE user_id = :user_id');\n        $query_update->bindValue(':user_password_hash', $user_password_hash, \\PDO::PARAM_STR);\n        $query_update->bindValue(':user_id', $user_id, \\PDO::PARAM_STR);\n        $query_update->execute();\n\n        // check if exactly one row was successfully changed:\n        if ($query_update->rowCount() == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Gets the user id\n     * @return int\n     */\n    public function getUserId()\n    {\n        return $this->user_id;\n    }\n\n    /**\n     * Gets the username\n     * @return string\n     */\n    public function getUsername()\n    {\n        $user = $this->getUser();\n        return (isset($user->user_name) ? $user->user_name : null);\n    }\n\n    /**\n     * Gets the user level\n     * @return int\n     */\n    public function getUserLevel()\n    {\n        $user = $this->getUser();\n\n        if (isset($user->level)) {\n            return $user->level;\n        } else {\n            return PSM_USER_ANONYMOUS;\n        }\n    }\n\n    /**\n     * read current user preferences from the database\n     * @return boolean return false is user not connected\n     */\n    protected function loadPreferences()\n    {\n        if ($this->user_preferences === null) {\n            if (!$this->getUser()) {\n                return false;\n            }\n\n            $this->user_preferences = array();\n            foreach ($this->db_connection->query('SELECT `key`,`value` FROM `' .\n                PSM_DB_PREFIX . 'users_preferences` WHERE `user_id` = ' . $this->user_id) as $row) {\n                $this->user_preferences[$row['key']] = $row['value'];\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get a user preference value\n     * @param string $key\n     * @param mixed $default\n     * @return mixed\n     */\n    public function getUserPref($key, $default = '')\n    {\n        if (!$this->loadPreferences() || !isset($this->user_preferences[$key])) {\n            return $default;\n        }\n\n        $value = $this->user_preferences[$key];\n        settype($value, gettype($default));\n        return $value;\n    }\n\n    /**\n     * Set a user preference value\n     * @param string $key\n     * @param mixed $value\n     */\n    public function setUserPref($key, $value)\n    {\n        if ($this->loadPreferences()) {\n            if (isset($this->user_preferences[$key])) {\n                if ($this->user_preferences[$key] == $value) {\n                    return; // no change\n                }\n                $sql = 'UPDATE `' . PSM_DB_PREFIX . 'users_preferences` SET `key` = ?, `value` = ? WHERE `user_id` = ?';\n            } else {\n                $sql = 'INSERT INTO `' . PSM_DB_PREFIX . 'users_preferences` SET `key` = ?, `value` = ?, `user_id` = ?';\n            }\n            $sth = $this->db_connection->prepare($sql);\n            $sth->execute(array($key, $value, $this->user_id));\n            $this->user_preferences[$key] = $value;\n        }\n    }\n\n    /**\n     * Get session object\n     * @return \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n}\n", "<?php\n\n/**\n * PHP Server Monitor\n * Monitor your servers and websites.\n *\n * This file is part of PHP Server Monitor.\n * PHP Server Monitor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PHP Server Monitor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with PHP Server Monitor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @package     phpservermon\n * @author      Pepijn Over <pep@mailbox.org>\n * @copyright   Copyright (c) 2008-2017 Pepijn Over <pep@mailbox.org>\n * @license     http://www.gnu.org/licenses/gpl.txt GNU GPL v3\n * @version     Release: @package_version@\n * @link        http://www.phpservermonitor.org/\n * @since       phpservermon 2.1.0\n **/\n\nnamespace psm\\Util\\Install;\n\n/**\n * Installer class.\n *\n * Executes the queries to install/upgrade phpservermon.\n */\nclass Installer\n{\n\n    /**\n     * Database service\n     * @var \\psm\\Service\\Database $db\n     */\n    protected $db;\n\n    /**\n     * Log callback\n     * @var callable $logger\n     */\n    protected $logger;\n\n    /**\n     * Log of executed queries\n     * @var array $queries\n     */\n    protected $queries = array();\n\n    /**\n     * Open a new installer instance\n     * @param \\psm\\Service\\Database $db\n     * @param callable $logger\n     */\n    public function __construct(\\psm\\Service\\Database $db, $logger = null)\n    {\n        $this->db = $db;\n        $this->logger = $logger;\n    }\n\n    /**\n     * Check if an upgrade is required for the current version.\n     * @return boolean\n     * @see upgrade()\n     */\n    public function isUpgradeRequired()\n    {\n        $version_db = psm_get_conf('version');\n\n        if (version_compare(PSM_VERSION, $version_db, '==')) {\n            // version is up to date\n            return false;\n        }\n\n        // different DB version, check if the version requires any changes\n        if (version_compare($version_db, PSM_VERSION, '<')) {\n            return true;\n        } else {\n            // change database version to current version so this check won't be required next time\n            psm_update_conf('version', PSM_VERSION);\n        }\n        return false;\n    }\n\n    /**\n     * Log a message to the logger callable (if any)\n     * @param string|array $msg\n     * @return \\psm\\Util\\Install\\Installer\n     */\n    protected function log($msg)\n    {\n        if (is_callable($this->logger)) {\n            $msg = (!is_array($msg)) ? array($msg) : $msg;\n\n            foreach ($msg as $m) {\n                call_user_func($this->logger, $m);\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * Execute one or more queries. Does no fetching or anything, so execute only.\n     * @param string|array $query\n     * @return \\psm\\Util\\Install\\Installer\n     */\n    protected function execSQL($query)\n    {\n        $query = (!is_array($query)) ? array($query) : $query;\n\n        foreach ($query as $q) {\n            $this->queries[] = $q;\n            $this->db->exec($q);\n        }\n        return $this;\n    }\n\n    /**\n     * Retrieve table queries for install\n     */\n    public function install()\n    {\n        $this->installTables();\n\n        $this->log('Populating database...');\n        $queries = array();\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"servers` (\n            `ip`, `port`, `label`, `type`, `pattern`, `pattern_online`, `redirect_check`,\n            `status`, `rtime`, `active`, `email`, `sms`, `pushover`,`webhook`, `telegram`, `jabber`)\n            VALUES ('http://sourceforge.net/index.php', 80, 'SourceForge', 'website', '',\n                'yes', 'bad', 'on', '0.0000000', 'yes', 'yes', 'yes', 'yes','yes', 'yes', 'yes'),\n                ('smtp.gmail.com', 465, 'Gmail SMTP', 'service', '',\n                'yes', 'bad','on', '0.0000000', 'yes', 'yes', 'yes', 'yes', 'yes', 'yes', 'yes')\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"users_servers` (`user_id`,`server_id`) VALUES (1, 1), (1, 2);\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUE\n                    ('language', 'en_US'),\n                    ('proxy', '0'),\n                    ('proxy_url', ''),\n                    ('proxy_user', ''),\n                    ('proxy_password', ''),\n                    ('email_status', '1'),\n                    ('email_add_url', '0'),\n                    ('email_from_email', 'monitor@example.org'),\n                    ('email_from_name', 'Server Monitor'),\n                    ('email_smtp', ''),\n                    ('email_smtp_host', ''),\n                    ('email_smtp_port', ''),\n                    ('email_smtp_security', ''),\n                    ('email_smtp_username', ''),\n                    ('email_smtp_password', ''),\n                    ('sms_status', '0'),\n                    ('sms_gateway', 'messagebird'),\n                    ('sms_gateway_username', 'username'),\n                    ('sms_gateway_password', 'password'),\n                    ('sms_from', '1234567890'),\n                    ('webhook_status', '0'),\n                    ('pushover_status', '0'),\n                    ('pushover_api_token', ''),\n                    ('telegram_status', '0'),\n                    ('telegram_add_url', '0'),\n                    ('telegram_api_token', ''),\n                    ('jabber_status', '1'),\n                    ('jabber_host', ''),\n                    ('jabber_port', ''),\n                    ('jabber_username', ''),\n                    ('jabber_domain', ''),\n                    ('jabber_password', ''),\n                    ('password_encrypt_key', '\" . sha1(microtime()) . \"'),\n                    ('alert_type', 'status'),\n                    ('log_status', '1'),\n                    ('log_email', '1'),\n                    ('log_sms', '1'),\n                    ('log_pushover', '1'),\n                    ('log_webhook', '1'),\n                    ('log_telegram', '1'),\n                    ('log_jabber', '1'),\n                    ('discord_status', '0'),\n                    ('log_jdiscord', '1'),\n                    ('log_retention_period', '365'),\n                    ('version', '\" . PSM_VERSION . \"'),\n                    ('version_update_check', '\" . PSM_VERSION . \"'),\n                    ('auto_refresh_servers', '0'),\n                    ('show_update', '1'),\n                    ('last_update_check', '0'),\n                    ('cron_running', '0'),\n                    ('cron_running_time', '0'),\n                    ('cron_off_running', '0'),\n                    ('cron_off_running_time', '0');\";\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Install the tables for the monitor\n     */\n    protected function installTables()\n    {\n        $tables = array(\n            PSM_DB_PREFIX . 'config' => \"CREATE TABLE `\" . PSM_DB_PREFIX . \"config` (\n                `key` varchar(255) NOT NULL,\n                `value` varchar(255) NOT NULL,\n                PRIMARY KEY (`key`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'users' => \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"users` (\n                `user_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `user_name` varchar(64) NOT NULL COMMENT 'user''s name, unique',\n                `password` varchar(255) NOT NULL COMMENT 'user''s password in salted and hashed format',\n                `password_reset_hash` char(40) DEFAULT NULL COMMENT 'user''s password reset code',\n                `password_reset_timestamp` bigint(20) DEFAULT NULL COMMENT 'timestamp of the password reset request',\n                `rememberme_token` varchar(64) DEFAULT NULL COMMENT 'user''s remember-me cookie token',\n                `level` tinyint(2) unsigned NOT NULL DEFAULT '20',\n                `name` varchar(255) NOT NULL,\n                `mobile` varchar(15) NOT NULL,\n                `discord` varchar(255) NOT NULL,\n                `pushover_key` varchar(255) NOT NULL,\n                `pushover_device` varchar(255) NOT NULL,\n                `webhook_url` varchar(255) NOT NULL,\n                `webhook_json` varchar(255) NOT NULL DEFAULT '{\\\"text\\\":\\\"servermon: #message\\\"}',\n                `telegram_id` varchar(255) NOT NULL ,\n                `jabber` varchar(255) NOT NULL,\n                `email` varchar(255) NOT NULL,\n                PRIMARY KEY (`user_id`),\n                UNIQUE KEY `unique_username` (`user_name`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX .\n            'users_preferences' => \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"users_preferences` (\n                `user_id` int(11) unsigned NOT NULL,\n                `key` varchar(255) NOT NULL,\n                `value` varchar(255) NOT NULL,\n                PRIMARY KEY (`user_id`, `key`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'users_servers' => \"CREATE TABLE `\" . PSM_DB_PREFIX . \"users_servers` (\n                `user_id` INT( 11 ) UNSIGNED NOT NULL ,\n                `server_id` INT( 11 ) UNSIGNED NOT NULL ,\n                PRIMARY KEY ( `user_id` , `server_id` )\n            ) ENGINE = MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'log' => \"CREATE TABLE `\" . PSM_DB_PREFIX . \"log` (\n                `log_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `server_id` int(11) unsigned NOT NULL,\n                `type` enum('status','email','sms','discord','pushover','webhook','telegram', 'jabber') NOT NULL,\n                `message` TEXT NOT NULL,\n                `datetime` timestamp NOT NULL default CURRENT_TIMESTAMP,\n                PRIMARY KEY  (`log_id`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'log_users' => \"CREATE TABLE `\" . PSM_DB_PREFIX . \"log_users` (\n                `log_id`  int(11) UNSIGNED NOT NULL ,\n                `user_id`  int(11) UNSIGNED NOT NULL ,\n                PRIMARY KEY (`log_id`, `user_id`)\n            ) ENGINE=MyISAM  DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'servers' => \"CREATE TABLE `\" . PSM_DB_PREFIX . \"servers` (\n                `server_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `ip` varchar(500) NOT NULL,\n                `port` int(5) NOT NULL,\n                `request_method` varchar(50) NULL,\n                `label` varchar(255) NOT NULL,\n                `type` enum('ping','service','website') NOT NULL default 'service',\n                `pattern` varchar(255) NOT NULL default '',\n                `pattern_online` enum('yes','no') NOT NULL default 'yes',\n                `post_field` varchar(255) NULL,\n                `redirect_check` enum('ok','bad') NOT NULL default 'bad',\n                `allow_http_status` varchar(255) NOT NULL default '',\n                `header_name` varchar(255) NOT NULL default '',\n                `header_value` varchar(255) NOT NULL default '',\n                `status` enum('on','off') NOT NULL default 'on',\n                `error` varchar(255) NULL,\n                `rtime` FLOAT(9, 7) NULL,\n                `last_online` datetime NULL,\n                `last_offline` datetime NULL,\n                `last_offline_duration` varchar(255) NULL,\n                `last_check` datetime NULL,\n                `active` enum('yes','no') NOT NULL default 'yes',\n                `email` enum('yes','no') NOT NULL default 'yes',\n                `sms` enum('yes','no') NOT NULL default 'no',\n                `discord` enum('yes','no') NOT NULL default 'yes',\n                `pushover` enum('yes','no') NOT NULL default 'yes',\n                `webhook` enum('yes','no') NOT NULL default 'yes',\n                `telegram` enum('yes','no') NOT NULL default 'yes',\n                `jabber` enum('yes','no') NOT NULL default 'yes',\n                `warning_threshold` mediumint(1) unsigned NOT NULL DEFAULT '1',\n                `warning_threshold_counter` mediumint(1) unsigned NOT NULL DEFAULT '0',\n                `ssl_cert_expiry_days` mediumint(1) unsigned NOT NULL DEFAULT '0',\n                `ssl_cert_expired_time` varchar(255) NULL,\n                `timeout` smallint(1) unsigned NULL DEFAULT NULL,\n                `website_username` varchar(255) DEFAULT NULL,\n                `website_password` varchar(255) DEFAULT NULL,\n                `last_error` varchar(255) DEFAULT NULL,\n                `last_error_output` TEXT,\n                `last_output` TEXT,\n                PRIMARY KEY  (`server_id`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'servers_uptime' => \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"servers_uptime` (\n                `servers_uptime_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `server_id` int(11) unsigned NOT NULL,\n                `date` datetime NOT NULL,\n                `status` tinyint(1) unsigned NOT NULL,\n                `latency` float(9,7) DEFAULT NULL,\n                PRIMARY KEY (`servers_uptime_id`),\n                KEY `server_id` (`server_id`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'servers_history' => \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"servers_history` (\n                `servers_history_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `server_id` int(11) unsigned NOT NULL,\n                `date` date NOT NULL,\n                `latency_min` float(9,7) NOT NULL,\n                `latency_avg` float(9,7) NOT NULL,\n                `latency_max` float(9,7) NOT NULL,\n                `checks_total` int(11) unsigned NOT NULL,\n                `checks_failed` int(11) unsigned NOT NULL,\n                PRIMARY KEY (`servers_history_id`),\n                UNIQUE KEY `server_id_date` (`server_id`,`date`)\n            ) ENGINE=MyISAM  DEFAULT CHARSET=utf8;\",\n        );\n\n        foreach ($tables as $name => $sql) {\n            $if_table_exists = $this->db->query(\"SHOW TABLES LIKE '{$name}'\");\n\n            if (!empty($if_table_exists)) {\n                $this->log('Table ' . $name . ' already exists in your database!');\n            } else {\n                $this->execSQL($sql);\n                $this->log('Table ' . $name . ' added.');\n            }\n        }\n    }\n\n    /**\n     * Populate the tables and perform upgrades if necessary\n     * @param string $version_from\n     * @param string $version_to\n     * @see isUpgradeRequired()\n     */\n    public function upgrade($version_from, $version_to)\n    {\n        if (version_compare($version_from, '2.1.0', '<')) {\n            $this->upgrade210();\n        }\n        if (version_compare($version_from, '3.0.0', '<')) {\n            $this->upgrade300();\n        }\n        if (version_compare($version_from, '3.1.0', '<')) {\n            $this->upgrade310();\n        }\n        if (version_compare($version_from, '3.2.0', '<')) {\n            $this->upgrade320();\n        }\n        if (version_compare($version_from, '3.2.1', '<')) {\n            $this->upgrade321();\n        }\n        if (version_compare($version_from, '3.2.2', '<')) {\n            $this->upgrade322();\n        }\n        if (version_compare($version_from, '3.3.0', '<')) {\n            $this->upgrade330();\n        }\n        if (version_compare($version_from, '3.4.0', '<')) {\n            $this->upgrade340();\n        }\n        if (version_compare($version_from, '3.4.2', '<')) {\n            $this->upgrade342();\n        }\n        if (version_compare($version_from, '3.5.0', '<')) {\n            $this->upgrade350();\n        }\n        if (version_compare($version_from, '3.6.0', '<')) {\n            $this->upgrade360();\n        }\n        psm_update_conf('version', $version_to);\n    }\n\n    /**\n     * Upgrade for v2.1.0 release\n     */\n    protected function upgrade210()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"config` DROP `config_id`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"config` ADD PRIMARY KEY ( `key` );\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"config` DROP INDEX `key`;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('cron_running', '0');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('cron_running_time', '0');\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `error` `error` VARCHAR( 255 )\n            CHARACTER SET utf8 COLLATE utf8_general_ci NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `rtime` `rtime` FLOAT( 9, 7 ) NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `last_online` `last_online` DATETIME NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `last_check` `last_check` DATETIME NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `pattern` VARCHAR( 255 ) NOT NULL AFTER  `type`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline` DATETIME NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline_duration` varchar(255) NULL;\";\n\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Upgrade for v3.0.0 release\n     */\n    protected function upgrade300()\n    {\n        $queries = array();\n        // language is now stored as language code (ISO 639-1) + country code (ISO 3166-1)\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='bg_BG' \n            WHERE `key`='language' AND `value`='bg';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='de_DE' \n            WHERE `key`='language' AND `value`='de';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='en_US' \n            WHERE `key`='language' AND `value`='en';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='fr_FR' \n            WHERE `key`='language' AND `value`='fr';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='ko_KR' \n            WHERE `key`='language' AND `value`='kr';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='nl_NL' \n            WHERE `key`='language' AND `value`='nl';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='pt_BR' \n            WHERE `key`='language' AND `value`='br';\";\n\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES\n            ('version_update_check', '\" . PSM_VERSION . \"');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('email_smtp', '');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('email_smtp_host', '');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('email_smtp_port', '');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('email_smtp_username', '');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('email_smtp_password', '');\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"log` CHANGE `log_id` `log_id` INT( 11 )\n            UNSIGNED NOT NULL AUTO_INCREMENT;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"log` CHANGE `server_id` `server_id` INT( 11 )\n            UNSIGNED NOT NULL;\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `server_id` `server_id` INT( 11 )\n            UNSIGNED NOT NULL AUTO_INCREMENT;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD `warning_threshold` MEDIUMINT( 1 )\n            UNSIGNED NOT NULL DEFAULT '1';\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD `warning_threshold_counter` MEDIUMINT( 1 )\n            UNSIGNED NOT NULL DEFAULT '0';\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline` DATETIME NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline_duration` varchar(255) NULL;\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` CHANGE `user_id` `user_id` INT( 11 )\n            UNSIGNED NOT NULL AUTO_INCREMENT;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users`\n            ADD `user_name` varchar(64) COLLATE utf8_general_ci NOT NULL \n                COMMENT 'user\\'s name, unique' AFTER `user_id`,\n            ADD `password` varchar(255) COLLATE utf8_general_ci NOT NULL \n                COMMENT 'user\\'s password in salted and hashed format' AFTER `user_name`,\n            ADD `password_reset_hash` char(40) COLLATE utf8_general_ci DEFAULT NULL \n                COMMENT 'user\\'s password reset code' AFTER `password`,\n            ADD `password_reset_timestamp` bigint(20) DEFAULT NULL \n                COMMENT 'timestamp of the password reset request' AFTER `password_reset_hash`,\n            ADD `rememberme_token` varchar(64) COLLATE utf8_general_ci DEFAULT NULL \n                COMMENT 'user\\'s remember-me cookie token' AFTER `password_reset_timestamp`,\n            ADD `level` TINYINT( 2 ) UNSIGNED NOT NULL DEFAULT '20' AFTER `rememberme_token`;\";\n        // make sure all current users are admins (previously we didnt have non-admins):\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"users` SET `user_name`=`email`, `level`=10;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` ADD UNIQUE `unique_username` ( `user_name` );\";\n\n        $queries[] = \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"servers_uptime` (\n                        `servers_uptime_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                        `server_id` int(11) unsigned NOT NULL,\n                        `date` datetime NOT NULL,\n                        `status` tinyint(1) unsigned NOT NULL,\n                        `latency` float(9,7) DEFAULT NULL,\n                        PRIMARY KEY (`servers_uptime_id`),\n                        KEY `server_id` (`server_id`)\n                      ) ENGINE=MyISAM  DEFAULT CHARSET=utf8;\";\n\n        $queries[] = \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"servers_history` (\n                `servers_history_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `server_id` int(11) unsigned NOT NULL,\n                `date` date NOT NULL,\n                `latency_min` float(9,7) NOT NULL,\n                `latency_avg` float(9,7) NOT NULL,\n                `latency_max` float(9,7) NOT NULL,\n                `checks_total` int(11) unsigned NOT NULL,\n                `checks_failed` int(11) unsigned NOT NULL,\n                          PRIMARY KEY (`servers_history_id`),\n                          UNIQUE KEY `server_id_date` (`server_id`,`date`)\n                        ) ENGINE=MyISAM  DEFAULT CHARSET=utf8;\";\n\n        $queries[] = \"CREATE TABLE `\" . PSM_DB_PREFIX . \"users_servers` (\n                        `user_id` INT( 11 ) UNSIGNED NOT NULL ,\n                        `server_id` INT( 11 ) UNSIGNED NOT NULL ,\n                        PRIMARY KEY ( `user_id` , `server_id` )\n                        ) ENGINE = MYISAM ;\";\n        $this->execSQL($queries);\n\n        // from 3.0 all user-server relations are in a separate table\n        $users = $this->db->select(PSM_DB_PREFIX . 'users', null, array('user_id', 'server_id'));\n        foreach ($users as $user) {\n            $idc = array();\n            if ($user['server_id'] == '') {\n                continue;\n            }\n            if (strpos($user['server_id'], ',') === false) {\n                $idc[] = $user['server_id'];\n            } else {\n                $idc = explode(',', $user['server_id']);\n            }\n            foreach ($idc as $id) {\n                $this->db->save(PSM_DB_PREFIX . 'users_servers', array(\n                    'user_id' => $user['user_id'],\n                    'server_id' => $id,\n                ));\n            }\n        }\n        $this->execSQL(\"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` DROP `server_id`;\");\n    }\n\n    /**\n     * Upgrade for v3.1.0 release\n     */\n    protected function upgrade310()\n    {\n        $queries = array();\n        psm_update_conf('log_retention_period', '365');\n\n        psm_update_conf('pushover_status', 0);\n        psm_update_conf('log_pushover', 1);\n        psm_update_conf('pushover_api_token', '');\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` ADD  `pushover_key` VARCHAR( 255 )\n            NOT NULL AFTER `mobile`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` ADD  `pushover_device` VARCHAR( 255 )\n            NOT NULL AFTER `pushover_key`;\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `pushover` ENUM( 'yes','no' )\n            NOT NULL DEFAULT 'yes' AFTER  `sms`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX .\n            \"log` CHANGE `type` `type` ENUM( 'status', 'email', 'sms', 'pushover' )\n            CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD `timeout` smallint(1) unsigned NULL DEFAULT NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline` DATETIME NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline_duration` varchar(255) NULL;\";\n\n        $queries[] = \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"users_preferences` (\n                        `user_id` int(11) unsigned NOT NULL,\n                        `key` varchar(255) NOT NULL,\n                        `value` varchar(255) NOT NULL,\n                        PRIMARY KEY (`user_id`, `key`)\n                      ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\";\n\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Upgrade for v3.2.0 release\n     */\n    protected function upgrade320()\n    {\n        $queries = array();\n\n        psm_update_conf('password_encrypt_key', sha1(microtime()));\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `ip` `ip` VARCHAR(500) NOT NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD `website_username` varchar(255) NULL,\n            ADD `website_password` varchar(255) NULL AFTER `website_username`;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUE\n                    ('proxy', '0'),\n                    ('proxy_url', ''),\n                    ('proxy_user', ''),\n                    ('proxy_password', '');\";\n\n        $this->execSQL($queries);\n\n        // Create log_users table\n        $this->execSQL(\"CREATE TABLE `\" . PSM_DB_PREFIX . \"log_users` (\n                        `log_id`  int(11) UNSIGNED NOT NULL ,\n                        `user_id`  int(11) UNSIGNED NOT NULL ,\n                        PRIMARY KEY (`log_id`, `user_id`)\n                      ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\");\n\n        // Migrate the data\n        $logs = $this->db->select(PSM_DB_PREFIX . 'log', null, array('log_id', 'user_id'));\n        foreach ($logs as $log) {\n            // Validation\n            if (empty($log['user_id']) || trim($log['user_id']) == '') {\n                continue;\n            }\n\n            // Insert into new table\n            foreach (explode(',', $log['user_id']) as $user_id) {\n                psm_add_log_user($log['log_id'], $user_id);\n            }\n        }\n\n        // Drop old user_id('s) column\n        $this->execSQL(\"ALTER TABLE `\" . PSM_DB_PREFIX . \"log` DROP COLUMN `user_id`;\");\n    }\n\n    /**\n     * Upgrade for v3.2.1 release\n     */\n    protected function upgrade321()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD COLUMN `header_name` VARCHAR(255) AFTER `pattern`,\n            ADD COLUMN `header_value` VARCHAR(255) AFTER `header_name`\";\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Upgrade for v3.2.2 release\n     */\n    protected function upgrade322()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` ADD  `telegram_id` VARCHAR( 255 ) \n            NOT NULL AFTER `pushover_device`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `telegram` ENUM( 'yes','no' ) \n            NOT NULL DEFAULT 'yes' AFTER  `pushover`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX .\n            \"log` CHANGE `type` `type` ENUM( 'status', 'email', 'sms', 'pushover', 'telegram' )\n            CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUE\n                    ('telegram_status', '0'),\n                    ('log_telegram', '1'),\n                    ('telegram_api_token', '');\";\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Upgrade for v3.3.0 release\n     */\n    protected function upgrade330()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD COLUMN `last_offline` DATETIME\n            NULL AFTER `last_online`, ADD COLUMN `last_offline_duration` varchar(255) NULL AFTER `last_offline`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD `pattern_online` ENUM( 'yes','no' )\n            NOT NULL DEFAULT 'yes' AFTER `pattern`;\";\n        $this->execSQL($queries);\n        if (psm_get_conf('sms_gateway') == 'mollie') {\n            psm_update_conf('sms_gateway', 'messagebird');\n        }\n    }\n\n    /**\n     * Upgrade for v3.4.0 release\n     */\n    protected function upgrade340()\n    {\n        $queries = array();\n        /**\n         * Redirect_check is first set to default ok.\n         * If you have a lot of server that are redirecting,\n         * this will make sure you're servers stay online.\n         */\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `allow_http_status` VARCHAR(255) NOT NULL DEFAULT '' AFTER `pattern_online`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD `redirect_check` ENUM( 'ok','bad' ) NOT NULL DEFAULT 'ok' AFTER `allow_http_status`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            CHANGE `redirect_check` `redirect_check` ENUM('ok','bad') NOT NULL DEFAULT 'bad';\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `last_error` VARCHAR(255) NULL AFTER `website_password`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `last_error_output` TEXT AFTER `last_error`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `last_output` TEXT AFTER `last_error_output`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `request_method` varchar(50) NULL AFTER `port`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `post_field` varchar(255) NULL AFTER `pattern_online`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"log`\n            CHANGE `message` `message` TEXT CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`)\n            VALUES ('combine_notifications', '1');\";\n        $this->execSQL($queries);\n        $this->log('Combined notifications enabled. Check out the config page for more info.');\n    }\n\n    /**\n     * Patch for v3.4.2 release\n     * Version_compare was forgotten in v3.4.1 and query failed.\n     * Fixed in v3.4.2, 3.4.1 has been removed.\n     */\n    protected function upgrade342()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `last_output` `last_output` TEXT;\";\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Upgrade for v3.5.0 release\n     */\n    protected function upgrade350()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` \n            ADD `ssl_cert_expiry_days` MEDIUMINT(1) UNSIGNED NOT NULL DEFAULT '0' AFTER `warning_threshold_counter`\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` \n            ADD `ssl_cert_expired_time` VARCHAR(255) NULL AFTER `ssl_cert_expiry_days`\";\n\n        if (\n            @psm_password_decrypt(\n                psm_get_conf('password_encrypt_key'),\n                psm_get_conf('email_smtp_password')\n            ) === false\n        ) {\n            // Prevents encrypting the password multiple times.\n            $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` \n                SET `value` = '\" .\n                psm_password_encrypt(psm_get_conf('password_encrypt_key'), psm_get_conf('email_smtp_password')) .\n                \"' WHERE `key` = 'email_smtp_password'\";\n            $this->log('SMTP password is now encrypted.');\n        }\n\n        $queries[] = 'ALTER TABLE `' . PSM_DB_PREFIX . 'users` ADD  `jabber` VARCHAR( 255 )\n            NOT NULL AFTER `telegram_id`;';\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `jabber` ENUM( 'yes','no' )\n            NOT NULL DEFAULT 'yes' AFTER  `telegram`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX .\n            \"log` CHANGE `type` `type` ENUM( 'status', 'email', 'sms', 'pushover', 'telegram', 'jabber' )\n            CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUE\n                    ('jabber_status', '0'),\n                    ('log_jabber', '1'),\n                    ('jabber_host', ''),\n                    ('jabber_port', ''),\n                    ('jabber_username', ''),\n                    ('jabber_domain', ''),\n                    ('jabber_password', '');\";\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Patch for v3.6.0 release\n     * Added support for Discord and webhooks\n     */\n    protected function upgrade360()\n    {\n        $queries = array();\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` \n            ADD  `webhook_url` VARCHAR( 255 ) NOT NULL AFTER `telegram_id`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` \n            ADD  `webhook_json` VARCHAR( 255 ) NOT NULL AFTER `telegram_id`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"log` \n            CHANGE `type` `type` ENUM('status','email','sms','discord','webhook','pushover','telegram','jabber') \n            CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` \n            ADD `webhook` ENUM( 'yes','no' ) NOT NULL DEFAULT 'yes' AFTER `telegram`;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUE\n                    ('discord_status', '0'),\n                    ('log_discord', '1'),\n                    ('webhook_status', '0'),\n                    ('log_webhook', '1')\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` \n            ADD `discord` VARCHAR( 255 ) NOT NULL AFTER `mobile`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` \n            ADD `discord` ENUM( 'yes','no' ) NOT NULL DEFAULT 'yes' AFTER  `sms`;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"users` (\n            `user_name`, `level`, `name`, `email`)\n            VALUES ('__PUBLIC__', 30, 'Public page', 'publicpage@psm.psm')\";\n        $this->execSQL($queries);\n\n        $this->log('Public page is now available. Added user \\'__PUBLIC__\\'. See documentation for more info.');\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * PHP Server Monitor\n * Monitor your servers and websites.\n *\n * This file is part of PHP Server Monitor.\n * PHP Server Monitor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PHP Server Monitor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with PHP Server Monitor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @package     phpservermon\n * @author      Pepijn Over <pep@mailbox.org>\n * @copyright   Copyright (c) 2008-2017 Pepijn Over <pep@mailbox.org>\n * @license     http://www.gnu.org/licenses/gpl.txt GNU GPL v3\n * @version     Release: @package_version@\n * @link        http://www.phpservermonitor.org/\n * @since       phpservermon 3.0.0\n **/\n\n/**\n * Current PSM version\n */\ndefine('PSM_VERSION', '3.6.0');\n\n/**\n * URL to check for updates. Will not be checked if turned off on config page.\n * @see psm_update_available()\n */\ndefine('PSM_UPDATE_URL', 'https://api.github.com/repos/phpservermon/phpservermon/releases/latest');\n\n/**\n * Default update interval (1 day). Only applicable when updates are enabled.\n * @see psm_update_available()\n */\ndefine('PSM_UPDATE_INTERVAL', 1 * 24 * 60 * 60);\n\n/**\n * Configuration for: Hashing strength\n * This is the place where you define the strength of your password hashing/salting\n *\n * To make password encryption very safe and future-proof, the PHP 5.5 hashing/salting functions\n * come with a clever so called COST FACTOR. This number defines the base-2 logarithm of the rounds of hashing,\n * something like 2^12 if your cost factor is 12. By the way, 2^12 would be 4096 rounds of hashing, doubling the\n * round with each increase of the cost factor and therefore doubling the CPU power it needs.\n * Currently, in 2013, the developers of this functions have chosen a cost factor of 10, which fits most standard\n * server setups. When time goes by and server power becomes much more powerful, it might be useful to increase\n * the cost factor, to make the password hashing one step more secure. Have a look here\n * (@see https://github.com/panique/php-login/wiki/Which-hashing-&-salting-algorithm-should-be-used-%3F)\n * in the BLOWFISH benchmark table to get an idea how this factor behaves. For most people this is irrelevant,\n * but after some years this might be very very useful to keep the encryption of your database up to date.\n *\n * Remember: Every time a user registers or tries to log in (!) this calculation will be done.\n * Don't change this if you don't know what you do.\n *\n * To get more information about the best cost factor please have a look here\n * @see http://stackoverflow.com/q/4443476/1114320\n *\n * This constant will be used in the login and the registration class.\n */\ndefine('PSM_LOGIN_HASH_COST_FACTOR', '10');\n\n/**\n * Configuration for: Cookies\n * Please note: The COOKIE_DOMAIN needs the domain where your app is,\n * in a format like this: .mydomain.com\n * Note the . in front of the domain. No www, no http, no slash here!\n * For local development .127.0.0.1 or .localhost is fine, but when deploying you should\n * change this to your real domain, like '.mydomain.com' ! The leading dot makes the cookie available for\n * sub-domains too.\n * @see http://stackoverflow.com/q/9618217/1114320\n * @see http://www.php.net/manual/en/function.setcookie.php\n *\n * COOKIE_RUNTIME: How long should a cookie be valid ? 1209600 seconds = 2 weeks\n * COOKIE_DOMAIN: The domain where the cookie is valid for, like '.mydomain.com'\n * COOKIE_SECRET_KEY: Put a random value here to make your app more secure. When changed, all cookies are reset.\n */\ndefine('PSM_LOGIN_COOKIE_RUNTIME', 1209600);\ndefine('PSM_LOGIN_COOKIE_DOMAIN', null);\ndefine('PSM_LOGIN_COOKIE_SECRET_KEY', '4w900de52e3ap7y77y8675jy6c594286');\n\n/**\n * Number of seconds the reset link is valid after sending it to the user.\n */\ndefine('PSM_LOGIN_RESET_RUNTIME', 3600);\n\n/**\n * Number of seconds the cron is supposedly dead and we will run another cron anyway. Set to 0 to disable.\n */\ndefine('PSM_CRON_TIMEOUT', 600);\n\n/**\n * Default timeout in seconds for curl requests (can be overwritten per-server).\n */\ndefine('PSM_CURL_TIMEOUT', 10);\n\n/**\n * Clone URL for the Pushover.net service.\n */\ndefine('PSM_PUSHOVER_CLONE_URL', 'https://pushover.net/apps/clone/php_server_monitor');\n\n/**\n * Get chat id for Telegram service.\n */\ndefine('PSM_TELEGRAM_GET_ID_URL', 'https://telegram.me/cid_bot');\n\n/**\n * By defining the PSM_BASE_URL, you will force the psm_build_url() to use this.\n * Useful for cronjobs if it cannot be auto-detected.\n */\n//define('PSM_BASE_URL', null);\n\nif (!defined('PSM_MODULE_DEFAULT')) {\n    /**\n     * Default theme\n     */\n    define('PSM_THEME', 'default');\n\n    /**\n     * Default module (if none given or invalid one)\n     */\n    define('PSM_MODULE_DEFAULT', 'server_status');\n}\n\nif (defined('PSM_JABBER_FORCE_TLS') === false) {\n    define('PSM_JABBER_FORCE_TLS', true);\n}\nif (defined('PSM_JABBER_AUTH_TYPE') === false) {\n    // possible values: PLAIN, X-OAUTH2, DIGEST-MD5, CRAM-MD5, SCRAM-SHA-1, ANONYMOUS, EXTERNAL\n    define('PSM_JABBER_AUTH_TYPE', 'PLAIN'); // default just plain because of google for example :(\n}\nif (defined('PSM_JABBER_DEBUG_LEVEL') === false) {\n    // possible values: ERROR, WARNING, NOTICE, INFO, DEBUG\n    define('PSM_JABBER_DEBUG_LEVEL', JAXLLogger::WARNING);\n}\n", "<?php\n\n/**\n * PHP Server Monitor\n * Monitor your servers and websites.\n *\n * This file is part of PHP Server Monitor.\n * PHP Server Monitor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PHP Server Monitor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with PHP Server Monitor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @package     phpservermon\n * @author      Panique <https://github.com/panique/php-login-advanced/>\n * @author      Pepijn Over <pep@mailbox.org>\n * @copyright   Copyright (c) 2008-2017 Pepijn Over <pep@mailbox.org>\n * @license     http://www.gnu.org/licenses/gpl.txt GNU GPL v3\n * @version     Release: @package_version@\n * @link        http://www.phpservermonitor.org/\n * @since       phpservermon 3.0.0\n **/\n\nnamespace psm\\Service;\n\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n/**\n * This is a heavily modified version of the php-login-advanced project by Panique.\n *\n * It uses the Session classes from the Symfony HttpFoundation component.\n *\n * @author Panique\n * @author Pepijn Over\n * @link http://www.php-login.net\n * @link https://github.com/panique/php-login-advanced/\n * @license http://opensource.org/licenses/MIT MIT License\n */\nclass User\n{\n\n    /**\n     * The database connection\n     * @var \\PDO $db_connection\n     */\n    protected $db_connection = null;\n\n    /**\n     * Local cache of user data\n     * @var array $user_data\n     */\n    protected $user_data = array();\n\n    /**\n     * Session object\n     * @var \\Symfony\\Component\\HttpFoundation\\Session\\Session $session\n     */\n    protected $session;\n\n    /**\n     * Current user id\n     * @var int $user_id\n     */\n    protected $user_id;\n\n    /**\n     * Current user preferences\n     * @var array $user_preferences\n     */\n    protected $user_preferences;\n\n    /**\n     * The user's login status\n     * @var boolean $user_is_logged_in\n     */\n    protected $user_is_logged_in = false;\n\n    /**\n     * Open a new user service\n     *\n     * @param \\psm\\Service\\Database $db\n     * @param \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface $session if NULL, one will be created\n     */\n    public function __construct(Database $db, SessionInterface $session = null)\n    {\n        $this->db_connection = $db->pdo();\n\n        if (!psm_is_cli()) {\n            if ($session == null) {\n                $session = new Session();\n                $session->start();\n            }\n            $this->session = $session;\n\n            if (PSM_PUBLIC === true && PSM_PUBLIC_PAGE === true) {\n                $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n                    PSM_DB_PREFIX . 'users WHERE user_name = :user_name and level = :level');\n                $query_user->bindValue(':user_name', \"__PUBLIC__\", \\PDO::PARAM_STR);\n                $query_user->bindValue(':level', PSM_USER_ANONYMOUS, \\PDO::PARAM_STR);\n                $query_user->execute();\n\n                // get result row (as an object)\n                $this->setUserLoggedIn($query_user->fetchObject()->user_id);\n            }\n\n            if ((!defined('PSM_INSTALL') || !PSM_INSTALL)) {\n                // check the possible login actions:\n                // 1. login via session data (happens each time user opens a page on your php project AFTER\n                // he has successfully logged in via the login form)\n                // 2. login via cookie\n\n                // if user has an active session on the server\n                if (!$this->loginWithSessionData()) {\n                    $this->loginWithCookieData();\n                }\n            }\n        }\n    }\n\n    /**\n     * Get user by id, or get current user.\n     * @param int $user_id if null it will attempt current user id\n     * @param boolean $flush if TRUE it will query db regardless of whether we already have the data\n     * @return object|boolean FALSE if user not found, object otherwise\n     */\n    public function getUser($user_id = null, $flush = false)\n    {\n        if ($user_id == null) {\n            if (!$this->isUserLoggedIn()) {\n                return false;\n            } else {\n                $user_id = $this->getUserId();\n            }\n        }\n\n        if (!isset($this->user_data[$user_id]) || $flush) {\n            $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n                PSM_DB_PREFIX . 'users WHERE user_id = :user_id');\n            $query_user->bindValue(':user_id', $user_id, \\PDO::PARAM_INT);\n            $query_user->execute();\n            // get result row (as an object)\n            $this->user_data[$user_id] = $query_user->fetchObject();\n        }\n        return $this->user_data[$user_id];\n    }\n\n    /**\n     * Search into database for the user data of user_name specified as parameter\n     * @return object|boolean user data as an object if existing user\n     */\n    public function getUserByUsername($user_name)\n    {\n        // database query, getting all the info of the selected user\n        $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n            PSM_DB_PREFIX . 'users WHERE user_name = :user_name');\n        $query_user->bindValue(':user_name', $user_name, \\PDO::PARAM_STR);\n        $query_user->execute();\n        // get result row (as an object)\n        return $query_user->fetchObject();\n    }\n\n    /**\n     * Logs in with SESSION data.\n     *\n     * @return boolean\n     */\n    protected function loginWithSessionData()\n    {\n        if (!$this->session->has('user_id')) {\n            return false;\n        }\n        $user = $this->getUser($this->session->get('user_id'));\n\n        if (!empty($user)) {\n            $this->setUserLoggedIn($user->user_id);\n            return true;\n        } else {\n            // user no longer exists in database\n            // call logout to clean up session vars\n            $this->doLogout();\n            return false;\n        }\n    }\n\n    /**\n     * Logs in via the Cookie\n     * @return bool success state of cookie login\n     */\n    private function loginWithCookieData()\n    {\n        if (isset($_COOKIE['rememberme'])) {\n            // extract data from the cookie\n            list($user_id, $token, $hash) = explode('_', $_COOKIE['rememberme']);\n            // check cookie hash validity\n            if ($hash == hash('sha256', $user_id . '_' . $token . PSM_LOGIN_COOKIE_SECRET_KEY) && !empty($token)) {\n                // cookie looks good, try to select corresponding user\n                // get real token from database (and all other data)\n                $user = $this->getUser($user_id);\n\n                if (!empty($user) && $token === $user->rememberme_token) {\n                    $this->setUserLoggedIn($user->user_id, true);\n\n                    // Cookie token usable only once\n                    $this->newRememberMeCookie();\n                    return true;\n                }\n            }\n            // call logout to remove invalid cookie\n            $this->doLogout();\n        }\n        return false;\n    }\n\n    /**\n     * Logs in with the data provided in $_POST, coming from the login form\n     * @param string $user_name\n     * @param string $user_password\n     * @param boolean $user_rememberme\n     * @return boolean\n     */\n    public function loginWithPostData($user_name, $user_password, $user_rememberme = false)\n    {\n        $user_name = trim($user_name);\n        $user_password = trim($user_password);\n        $ldapauthstatus = false;\n\n        if (empty($user_name) && empty($user_password)) {\n            return false;\n        }\n\n        $dirauthconfig = psm_get_conf('dirauth_status');\n\n        // LDAP auth enabled\n        if ($dirauthconfig === '1') {\n            $ldaplibpath = realpath(\n                PSM_PATH_SRC . '..' . DIRECTORY_SEPARATOR .\n                    'vendor' . DIRECTORY_SEPARATOR .\n                    'viharm' . DIRECTORY_SEPARATOR .\n                    'psm-ldap-auth' . DIRECTORY_SEPARATOR .\n                    'psmldapauth.php'\n            );\n            // If the library is found\n            if ($ldaplibpath) {\n                // Delegate the authentication to the PsmLDAPauth module.\n                // If LDAP auth fails or if library not found, fall back to native auth\n                include_once($ldaplibpath);\n                $ldapauthstatus = psmldapauth($user_name, $user_password, $GLOBALS['sm_config'], $this->db_connection);\n            }\n        }\n\n        $user = $this->getUserByUsername($user_name);\n\n        // Authenticated\n        if ($ldapauthstatus === true) {\n            // Remove password to prevent it from being saved in the DB.\n            // Otherwise, user may still be authenticated if LDAP is disabled later.\n            $user_password = null;\n            @fn_Debug('Authenticated', $user);\n        } else {\n\n            // using PHP 5.5's password_verify() function to check if the provided passwords\n            // fits to the hash of that user's password\n            if (!isset($user->user_id)) {\n                password_verify($user_password, 'dummy_call_against_timing');\n                return false;\n            } elseif (!password_verify($user_password, $user->password)) {\n                return false;\n            }\n        } // not authenticated\n\n        $this->setUserLoggedIn($user->user_id, true);\n\n        // if user has check the \"remember me\" checkbox, then generate token and write cookie\n        if ($user_rememberme) {\n            $this->newRememberMeCookie();\n        }\n\n        // recalculate the user's password hash\n        // DELETE this if-block if you like, it only exists to recalculate\n        // users's hashes when you provide a cost factor,\n        // by default the script will use a cost factor of 10 and never change it.\n        // check if the have defined a cost factor in config/hashing.php\n        if (defined('PSM_LOGIN_HASH_COST_FACTOR')) {\n            // check if the hash needs to be rehashed\n            if (password_needs_rehash($user->password, PASSWORD_DEFAULT, array('cost' => PSM_LOGIN_HASH_COST_FACTOR))) {\n                $this->changePassword($user->user_id, $user_password);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Set the user logged in\n     * @param int $user_id\n     * @param boolean $regenerate regenerate session id against session fixation?\n     */\n    protected function setUserLoggedIn($user_id, $regenerate = false)\n    {\n        if ($regenerate) {\n            $this->session->invalidate();\n        }\n        $this->session->set('user_id', $user_id);\n        $this->session->set('user_logged_in', 1);\n\n        // declare user id, set the login status to true\n        $this->user_id = $user_id;\n        $this->user_is_logged_in = true;\n    }\n\n    /**\n     * Create all data needed for remember me cookie connection on client and server side\n     */\n    protected function newRememberMeCookie()\n    {\n        // generate 64 char random string and store it in current user data\n        $random_token_string = hash('sha256', random_bytes(64));\n        $sth = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET rememberme_token = :user_rememberme_token WHERE user_id = :user_id');\n        $sth->execute(array(':user_rememberme_token' => $random_token_string, ':user_id' => $this->getUserId()));\n\n        // generate cookie string that consists of userid, randomstring and combined hash of both\n        $cookie_string_first_part = $this->getUserId() . '_' . $random_token_string;\n        $cookie_string_hash = hash('sha256', $cookie_string_first_part . PSM_LOGIN_COOKIE_SECRET_KEY);\n        $cookie_string = $cookie_string_first_part . '_' . $cookie_string_hash;\n\n        // set cookie\n        setcookie('rememberme', $cookie_string, time() + PSM_LOGIN_COOKIE_RUNTIME, \"/\", PSM_LOGIN_COOKIE_DOMAIN);\n    }\n\n    /**\n     * Delete all data needed for remember me cookie connection on client and server side\n     */\n    protected function deleteRememberMeCookie()\n    {\n        // Reset rememberme token\n        if ($this->session->has('user_id')) {\n            $sth = $this->db_connection->prepare('UPDATE ' .\n                PSM_DB_PREFIX . 'users SET rememberme_token = NULL WHERE user_id = :user_id');\n            $sth->execute(array(':user_id' => $this->session->get('user_id')));\n        }\n\n        // set the rememberme-cookie to ten years ago (3600sec * 365 days * 10).\n        // that's obivously the best practice to kill a cookie via php\n        // @see http://stackoverflow.com/a/686166/1114320\n        setcookie('rememberme', false, time() - (3600 * 3650), '/', PSM_LOGIN_COOKIE_DOMAIN);\n    }\n\n    /**\n     * Perform the logout, resetting the session\n     */\n    public function doLogout()\n    {\n        $this->deleteRememberMeCookie();\n\n        $this->session->clear();\n        $this->session->invalidate();\n\n        $this->user_is_logged_in = false;\n    }\n\n    /**\n     * Simply return the current state of the user's login\n     * @return bool user's login status\n     */\n    public function isUserLoggedIn()\n    {\n        return $this->user_is_logged_in;\n    }\n\n    /**\n     * Sets a random token into the database (that will verify the user when he/she comes back via the link\n     * in the email) and returns it\n     * @param int $user_id\n     * @return string|boolean FALSE on error, string otherwise\n     */\n    public function generatePasswordResetToken($user_id)\n    {\n        $user_id = intval($user_id);\n\n        if ($user_id == 0) {\n            return false;\n        }\n        // generate timestamp (to see when exactly the user (or an attacker) requested the password reset mail)\n        $temporary_timestamp = time();\n        // generate random hash for email password reset verification (64 char string)\n        $user_password_reset_hash = hash('sha256', uniqid(random_bytes(64), true));\n\n        $query_update = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET password_reset_hash = :user_password_reset_hash,\n            password_reset_timestamp = :user_password_reset_timestamp\n            WHERE user_id = :user_id');\n        $query_update->bindValue(':user_password_reset_hash', $user_password_reset_hash, \\PDO::PARAM_STR);\n        $query_update->bindValue(':user_password_reset_timestamp', $temporary_timestamp, \\PDO::PARAM_INT);\n        $query_update->bindValue(':user_id', $user_id, \\PDO::PARAM_INT);\n        $query_update->execute();\n\n        // check if exactly one row was successfully changed:\n        if ($query_update->rowCount() == 1) {\n            return $user_password_reset_hash;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Checks if the verification string in the account verification mail is valid and matches to the user.\n     *\n     * Please note it is valid for 1 hour.\n     * @param int $user_id\n     * @param string $token\n     * @return boolean\n     */\n    public function verifyPasswordResetToken($user_id, $token)\n    {\n        $user_id = intval($user_id);\n\n        if (empty($user_id) || empty($token)) {\n            return false;\n        }\n        $user = $this->getUser($user_id);\n\n        if (isset($user->user_id) && $user->password_reset_hash == $token) {\n            $runtime = (defined('PSM_LOGIN_RESET_RUNTIME')) ? PSM_LOGIN_RESET_RUNTIME : 3600;\n            $timestamp_max_interval = time() - $runtime;\n\n            if ($user->password_reset_timestamp > $timestamp_max_interval) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Change the password of a user\n     * @param int|\\PDOStatement $user_id\n     * @param string $password\n     * @return boolean TRUE on success, FALSE on failure\n     */\n    public function changePassword($user_id, $password)\n    {\n        $user_id = intval($user_id);\n\n        if (empty($user_id) || empty($password)) {\n            return false;\n        }\n        // now it gets a little bit crazy: check if we have a constant\n        // PSM_LOGIN_HASH_COST_FACTOR defined (in src/includes/psmconfig.inc.php),\n        // if so: put the value into $hash_cost_factor, if not, make $hash_cost_factor = null\n        $hash_cost_factor = (defined('PSM_LOGIN_HASH_COST_FACTOR') ? PSM_LOGIN_HASH_COST_FACTOR : null);\n\n        // crypt the user's password with the PHP 5.5's password_hash() function, results in a 60 character hash string\n        // the PASSWORD_DEFAULT constant is defined by the PHP 5.5,\n        // or if you are using PHP 5.3/5.4, by the password hashing\n        // compatibility library. the third parameter looks a little bit shitty, but that's how those PHP 5.5 functions\n        // want the parameter: as an array with, currently only used with 'cost' => XX.\n        $user_password_hash = password_hash($password, PASSWORD_DEFAULT, array('cost' => $hash_cost_factor));\n\n        // write users new hash into database\n        $query_update = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET password = :user_password_hash,\n\t\t\t\tpassword_reset_hash = NULL, password_reset_timestamp = NULL\n\t\t\t\tWHERE user_id = :user_id');\n        $query_update->bindValue(':user_password_hash', $user_password_hash, \\PDO::PARAM_STR);\n        $query_update->bindValue(':user_id', $user_id, \\PDO::PARAM_STR);\n        $query_update->execute();\n\n        // check if exactly one row was successfully changed:\n        if ($query_update->rowCount() == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Gets the user id\n     * @return int\n     */\n    public function getUserId()\n    {\n        return $this->user_id;\n    }\n\n    /**\n     * Gets the username\n     * @return string\n     */\n    public function getUsername()\n    {\n        $user = $this->getUser();\n        return (isset($user->user_name) ? $user->user_name : null);\n    }\n\n    /**\n     * Gets the user level\n     * @return int\n     */\n    public function getUserLevel()\n    {\n        $user = $this->getUser();\n\n        if (isset($user->level)) {\n            return $user->level;\n        } else {\n            return PSM_USER_ANONYMOUS;\n        }\n    }\n\n    /**\n     * read current user preferences from the database\n     * @return boolean return false is user not connected\n     */\n    protected function loadPreferences()\n    {\n        if ($this->user_preferences === null) {\n            if (!$this->getUser()) {\n                return false;\n            }\n\n            $this->user_preferences = array();\n            foreach ($this->db_connection->query('SELECT `key`,`value` FROM `' .\n                PSM_DB_PREFIX . 'users_preferences` WHERE `user_id` = ' . $this->user_id) as $row) {\n                $this->user_preferences[$row['key']] = $row['value'];\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get a user preference value\n     * @param string $key\n     * @param mixed $default\n     * @return mixed\n     */\n    public function getUserPref($key, $default = '')\n    {\n        if (!$this->loadPreferences() || !isset($this->user_preferences[$key])) {\n            return $default;\n        }\n\n        $value = $this->user_preferences[$key];\n        settype($value, gettype($default));\n        return $value;\n    }\n\n    /**\n     * Set a user preference value\n     * @param string $key\n     * @param mixed $value\n     */\n    public function setUserPref($key, $value)\n    {\n        if ($this->loadPreferences()) {\n            if (isset($this->user_preferences[$key])) {\n                if ($this->user_preferences[$key] == $value) {\n                    return; // no change\n                }\n                $sql = 'UPDATE `' . PSM_DB_PREFIX . 'users_preferences` SET `key` = ?, `value` = ? WHERE `user_id` = ?';\n            } else {\n                $sql = 'INSERT INTO `' . PSM_DB_PREFIX . 'users_preferences` SET `key` = ?, `value` = ?, `user_id` = ?';\n            }\n            $sth = $this->db_connection->prepare($sql);\n            $sth->execute(array($key, $value, $this->user_id));\n            $this->user_preferences[$key] = $value;\n        }\n    }\n\n    /**\n     * Get session object\n     * @return \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n}\n", "<?php\n\n/**\n * PHP Server Monitor\n * Monitor your servers and websites.\n *\n * This file is part of PHP Server Monitor.\n * PHP Server Monitor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PHP Server Monitor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with PHP Server Monitor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @package     phpservermon\n * @author      Pepijn Over <pep@mailbox.org>\n * @copyright   Copyright (c) 2008-2017 Pepijn Over <pep@mailbox.org>\n * @license     http://www.gnu.org/licenses/gpl.txt GNU GPL v3\n * @version     Release: @package_version@\n * @link        http://www.phpservermonitor.org/\n * @since       phpservermon 2.1.0\n **/\n\nnamespace psm\\Util\\Install;\n\n/**\n * Installer class.\n *\n * Executes the queries to install/upgrade phpservermon.\n */\nclass Installer\n{\n\n    /**\n     * Database service\n     * @var \\psm\\Service\\Database $db\n     */\n    protected $db;\n\n    /**\n     * Log callback\n     * @var callable $logger\n     */\n    protected $logger;\n\n    /**\n     * Log of executed queries\n     * @var array $queries\n     */\n    protected $queries = array();\n\n    /**\n     * Open a new installer instance\n     * @param \\psm\\Service\\Database $db\n     * @param callable $logger\n     */\n    public function __construct(\\psm\\Service\\Database $db, $logger = null)\n    {\n        $this->db = $db;\n        $this->logger = $logger;\n    }\n\n    /**\n     * Check if an upgrade is required for the current version.\n     * @return boolean\n     * @see upgrade()\n     */\n    public function isUpgradeRequired()\n    {\n        $version_db = psm_get_conf('version');\n\n        if (version_compare(PSM_VERSION, $version_db, '==')) {\n            // version is up to date\n            return false;\n        }\n\n        // different DB version, check if the version requires any changes\n        if (version_compare($version_db, PSM_VERSION, '<')) {\n            return true;\n        } else {\n            // change database version to current version so this check won't be required next time\n            psm_update_conf('version', PSM_VERSION);\n        }\n        return false;\n    }\n\n    /**\n     * Log a message to the logger callable (if any)\n     * @param string|array $msg\n     * @return \\psm\\Util\\Install\\Installer\n     */\n    protected function log($msg)\n    {\n        if (is_callable($this->logger)) {\n            $msg = (!is_array($msg)) ? array($msg) : $msg;\n\n            foreach ($msg as $m) {\n                call_user_func($this->logger, $m);\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * Execute one or more queries. Does no fetching or anything, so execute only.\n     * @param string|array $query\n     * @return \\psm\\Util\\Install\\Installer\n     */\n    protected function execSQL($query)\n    {\n        $query = (!is_array($query)) ? array($query) : $query;\n\n        foreach ($query as $q) {\n            $this->queries[] = $q;\n            $this->db->exec($q);\n        }\n        return $this;\n    }\n\n    /**\n     * Retrieve table queries for install\n     */\n    public function install()\n    {\n        $this->installTables();\n\n        $this->log('Populating database...');\n        $queries = array();\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"servers` (\n            `ip`, `port`, `label`, `type`, `pattern`, `pattern_online`, `redirect_check`,\n            `status`, `rtime`, `active`, `email`, `sms`, `pushover`,`webhook`, `telegram`, `jabber`)\n            VALUES ('http://sourceforge.net/index.php', 80, 'SourceForge', 'website', '',\n                'yes', 'bad', 'on', '0.0000000', 'yes', 'yes', 'yes', 'yes','yes', 'yes', 'yes'),\n                ('smtp.gmail.com', 465, 'Gmail SMTP', 'service', '',\n                'yes', 'bad','on', '0.0000000', 'yes', 'yes', 'yes', 'yes', 'yes', 'yes', 'yes')\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"users_servers` (`user_id`,`server_id`) VALUES (1, 1), (1, 2);\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUE\n                    ('language', 'en_US'),\n                    ('proxy', '0'),\n                    ('proxy_url', ''),\n                    ('proxy_user', ''),\n                    ('proxy_password', ''),\n                    ('email_status', '1'),\n                    ('email_add_url', '0'),\n                    ('email_from_email', 'monitor@example.org'),\n                    ('email_from_name', 'Server Monitor'),\n                    ('email_smtp', ''),\n                    ('email_smtp_host', ''),\n                    ('email_smtp_port', ''),\n                    ('email_smtp_security', ''),\n                    ('email_smtp_username', ''),\n                    ('email_smtp_password', ''),\n                    ('sms_status', '0'),\n                    ('sms_gateway', 'messagebird'),\n                    ('sms_gateway_username', 'username'),\n                    ('sms_gateway_password', 'password'),\n                    ('sms_from', '1234567890'),\n                    ('webhook_status', '0'),\n                    ('pushover_status', '0'),\n                    ('pushover_api_token', ''),\n                    ('telegram_status', '0'),\n                    ('telegram_add_url', '0'),\n                    ('telegram_api_token', ''),\n                    ('jabber_status', '1'),\n                    ('jabber_host', ''),\n                    ('jabber_port', ''),\n                    ('jabber_username', ''),\n                    ('jabber_domain', ''),\n                    ('jabber_password', ''),\n                    ('password_encrypt_key', '\" . sha1(microtime()) . \"'),\n                    ('alert_type', 'status'),\n                    ('log_status', '1'),\n                    ('log_email', '1'),\n                    ('log_sms', '1'),\n                    ('log_pushover', '1'),\n                    ('log_webhook', '1'),\n                    ('log_telegram', '1'),\n                    ('log_jabber', '1'),\n                    ('discord_status', '0'),\n                    ('log_jdiscord', '1'),\n                    ('log_retention_period', '365'),\n                    ('version', '\" . PSM_VERSION . \"'),\n                    ('version_update_check', '\" . PSM_VERSION . \"'),\n                    ('auto_refresh_servers', '0'),\n                    ('show_update', '1'),\n                    ('last_update_check', '0'),\n                    ('cron_running', '0'),\n                    ('cron_running_time', '0'),\n                    ('cron_off_running', '0'),\n                    ('cron_off_running_time', '0');\";\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Install the tables for the monitor\n     */\n    protected function installTables()\n    {\n        $tables = array(\n            PSM_DB_PREFIX . 'config' => \"CREATE TABLE `\" . PSM_DB_PREFIX . \"config` (\n                `key` varchar(255) NOT NULL,\n                `value` varchar(255) NOT NULL,\n                PRIMARY KEY (`key`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'users' => \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"users` (\n                `user_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `user_name` varchar(64) NOT NULL COMMENT 'user''s name, unique',\n                `password` varchar(255) NOT NULL COMMENT 'user''s password in salted and hashed format',\n                `password_reset_hash` varchar(64) DEFAULT NULL COMMENT 'user''s password reset code',\n                `password_reset_timestamp` bigint(20) DEFAULT NULL COMMENT 'timestamp of the password reset request',\n                `rememberme_token` varchar(64) DEFAULT NULL COMMENT 'user''s remember-me cookie token',\n                `level` tinyint(2) unsigned NOT NULL DEFAULT '20',\n                `name` varchar(255) NOT NULL,\n                `mobile` varchar(15) NOT NULL,\n                `discord` varchar(255) NOT NULL,\n                `pushover_key` varchar(255) NOT NULL,\n                `pushover_device` varchar(255) NOT NULL,\n                `webhook_url` varchar(255) NOT NULL,\n                `webhook_json` varchar(255) NOT NULL DEFAULT '{\\\"text\\\":\\\"servermon: #message\\\"}',\n                `telegram_id` varchar(255) NOT NULL ,\n                `jabber` varchar(255) NOT NULL,\n                `email` varchar(255) NOT NULL,\n                PRIMARY KEY (`user_id`),\n                UNIQUE KEY `unique_username` (`user_name`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX .\n                'users_preferences' => \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"users_preferences` (\n                `user_id` int(11) unsigned NOT NULL,\n                `key` varchar(255) NOT NULL,\n                `value` varchar(255) NOT NULL,\n                PRIMARY KEY (`user_id`, `key`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'users_servers' => \"CREATE TABLE `\" . PSM_DB_PREFIX . \"users_servers` (\n                `user_id` INT( 11 ) UNSIGNED NOT NULL ,\n                `server_id` INT( 11 ) UNSIGNED NOT NULL ,\n                PRIMARY KEY ( `user_id` , `server_id` )\n            ) ENGINE = MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'log' => \"CREATE TABLE `\" . PSM_DB_PREFIX . \"log` (\n                `log_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `server_id` int(11) unsigned NOT NULL,\n                `type` enum('status','email','sms','discord','pushover','webhook','telegram', 'jabber') NOT NULL,\n                `message` TEXT NOT NULL,\n                `datetime` timestamp NOT NULL default CURRENT_TIMESTAMP,\n                PRIMARY KEY  (`log_id`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'log_users' => \"CREATE TABLE `\" . PSM_DB_PREFIX . \"log_users` (\n                `log_id`  int(11) UNSIGNED NOT NULL ,\n                `user_id`  int(11) UNSIGNED NOT NULL ,\n                PRIMARY KEY (`log_id`, `user_id`)\n            ) ENGINE=MyISAM  DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'servers' => \"CREATE TABLE `\" . PSM_DB_PREFIX . \"servers` (\n                `server_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `ip` varchar(500) NOT NULL,\n                `port` int(5) NOT NULL,\n                `request_method` varchar(50) NULL,\n                `label` varchar(255) NOT NULL,\n                `type` enum('ping','service','website') NOT NULL default 'service',\n                `pattern` varchar(255) NOT NULL default '',\n                `pattern_online` enum('yes','no') NOT NULL default 'yes',\n                `post_field` varchar(255) NULL,\n                `redirect_check` enum('ok','bad') NOT NULL default 'bad',\n                `allow_http_status` varchar(255) NOT NULL default '',\n                `header_name` varchar(255) NOT NULL default '',\n                `header_value` varchar(255) NOT NULL default '',\n                `status` enum('on','off') NOT NULL default 'on',\n                `error` varchar(255) NULL,\n                `rtime` FLOAT(9, 7) NULL,\n                `last_online` datetime NULL,\n                `last_offline` datetime NULL,\n                `last_offline_duration` varchar(255) NULL,\n                `last_check` datetime NULL,\n                `active` enum('yes','no') NOT NULL default 'yes',\n                `email` enum('yes','no') NOT NULL default 'yes',\n                `sms` enum('yes','no') NOT NULL default 'no',\n                `discord` enum('yes','no') NOT NULL default 'yes',\n                `pushover` enum('yes','no') NOT NULL default 'yes',\n                `webhook` enum('yes','no') NOT NULL default 'yes',\n                `telegram` enum('yes','no') NOT NULL default 'yes',\n                `jabber` enum('yes','no') NOT NULL default 'yes',\n                `warning_threshold` mediumint(1) unsigned NOT NULL DEFAULT '1',\n                `warning_threshold_counter` mediumint(1) unsigned NOT NULL DEFAULT '0',\n                `ssl_cert_expiry_days` mediumint(1) unsigned NOT NULL DEFAULT '0',\n                `ssl_cert_expired_time` varchar(255) NULL,\n                `timeout` smallint(1) unsigned NULL DEFAULT NULL,\n                `website_username` varchar(255) DEFAULT NULL,\n                `website_password` varchar(255) DEFAULT NULL,\n                `last_error` varchar(255) DEFAULT NULL,\n                `last_error_output` TEXT,\n                `last_output` TEXT,\n                PRIMARY KEY  (`server_id`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'servers_uptime' => \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"servers_uptime` (\n                `servers_uptime_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `server_id` int(11) unsigned NOT NULL,\n                `date` datetime NOT NULL,\n                `status` tinyint(1) unsigned NOT NULL,\n                `latency` float(9,7) DEFAULT NULL,\n                PRIMARY KEY (`servers_uptime_id`),\n                KEY `server_id` (`server_id`)\n            ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\n            PSM_DB_PREFIX . 'servers_history' => \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"servers_history` (\n                `servers_history_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `server_id` int(11) unsigned NOT NULL,\n                `date` date NOT NULL,\n                `latency_min` float(9,7) NOT NULL,\n                `latency_avg` float(9,7) NOT NULL,\n                `latency_max` float(9,7) NOT NULL,\n                `checks_total` int(11) unsigned NOT NULL,\n                `checks_failed` int(11) unsigned NOT NULL,\n                PRIMARY KEY (`servers_history_id`),\n                UNIQUE KEY `server_id_date` (`server_id`,`date`)\n            ) ENGINE=MyISAM  DEFAULT CHARSET=utf8;\",\n        );\n\n        foreach ($tables as $name => $sql) {\n            $if_table_exists = $this->db->query(\"SHOW TABLES LIKE '{$name}'\");\n\n            if (!empty($if_table_exists)) {\n                $this->log('Table ' . $name . ' already exists in your database!');\n            } else {\n                $this->execSQL($sql);\n                $this->log('Table ' . $name . ' added.');\n            }\n        }\n    }\n\n    /**\n     * Populate the tables and perform upgrades if necessary\n     * @param string $version_from\n     * @param string $version_to\n     * @see isUpgradeRequired()\n     */\n    public function upgrade($version_from, $version_to)\n    {\n        if (version_compare($version_from, '2.1.0', '<')) {\n            $this->upgrade210();\n        }\n        if (version_compare($version_from, '3.0.0', '<')) {\n            $this->upgrade300();\n        }\n        if (version_compare($version_from, '3.1.0', '<')) {\n            $this->upgrade310();\n        }\n        if (version_compare($version_from, '3.2.0', '<')) {\n            $this->upgrade320();\n        }\n        if (version_compare($version_from, '3.2.1', '<')) {\n            $this->upgrade321();\n        }\n        if (version_compare($version_from, '3.2.2', '<')) {\n            $this->upgrade322();\n        }\n        if (version_compare($version_from, '3.3.0', '<')) {\n            $this->upgrade330();\n        }\n        if (version_compare($version_from, '3.4.0', '<')) {\n            $this->upgrade340();\n        }\n        if (version_compare($version_from, '3.4.2', '<')) {\n            $this->upgrade342();\n        }\n        if (version_compare($version_from, '3.5.0', '<')) {\n            $this->upgrade350();\n        }\n        if (version_compare($version_from, '3.6.0', '<')) {\n            $this->upgrade360();\n        }\n        psm_update_conf('version', $version_to);\n    }\n\n    /**\n     * Upgrade for v2.1.0 release\n     */\n    protected function upgrade210()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"config` DROP `config_id`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"config` ADD PRIMARY KEY ( `key` );\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"config` DROP INDEX `key`;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('cron_running', '0');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('cron_running_time', '0');\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `error` `error` VARCHAR( 255 )\n            CHARACTER SET utf8 COLLATE utf8_general_ci NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `rtime` `rtime` FLOAT( 9, 7 ) NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `last_online` `last_online` DATETIME NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `last_check` `last_check` DATETIME NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `pattern` VARCHAR( 255 ) NOT NULL AFTER  `type`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline` DATETIME NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline_duration` varchar(255) NULL;\";\n\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Upgrade for v3.0.0 release\n     */\n    protected function upgrade300()\n    {\n        $queries = array();\n        // language is now stored as language code (ISO 639-1) + country code (ISO 3166-1)\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='bg_BG' \n            WHERE `key`='language' AND `value`='bg';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='de_DE' \n            WHERE `key`='language' AND `value`='de';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='en_US' \n            WHERE `key`='language' AND `value`='en';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='fr_FR' \n            WHERE `key`='language' AND `value`='fr';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='ko_KR' \n            WHERE `key`='language' AND `value`='kr';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='nl_NL' \n            WHERE `key`='language' AND `value`='nl';\";\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` SET `value`='pt_BR' \n            WHERE `key`='language' AND `value`='br';\";\n\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES\n            ('version_update_check', '\" . PSM_VERSION . \"');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('email_smtp', '');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('email_smtp_host', '');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('email_smtp_port', '');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('email_smtp_username', '');\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUES ('email_smtp_password', '');\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"log` CHANGE `log_id` `log_id` INT( 11 )\n            UNSIGNED NOT NULL AUTO_INCREMENT;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"log` CHANGE `server_id` `server_id` INT( 11 )\n            UNSIGNED NOT NULL;\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `server_id` `server_id` INT( 11 )\n            UNSIGNED NOT NULL AUTO_INCREMENT;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD `warning_threshold` MEDIUMINT( 1 )\n            UNSIGNED NOT NULL DEFAULT '1';\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD `warning_threshold_counter` MEDIUMINT( 1 )\n            UNSIGNED NOT NULL DEFAULT '0';\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline` DATETIME NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline_duration` varchar(255) NULL;\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` CHANGE `user_id` `user_id` INT( 11 )\n            UNSIGNED NOT NULL AUTO_INCREMENT;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users`\n            ADD `user_name` varchar(64) COLLATE utf8_general_ci NOT NULL \n                COMMENT 'user\\'s name, unique' AFTER `user_id`,\n            ADD `password` varchar(255) COLLATE utf8_general_ci NOT NULL \n                COMMENT 'user\\'s password in salted and hashed format' AFTER `user_name`,\n            ADD `password_reset_hash` char(40) COLLATE utf8_general_ci DEFAULT NULL \n                COMMENT 'user\\'s password reset code' AFTER `password`,\n            ADD `password_reset_timestamp` bigint(20) DEFAULT NULL \n                COMMENT 'timestamp of the password reset request' AFTER `password_reset_hash`,\n            ADD `rememberme_token` varchar(64) COLLATE utf8_general_ci DEFAULT NULL \n                COMMENT 'user\\'s remember-me cookie token' AFTER `password_reset_timestamp`,\n            ADD `level` TINYINT( 2 ) UNSIGNED NOT NULL DEFAULT '20' AFTER `rememberme_token`;\";\n        // make sure all current users are admins (previously we didnt have non-admins):\n        $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"users` SET `user_name`=`email`, `level`=10;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` ADD UNIQUE `unique_username` ( `user_name` );\";\n\n        $queries[] = \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"servers_uptime` (\n                        `servers_uptime_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                        `server_id` int(11) unsigned NOT NULL,\n                        `date` datetime NOT NULL,\n                        `status` tinyint(1) unsigned NOT NULL,\n                        `latency` float(9,7) DEFAULT NULL,\n                        PRIMARY KEY (`servers_uptime_id`),\n                        KEY `server_id` (`server_id`)\n                      ) ENGINE=MyISAM  DEFAULT CHARSET=utf8;\";\n\n        $queries[] = \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"servers_history` (\n                `servers_history_id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n                `server_id` int(11) unsigned NOT NULL,\n                `date` date NOT NULL,\n                `latency_min` float(9,7) NOT NULL,\n                `latency_avg` float(9,7) NOT NULL,\n                `latency_max` float(9,7) NOT NULL,\n                `checks_total` int(11) unsigned NOT NULL,\n                `checks_failed` int(11) unsigned NOT NULL,\n                          PRIMARY KEY (`servers_history_id`),\n                          UNIQUE KEY `server_id_date` (`server_id`,`date`)\n                        ) ENGINE=MyISAM  DEFAULT CHARSET=utf8;\";\n\n        $queries[] = \"CREATE TABLE `\" . PSM_DB_PREFIX . \"users_servers` (\n                        `user_id` INT( 11 ) UNSIGNED NOT NULL ,\n                        `server_id` INT( 11 ) UNSIGNED NOT NULL ,\n                        PRIMARY KEY ( `user_id` , `server_id` )\n                        ) ENGINE = MYISAM ;\";\n        $this->execSQL($queries);\n\n        // from 3.0 all user-server relations are in a separate table\n        $users = $this->db->select(PSM_DB_PREFIX . 'users', null, array('user_id', 'server_id'));\n        foreach ($users as $user) {\n            $idc = array();\n            if ($user['server_id'] == '') {\n                continue;\n            }\n            if (strpos($user['server_id'], ',') === false) {\n                $idc[] = $user['server_id'];\n            } else {\n                $idc = explode(',', $user['server_id']);\n            }\n            foreach ($idc as $id) {\n                $this->db->save(PSM_DB_PREFIX . 'users_servers', array(\n                    'user_id' => $user['user_id'],\n                    'server_id' => $id,\n                ));\n            }\n        }\n        $this->execSQL(\"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` DROP `server_id`;\");\n    }\n\n    /**\n     * Upgrade for v3.1.0 release\n     */\n    protected function upgrade310()\n    {\n        $queries = array();\n        psm_update_conf('log_retention_period', '365');\n\n        psm_update_conf('pushover_status', 0);\n        psm_update_conf('log_pushover', 1);\n        psm_update_conf('pushover_api_token', '');\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` ADD  `pushover_key` VARCHAR( 255 )\n            NOT NULL AFTER `mobile`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` ADD  `pushover_device` VARCHAR( 255 )\n            NOT NULL AFTER `pushover_key`;\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `pushover` ENUM( 'yes','no' )\n            NOT NULL DEFAULT 'yes' AFTER  `sms`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX .\n            \"log` CHANGE `type` `type` ENUM( 'status', 'email', 'sms', 'pushover' )\n            CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\";\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD `timeout` smallint(1) unsigned NULL DEFAULT NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline` DATETIME NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `last_offline_duration` varchar(255) NULL;\";\n\n        $queries[] = \"CREATE TABLE IF NOT EXISTS `\" . PSM_DB_PREFIX . \"users_preferences` (\n                        `user_id` int(11) unsigned NOT NULL,\n                        `key` varchar(255) NOT NULL,\n                        `value` varchar(255) NOT NULL,\n                        PRIMARY KEY (`user_id`, `key`)\n                      ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\";\n\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Upgrade for v3.2.0 release\n     */\n    protected function upgrade320()\n    {\n        $queries = array();\n\n        psm_update_conf('password_encrypt_key', sha1(microtime()));\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `ip` `ip` VARCHAR(500) NOT NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD `website_username` varchar(255) NULL,\n            ADD `website_password` varchar(255) NULL AFTER `website_username`;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUE\n                    ('proxy', '0'),\n                    ('proxy_url', ''),\n                    ('proxy_user', ''),\n                    ('proxy_password', '');\";\n\n        $this->execSQL($queries);\n\n        // Create log_users table\n        $this->execSQL(\"CREATE TABLE `\" . PSM_DB_PREFIX . \"log_users` (\n                        `log_id`  int(11) UNSIGNED NOT NULL ,\n                        `user_id`  int(11) UNSIGNED NOT NULL ,\n                        PRIMARY KEY (`log_id`, `user_id`)\n                      ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\");\n\n        // Migrate the data\n        $logs = $this->db->select(PSM_DB_PREFIX . 'log', null, array('log_id', 'user_id'));\n        foreach ($logs as $log) {\n            // Validation\n            if (empty($log['user_id']) || trim($log['user_id']) == '') {\n                continue;\n            }\n\n            // Insert into new table\n            foreach (explode(',', $log['user_id']) as $user_id) {\n                psm_add_log_user($log['log_id'], $user_id);\n            }\n        }\n\n        // Drop old user_id('s) column\n        $this->execSQL(\"ALTER TABLE `\" . PSM_DB_PREFIX . \"log` DROP COLUMN `user_id`;\");\n    }\n\n    /**\n     * Upgrade for v3.2.1 release\n     */\n    protected function upgrade321()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD COLUMN `header_name` VARCHAR(255) AFTER `pattern`,\n            ADD COLUMN `header_value` VARCHAR(255) AFTER `header_name`\";\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Upgrade for v3.2.2 release\n     */\n    protected function upgrade322()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` ADD  `telegram_id` VARCHAR( 255 ) \n            NOT NULL AFTER `pushover_device`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `telegram` ENUM( 'yes','no' ) \n            NOT NULL DEFAULT 'yes' AFTER  `pushover`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX .\n            \"log` CHANGE `type` `type` ENUM( 'status', 'email', 'sms', 'pushover', 'telegram' )\n            CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUE\n                    ('telegram_status', '0'),\n                    ('log_telegram', '1'),\n                    ('telegram_api_token', '');\";\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Upgrade for v3.3.0 release\n     */\n    protected function upgrade330()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD COLUMN `last_offline` DATETIME\n            NULL AFTER `last_online`, ADD COLUMN `last_offline_duration` varchar(255) NULL AFTER `last_offline`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD `pattern_online` ENUM( 'yes','no' )\n            NOT NULL DEFAULT 'yes' AFTER `pattern`;\";\n        $this->execSQL($queries);\n        if (psm_get_conf('sms_gateway') == 'mollie') {\n            psm_update_conf('sms_gateway', 'messagebird');\n        }\n    }\n\n    /**\n     * Upgrade for v3.4.0 release\n     */\n    protected function upgrade340()\n    {\n        $queries = array();\n        /**\n         * Redirect_check is first set to default ok.\n         * If you have a lot of server that are redirecting,\n         * this will make sure you're servers stay online.\n         */\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `allow_http_status` VARCHAR(255) NOT NULL DEFAULT '' AFTER `pattern_online`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD `redirect_check` ENUM( 'ok','bad' ) NOT NULL DEFAULT 'ok' AFTER `allow_http_status`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            CHANGE `redirect_check` `redirect_check` ENUM('ok','bad') NOT NULL DEFAULT 'bad';\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `last_error` VARCHAR(255) NULL AFTER `website_password`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `last_error_output` TEXT AFTER `last_error`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `last_output` TEXT AFTER `last_error_output`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `request_method` varchar(50) NULL AFTER `port`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers`\n            ADD COLUMN `post_field` varchar(255) NULL AFTER `pattern_online`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"log`\n            CHANGE `message` `message` TEXT CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`)\n            VALUES ('combine_notifications', '1');\";\n        $this->execSQL($queries);\n        $this->log('Combined notifications enabled. Check out the config page for more info.');\n    }\n\n    /**\n     * Patch for v3.4.2 release\n     * Version_compare was forgotten in v3.4.1 and query failed.\n     * Fixed in v3.4.2, 3.4.1 has been removed.\n     */\n    protected function upgrade342()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` CHANGE `last_output` `last_output` TEXT;\";\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Upgrade for v3.5.0 release\n     */\n    protected function upgrade350()\n    {\n        $queries = array();\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` \n            ADD `ssl_cert_expiry_days` MEDIUMINT(1) UNSIGNED NOT NULL DEFAULT '0' AFTER `warning_threshold_counter`\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` \n            ADD `ssl_cert_expired_time` VARCHAR(255) NULL AFTER `ssl_cert_expiry_days`\";\n\n        if (\n            @psm_password_decrypt(\n                psm_get_conf('password_encrypt_key'),\n                psm_get_conf('email_smtp_password')\n            ) === false\n        ) {\n            // Prevents encrypting the password multiple times.\n            $queries[] = \"UPDATE `\" . PSM_DB_PREFIX . \"config` \n                SET `value` = '\" .\n                psm_password_encrypt(psm_get_conf('password_encrypt_key'), psm_get_conf('email_smtp_password')) .\n                \"' WHERE `key` = 'email_smtp_password'\";\n            $this->log('SMTP password is now encrypted.');\n        }\n\n        $queries[] = 'ALTER TABLE `' . PSM_DB_PREFIX . 'users` ADD  `jabber` VARCHAR( 255 )\n            NOT NULL AFTER `telegram_id`;';\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` ADD  `jabber` ENUM( 'yes','no' )\n            NOT NULL DEFAULT 'yes' AFTER  `telegram`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX .\n            \"log` CHANGE `type` `type` ENUM( 'status', 'email', 'sms', 'pushover', 'telegram', 'jabber' )\n            CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUE\n                    ('jabber_status', '0'),\n                    ('log_jabber', '1'),\n                    ('jabber_host', ''),\n                    ('jabber_port', ''),\n                    ('jabber_username', ''),\n                    ('jabber_domain', ''),\n                    ('jabber_password', '');\";\n        $this->execSQL($queries);\n    }\n\n    /**\n     * Patch for v3.6.0 release\n     * Added support for Discord and webhooks\n     * Password_reset_hash varchar 40 -> 64 to allow for SHA256 hash\n     */\n    protected function upgrade360()\n    {\n        $queries = array();\n\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` \n            ADD  `webhook_url` VARCHAR( 255 ) NOT NULL AFTER `telegram_id`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` \n            ADD  `webhook_json` VARCHAR( 255 ) NOT NULL AFTER `telegram_id`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"log` \n            CHANGE `type` `type` ENUM('status','email','sms','discord','webhook','pushover','telegram','jabber') \n            CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` \n            ADD `webhook` ENUM( 'yes','no' ) NOT NULL DEFAULT 'yes' AFTER `telegram`;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"config` (`key`, `value`) VALUE\n                    ('discord_status', '0'),\n                    ('log_discord', '1'),\n                    ('webhook_status', '0'),\n                    ('log_webhook', '1')\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users` \n            ADD `discord` VARCHAR( 255 ) NOT NULL AFTER `mobile`;\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"servers` \n            ADD `discord` ENUM( 'yes','no' ) NOT NULL DEFAULT 'yes' AFTER  `sms`;\";\n        $queries[] = \"INSERT INTO `\" . PSM_DB_PREFIX . \"users` (\n            `user_name`, `level`, `name`, `email`)\n            VALUES ('__PUBLIC__', 30, 'Public page', 'publicpage@psm.psm')\";\n        $queries[] = \"ALTER TABLE `\" . PSM_DB_PREFIX . \"users`\n            CHANGE `password_reset_hash` `password_reset_hash`  VARCHAR( 64 ) DEFAULT NULL COMMENT 'user''s password reset code';\";\n        $this->execSQL($queries);\n\n        $this->log('Public page is now available. Added user \\'__PUBLIC__\\'. See documentation for more info.');\n    }\n}\n"], "filenames": ["src/includes/psmconfig.inc.php", "src/psm/Service/User.php", "src/psm/Util/Install/Installer.php"], "buggy_code_start_loc": [33, 75, 215], "buggy_code_end_loc": [34, 395, 760], "fixing_code_start_loc": [33, 75, 215], "fixing_code_end_loc": [34, 395, 764], "type": "CWE-1241", "message": "A vulnerability, which was classified as problematic, was found in phpservermon. This affects the function generatePasswordResetToken of the file src/psm/Service/User.php. The manipulation leads to use of predictable algorithm in random number generator. The exploit has been disclosed to the public and may be used. The name of the patch is 3daa804d5f56c55b3ae13bfac368bb84ec632193. It is recommended to apply a patch to fix this issue. The identifier VDB-213717 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2021-4240", "sourceIdentifier": "cna@vuldb.com", "published": "2022-11-15T23:15:10.233", "lastModified": "2022-11-18T19:51:51.210", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, was found in phpservermon. This affects the function generatePasswordResetToken of the file src/psm/Service/User.php. The manipulation leads to use of predictable algorithm in random number generator. The exploit has been disclosed to the public and may be used. The name of the patch is 3daa804d5f56c55b3ae13bfac368bb84ec632193. It is recommended to apply a patch to fix this issue. The identifier VDB-213717 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1241"}, {"lang": "en", "value": "CWE-331"}, {"lang": "en", "value": "CWE-338"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpservermonitor:php_server_monitor:-:*:*:*:*:*:*:*", "matchCriteriaId": "8BA6165A-0BEC-4027-BFF8-92EF2B82B3CF"}]}]}], "references": [{"url": "https://github.com/phpservermon/phpservermon/commit/3daa804d5f56c55b3ae13bfac368bb84ec632193", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2-phpservermon/phpservermon/", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.213717", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/phpservermon/phpservermon/commit/3daa804d5f56c55b3ae13bfac368bb84ec632193"}}