{"buggy_code": ["/*\n  Copyright (C) 2013-2015 Yubico AB\n\n  This program is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1, or (at your option) any\n  later version.\n\n  This program is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser\n  General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with this program; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <config.h>\n#include \"internal.h\"\n\n#include <stdlib.h>\n\n#ifdef _WIN32\n#include <windows.h>\n#include <winternl.h>\n#include <winerror.h>\n#include <stdio.h>\n#include <bcrypt.h>\n#include <sal.h>\n\n#pragma comment(lib, \"bcrypt.lib\")\n\n#else\n#include <unistd.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#endif\n\n#ifdef __linux\n#include <linux/hidraw.h>\n#endif\n\n#ifdef __linux\nstatic uint32_t\nget_bytes (uint8_t * rpt, size_t len, size_t num_bytes, size_t cur)\n{\n  /* Return if there aren't enough bytes. */\n  if (cur + num_bytes >= len)\n    return 0;\n\n  if (num_bytes == 0)\n    return 0;\n  else if (num_bytes == 1)\n    {\n      return rpt[cur + 1];\n    }\n  else if (num_bytes == 2)\n    {\n      return (rpt[cur + 2] * 256 + rpt[cur + 1]);\n    }\n  else\n    return 0;\n}\n\nstatic int\nget_usage (uint8_t * report_descriptor, size_t size,\n\t   unsigned short *usage_page, unsigned short *usage)\n{\n  size_t i = 0;\n  int size_code;\n  int data_len, key_size;\n  int usage_found = 0, usage_page_found = 0;\n\n  while (i < size)\n    {\n      int key = report_descriptor[i];\n      int key_cmd = key & 0xfc;\n\n      if ((key & 0xf0) == 0xf0)\n\t{\n\t  fprintf (stderr, \"invalid data received.\\n\");\n\t  return -1;\n\t}\n      else\n\t{\n\t  size_code = key & 0x3;\n\t  switch (size_code)\n\t    {\n\t    case 0:\n\t    case 1:\n\t    case 2:\n\t      data_len = size_code;\n\t      break;\n\t    case 3:\n\t      data_len = 4;\n\t      break;\n\t    default:\n\t      /* Can't ever happen since size_code is & 0x3 */\n\t      data_len = 0;\n\t      break;\n\t    };\n\t  key_size = 1;\n\t}\n\n      if (key_cmd == 0x4)\n\t{\n\t  *usage_page = get_bytes (report_descriptor, size, data_len, i);\n\t  usage_page_found = 1;\n\t}\n      if (key_cmd == 0x8)\n\t{\n\t  *usage = get_bytes (report_descriptor, size, data_len, i);\n\t  usage_found = 1;\n\t}\n\n      if (usage_page_found && usage_found)\n\treturn 0;\t\t/* success */\n\n      i += data_len + key_size;\n    }\n\n  return -1;\t\t\t/* failure */\n}\n#endif\n\nstatic int\nget_usages (struct hid_device_info *dev, unsigned short *usage_page,\n\t    unsigned short *usage)\n{\n#ifdef __linux\n  int res, desc_size;\n  int ret = U2FH_TRANSPORT_ERROR;\n  struct hidraw_report_descriptor rpt_desc;\n  int handle = open (dev->path, O_RDWR);\n  if (handle > 0)\n    {\n      memset (&rpt_desc, 0, sizeof (rpt_desc));\n      res = ioctl (handle, HIDIOCGRDESCSIZE, &desc_size);\n      if (res >= 0)\n\t{\n\t  rpt_desc.size = desc_size;\n\t  res = ioctl (handle, HIDIOCGRDESC, &rpt_desc);\n\t  if (res >= 0)\n\t    {\n\t      res =\n\t\tget_usage (rpt_desc.value, rpt_desc.size, usage_page, usage);\n\t      if (res >= 0)\n\t\t{\n\t\t  ret = U2FH_OK;\n\t\t}\n\t    }\n\t}\n      close (handle);\n    }\n  return ret;\n#else\n  *usage_page = dev->usage_page;\n  *usage = dev->usage;\n  return U2FH_OK;\n#endif\n}\n\nstatic struct u2fdevice *\nclose_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  struct u2fdevice *next = dev->next;\n  hid_close (dev->devh);\n  free (dev->device_path);\n  free (dev->device_string);\n  if (dev == devs->first)\n    {\n      devs->first = next;\n      free (dev);\n    }\n  else\n    {\n      struct u2fdevice *d;\n      for (d = devs->first; d != NULL; d = d->next)\n\t{\n\t  if (d->next == dev)\n\t    {\n\t      d->next = next;\n\t      free (dev);\n\t      break;\n\t    }\n\t}\n    }\n  return next;\n}\n\nstruct u2fdevice *\nget_device (u2fh_devs * devs, unsigned id)\n{\n  struct u2fdevice *dev;\n  for (dev = devs->first; dev != NULL; dev = dev->next)\n    {\n      if (dev->id == id)\n\t{\n\t  return dev;\n\t}\n    }\n  return NULL;\n}\n\nstatic struct u2fdevice *\nnew_device (u2fh_devs * devs)\n{\n  struct u2fdevice *new = malloc (sizeof (struct u2fdevice));\n  if (new == NULL)\n    {\n      return NULL;\n    }\n  memset (new, 0, sizeof (struct u2fdevice));\n  new->id = devs->max_id++;\n  if (devs->first == NULL)\n    {\n      devs->first = new;\n    }\n  else\n    {\n      struct u2fdevice *dev;\n      for (dev = devs->first; dev != NULL; dev = dev->next)\n\t{\n\t  if (dev->next == NULL)\n\t    {\n\t      break;\n\t    }\n\t}\n      dev->next = new;\n    }\n  return new;\n}\n\nstatic void\nclose_devices (u2fh_devs * devs)\n{\n  struct u2fdevice *dev;\n  if (devs == NULL)\n    {\n      return;\n    }\n  dev = devs->first;\n\n  while (dev)\n    {\n      dev = close_device (devs, dev);\n    }\n}\n\n#if defined(_WIN32)\nstatic int\nobtain_nonce(unsigned char* nonce)\n{\n  NTSTATUS status;\n\n  status = BCryptGenRandom(NULL, nonce, 8,\n\t\t\t   BCRYPT_USE_SYSTEM_PREFERRED_RNG);\n\n  if (!NT_SUCCESS(status))\n    return (-1);\n\n  return (0);\n}\n#elif defined(HAVE_DEV_URANDOM)\nstatic int\nobtain_nonce(unsigned char* nonce)\n{\n  int     fd = -1;\n  int     ok = -1;\n  ssize_t r;\n\n  if ((fd = open(\"/dev/urandom\", O_RDONLY)) < 0)\n    goto fail;\n  if ((r = read(fd, nonce, 8)) < 0 || r != 8)\n    goto fail;\n\n  ok = 0;\n fail:\n  if (fd != -1)\n    close(fd);\n\n  return (ok);\n}\n#else\n#error \"please provide an implementation of obtain_nonce() for your platform\"\n#endif /* _WIN32 */\n\nstatic int\ninit_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n\t{\n\t  return U2FH_MEMORY_ERROR;\n\t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}\n\nstatic int\nping_device (u2fh_devs * devs, unsigned index)\n{\n  unsigned char data[1] = { 0 };\n  unsigned char resp[1024];\n  size_t resplen = sizeof (resp);\n  return u2fh_sendrecv (devs, index, U2FHID_PING, data, sizeof (data), resp,\n\t\t\t&resplen);\n}\n\n\n/**\n * u2fh_devs_init:\n * @devs: pointer to #u2fh_devs type to initialize.\n *\n * Initialize device handle.\n *\n * Returns: On success %U2FH_OK (integer 0) is returned, on memory\n * allocation errors %U2FH_MEMORY_ERROR is returned, or another\n * #u2fh_rc error code is returned.\n */\nu2fh_rc\nu2fh_devs_init (u2fh_devs ** devs)\n{\n  u2fh_devs *d;\n  int rc;\n\n  d = malloc (sizeof (*d));\n  if (d == NULL)\n    return U2FH_MEMORY_ERROR;\n\n  memset (d, 0, sizeof (*d));\n\n  rc = hid_init ();\n  if (rc != 0)\n    {\n      free (d);\n      return U2FH_TRANSPORT_ERROR;\n    }\n\n  *devs = d;\n\n  return U2FH_OK;\n}\n\n/**\n * u2fh_devs_discover:\n * @devs: device handle, from u2fh_devs_init().\n * @max_index: will on return be set to the maximum index, may be NULL; if\n *   there is 1 device this will be 0, if there are 2 devices this\n *   will be 1, and so on.\n *\n * Discover and open new devices.  This function can safely be called\n * several times and will free resources associated with unplugged\n * devices and open new.\n *\n * Returns: On success, %U2FH_OK (integer 0) is returned, when no U2F\n *   device could be found %U2FH_NO_U2F_DEVICE is returned, or another\n *   #u2fh_rc error code.\n */\nu2fh_rc\nu2fh_devs_discover (u2fh_devs * devs, unsigned *max_index)\n{\n  struct hid_device_info *di, *cur_dev;\n  u2fh_rc res = U2FH_NO_U2F_DEVICE;\n  struct u2fdevice *dev;\n\n  di = hid_enumerate (0, 0);\n  for (cur_dev = di; cur_dev; cur_dev = cur_dev->next)\n    {\n      int found = 0;\n      unsigned short usage_page = 0, usage = 0;\n\n      /* check if we already opened this device */\n      for (dev = devs->first; dev != NULL; dev = dev->next)\n\t{\n\t  if (strcmp (dev->device_path, cur_dev->path) == 0)\n\t    {\n\t      if (ping_device (devs, dev->id) == U2FH_OK)\n\t\t{\n\t\t  found = 1;\n\t\t  res = U2FH_OK;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (debug)\n\t\t    {\n\t\t      fprintf (stderr, \"Device %s failed ping, dead.\\n\",\n\t\t\t       dev->device_path);\n\t\t    }\n\t\t  close_device (devs, dev);\n\t\t}\n\t      break;\n\t    }\n\t}\n      if (found)\n\t{\n\t  continue;\n\t}\n\n      get_usages (cur_dev, &usage_page, &usage);\n      if (usage_page == FIDO_USAGE_PAGE && usage == FIDO_USAGE_U2FHID)\n\t{\n\t  dev = new_device (devs);\n\t  dev->devh = hid_open_path (cur_dev->path);\n\t  if (dev->devh != NULL)\n\t    {\n\t      dev->device_path = strdup (cur_dev->path);\n\t      if (dev->device_path == NULL)\n\t\t{\n\t\t  close_device (devs, dev);\n\t\t  goto out;\n\t\t}\n\t      if (init_device (devs, dev) == U2FH_OK)\n\t\t{\n\t\t  if (cur_dev->product_string)\n\t\t    {\n\t\t      size_t len =\n\t\t\twcstombs (NULL, cur_dev->product_string, 0);\n\t\t      dev->device_string = malloc (len + 1);\n\t\t      if (dev->device_string == NULL)\n\t\t\t{\n\t\t\t  close_device (devs, dev);\n\t\t\t  goto out;\n\t\t\t}\n\t\t      memset (dev->device_string, 0, len + 1);\n\t\t      wcstombs (dev->device_string, cur_dev->product_string,\n\t\t\t\tlen);\n\t\t      if (debug)\n\t\t\t{\n\t\t\t  fprintf (stderr, \"device %s discovered as '%s'\\n\",\n\t\t\t\t   dev->device_path, dev->device_string);\n\t\t\t  fprintf (stderr,\n\t\t\t\t   \"  version (Interface, Major, \"\n\t\t\t\t   \"Minor, Build): %d, %d, \"\n\t\t\t\t   \"%d, %d  capFlags: %d\\n\",\n\t\t\t\t   dev->versionInterface,\n\t\t\t\t   dev->versionMajor,\n\t\t\t\t   dev->versionMinor,\n\t\t\t\t   dev->versionBuild, dev->capFlags);\n\t\t\t}\n\t\t    }\n\t\t  res = U2FH_OK;\n\t\t  continue;\n\t\t}\n\t    }\n\t  close_device (devs, dev);\n\t}\n    }\n\n\n  /* loop through all open devices and make sure we find them in the enumeration */\n  dev = devs->first;\n  while (dev)\n    {\n      int found = 0;\n\n      for (cur_dev = di; cur_dev; cur_dev = cur_dev->next)\n\t{\n\t  if (strcmp (cur_dev->path, dev->device_path) == 0)\n\t    {\n\t      found = 1;\n\t      dev = dev->next;\n\t      break;\n\t    }\n\t}\n      if (!found)\n\t{\n\t  if (debug)\n\t    {\n\t      fprintf (stderr, \"device %s looks dead.\\n\", dev->device_path);\n\t    }\n\t  dev = close_device (devs, dev);\n\t}\n    }\n\nout:\n  hid_free_enumeration (di);\n  if (res == U2FH_OK && max_index)\n    *max_index = devs->max_id - 1;\n\n  return res;\n}\n\n/**\n * u2fh_devs_done:\n * @devs: device handle, from u2fh_devs_init().\n *\n * Release all resources associated with @devs.  This function must be\n * called when you are finished with a device handle.\n */\nvoid\nu2fh_devs_done (u2fh_devs * devs)\n{\n  close_devices (devs);\n  hid_exit ();\n\n  free (devs);\n}\n\n/**\n * u2fh_get_device_description:\n * @devs: device_handle, from u2fh_devs_init().\n * @index: index of device\n * @out: buffer for storing device description\n * @len: maximum amount of data to store in @out. Will be updated.\n *\n * Get the device description of the device at @index. Stores the\n * string in @out.\n *\n * Returns: %U2FH_OK on success.\n */\nu2fh_rc\nu2fh_get_device_description (u2fh_devs * devs, unsigned index, char *out,\n\t\t\t     size_t * len)\n{\n  size_t i;\n  struct u2fdevice *dev = get_device (devs, index);\n\n  if (!dev)\n    {\n      return U2FH_NO_U2F_DEVICE;\n    }\n  i = strlen (dev->device_string);\n  if (i < *len)\n    {\n      *len = i;\n    }\n  else\n    {\n      return U2FH_MEMORY_ERROR;\n    }\n  strcpy (out, dev->device_string);\n  return U2FH_OK;\n}\n\n/**\n * u2fh_is_alive:\n * @devs: device_handle, from u2fh_devs_init().\n * @index: index of device\n *\n * Get the liveliness of the device @index.\n *\n * Returns: 1 if the device is considered alive, 0 otherwise.\n */\nint\nu2fh_is_alive (u2fh_devs * devs, unsigned index)\n{\n  if (!get_device (devs, index))\n    return 0;\n  return 1;\n}\n"], "fixing_code": ["/*\n  Copyright (C) 2013-2015 Yubico AB\n\n  This program is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1, or (at your option) any\n  later version.\n\n  This program is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser\n  General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with this program; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <config.h>\n#include \"internal.h\"\n\n#include <stdlib.h>\n\n#ifdef _WIN32\n#include <windows.h>\n#include <winternl.h>\n#include <winerror.h>\n#include <stdio.h>\n#include <bcrypt.h>\n#include <sal.h>\n\n#pragma comment(lib, \"bcrypt.lib\")\n\n#else\n#include <unistd.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#endif\n\n#ifdef __linux\n#include <linux/hidraw.h>\n#endif\n\n#ifdef __linux\nstatic uint32_t\nget_bytes (uint8_t * rpt, size_t len, size_t num_bytes, size_t cur)\n{\n  /* Return if there aren't enough bytes. */\n  if (cur + num_bytes >= len)\n    return 0;\n\n  if (num_bytes == 0)\n    return 0;\n  else if (num_bytes == 1)\n    {\n      return rpt[cur + 1];\n    }\n  else if (num_bytes == 2)\n    {\n      return (rpt[cur + 2] * 256 + rpt[cur + 1]);\n    }\n  else\n    return 0;\n}\n\nstatic int\nget_usage (uint8_t * report_descriptor, size_t size,\n\t   unsigned short *usage_page, unsigned short *usage)\n{\n  size_t i = 0;\n  int size_code;\n  int data_len, key_size;\n  int usage_found = 0, usage_page_found = 0;\n\n  while (i < size)\n    {\n      int key = report_descriptor[i];\n      int key_cmd = key & 0xfc;\n\n      if ((key & 0xf0) == 0xf0)\n\t{\n\t  fprintf (stderr, \"invalid data received.\\n\");\n\t  return -1;\n\t}\n      else\n\t{\n\t  size_code = key & 0x3;\n\t  switch (size_code)\n\t    {\n\t    case 0:\n\t    case 1:\n\t    case 2:\n\t      data_len = size_code;\n\t      break;\n\t    case 3:\n\t      data_len = 4;\n\t      break;\n\t    default:\n\t      /* Can't ever happen since size_code is & 0x3 */\n\t      data_len = 0;\n\t      break;\n\t    };\n\t  key_size = 1;\n\t}\n\n      if (key_cmd == 0x4)\n\t{\n\t  *usage_page = get_bytes (report_descriptor, size, data_len, i);\n\t  usage_page_found = 1;\n\t}\n      if (key_cmd == 0x8)\n\t{\n\t  *usage = get_bytes (report_descriptor, size, data_len, i);\n\t  usage_found = 1;\n\t}\n\n      if (usage_page_found && usage_found)\n\treturn 0;\t\t/* success */\n\n      i += data_len + key_size;\n    }\n\n  return -1;\t\t\t/* failure */\n}\n#endif\n\nstatic int\nget_usages (struct hid_device_info *dev, unsigned short *usage_page,\n\t    unsigned short *usage)\n{\n#ifdef __linux\n  int res, desc_size;\n  int ret = U2FH_TRANSPORT_ERROR;\n  struct hidraw_report_descriptor rpt_desc;\n  int handle = open (dev->path, O_RDWR);\n  if (handle > 0)\n    {\n      memset (&rpt_desc, 0, sizeof (rpt_desc));\n      res = ioctl (handle, HIDIOCGRDESCSIZE, &desc_size);\n      if (res >= 0)\n\t{\n\t  rpt_desc.size = desc_size;\n\t  res = ioctl (handle, HIDIOCGRDESC, &rpt_desc);\n\t  if (res >= 0)\n\t    {\n\t      res =\n\t\tget_usage (rpt_desc.value, rpt_desc.size, usage_page, usage);\n\t      if (res >= 0)\n\t\t{\n\t\t  ret = U2FH_OK;\n\t\t}\n\t    }\n\t}\n      close (handle);\n    }\n  return ret;\n#else\n  *usage_page = dev->usage_page;\n  *usage = dev->usage;\n  return U2FH_OK;\n#endif\n}\n\nstatic struct u2fdevice *\nclose_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  struct u2fdevice *next = dev->next;\n  hid_close (dev->devh);\n  free (dev->device_path);\n  free (dev->device_string);\n  if (dev == devs->first)\n    {\n      devs->first = next;\n      free (dev);\n    }\n  else\n    {\n      struct u2fdevice *d;\n      for (d = devs->first; d != NULL; d = d->next)\n\t{\n\t  if (d->next == dev)\n\t    {\n\t      d->next = next;\n\t      free (dev);\n\t      break;\n\t    }\n\t}\n    }\n  return next;\n}\n\nstruct u2fdevice *\nget_device (u2fh_devs * devs, unsigned id)\n{\n  struct u2fdevice *dev;\n  for (dev = devs->first; dev != NULL; dev = dev->next)\n    {\n      if (dev->id == id)\n\t{\n\t  return dev;\n\t}\n    }\n  return NULL;\n}\n\nstatic struct u2fdevice *\nnew_device (u2fh_devs * devs)\n{\n  struct u2fdevice *new = malloc (sizeof (struct u2fdevice));\n  if (new == NULL)\n    {\n      return NULL;\n    }\n  memset (new, 0, sizeof (struct u2fdevice));\n  new->id = devs->max_id++;\n  if (devs->first == NULL)\n    {\n      devs->first = new;\n    }\n  else\n    {\n      struct u2fdevice *dev;\n      for (dev = devs->first; dev != NULL; dev = dev->next)\n\t{\n\t  if (dev->next == NULL)\n\t    {\n\t      break;\n\t    }\n\t}\n      dev->next = new;\n    }\n  return new;\n}\n\nstatic void\nclose_devices (u2fh_devs * devs)\n{\n  struct u2fdevice *dev;\n  if (devs == NULL)\n    {\n      return;\n    }\n  dev = devs->first;\n\n  while (dev)\n    {\n      dev = close_device (devs, dev);\n    }\n}\n\n#if defined(_WIN32)\nstatic int\nobtain_nonce(unsigned char* nonce)\n{\n  NTSTATUS status;\n\n  status = BCryptGenRandom(NULL, nonce, 8,\n\t\t\t   BCRYPT_USE_SYSTEM_PREFERRED_RNG);\n\n  if (!NT_SUCCESS(status))\n    return (-1);\n\n  return (0);\n}\n#elif defined(HAVE_DEV_URANDOM)\nstatic int\nobtain_nonce(unsigned char* nonce)\n{\n  int     fd = -1;\n  int     ok = -1;\n  ssize_t r;\n\n  if ((fd = open(\"/dev/urandom\", O_RDONLY)) < 0)\n    goto fail;\n  if ((r = read(fd, nonce, 8)) < 0 || r != 8)\n    goto fail;\n\n  ok = 0;\n fail:\n  if (fd != -1)\n    close(fd);\n\n  return (ok);\n}\n#else\n#error \"please provide an implementation of obtain_nonce() for your platform\"\n#endif /* _WIN32 */\n\nstatic int\ninit_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      int offs = sizeof (nonce);\n      /* the response has to be atleast 17 bytes, if it's more we discard that */\n      if (resplen < 17)\n\t{\n\t  return U2FH_SIZE_ERROR;\n\t}\n\n      /* incoming and outgoing nonce has to match */\n      if (memcmp (nonce, resp, sizeof (nonce)) != 0)\n\t{\n\t  return U2FH_TRANSPORT_ERROR;\n\t}\n\n      dev->cid =\n\tresp[offs] << 24 | resp[offs + 1] << 16 | resp[offs +\n\t\t\t\t\t\t       2] << 8 | resp[offs +\n\t\t\t\t\t\t\t\t      3];\n      offs += 4;\n      dev->versionInterface = resp[offs++];\n      dev->versionMajor = resp[offs++];\n      dev->versionMinor = resp[offs++];\n      dev->versionBuild = resp[offs++];\n      dev->capFlags = resp[offs++];\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}\n\nstatic int\nping_device (u2fh_devs * devs, unsigned index)\n{\n  unsigned char data[1] = { 0 };\n  unsigned char resp[1024];\n  size_t resplen = sizeof (resp);\n  return u2fh_sendrecv (devs, index, U2FHID_PING, data, sizeof (data), resp,\n\t\t\t&resplen);\n}\n\n\n/**\n * u2fh_devs_init:\n * @devs: pointer to #u2fh_devs type to initialize.\n *\n * Initialize device handle.\n *\n * Returns: On success %U2FH_OK (integer 0) is returned, on memory\n * allocation errors %U2FH_MEMORY_ERROR is returned, or another\n * #u2fh_rc error code is returned.\n */\nu2fh_rc\nu2fh_devs_init (u2fh_devs ** devs)\n{\n  u2fh_devs *d;\n  int rc;\n\n  d = malloc (sizeof (*d));\n  if (d == NULL)\n    return U2FH_MEMORY_ERROR;\n\n  memset (d, 0, sizeof (*d));\n\n  rc = hid_init ();\n  if (rc != 0)\n    {\n      free (d);\n      return U2FH_TRANSPORT_ERROR;\n    }\n\n  *devs = d;\n\n  return U2FH_OK;\n}\n\n/**\n * u2fh_devs_discover:\n * @devs: device handle, from u2fh_devs_init().\n * @max_index: will on return be set to the maximum index, may be NULL; if\n *   there is 1 device this will be 0, if there are 2 devices this\n *   will be 1, and so on.\n *\n * Discover and open new devices.  This function can safely be called\n * several times and will free resources associated with unplugged\n * devices and open new.\n *\n * Returns: On success, %U2FH_OK (integer 0) is returned, when no U2F\n *   device could be found %U2FH_NO_U2F_DEVICE is returned, or another\n *   #u2fh_rc error code.\n */\nu2fh_rc\nu2fh_devs_discover (u2fh_devs * devs, unsigned *max_index)\n{\n  struct hid_device_info *di, *cur_dev;\n  u2fh_rc res = U2FH_NO_U2F_DEVICE;\n  struct u2fdevice *dev;\n\n  di = hid_enumerate (0, 0);\n  for (cur_dev = di; cur_dev; cur_dev = cur_dev->next)\n    {\n      int found = 0;\n      unsigned short usage_page = 0, usage = 0;\n\n      /* check if we already opened this device */\n      for (dev = devs->first; dev != NULL; dev = dev->next)\n\t{\n\t  if (strcmp (dev->device_path, cur_dev->path) == 0)\n\t    {\n\t      if (ping_device (devs, dev->id) == U2FH_OK)\n\t\t{\n\t\t  found = 1;\n\t\t  res = U2FH_OK;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (debug)\n\t\t    {\n\t\t      fprintf (stderr, \"Device %s failed ping, dead.\\n\",\n\t\t\t       dev->device_path);\n\t\t    }\n\t\t  close_device (devs, dev);\n\t\t}\n\t      break;\n\t    }\n\t}\n      if (found)\n\t{\n\t  continue;\n\t}\n\n      get_usages (cur_dev, &usage_page, &usage);\n      if (usage_page == FIDO_USAGE_PAGE && usage == FIDO_USAGE_U2FHID)\n\t{\n\t  dev = new_device (devs);\n\t  dev->devh = hid_open_path (cur_dev->path);\n\t  if (dev->devh != NULL)\n\t    {\n\t      dev->device_path = strdup (cur_dev->path);\n\t      if (dev->device_path == NULL)\n\t\t{\n\t\t  close_device (devs, dev);\n\t\t  goto out;\n\t\t}\n\t      if (init_device (devs, dev) == U2FH_OK)\n\t\t{\n\t\t  if (cur_dev->product_string)\n\t\t    {\n\t\t      size_t len =\n\t\t\twcstombs (NULL, cur_dev->product_string, 0);\n\t\t      dev->device_string = malloc (len + 1);\n\t\t      if (dev->device_string == NULL)\n\t\t\t{\n\t\t\t  close_device (devs, dev);\n\t\t\t  goto out;\n\t\t\t}\n\t\t      memset (dev->device_string, 0, len + 1);\n\t\t      wcstombs (dev->device_string, cur_dev->product_string,\n\t\t\t\tlen);\n\t\t      if (debug)\n\t\t\t{\n\t\t\t  fprintf (stderr, \"device %s discovered as '%s'\\n\",\n\t\t\t\t   dev->device_path, dev->device_string);\n\t\t\t  fprintf (stderr,\n\t\t\t\t   \"  version (Interface, Major, \"\n\t\t\t\t   \"Minor, Build): %d, %d, \"\n\t\t\t\t   \"%d, %d  capFlags: %d\\n\",\n\t\t\t\t   dev->versionInterface,\n\t\t\t\t   dev->versionMajor,\n\t\t\t\t   dev->versionMinor,\n\t\t\t\t   dev->versionBuild, dev->capFlags);\n\t\t\t}\n\t\t    }\n\t\t  res = U2FH_OK;\n\t\t  continue;\n\t\t}\n\t    }\n\t  close_device (devs, dev);\n\t}\n    }\n\n\n  /* loop through all open devices and make sure we find them in the enumeration */\n  dev = devs->first;\n  while (dev)\n    {\n      int found = 0;\n\n      for (cur_dev = di; cur_dev; cur_dev = cur_dev->next)\n\t{\n\t  if (strcmp (cur_dev->path, dev->device_path) == 0)\n\t    {\n\t      found = 1;\n\t      dev = dev->next;\n\t      break;\n\t    }\n\t}\n      if (!found)\n\t{\n\t  if (debug)\n\t    {\n\t      fprintf (stderr, \"device %s looks dead.\\n\", dev->device_path);\n\t    }\n\t  dev = close_device (devs, dev);\n\t}\n    }\n\nout:\n  hid_free_enumeration (di);\n  if (res == U2FH_OK && max_index)\n    *max_index = devs->max_id - 1;\n\n  return res;\n}\n\n/**\n * u2fh_devs_done:\n * @devs: device handle, from u2fh_devs_init().\n *\n * Release all resources associated with @devs.  This function must be\n * called when you are finished with a device handle.\n */\nvoid\nu2fh_devs_done (u2fh_devs * devs)\n{\n  close_devices (devs);\n  hid_exit ();\n\n  free (devs);\n}\n\n/**\n * u2fh_get_device_description:\n * @devs: device_handle, from u2fh_devs_init().\n * @index: index of device\n * @out: buffer for storing device description\n * @len: maximum amount of data to store in @out. Will be updated.\n *\n * Get the device description of the device at @index. Stores the\n * string in @out.\n *\n * Returns: %U2FH_OK on success.\n */\nu2fh_rc\nu2fh_get_device_description (u2fh_devs * devs, unsigned index, char *out,\n\t\t\t     size_t * len)\n{\n  size_t i;\n  struct u2fdevice *dev = get_device (devs, index);\n\n  if (!dev)\n    {\n      return U2FH_NO_U2F_DEVICE;\n    }\n  i = strlen (dev->device_string);\n  if (i < *len)\n    {\n      *len = i;\n    }\n  else\n    {\n      return U2FH_MEMORY_ERROR;\n    }\n  strcpy (out, dev->device_string);\n  return U2FH_OK;\n}\n\n/**\n * u2fh_is_alive:\n * @devs: device_handle, from u2fh_devs_init().\n * @index: index of device\n *\n * Get the liveliness of the device @index.\n *\n * Returns: 1 if the device is considered alive, 0 otherwise.\n */\nint\nu2fh_is_alive (u2fh_devs * devs, unsigned index)\n{\n  if (!get_device (devs, index))\n    return 0;\n  return 1;\n}\n"], "filenames": ["u2f-host/devs.c"], "buggy_code_start_loc": [305], "buggy_code_end_loc": [316], "fixing_code_start_loc": [305], "fixing_code_end_loc": [328], "type": "CWE-908", "message": "In devs.c in Yubico libu2f-host before 1.1.8, the response to init is misparsed, leaking uninitialized stack memory back to the device.", "other": {"cve": {"id": "CVE-2019-9578", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-05T23:29:02.943", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In devs.c in Yubico libu2f-host before 1.1.8, the response to init is misparsed, leaking uninitialized stack memory back to the device."}, {"lang": "es", "value": "En devs.c en Yubico libu2f-host, en versiones anteriores a la 1.1.8, la respuesta a init se analiza err\u00f3neamente, filtrando memoria de pila no inicializada de vuelta al dispositivo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yubico:libu2f-host:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.8", "matchCriteriaId": "454B0C30-785E-42BB-9AF8-4497C5F0B774"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00012.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00018.html", "source": "cve@mitre.org"}, {"url": "https://blog.inhq.net/posts/yubico-libu2f-host-vuln-part2/", "source": "cve@mitre.org"}, {"url": "https://developers.yubico.com/libu2f-host/Release_Notes.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory", "Release Notes"]}, {"url": "https://github.com/Yubico/libu2f-host/commit/e4bb58cc8b6202a421e65f8230217d8ae6e16eb5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GMA4H6AZFYIR3LA5VKKEJZNCCIVMUCFQ/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/S4YCFMSNMXZ7XC4U6WXPQA7JCXC6VOAJ/", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202004-15", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/Yubico/libu2f-host/commit/e4bb58cc8b6202a421e65f8230217d8ae6e16eb5"}}