{"buggy_code": ["/*\n * Load_stp.cpp\n * ------------\n * Purpose: STP (Soundtracker Pro II) module loader\n * Notes  : A few exotic effects aren't supported.\n *          Multiple sample loops are supported, but only the first 10 can be used as cue points\n *          (with 16xx and 18xx).\n *          Fractional speed values and combined auto effects are handled whenever possible,\n *          but some effects may be omitted (and there may be tempo accuracy issues).\n * Authors: Devin Acker\n *          OpenMPT Devs\n * The OpenMPT source code is released under the BSD license. Read LICENSE for more details.\n *\n * Wisdom from the Soundtracker Pro II manual:\n * \"To create shorter patterns, simply create shorter patterns.\"\n */\n\n#include \"stdafx.h\"\n#include \"Loaders.h\"\n\nOPENMPT_NAMESPACE_BEGIN\n\n// File header\nstruct STPFileHeader\n{\n\tchar     magic[4];\n\tuint16be version;\n\tuint8be  numOrders;\n\tuint8be  patternLength;\n\tuint8be  orderList[128];\n\tuint16be speed;\n\tuint16be speedFrac;\n\tuint16be timerCount;\n\tuint16be flags;\n\tuint32be reserved;\n\tuint16be midiCount; // always 50\n\tuint8be  midi[50];\n\tuint16be numSamples;\n\tuint16be sampleStructSize;\n};\n\nMPT_BINARY_STRUCT(STPFileHeader, 204)\n\n\n// Sample header (common part between all versions)\nstruct STPSampleHeader\n{\n\tuint32be length;\n\tuint8be  volume;\n\tuint8be  reserved1;\n\tuint32be loopStart;\n\tuint32be loopLength;\n\tuint16be defaultCommand;\t// Default command to put next to note when editing patterns; not relevant for playback\n\t// The following 4 bytes are reserved in version 0 and 1.\n\tuint16be defaultPeriod;\n\tuint8be  finetune;\n\tuint8be  reserved2;\n\n\tvoid ConvertToMPT(ModSample &mptSmp) const\n\t{\n\t\tmptSmp.nLength = length;\n\t\tmptSmp.nVolume = 4u * std::min<uint16>(volume, 64);\n\n\t\tmptSmp.nLoopStart = loopStart;\n\t\tmptSmp.nLoopEnd = loopStart + loopLength;\n\n\t\tif(mptSmp.nLoopStart >= mptSmp.nLength)\n\t\t{\n\t\t\tmptSmp.nLoopStart = mptSmp.nLength - 1;\n\t\t}\n\t\tif(mptSmp.nLoopEnd > mptSmp.nLength)\n\t\t{\n\t\t\tmptSmp.nLoopEnd = mptSmp.nLength;\n\t\t}\n\n\t\tif(mptSmp.nLoopStart > mptSmp.nLoopEnd)\n\t\t{\n\t\t\tmptSmp.nLoopStart = 0;\n\t\t\tmptSmp.nLoopEnd = 0;\n\t\t} else if(mptSmp.nLoopEnd > mptSmp.nLoopStart)\n\t\t{\n\t\t\tmptSmp.uFlags.set(CHN_LOOP);\n\t\t\tmptSmp.cues[0] = mptSmp.nLoopStart;\n\t\t}\n\t}\n};\n\nMPT_BINARY_STRUCT(STPSampleHeader, 20)\n\n\nstruct STPLoopInfo\n{\n\tSmpLength loopStart;\n\tSmpLength loopLength;\n\tSAMPLEINDEX looped;\n\tSAMPLEINDEX nonLooped;\n};\n\ntypedef std::vector<STPLoopInfo> STPLoopList;\n\n\nstatic TEMPO ConvertTempo(uint16 ciaSpeed)\n{\n\t// 3546 is the resulting CIA timer value when using 4F7D (tempo 125 bpm) command in STProII\n\treturn TEMPO((125.0 * 3546.0) / ciaSpeed);\n}\n\n\nstatic void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)\n{\n\tif(!src.HasSampleData()) return;\n\n\tdest.FreeSample();\n\tdest = src;\n\tdest.nLength = len;\n\tdest.pSample = nullptr;\n\n\tif(!dest.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\n\t// only preserve cue points if the target sample length is the same\n\tif(len != src.nLength)\n\t\tMemsetZero(dest.cues);\n\n\tstd::memcpy(dest.pSample8, src.pSample8 + start, len);\n\tdest.uFlags.set(CHN_LOOP, loop);\n\tif(loop)\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = len;\n\t} else\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = 0;\n\t}\n}\n\nstatic void ConvertLoopSequence(ModSample &smp, STPLoopList &loopList)\n{\n\t// This should only modify a sample if it has more than one loop\n\t// (otherwise, it behaves like a normal sample loop)\n\tif(!smp.HasSampleData() || loopList.size() < 2) return;\n\n\tModSample newSmp = smp;\n\tnewSmp.nLength = 0;\n\tnewSmp.pSample = nullptr;\n\n\tsize_t numLoops = loopList.size();\n\n\t// Get the total length of the sample after combining all looped sections\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\n\t\t// If adding this loop would cause the sample length to exceed maximum,\n\t\t// then limit and bail out\n\t\tif((newSmp.nLength + info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopStart + info.loopLength > smp.nLength))\n\t\t{\n\t\t\tnumLoops = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tnewSmp.nLength += info.loopLength;\n\t}\n\n\tif(!newSmp.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\n\t// start copying the looped sample data parts\n\tSmpLength start = 0;\n\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\n\t\tmemcpy(newSmp.pSample8 + start, smp.pSample8 + info.loopStart, info.loopLength);\n\n\t\t// update loop info based on position in edited sample\n\t\tinfo.loopStart = start;\n\t\tif(i > 0 && i <= mpt::size(newSmp.cues))\n\t\t{\n\t\t\tnewSmp.cues[i - 1] = start;\n\t\t}\n\t\tstart += info.loopLength;\n\t}\n\n\t// replace old sample with new one\n\tsmp.FreeSample();\n\tsmp = newSmp;\n\n\tsmp.nLoopStart = 0;\n\tsmp.nLoopEnd = smp.nLength;\n\tsmp.uFlags.set(CHN_LOOP);\n}\n\n\nstatic bool ValidateHeader(const STPFileHeader &fileHeader)\n{\n\tif(std::memcmp(fileHeader.magic, \"STP3\", 4)\n\t\t|| fileHeader.version > 2\n\t\t|| fileHeader.numOrders > 128\n\t\t|| fileHeader.numSamples >= MAX_SAMPLES\n\t\t|| fileHeader.timerCount == 0\n\t\t|| fileHeader.midiCount != 50)\n\t{\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nCSoundFile::ProbeResult CSoundFile::ProbeFileHeaderSTP(MemoryFileReader file, const uint64 *pfilesize)\n{\n\tSTPFileHeader fileHeader;\n\tif(!file.ReadStruct(fileHeader))\n\t{\n\t\treturn ProbeWantMoreData;\n\t}\n\tif(!ValidateHeader(fileHeader))\n\t{\n\t\treturn ProbeFailure;\n\t}\n\tMPT_UNREFERENCED_PARAMETER(pfilesize);\n\treturn ProbeSuccess;\n}\n\n\nbool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n{\n\tfile.Rewind();\n\n\tSTPFileHeader fileHeader;\n\tif(!file.ReadStruct(fileHeader))\n\t{\n\t\treturn false;\n\t}\n\tif(!ValidateHeader(fileHeader))\n\t{\n\t\treturn false;\n\t}\n\tif(loadFlags == onlyVerifyHeader)\n\t{\n\t\treturn true;\n\t}\n\n\tInitializeGlobals(MOD_TYPE_STP);\n\n\tm_nChannels = 4;\n\tm_nSamples = 0;\n\n\tm_nDefaultSpeed = fileHeader.speed;\n\tm_nDefaultTempo = ConvertTempo(fileHeader.timerCount);\n\n\tm_nMinPeriod = 14 * 4;\n\tm_nMaxPeriod = 3424 * 4;\n\n\tReadOrderFromArray(Order(), fileHeader.orderList, fileHeader.numOrders);\n\n\tstd::vector<STPLoopList> loopInfo;\n\t// Non-looped versions of samples with loops (when needed)\n\tstd::vector<SAMPLEINDEX> nonLooped;\n\n\t// Load sample headers\n\tSAMPLEINDEX samplesInFile = 0;\n\n\tfor(SAMPLEINDEX smp = 0; smp < fileHeader.numSamples; smp++)\n\t{\n\t\tSAMPLEINDEX actualSmp = file.ReadUint16BE();\n\t\tif(actualSmp == 0 || actualSmp >= MAX_SAMPLES)\n\t\t\treturn false;\n\t\tuint32 chunkSize = fileHeader.sampleStructSize;\n\t\tif(fileHeader.version == 2)\n\t\t\tchunkSize = file.ReadUint32BE() - 2;\n\t\tFileReader chunk = file.ReadChunk(chunkSize);\n\n\t\tsamplesInFile = m_nSamples = std::max(m_nSamples, actualSmp);\n\n\t\tModSample &mptSmp = Samples[actualSmp];\n\t\tmptSmp.Initialize(MOD_TYPE_MOD);\n\n\t\tif(fileHeader.version < 2)\n\t\t{\n\t\t\t// Read path\n\t\t\tchunk.ReadString<mpt::String::maybeNullTerminated>(mptSmp.filename, 31);\n\t\t\t// Ignore flags, they are all not relevant for us\n\t\t\tchunk.Skip(1);\n\t\t\t// Read filename / sample text\n\t\t\tchunk.ReadString<mpt::String::maybeNullTerminated>(m_szNames[actualSmp], 30);\n\t\t} else\n\t\t{\n\t\t\tstd::string str;\n\t\t\t// Read path\n\t\t\tchunk.ReadNullString(str, 257);\n\t\t\tmpt::String::Copy(mptSmp.filename, str);\n\t\t\t// Ignore flags, they are all not relevant for us\n\t\t\tchunk.Skip(1);\n\t\t\t// Read filename / sample text\n\t\t\tchunk.ReadNullString(str, 31);\n\t\t\tmpt::String::Copy(m_szNames[actualSmp], str);\n\t\t\t// Seek to even boundary\n\t\t\tif(chunk.GetPosition() % 2u)\n\t\t\t\tchunk.Skip(1);\n\t\t}\n\n\t\tSTPSampleHeader sampleHeader;\n\t\tchunk.ReadStruct(sampleHeader);\n\t\tsampleHeader.ConvertToMPT(mptSmp);\n\n\t\tif(fileHeader.version == 2)\n\t\t{\n\t\t\tmptSmp.nFineTune = static_cast<int8>(sampleHeader.finetune << 3);\n\t\t}\n\n\t\tif(fileHeader.version >= 1)\n\t\t{\n\t\t\tnonLooped.resize(samplesInFile);\n\t\t\tloopInfo.resize(samplesInFile);\n\t\t\tSTPLoopList &loopList = loopInfo[actualSmp - 1];\n\t\t\tloopList.clear();\n\n\t\t\tuint16 numLoops = file.ReadUint16BE();\n\t\t\tloopList.reserve(numLoops);\n\n\t\t\tSTPLoopInfo loop;\n\t\t\tloop.looped = loop.nonLooped = 0;\n\n\t\t\tif(numLoops == 0 && mptSmp.uFlags[CHN_LOOP])\n\t\t\t{\n\t\t\t\tloop.loopStart  = mptSmp.nLoopStart;\n\t\t\t\tloop.loopLength = mptSmp.nLoopEnd - mptSmp.nLoopStart;\n\t\t\t\tloopList.push_back(loop);\n\t\t\t} else for(uint16 i = 0; i < numLoops; i++)\n\t\t\t{\n\t\t\t\tloop.loopStart  = file.ReadUint32BE();\n\t\t\t\tloop.loopLength = file.ReadUint32BE();\n\t\t\t\tloopList.push_back(loop);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Load patterns\n\tuint16 numPatterns = 128;\n\tif(fileHeader.version == 0)\n\t\tnumPatterns = file.ReadUint16BE();\n\n\tuint16 patternLength = fileHeader.patternLength;\n\tCHANNELINDEX channels = 4;\n\tif(fileHeader.version > 0)\n\t{\n\t\t// Scan for total number of channels\n\t\tFileReader::off_t patOffset = file.GetPosition();\n\t\tfor(uint16 pat = 0; pat < numPatterns; pat++)\n\t\t{\n\t\t\tPATTERNINDEX actualPat = file.ReadUint16BE();\n\t\t\tif(actualPat == 0xFFFF)\n\t\t\t\tbreak;\n\n\t\t\tpatternLength = file.ReadUint16BE();\n\t\t\tchannels = file.ReadUint16BE();\n\t\t\tm_nChannels = std::max(m_nChannels, channels);\n\n\t\t\tfile.Skip(channels * patternLength * 4u);\n\t\t}\n\t\tfile.Seek(patOffset);\n\t\tif(m_nChannels > MAX_BASECHANNELS)\n\t\t\treturn false;\n\t}\n\n\tstruct ChannelMemory\n\t{\n\t\tuint8 autoFinePorta, autoPortaUp, autoPortaDown, autoVolSlide, autoVibrato;\n\t\tuint8 vibratoMem, autoTremolo, autoTonePorta, tonePortaMem;\n\t};\n\tstd::vector<ChannelMemory> channelMemory(m_nChannels);\n\tuint8 globalVolSlide = 0;\n\tuint8 speedFrac = static_cast<uint8>(fileHeader.speedFrac);\n\n\tfor(uint16 pat = 0; pat < numPatterns; pat++)\n\t{\n\t\tPATTERNINDEX actualPat = pat;\n\n\t\tif(fileHeader.version > 0)\n\t\t{\n\t\t\tactualPat = file.ReadUint16BE();\n\t\t\tif(actualPat == 0xFFFF)\n\t\t\t\tbreak;\n\n\t\t\tpatternLength = file.ReadUint16BE();\n\t\t\tchannels = file.ReadUint16BE();\n\t\t}\n\n\t\tif(!(loadFlags & loadPatternData) || !Patterns.Insert(actualPat, patternLength))\n\t\t{\n\t\t\tfile.Skip(channels * patternLength * 4u);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(ROWINDEX row = 0; row < patternLength; row++)\n\t\t{\n\t\t\tauto rowBase = Patterns[actualPat].GetRow(row);\n\n\t\t\tbool didGlobalVolSlide = false;\n\n\t\t\t// if a fractional speed value is in use then determine if we should stick a fine pattern delay somewhere\n\t\t\tbool shouldDelay;\n\t\t\tswitch(speedFrac & 3)\n\t\t\t{\n\t\t\tdefault: shouldDelay = false; break;\n\t\t\t// 1/4\n\t\t\tcase 1: shouldDelay = (row & 3) == 0; break;\n\t\t\t// 1/2\n\t\t\tcase 2: shouldDelay = (row & 1) == 0; break;\n\t\t\t// 3/4\n\t\t\tcase 3: shouldDelay = (row & 3) != 3; break;\n\t\t\t}\n\n\t\t\tfor(CHANNELINDEX chn = 0; chn < channels; chn++)\n\t\t\t{\n\t\t\t\tChannelMemory &chnMem = channelMemory[chn];\n\t\t\t\tModCommand &m = rowBase[chn];\n\t\t\t\tuint8 data[4];\n\t\t\t\tfile.ReadArray(data);\n\n\t\t\t\tm.instr   = data[0];\n\t\t\t\tm.note    = data[1];\n\t\t\t\tm.command = data[2];\n\t\t\t\tm.param   = data[3];\n\n\t\t\t\tif(m.note)\n\t\t\t\t{\n\t\t\t\t\tm.note += 24 + NOTE_MIN;\n\t\t\t\t\tchnMem = ChannelMemory();\n\t\t\t\t}\n\n\t\t\t\t// this is a nibble-swapped param value used for auto fine volside\n\t\t\t\t// and auto global fine volside\n\t\t\t\tuint8 swapped = (m.param >> 4) | (m.param << 4);\n\n\t\t\t\tif((m.command & 0xF0) == 0xF0)\n\t\t\t\t{\n\t\t\t\t\t// 12-bit CIA tempo\n\t\t\t\t\tuint16 ciaTempo = (static_cast<uint16>(m.command & 0x0F) << 8) | m.param;\n\t\t\t\t\tif(ciaTempo)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.param = mpt::saturate_cast<ModCommand::PARAM>(Util::Round(ConvertTempo(ciaTempo).ToDouble()));\n\t\t\t\t\t\tm.command = CMD_TEMPO;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\t}\n\t\t\t\t} else switch(m.command)\n\t\t\t\t{\n\t\t\t\tcase 0x00: // arpeggio\n\t\t\t\t\tif(m.param)\n\t\t\t\t\t\tm.command = CMD_ARPEGGIO;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x01: // portamento up\n\t\t\t\t\tm.command = CMD_PORTAMENTOUP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x02: // portamento down\n\t\t\t\t\tm.command = CMD_PORTAMENTODOWN;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x03: // auto fine portamento up\n\t\t\t\t\tchnMem.autoFinePorta = 0x10 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tchnMem.autoPortaUp = 0;\n\t\t\t\t\tchnMem.autoPortaDown = 0;\n\t\t\t\t\tchnMem.autoTonePorta = 0;\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x04: // auto fine portamento down\n\t\t\t\t\tchnMem.autoFinePorta = 0x20 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tchnMem.autoPortaUp = 0;\n\t\t\t\t\tchnMem.autoPortaDown = 0;\n\t\t\t\t\tchnMem.autoTonePorta = 0;\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x05: // auto portamento up\n\t\t\t\t\tchnMem.autoFinePorta = 0;\n\t\t\t\t\tchnMem.autoPortaUp = m.param;\n\t\t\t\t\tchnMem.autoPortaDown = 0;\n\t\t\t\t\tchnMem.autoTonePorta = 0;\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x06: // auto portamento down\n\t\t\t\t\tchnMem.autoFinePorta = 0;\n\t\t\t\t\tchnMem.autoPortaUp = 0;\n\t\t\t\t\tchnMem.autoPortaDown = m.param;\n\t\t\t\t\tchnMem.autoTonePorta = 0;\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x07: // set global volume\n\t\t\t\t\tm.command = CMD_GLOBALVOLUME;\n\t\t\t\t\tglobalVolSlide = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x08: // auto global fine volume slide\n\t\t\t\t\tglobalVolSlide = swapped;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x09: // fine portamento up\n\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\tm.param = 0x10 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0A: // fine portamento down\n\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\tm.param = 0x20 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0B: // auto fine volume slide\n\t\t\t\t\tchnMem.autoVolSlide = swapped;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0C: // set volume\n\t\t\t\t\tm.volcmd = VOLCMD_VOLUME;\n\t\t\t\t\tm.vol = m.param;\n\t\t\t\t\tchnMem.autoVolSlide = 0;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0D: // volume slide (param is swapped compared to .mod)\n\t\t\t\t\tif(m.param & 0xF0)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.volcmd = VOLCMD_VOLSLIDEDOWN;\n\t\t\t\t\t\tm.vol = m.param >> 4;\n\t\t\t\t\t} else if(m.param & 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.volcmd = VOLCMD_VOLSLIDEUP;\n\t\t\t\t\t\tm.vol = m.param & 0xF;\n\t\t\t\t\t}\n\t\t\t\t\tchnMem.autoVolSlide = 0;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0E: // set filter (also uses opposite value compared to .mod)\n\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\tm.param = 1 ^ (m.param ? 1 : 0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0F: // set speed\n\t\t\t\t\tm.command = CMD_SPEED;\n\t\t\t\t\tspeedFrac = m.param & 0x0F;\n\t\t\t\t\tm.param >>= 4;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x10: // auto vibrato\n\t\t\t\t\tchnMem.autoVibrato = m.param;\n\t\t\t\t\tchnMem.vibratoMem = 0;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x11: // auto tremolo\n\t\t\t\t\tif(m.param & 0xF)\n\t\t\t\t\t\tchnMem.autoTremolo = m.param;\n\t\t\t\t\telse\n\t\t\t\t\t\tchnMem.autoTremolo = 0;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x12: // pattern break\n\t\t\t\t\tm.command = CMD_PATTERNBREAK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x13: // auto tone portamento\n\t\t\t\t\tchnMem.autoFinePorta = 0;\n\t\t\t\t\tchnMem.autoPortaUp = 0;\n\t\t\t\t\tchnMem.autoPortaDown = 0;\n\t\t\t\t\tchnMem.autoTonePorta = m.param;\n\n\t\t\t\t\tchnMem.tonePortaMem = 0;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x14: // position jump\n\t\t\t\t\tm.command = CMD_POSITIONJUMP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x16: // start loop sequence\n\t\t\t\t\tif(m.instr && m.instr <= loopInfo.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSTPLoopList &loopList = loopInfo[m.instr - 1];\n\n\t\t\t\t\t\tm.param--;\n\t\t\t\t\t\tif(m.param < std::min(mpt::size(ModSample().cues), loopList.size()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm.volcmd = VOLCMD_OFFSET;\n\t\t\t\t\t\t\tm.vol = m.param;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x17: // play only loop nn\n\t\t\t\t\tif(m.instr && m.instr <= loopInfo.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSTPLoopList &loopList = loopInfo[m.instr - 1];\n\n\t\t\t\t\t\tm.param--;\n\t\t\t\t\t\tif(m.param < loopList.size())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!loopList[m.param].looped && m_nSamples < MAX_SAMPLES - 1)\n\t\t\t\t\t\t\t\tloopList[m.param].looped = ++m_nSamples;\n\t\t\t\t\t\t\tm.instr = static_cast<ModCommand::INSTR>(loopList[m.param].looped);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x18: // play sequence without loop\n\t\t\t\t\tif(m.instr && m.instr <= loopInfo.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSTPLoopList &loopList = loopInfo[m.instr - 1];\n\n\t\t\t\t\t\tm.param--;\n\t\t\t\t\t\tif(m.param < std::min(mpt::size(ModSample().cues), loopList.size()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm.volcmd = VOLCMD_OFFSET;\n\t\t\t\t\t\t\tm.vol = m.param;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// switch to non-looped version of sample and create it if needed\n\t\t\t\t\t\tif(!nonLooped[m.instr - 1] && m_nSamples < MAX_SAMPLES - 1)\n\t\t\t\t\t\t\tnonLooped[m.instr - 1] = ++m_nSamples;\n\t\t\t\t\t\tm.instr = static_cast<ModCommand::INSTR>(nonLooped[m.instr - 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x19: // play only loop nn without loop\n\t\t\t\t\tif(m.instr && m.instr <= loopInfo.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSTPLoopList &loopList = loopInfo[m.instr - 1];\n\n\t\t\t\t\t\tm.param--;\n\t\t\t\t\t\tif(m.param < loopList.size())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!loopList[m.param].nonLooped && m_nSamples < MAX_SAMPLES-1)\n\t\t\t\t\t\t\t\tloopList[m.param].nonLooped = ++m_nSamples;\n\t\t\t\t\t\t\tm.instr = static_cast<ModCommand::INSTR>(loopList[m.param].nonLooped);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x1D: // fine volume slide (nibble order also swapped)\n\t\t\t\t\tm.command = CMD_VOLUMESLIDE;\n\t\t\t\t\tm.param = swapped;\n\t\t\t\t\tif(m.param & 0xF0) // slide down\n\t\t\t\t\t\tm.param |= 0x0F;\n\t\t\t\t\telse if(m.param & 0x0F)\n\t\t\t\t\t\tm.param |= 0xF0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x20: // \"delayed fade\"\n\t\t\t\t\t// just behave like either a normal fade or a notecut\n\t\t\t\t\t// depending on the speed\n\t\t\t\t\tif(m.param & 0xF0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchnMem.autoVolSlide = m.param >> 4;\n\t\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\t\tm.param = 0xC0 | (m.param & 0xF);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x21: // note delay\n\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\tm.param = 0xD0 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x22: // retrigger note\n\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\tm.param = 0x90 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x49: // set sample offset\n\t\t\t\t\tm.command = CMD_OFFSET;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x4E: // other protracker commands (pattern loop / delay)\n\t\t\t\t\tif((m.param & 0xF0) == 0x60 || (m.param & 0xF0) == 0xE0)\n\t\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\telse\n\t\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x4F: // set speed/tempo\n\t\t\t\t\tif(m.param < 0x20)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_SPEED;\n\t\t\t\t\t\tspeedFrac = 0;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_TEMPO;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbool didVolSlide = false;\n\n\t\t\t\t// try to put volume slide in volume command\n\t\t\t\tif(chnMem.autoVolSlide && m.volcmd == VOLCMD_NONE)\n\t\t\t\t{\n\t\t\t\t\tif(chnMem.autoVolSlide & 0xF0)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.volcmd = VOLCMD_FINEVOLUP;\n\t\t\t\t\t\tm.vol = chnMem.autoVolSlide >> 4;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tm.volcmd = VOLCMD_FINEVOLDOWN;\n\t\t\t\t\t\tm.vol = chnMem.autoVolSlide & 0xF;\n\t\t\t\t\t}\n\t\t\t\t\tdidVolSlide = true;\n\t\t\t\t}\n\n\t\t\t\t// try to place/combine all remaining running effects.\n\t\t\t\tif(m.command == CMD_NONE)\n\t\t\t\t{\n\t\t\t\t\tif(chnMem.autoPortaUp)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_PORTAMENTOUP;\n\t\t\t\t\t\tm.param = chnMem.autoPortaUp;\n\n\t\t\t\t\t} else if(chnMem.autoPortaDown)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_PORTAMENTODOWN;\n\t\t\t\t\t\tm.param = chnMem.autoPortaDown;\n\t\t\t\t\t} else if(chnMem.autoFinePorta)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\t\tm.param = chnMem.autoFinePorta;\n\n\t\t\t\t\t} else if(chnMem.autoTonePorta)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_TONEPORTAMENTO;\n\t\t\t\t\t\tm.param = chnMem.tonePortaMem = chnMem.autoTonePorta;\n\n\t\t\t\t\t} else if(chnMem.autoVibrato)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_VIBRATO;\n\t\t\t\t\t\tm.param = chnMem.vibratoMem = chnMem.autoVibrato;\n\n\t\t\t\t\t} else if(!didVolSlide && chnMem.autoVolSlide)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_VOLUMESLIDE;\n\t\t\t\t\t\tm.param = chnMem.autoVolSlide;\n\t\t\t\t\t\t// convert to a \"fine\" value by setting the other nibble to 0xF\n\t\t\t\t\t\tif(m.param & 0x0F)\n\t\t\t\t\t\t\tm.param |= 0xF0;\n\t\t\t\t\t\telse if(m.param & 0xF0)\n\t\t\t\t\t\t\tm.param |= 0x0F;\n\t\t\t\t\t\tdidVolSlide = true;\n\n\t\t\t\t\t} else if(chnMem.autoTremolo)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_TREMOLO;\n\t\t\t\t\t\tm.param = chnMem.autoTremolo;\n\n\t\t\t\t\t} else if(shouldDelay)\n\t\t\t\t\t{\n\t\t\t\t\t\t// insert a fine pattern delay here\n\t\t\t\t\t\tm.command = CMD_S3MCMDEX;\n\t\t\t\t\t\tm.param = 0x61;\n\t\t\t\t\t\tshouldDelay = false;\n\n\t\t\t\t\t} else if(!didGlobalVolSlide && globalVolSlide)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_GLOBALVOLSLIDE;\n\t\t\t\t\t\tm.param = globalVolSlide;\n\t\t\t\t\t\t// convert to a \"fine\" value by setting the other nibble to 0xF\n\t\t\t\t\t\tif(m.param & 0x0F)\n\t\t\t\t\t\t\tm.param |= 0xF0;\n\t\t\t\t\t\telse if(m.param & 0xF0)\n\t\t\t\t\t\t\tm.param |= 0x0F;\n\n\t\t\t\t\t\tdidGlobalVolSlide = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: create/use extra channels for global volslide/delay if needed\n\t\t}\n\t}\n\n\t// after we know how many channels there really are...\n\tm_nSamplePreAmp = 256 / m_nChannels;\n\t// Setup channel pan positions and volume\n\tSetupMODPanning(true);\n\n\t// Skip over scripts and drumpad info\n\tif(fileHeader.version > 0)\n\t{\n\t\twhile(file.CanRead(2))\n\t\t{\n\t\t\tuint16 scriptNum = file.ReadUint16BE();\n\t\t\tif(scriptNum == 0xFFFF)\n\t\t\t\tbreak;\n\n\t\t\tfile.Skip(2);\n\t\t\tuint32 length = file.ReadUint32BE();\n\t\t\tfile.Skip(length);\n\t\t}\n\n\t\t// Skip drumpad stuff\n\t\tfile.Skip(17 * 2);\n\t}\n\n\t// Reading samples\n\tif(loadFlags & loadSampleData)\n\t{\n\t\tfor(SAMPLEINDEX smp = 1; smp <= samplesInFile; smp++) if(Samples[smp].nLength)\n\t\t{\n\t\t\tSampleIO(\n\t\t\t\tSampleIO::_8bit,\n\t\t\t\tSampleIO::mono,\n\t\t\t\tSampleIO::littleEndian,\n\t\t\t\tSampleIO::signedPCM)\n\t\t\t\t.ReadSample(Samples[smp], file);\n\n\t\t\tif(smp > loopInfo.size())\n\t\t\t\tcontinue;\n\n\t\t\tConvertLoopSequence(Samples[smp], loopInfo[smp - 1]);\n\n\t\t\t// make a non-looping duplicate of this sample if needed\n\t\t\tif(nonLooped[smp - 1])\n\t\t\t{\n\t\t\t\tConvertLoopSlice(Samples[smp], Samples[nonLooped[smp - 1]], 0, Samples[smp].nLength, false);\n\t\t\t}\n\n\t\t\tfor(const auto &info : loopInfo[smp - 1])\n\t\t\t{\n\t\t\t\t// make duplicate samples for this individual section if needed\n\t\t\t\tif(info.looped)\n\t\t\t\t{\n\t\t\t\t\tConvertLoopSlice(Samples[smp], Samples[info.looped], info.loopStart, info.loopLength, true);\n\t\t\t\t}\n\t\t\t\tif(info.nonLooped)\n\t\t\t\t{\n\t\t\t\t\tConvertLoopSlice(Samples[smp], Samples[info.nonLooped], info.loopStart, info.loopLength, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nOPENMPT_NAMESPACE_END\n"], "fixing_code": ["/*\n * Load_stp.cpp\n * ------------\n * Purpose: STP (Soundtracker Pro II) module loader\n * Notes  : A few exotic effects aren't supported.\n *          Multiple sample loops are supported, but only the first 10 can be used as cue points\n *          (with 16xx and 18xx).\n *          Fractional speed values and combined auto effects are handled whenever possible,\n *          but some effects may be omitted (and there may be tempo accuracy issues).\n * Authors: Devin Acker\n *          OpenMPT Devs\n * The OpenMPT source code is released under the BSD license. Read LICENSE for more details.\n *\n * Wisdom from the Soundtracker Pro II manual:\n * \"To create shorter patterns, simply create shorter patterns.\"\n */\n\n#include \"stdafx.h\"\n#include \"Loaders.h\"\n\nOPENMPT_NAMESPACE_BEGIN\n\n// File header\nstruct STPFileHeader\n{\n\tchar     magic[4];\n\tuint16be version;\n\tuint8be  numOrders;\n\tuint8be  patternLength;\n\tuint8be  orderList[128];\n\tuint16be speed;\n\tuint16be speedFrac;\n\tuint16be timerCount;\n\tuint16be flags;\n\tuint32be reserved;\n\tuint16be midiCount; // always 50\n\tuint8be  midi[50];\n\tuint16be numSamples;\n\tuint16be sampleStructSize;\n};\n\nMPT_BINARY_STRUCT(STPFileHeader, 204)\n\n\n// Sample header (common part between all versions)\nstruct STPSampleHeader\n{\n\tuint32be length;\n\tuint8be  volume;\n\tuint8be  reserved1;\n\tuint32be loopStart;\n\tuint32be loopLength;\n\tuint16be defaultCommand;\t// Default command to put next to note when editing patterns; not relevant for playback\n\t// The following 4 bytes are reserved in version 0 and 1.\n\tuint16be defaultPeriod;\n\tuint8be  finetune;\n\tuint8be  reserved2;\n\n\tvoid ConvertToMPT(ModSample &mptSmp) const\n\t{\n\t\tmptSmp.nLength = length;\n\t\tmptSmp.nVolume = 4u * std::min<uint16>(volume, 64);\n\n\t\tmptSmp.nLoopStart = loopStart;\n\t\tmptSmp.nLoopEnd = loopStart + loopLength;\n\n\t\tif(mptSmp.nLoopStart >= mptSmp.nLength)\n\t\t{\n\t\t\tmptSmp.nLoopStart = mptSmp.nLength - 1;\n\t\t}\n\t\tif(mptSmp.nLoopEnd > mptSmp.nLength)\n\t\t{\n\t\t\tmptSmp.nLoopEnd = mptSmp.nLength;\n\t\t}\n\n\t\tif(mptSmp.nLoopStart > mptSmp.nLoopEnd)\n\t\t{\n\t\t\tmptSmp.nLoopStart = 0;\n\t\t\tmptSmp.nLoopEnd = 0;\n\t\t} else if(mptSmp.nLoopEnd > mptSmp.nLoopStart)\n\t\t{\n\t\t\tmptSmp.uFlags.set(CHN_LOOP);\n\t\t\tmptSmp.cues[0] = mptSmp.nLoopStart;\n\t\t}\n\t}\n};\n\nMPT_BINARY_STRUCT(STPSampleHeader, 20)\n\n\nstruct STPLoopInfo\n{\n\tSmpLength loopStart;\n\tSmpLength loopLength;\n\tSAMPLEINDEX looped;\n\tSAMPLEINDEX nonLooped;\n};\n\ntypedef std::vector<STPLoopInfo> STPLoopList;\n\n\nstatic TEMPO ConvertTempo(uint16 ciaSpeed)\n{\n\t// 3546 is the resulting CIA timer value when using 4F7D (tempo 125 bpm) command in STProII\n\treturn TEMPO((125.0 * 3546.0) / ciaSpeed);\n}\n\n\nstatic void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)\n{\n\tif(!src.HasSampleData()\n\t\t|| start >= src.nLength\n\t\t|| src.nLength - start < len)\n\t{\n\t\treturn;\n\t}\n\n\tdest.FreeSample();\n\tdest = src;\n\tdest.nLength = len;\n\tdest.pSample = nullptr;\n\n\tif(!dest.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\n\t// only preserve cue points if the target sample length is the same\n\tif(len != src.nLength)\n\t\tMemsetZero(dest.cues);\n\n\tstd::memcpy(dest.pSample8, src.pSample8 + start, len);\n\tdest.uFlags.set(CHN_LOOP, loop);\n\tif(loop)\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = len;\n\t} else\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = 0;\n\t}\n}\n\nstatic void ConvertLoopSequence(ModSample &smp, STPLoopList &loopList)\n{\n\t// This should only modify a sample if it has more than one loop\n\t// (otherwise, it behaves like a normal sample loop)\n\tif(!smp.HasSampleData() || loopList.size() < 2) return;\n\n\tModSample newSmp = smp;\n\tnewSmp.nLength = 0;\n\tnewSmp.pSample = nullptr;\n\n\tsize_t numLoops = loopList.size();\n\n\t// Get the total length of the sample after combining all looped sections\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\n\t\t// If adding this loop would cause the sample length to exceed maximum,\n\t\t// then limit and bail out\n\t\tif(info.loopStart >= smp.nLength\n\t\t\t|| smp.nLength - info.loopStart < info.loopLength\n\t\t\t|| newSmp.nLength > MAX_SAMPLE_LENGTH - info.loopLength)\n\t\t{\n\t\t\tnumLoops = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tnewSmp.nLength += info.loopLength;\n\t}\n\n\tif(!newSmp.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\n\t// start copying the looped sample data parts\n\tSmpLength start = 0;\n\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\n\t\tmemcpy(newSmp.pSample8 + start, smp.pSample8 + info.loopStart, info.loopLength);\n\n\t\t// update loop info based on position in edited sample\n\t\tinfo.loopStart = start;\n\t\tif(i > 0 && i <= mpt::size(newSmp.cues))\n\t\t{\n\t\t\tnewSmp.cues[i - 1] = start;\n\t\t}\n\t\tstart += info.loopLength;\n\t}\n\n\t// replace old sample with new one\n\tsmp.FreeSample();\n\tsmp = newSmp;\n\n\tsmp.nLoopStart = 0;\n\tsmp.nLoopEnd = smp.nLength;\n\tsmp.uFlags.set(CHN_LOOP);\n}\n\n\nstatic bool ValidateHeader(const STPFileHeader &fileHeader)\n{\n\tif(std::memcmp(fileHeader.magic, \"STP3\", 4)\n\t\t|| fileHeader.version > 2\n\t\t|| fileHeader.numOrders > 128\n\t\t|| fileHeader.numSamples >= MAX_SAMPLES\n\t\t|| fileHeader.timerCount == 0\n\t\t|| fileHeader.midiCount != 50)\n\t{\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nCSoundFile::ProbeResult CSoundFile::ProbeFileHeaderSTP(MemoryFileReader file, const uint64 *pfilesize)\n{\n\tSTPFileHeader fileHeader;\n\tif(!file.ReadStruct(fileHeader))\n\t{\n\t\treturn ProbeWantMoreData;\n\t}\n\tif(!ValidateHeader(fileHeader))\n\t{\n\t\treturn ProbeFailure;\n\t}\n\tMPT_UNREFERENCED_PARAMETER(pfilesize);\n\treturn ProbeSuccess;\n}\n\n\nbool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n{\n\tfile.Rewind();\n\n\tSTPFileHeader fileHeader;\n\tif(!file.ReadStruct(fileHeader))\n\t{\n\t\treturn false;\n\t}\n\tif(!ValidateHeader(fileHeader))\n\t{\n\t\treturn false;\n\t}\n\tif(loadFlags == onlyVerifyHeader)\n\t{\n\t\treturn true;\n\t}\n\n\tInitializeGlobals(MOD_TYPE_STP);\n\n\tm_nChannels = 4;\n\tm_nSamples = 0;\n\n\tm_nDefaultSpeed = fileHeader.speed;\n\tm_nDefaultTempo = ConvertTempo(fileHeader.timerCount);\n\n\tm_nMinPeriod = 14 * 4;\n\tm_nMaxPeriod = 3424 * 4;\n\n\tReadOrderFromArray(Order(), fileHeader.orderList, fileHeader.numOrders);\n\n\tstd::vector<STPLoopList> loopInfo;\n\t// Non-looped versions of samples with loops (when needed)\n\tstd::vector<SAMPLEINDEX> nonLooped;\n\n\t// Load sample headers\n\tSAMPLEINDEX samplesInFile = 0;\n\n\tfor(SAMPLEINDEX smp = 0; smp < fileHeader.numSamples; smp++)\n\t{\n\t\tSAMPLEINDEX actualSmp = file.ReadUint16BE();\n\t\tif(actualSmp == 0 || actualSmp >= MAX_SAMPLES)\n\t\t\treturn false;\n\t\tuint32 chunkSize = fileHeader.sampleStructSize;\n\t\tif(fileHeader.version == 2)\n\t\t\tchunkSize = file.ReadUint32BE() - 2;\n\t\tFileReader chunk = file.ReadChunk(chunkSize);\n\n\t\tsamplesInFile = m_nSamples = std::max(m_nSamples, actualSmp);\n\n\t\tModSample &mptSmp = Samples[actualSmp];\n\t\tmptSmp.Initialize(MOD_TYPE_MOD);\n\n\t\tif(fileHeader.version < 2)\n\t\t{\n\t\t\t// Read path\n\t\t\tchunk.ReadString<mpt::String::maybeNullTerminated>(mptSmp.filename, 31);\n\t\t\t// Ignore flags, they are all not relevant for us\n\t\t\tchunk.Skip(1);\n\t\t\t// Read filename / sample text\n\t\t\tchunk.ReadString<mpt::String::maybeNullTerminated>(m_szNames[actualSmp], 30);\n\t\t} else\n\t\t{\n\t\t\tstd::string str;\n\t\t\t// Read path\n\t\t\tchunk.ReadNullString(str, 257);\n\t\t\tmpt::String::Copy(mptSmp.filename, str);\n\t\t\t// Ignore flags, they are all not relevant for us\n\t\t\tchunk.Skip(1);\n\t\t\t// Read filename / sample text\n\t\t\tchunk.ReadNullString(str, 31);\n\t\t\tmpt::String::Copy(m_szNames[actualSmp], str);\n\t\t\t// Seek to even boundary\n\t\t\tif(chunk.GetPosition() % 2u)\n\t\t\t\tchunk.Skip(1);\n\t\t}\n\n\t\tSTPSampleHeader sampleHeader;\n\t\tchunk.ReadStruct(sampleHeader);\n\t\tsampleHeader.ConvertToMPT(mptSmp);\n\n\t\tif(fileHeader.version == 2)\n\t\t{\n\t\t\tmptSmp.nFineTune = static_cast<int8>(sampleHeader.finetune << 3);\n\t\t}\n\n\t\tif(fileHeader.version >= 1)\n\t\t{\n\t\t\tnonLooped.resize(samplesInFile);\n\t\t\tloopInfo.resize(samplesInFile);\n\t\t\tSTPLoopList &loopList = loopInfo[actualSmp - 1];\n\t\t\tloopList.clear();\n\n\t\t\tuint16 numLoops = file.ReadUint16BE();\n\t\t\tloopList.reserve(numLoops);\n\n\t\t\tSTPLoopInfo loop;\n\t\t\tloop.looped = loop.nonLooped = 0;\n\n\t\t\tif(numLoops == 0 && mptSmp.uFlags[CHN_LOOP])\n\t\t\t{\n\t\t\t\tloop.loopStart  = mptSmp.nLoopStart;\n\t\t\t\tloop.loopLength = mptSmp.nLoopEnd - mptSmp.nLoopStart;\n\t\t\t\tloopList.push_back(loop);\n\t\t\t} else for(uint16 i = 0; i < numLoops; i++)\n\t\t\t{\n\t\t\t\tloop.loopStart  = file.ReadUint32BE();\n\t\t\t\tloop.loopLength = file.ReadUint32BE();\n\t\t\t\tloopList.push_back(loop);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Load patterns\n\tuint16 numPatterns = 128;\n\tif(fileHeader.version == 0)\n\t\tnumPatterns = file.ReadUint16BE();\n\n\tuint16 patternLength = fileHeader.patternLength;\n\tCHANNELINDEX channels = 4;\n\tif(fileHeader.version > 0)\n\t{\n\t\t// Scan for total number of channels\n\t\tFileReader::off_t patOffset = file.GetPosition();\n\t\tfor(uint16 pat = 0; pat < numPatterns; pat++)\n\t\t{\n\t\t\tPATTERNINDEX actualPat = file.ReadUint16BE();\n\t\t\tif(actualPat == 0xFFFF)\n\t\t\t\tbreak;\n\n\t\t\tpatternLength = file.ReadUint16BE();\n\t\t\tchannels = file.ReadUint16BE();\n\t\t\tm_nChannels = std::max(m_nChannels, channels);\n\n\t\t\tfile.Skip(channels * patternLength * 4u);\n\t\t}\n\t\tfile.Seek(patOffset);\n\t\tif(m_nChannels > MAX_BASECHANNELS)\n\t\t\treturn false;\n\t}\n\n\tstruct ChannelMemory\n\t{\n\t\tuint8 autoFinePorta, autoPortaUp, autoPortaDown, autoVolSlide, autoVibrato;\n\t\tuint8 vibratoMem, autoTremolo, autoTonePorta, tonePortaMem;\n\t};\n\tstd::vector<ChannelMemory> channelMemory(m_nChannels);\n\tuint8 globalVolSlide = 0;\n\tuint8 speedFrac = static_cast<uint8>(fileHeader.speedFrac);\n\n\tfor(uint16 pat = 0; pat < numPatterns; pat++)\n\t{\n\t\tPATTERNINDEX actualPat = pat;\n\n\t\tif(fileHeader.version > 0)\n\t\t{\n\t\t\tactualPat = file.ReadUint16BE();\n\t\t\tif(actualPat == 0xFFFF)\n\t\t\t\tbreak;\n\n\t\t\tpatternLength = file.ReadUint16BE();\n\t\t\tchannels = file.ReadUint16BE();\n\t\t}\n\n\t\tif(!(loadFlags & loadPatternData) || !Patterns.Insert(actualPat, patternLength))\n\t\t{\n\t\t\tfile.Skip(channels * patternLength * 4u);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(ROWINDEX row = 0; row < patternLength; row++)\n\t\t{\n\t\t\tauto rowBase = Patterns[actualPat].GetRow(row);\n\n\t\t\tbool didGlobalVolSlide = false;\n\n\t\t\t// if a fractional speed value is in use then determine if we should stick a fine pattern delay somewhere\n\t\t\tbool shouldDelay;\n\t\t\tswitch(speedFrac & 3)\n\t\t\t{\n\t\t\tdefault: shouldDelay = false; break;\n\t\t\t// 1/4\n\t\t\tcase 1: shouldDelay = (row & 3) == 0; break;\n\t\t\t// 1/2\n\t\t\tcase 2: shouldDelay = (row & 1) == 0; break;\n\t\t\t// 3/4\n\t\t\tcase 3: shouldDelay = (row & 3) != 3; break;\n\t\t\t}\n\n\t\t\tfor(CHANNELINDEX chn = 0; chn < channels; chn++)\n\t\t\t{\n\t\t\t\tChannelMemory &chnMem = channelMemory[chn];\n\t\t\t\tModCommand &m = rowBase[chn];\n\t\t\t\tuint8 data[4];\n\t\t\t\tfile.ReadArray(data);\n\n\t\t\t\tm.instr   = data[0];\n\t\t\t\tm.note    = data[1];\n\t\t\t\tm.command = data[2];\n\t\t\t\tm.param   = data[3];\n\n\t\t\t\tif(m.note)\n\t\t\t\t{\n\t\t\t\t\tm.note += 24 + NOTE_MIN;\n\t\t\t\t\tchnMem = ChannelMemory();\n\t\t\t\t}\n\n\t\t\t\t// this is a nibble-swapped param value used for auto fine volside\n\t\t\t\t// and auto global fine volside\n\t\t\t\tuint8 swapped = (m.param >> 4) | (m.param << 4);\n\n\t\t\t\tif((m.command & 0xF0) == 0xF0)\n\t\t\t\t{\n\t\t\t\t\t// 12-bit CIA tempo\n\t\t\t\t\tuint16 ciaTempo = (static_cast<uint16>(m.command & 0x0F) << 8) | m.param;\n\t\t\t\t\tif(ciaTempo)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.param = mpt::saturate_cast<ModCommand::PARAM>(Util::Round(ConvertTempo(ciaTempo).ToDouble()));\n\t\t\t\t\t\tm.command = CMD_TEMPO;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\t}\n\t\t\t\t} else switch(m.command)\n\t\t\t\t{\n\t\t\t\tcase 0x00: // arpeggio\n\t\t\t\t\tif(m.param)\n\t\t\t\t\t\tm.command = CMD_ARPEGGIO;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x01: // portamento up\n\t\t\t\t\tm.command = CMD_PORTAMENTOUP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x02: // portamento down\n\t\t\t\t\tm.command = CMD_PORTAMENTODOWN;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x03: // auto fine portamento up\n\t\t\t\t\tchnMem.autoFinePorta = 0x10 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tchnMem.autoPortaUp = 0;\n\t\t\t\t\tchnMem.autoPortaDown = 0;\n\t\t\t\t\tchnMem.autoTonePorta = 0;\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x04: // auto fine portamento down\n\t\t\t\t\tchnMem.autoFinePorta = 0x20 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tchnMem.autoPortaUp = 0;\n\t\t\t\t\tchnMem.autoPortaDown = 0;\n\t\t\t\t\tchnMem.autoTonePorta = 0;\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x05: // auto portamento up\n\t\t\t\t\tchnMem.autoFinePorta = 0;\n\t\t\t\t\tchnMem.autoPortaUp = m.param;\n\t\t\t\t\tchnMem.autoPortaDown = 0;\n\t\t\t\t\tchnMem.autoTonePorta = 0;\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x06: // auto portamento down\n\t\t\t\t\tchnMem.autoFinePorta = 0;\n\t\t\t\t\tchnMem.autoPortaUp = 0;\n\t\t\t\t\tchnMem.autoPortaDown = m.param;\n\t\t\t\t\tchnMem.autoTonePorta = 0;\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x07: // set global volume\n\t\t\t\t\tm.command = CMD_GLOBALVOLUME;\n\t\t\t\t\tglobalVolSlide = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x08: // auto global fine volume slide\n\t\t\t\t\tglobalVolSlide = swapped;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x09: // fine portamento up\n\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\tm.param = 0x10 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0A: // fine portamento down\n\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\tm.param = 0x20 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0B: // auto fine volume slide\n\t\t\t\t\tchnMem.autoVolSlide = swapped;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0C: // set volume\n\t\t\t\t\tm.volcmd = VOLCMD_VOLUME;\n\t\t\t\t\tm.vol = m.param;\n\t\t\t\t\tchnMem.autoVolSlide = 0;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0D: // volume slide (param is swapped compared to .mod)\n\t\t\t\t\tif(m.param & 0xF0)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.volcmd = VOLCMD_VOLSLIDEDOWN;\n\t\t\t\t\t\tm.vol = m.param >> 4;\n\t\t\t\t\t} else if(m.param & 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.volcmd = VOLCMD_VOLSLIDEUP;\n\t\t\t\t\t\tm.vol = m.param & 0xF;\n\t\t\t\t\t}\n\t\t\t\t\tchnMem.autoVolSlide = 0;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0E: // set filter (also uses opposite value compared to .mod)\n\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\tm.param = 1 ^ (m.param ? 1 : 0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0F: // set speed\n\t\t\t\t\tm.command = CMD_SPEED;\n\t\t\t\t\tspeedFrac = m.param & 0x0F;\n\t\t\t\t\tm.param >>= 4;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x10: // auto vibrato\n\t\t\t\t\tchnMem.autoVibrato = m.param;\n\t\t\t\t\tchnMem.vibratoMem = 0;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x11: // auto tremolo\n\t\t\t\t\tif(m.param & 0xF)\n\t\t\t\t\t\tchnMem.autoTremolo = m.param;\n\t\t\t\t\telse\n\t\t\t\t\t\tchnMem.autoTremolo = 0;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x12: // pattern break\n\t\t\t\t\tm.command = CMD_PATTERNBREAK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x13: // auto tone portamento\n\t\t\t\t\tchnMem.autoFinePorta = 0;\n\t\t\t\t\tchnMem.autoPortaUp = 0;\n\t\t\t\t\tchnMem.autoPortaDown = 0;\n\t\t\t\t\tchnMem.autoTonePorta = m.param;\n\n\t\t\t\t\tchnMem.tonePortaMem = 0;\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x14: // position jump\n\t\t\t\t\tm.command = CMD_POSITIONJUMP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x16: // start loop sequence\n\t\t\t\t\tif(m.instr && m.instr <= loopInfo.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSTPLoopList &loopList = loopInfo[m.instr - 1];\n\n\t\t\t\t\t\tm.param--;\n\t\t\t\t\t\tif(m.param < std::min(mpt::size(ModSample().cues), loopList.size()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm.volcmd = VOLCMD_OFFSET;\n\t\t\t\t\t\t\tm.vol = m.param;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x17: // play only loop nn\n\t\t\t\t\tif(m.instr && m.instr <= loopInfo.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSTPLoopList &loopList = loopInfo[m.instr - 1];\n\n\t\t\t\t\t\tm.param--;\n\t\t\t\t\t\tif(m.param < loopList.size())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!loopList[m.param].looped && m_nSamples < MAX_SAMPLES - 1)\n\t\t\t\t\t\t\t\tloopList[m.param].looped = ++m_nSamples;\n\t\t\t\t\t\t\tm.instr = static_cast<ModCommand::INSTR>(loopList[m.param].looped);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x18: // play sequence without loop\n\t\t\t\t\tif(m.instr && m.instr <= loopInfo.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSTPLoopList &loopList = loopInfo[m.instr - 1];\n\n\t\t\t\t\t\tm.param--;\n\t\t\t\t\t\tif(m.param < std::min(mpt::size(ModSample().cues), loopList.size()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm.volcmd = VOLCMD_OFFSET;\n\t\t\t\t\t\t\tm.vol = m.param;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// switch to non-looped version of sample and create it if needed\n\t\t\t\t\t\tif(!nonLooped[m.instr - 1] && m_nSamples < MAX_SAMPLES - 1)\n\t\t\t\t\t\t\tnonLooped[m.instr - 1] = ++m_nSamples;\n\t\t\t\t\t\tm.instr = static_cast<ModCommand::INSTR>(nonLooped[m.instr - 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x19: // play only loop nn without loop\n\t\t\t\t\tif(m.instr && m.instr <= loopInfo.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSTPLoopList &loopList = loopInfo[m.instr - 1];\n\n\t\t\t\t\t\tm.param--;\n\t\t\t\t\t\tif(m.param < loopList.size())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!loopList[m.param].nonLooped && m_nSamples < MAX_SAMPLES-1)\n\t\t\t\t\t\t\t\tloopList[m.param].nonLooped = ++m_nSamples;\n\t\t\t\t\t\t\tm.instr = static_cast<ModCommand::INSTR>(loopList[m.param].nonLooped);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x1D: // fine volume slide (nibble order also swapped)\n\t\t\t\t\tm.command = CMD_VOLUMESLIDE;\n\t\t\t\t\tm.param = swapped;\n\t\t\t\t\tif(m.param & 0xF0) // slide down\n\t\t\t\t\t\tm.param |= 0x0F;\n\t\t\t\t\telse if(m.param & 0x0F)\n\t\t\t\t\t\tm.param |= 0xF0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x20: // \"delayed fade\"\n\t\t\t\t\t// just behave like either a normal fade or a notecut\n\t\t\t\t\t// depending on the speed\n\t\t\t\t\tif(m.param & 0xF0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchnMem.autoVolSlide = m.param >> 4;\n\t\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\t\tm.param = 0xC0 | (m.param & 0xF);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x21: // note delay\n\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\tm.param = 0xD0 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x22: // retrigger note\n\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\tm.param = 0x90 | std::min(m.param, ModCommand::PARAM(15));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x49: // set sample offset\n\t\t\t\t\tm.command = CMD_OFFSET;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x4E: // other protracker commands (pattern loop / delay)\n\t\t\t\t\tif((m.param & 0xF0) == 0x60 || (m.param & 0xF0) == 0xE0)\n\t\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\telse\n\t\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x4F: // set speed/tempo\n\t\t\t\t\tif(m.param < 0x20)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_SPEED;\n\t\t\t\t\t\tspeedFrac = 0;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_TEMPO;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tm.command = CMD_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbool didVolSlide = false;\n\n\t\t\t\t// try to put volume slide in volume command\n\t\t\t\tif(chnMem.autoVolSlide && m.volcmd == VOLCMD_NONE)\n\t\t\t\t{\n\t\t\t\t\tif(chnMem.autoVolSlide & 0xF0)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.volcmd = VOLCMD_FINEVOLUP;\n\t\t\t\t\t\tm.vol = chnMem.autoVolSlide >> 4;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tm.volcmd = VOLCMD_FINEVOLDOWN;\n\t\t\t\t\t\tm.vol = chnMem.autoVolSlide & 0xF;\n\t\t\t\t\t}\n\t\t\t\t\tdidVolSlide = true;\n\t\t\t\t}\n\n\t\t\t\t// try to place/combine all remaining running effects.\n\t\t\t\tif(m.command == CMD_NONE)\n\t\t\t\t{\n\t\t\t\t\tif(chnMem.autoPortaUp)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_PORTAMENTOUP;\n\t\t\t\t\t\tm.param = chnMem.autoPortaUp;\n\n\t\t\t\t\t} else if(chnMem.autoPortaDown)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_PORTAMENTODOWN;\n\t\t\t\t\t\tm.param = chnMem.autoPortaDown;\n\t\t\t\t\t} else if(chnMem.autoFinePorta)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_MODCMDEX;\n\t\t\t\t\t\tm.param = chnMem.autoFinePorta;\n\n\t\t\t\t\t} else if(chnMem.autoTonePorta)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_TONEPORTAMENTO;\n\t\t\t\t\t\tm.param = chnMem.tonePortaMem = chnMem.autoTonePorta;\n\n\t\t\t\t\t} else if(chnMem.autoVibrato)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_VIBRATO;\n\t\t\t\t\t\tm.param = chnMem.vibratoMem = chnMem.autoVibrato;\n\n\t\t\t\t\t} else if(!didVolSlide && chnMem.autoVolSlide)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_VOLUMESLIDE;\n\t\t\t\t\t\tm.param = chnMem.autoVolSlide;\n\t\t\t\t\t\t// convert to a \"fine\" value by setting the other nibble to 0xF\n\t\t\t\t\t\tif(m.param & 0x0F)\n\t\t\t\t\t\t\tm.param |= 0xF0;\n\t\t\t\t\t\telse if(m.param & 0xF0)\n\t\t\t\t\t\t\tm.param |= 0x0F;\n\t\t\t\t\t\tdidVolSlide = true;\n\n\t\t\t\t\t} else if(chnMem.autoTremolo)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_TREMOLO;\n\t\t\t\t\t\tm.param = chnMem.autoTremolo;\n\n\t\t\t\t\t} else if(shouldDelay)\n\t\t\t\t\t{\n\t\t\t\t\t\t// insert a fine pattern delay here\n\t\t\t\t\t\tm.command = CMD_S3MCMDEX;\n\t\t\t\t\t\tm.param = 0x61;\n\t\t\t\t\t\tshouldDelay = false;\n\n\t\t\t\t\t} else if(!didGlobalVolSlide && globalVolSlide)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.command = CMD_GLOBALVOLSLIDE;\n\t\t\t\t\t\tm.param = globalVolSlide;\n\t\t\t\t\t\t// convert to a \"fine\" value by setting the other nibble to 0xF\n\t\t\t\t\t\tif(m.param & 0x0F)\n\t\t\t\t\t\t\tm.param |= 0xF0;\n\t\t\t\t\t\telse if(m.param & 0xF0)\n\t\t\t\t\t\t\tm.param |= 0x0F;\n\n\t\t\t\t\t\tdidGlobalVolSlide = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: create/use extra channels for global volslide/delay if needed\n\t\t}\n\t}\n\n\t// after we know how many channels there really are...\n\tm_nSamplePreAmp = 256 / m_nChannels;\n\t// Setup channel pan positions and volume\n\tSetupMODPanning(true);\n\n\t// Skip over scripts and drumpad info\n\tif(fileHeader.version > 0)\n\t{\n\t\twhile(file.CanRead(2))\n\t\t{\n\t\t\tuint16 scriptNum = file.ReadUint16BE();\n\t\t\tif(scriptNum == 0xFFFF)\n\t\t\t\tbreak;\n\n\t\t\tfile.Skip(2);\n\t\t\tuint32 length = file.ReadUint32BE();\n\t\t\tfile.Skip(length);\n\t\t}\n\n\t\t// Skip drumpad stuff\n\t\tfile.Skip(17 * 2);\n\t}\n\n\t// Reading samples\n\tif(loadFlags & loadSampleData)\n\t{\n\t\tfor(SAMPLEINDEX smp = 1; smp <= samplesInFile; smp++) if(Samples[smp].nLength)\n\t\t{\n\t\t\tSampleIO(\n\t\t\t\tSampleIO::_8bit,\n\t\t\t\tSampleIO::mono,\n\t\t\t\tSampleIO::littleEndian,\n\t\t\t\tSampleIO::signedPCM)\n\t\t\t\t.ReadSample(Samples[smp], file);\n\n\t\t\tif(smp > loopInfo.size())\n\t\t\t\tcontinue;\n\n\t\t\tConvertLoopSequence(Samples[smp], loopInfo[smp - 1]);\n\n\t\t\t// make a non-looping duplicate of this sample if needed\n\t\t\tif(nonLooped[smp - 1])\n\t\t\t{\n\t\t\t\tConvertLoopSlice(Samples[smp], Samples[nonLooped[smp - 1]], 0, Samples[smp].nLength, false);\n\t\t\t}\n\n\t\t\tfor(const auto &info : loopInfo[smp - 1])\n\t\t\t{\n\t\t\t\t// make duplicate samples for this individual section if needed\n\t\t\t\tif(info.looped)\n\t\t\t\t{\n\t\t\t\t\tConvertLoopSlice(Samples[smp], Samples[info.looped], info.loopStart, info.loopLength, true);\n\t\t\t\t}\n\t\t\t\tif(info.nonLooped)\n\t\t\t\t{\n\t\t\t\t\tConvertLoopSlice(Samples[smp], Samples[info.nonLooped], info.loopStart, info.loopLength, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nOPENMPT_NAMESPACE_END\n"], "filenames": ["soundlib/Load_stp.cpp"], "buggy_code_start_loc": [111], "buggy_code_end_loc": [162], "fixing_code_start_loc": [111], "fixing_code_end_loc": [167], "type": "CWE-125", "message": "soundlib/Load_stp.cpp in OpenMPT through 1.27.04.00, and libopenmpt before 0.3.6, has an out-of-bounds read via a malformed STP file.", "other": {"cve": {"id": "CVE-2018-6611", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-04T12:29:00.317", "lastModified": "2020-10-15T14:25:58.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "soundlib/Load_stp.cpp in OpenMPT through 1.27.04.00, and libopenmpt before 0.3.6, has an out-of-bounds read via a malformed STP file."}, {"lang": "es", "value": "soundlib/Load_stp.cpp en OpenMPT hasta la versi\u00f3n 1.27.04.00 y libopenmpt en versiones anteriores a la 0.3.6 tienen una lectura fuera de l\u00edmites mediante un archivo STP mal formado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openmpt:libopenmpt:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.6", "matchCriteriaId": "ABE5289E-3AA5-4CEA-BE48-7B9DFCB753BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openmpt:openmpt:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.27.04.00", "matchCriteriaId": "54FE0A63-6CCC-45EB-A9EB-55CA2F8358FF"}]}]}], "references": [{"url": "https://github.com/OpenMPT/openmpt/commit/b60b322cf9f0ffa624018f1bb9783edf0dc908c3", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lib.openmpt.org/libopenmpt/2018/02/03/security-update-0.3.6/", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OpenMPT/openmpt/commit/b60b322cf9f0ffa624018f1bb9783edf0dc908c3"}}