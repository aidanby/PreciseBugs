{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre, Romain Bouqueau, Cyril Concolato\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/constants.h>\n#include <gpac/mpeg4_odf.h>\n#include <gpac/maths.h>\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_OGG\n#include <gpac/internal/ogg.h>\n#endif\n\n//uncomment/define globally to remove all bitstream parsing logging from code (this will break inspect mode ananlyze=bs)\n//#define GPAC_DISABLE_AVPARSE_LOGS\n\n#ifndef GPAC_DISABLE_AVPARSE_LOGS\nvoid gf_bs_log_idx(GF_BitStream *bs, u32 nBits, const char *fname, s64 val, s32 idx1, s32 idx2, s32 idx3);\n\n#define gf_bs_log(_bs, _nBits, _fname, _val) gf_bs_log_idx(_bs, _nBits, _fname, _val, -1, -1, -1)\n\nu32 gf_bs_read_int_log_idx3(GF_BitStream *bs, u32 nBits, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val = gf_bs_read_int(bs, nBits);\n\tgf_bs_log_idx(bs, nBits, fname, val, idx1, idx2, idx3);\n\treturn val;\n}\n\n#define gf_bs_read_int_log(_bs, _nBits, _fname) gf_bs_read_int_log_idx3(_bs, _nBits, _fname, -1, -1, -1)\n#define gf_bs_read_int_log_idx(_bs, _nBits, _fname, _idx) gf_bs_read_int_log_idx3(_bs, _nBits, _fname, _idx, -1, -1)\n#define gf_bs_read_int_log_idx2(_bs, _nBits, _fname, _idx1, _idx2) gf_bs_read_int_log_idx3(_bs, _nBits, _fname, (s32) _idx1, (s32) _idx2, -1)\n\n\n#else\n\n#define gf_bs_log(_bs, _nBits, _fname, _val)\n#define gf_bs_log_idx(_bs, _nBits, _fname, _val, _idx1, _idx2, _idx3)\n\n#define gf_bs_read_int_log(_bs, _nbb, _f) gf_bs_read_int(_bs, _nbb)\n#define gf_bs_read_int_log_idx(_bs, _nbb, _f, _idx) gf_bs_read_int(_bs, _nbb)\n#define gf_bs_read_int_log_idx2(_bs, _nbb, _f, _idx1, _idx2) gf_bs_read_int(_bs, _nbb)\n#define gf_bs_read_int_log_idx3(_bs, _nbb, _f, _idx1, _idx2, _idx3) gf_bs_read_int(_bs, _nbb)\n\n#endif\n\n\n\n\nstatic const struct {\n\tu32 w, h;\n} std_par[] =\n{\n\t{ 4, 3}, {3, 2}, {16, 9}, {5, 3}, {5, 4}, {8, 5}, {2, 1}, {1, 1},\n\t{0, 0},\n};\n\nGF_EXPORT\nvoid gf_media_reduce_aspect_ratio(u32 *width, u32 *height)\n{\n\tu32 i = 0;\n\tu32 w = *width;\n\tu32 h = *height;\n\twhile (std_par[i].w) {\n\t\tif (std_par[i].w * h == std_par[i].h * w) {\n\t\t\t*width = std_par[i].w;\n\t\t\t*height = std_par[i].h;\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t}\n\t//not standard one, reduce by power of 2\n\ti = 2;\n\twhile (1) {\n\t\tif (w <= i) return;\n\t\tif (h <= i) return;\n\n\t\tif (w % i) return;\n\t\tif (h % i) return;\n\t\t*width = w / i;\n\t\t*height = h / i;\n\t\ti *= 2;\n\t}\n}\n\nGF_EXPORT\nvoid gf_media_get_reduced_frame_rate(u32 *timescale, u32 *sample_dur)\n{\n\tu32 res;\n\tif (!*sample_dur) return;\n\tres = *timescale / *sample_dur;\n\tif (res * (*sample_dur) == *timescale) {\n\t\t*timescale = res;\n\t\t*sample_dur = 1;\n\t}\n\telse if ((double)(*timescale * 1001 - (res + 1) * *sample_dur * 1000) / ((res + 1) * *sample_dur * 1000) < 0.001) {\n\t\t*timescale = (res + 1) * 1000;\n\t\t*sample_dur = 1001;\n\t}\n}\n\nstruct __m4v_profile\n{\n\tu32 value;\n\tconst char *name;\n} M4VProfiles[] = {\n\t{0x00, \"Reserved (0x00) Profile\"},\n\t{0x01, \"Simple Profile @ Level 1\"},\n\t{0x02, \"Simple Profile @ Level 2\"},\n\t{0x03, \"Simple Profile @ Level 3\"},\n\t{0x08, \"Simple Profile @ Level 0\"},\n\t{0x10, \"Simple Scalable Profile @ Level 0\"},\n\t{0x11, \"Simple Scalable Profile @ Level 1\"},\n\t{0x12, \"Simple Scalable Profile @ Level 2\"},\n\t{0x21, \"Core Profile @ Level 1\"},\n\t{0x22, \"Core Profile @ Level 2\"},\n\t{0x32, \"Main Profile @ Level 2\"},\n\t{0x33, \"Main Profile @ Level 3\"},\n\t{0x34, \"Main Profile @ Level 4\"},\n\t{0x42, \"N-bit Profile @ Level 2\"},\n\t{0x51, \"Scalable Texture Profile @ Level 1\"},\n\t{0x61, \"Simple Face Animation Profile @ Level 1\"},\n\t{0x62, \"Simple Face Animation Profile @ Level 2\"},\n\t{0x63, \"Simple FBA Profile @ Level 1\"},\n\t{0x64, \"Simple FBA Profile @ Level 2\"},\n\t{0x71, \"Basic Animated Texture Profile @ Level 1\"},\n\t{0x72, \"Basic Animated Texture Profile @ Level 2\"},\n\t{0x7F, \"AVC/H264 Profile\"},\n\t{0x81, \"Hybrid Profile @ Level 1\"},\n\t{0x82, \"Hybrid Profile @ Level 2\"},\n\t{0x91, \"Advanced Real Time Simple Profile @ Level 1\"},\n\t{0x92, \"Advanced Real Time Simple Profile @ Level 2\"},\n\t{0x93, \"Advanced Real Time Simple Profile @ Level 3\"},\n\t{0x94, \"Advanced Real Time Simple Profile @ Level 4\"},\n\t{0xA1, \"Core Scalable Profile @ Level1\"},\n\t{0xA2, \"Core Scalable Profile @ Level2\"},\n\t{0xA3, \"Core Scalable Profile @ Level3\"},\n\t{0xB1, \"Advanced Coding Efficiency Profile @ Level 1\"},\n\t{0xB2, \"Advanced Coding Efficiency Profile @ Level 2\"},\n\t{0xB3, \"Advanced Coding Efficiency Profile @ Level 3\"},\n\t{0xB4, \"Advanced Coding Efficiency Profile @ Level 4\"},\n\t{0xC1, \"Advanced Core Profile @ Level 1\"},\n\t{0xC2, \"Advanced Core Profile @ Level 2\"},\n\t{0xD1, \"Advanced Scalable Texture @ Level1\"},\n\t{0xD2, \"Advanced Scalable Texture @ Level2\"},\n\t{0xE1, \"Simple Studio Profile @ Level 1\"},\n\t{0xE2, \"Simple Studio Profile @ Level 2\"},\n\t{0xE3, \"Simple Studio Profile @ Level 3\"},\n\t{0xE4, \"Simple Studio Profile @ Level 4\"},\n\t{0xE5, \"Core Studio Profile @ Level 1\"},\n\t{0xE6, \"Core Studio Profile @ Level 2\"},\n\t{0xE7, \"Core Studio Profile @ Level 3\"},\n\t{0xE8, \"Core Studio Profile @ Level 4\"},\n\t{0xF0, \"Advanced Simple Profile @ Level 0\"},\n\t{0xF1, \"Advanced Simple Profile @ Level 1\"},\n\t{0xF2, \"Advanced Simple Profile @ Level 2\"},\n\t{0xF3, \"Advanced Simple Profile @ Level 3\"},\n\t{0xF4, \"Advanced Simple Profile @ Level 4\"},\n\t{0xF5, \"Advanced Simple Profile @ Level 5\"},\n\t{0xF7, \"Advanced Simple Profile @ Level 3b\"},\n\t{0xF8, \"Fine Granularity Scalable Profile @ Level 0\"},\n\t{0xF9, \"Fine Granularity Scalable Profile @ Level 1\"},\n\t{0xFA, \"Fine Granularity Scalable Profile @ Level 2\"},\n\t{0xFB, \"Fine Granularity Scalable Profile @ Level 3\"},\n\t{0xFC, \"Fine Granularity Scalable Profile @ Level 4\"},\n\t{0xFD, \"Fine Granularity Scalable Profile @ Level 5\"},\n\t{0xFE, \"Not part of MPEG-4 Visual profiles\"},\n\t{0xFF, \"No visual capability required\"}\n};\n\nGF_EXPORT\nconst char *gf_m4v_get_profile_name(u8 video_pl)\n{\n\tu32 i, count = GF_ARRAY_LENGTH(M4VProfiles);\n\tfor (i=0; i<count; i++) {\n\t\tif ((u32)video_pl == M4VProfiles[i].value)\n\t\t\treturn M4VProfiles[i].name;\n\t}\n\treturn \"ISO Reserved Profile\";\n}\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n#define MPEG12_START_CODE_PREFIX\t\t0x000001\n#define MPEG12_PICTURE_START_CODE\t\t0x00000100\n#define MPEG12_SLICE_MIN_START\t\t\t0x00000101\n#define MPEG12_SLICE_MAX_START\t\t\t0x000001af\n#define MPEG12_USER_DATA_START_CODE\t\t0x000001b2\n#define MPEG12_SEQUENCE_START_CODE\t\t0x000001b3\n#define MPEG12_SEQUENCE_ERR_START_CODE\t0x000001b4\n#define MPEG12_EXT_START_CODE\t\t\t0x000001b5\n#define MPEG12_SEQUENCE_END_START_CODE\t0x000001b7\n#define MPEG12_GOP_START_CODE\t\t\t0x000001b8\n\ns32 gf_mv12_next_start_code(unsigned char *pbuffer, u32 buflen, u32 *optr, u32 *scode)\n{\n\tu32 value;\n\tu32 offset;\n\n\tif (buflen < 4) return -1;\n\tfor (offset = 0; offset < buflen - 3; offset++, pbuffer++) {\n#ifdef GPAC_BIG_ENDIAN\n\t\tvalue = *(u32 *)pbuffer >> 8;\n#else\n\t\tvalue = (pbuffer[0] << 16) | (pbuffer[1] << 8) | (pbuffer[2] << 0);\n#endif\n\n\t\tif (value == MPEG12_START_CODE_PREFIX) {\n\t\t\t*optr = offset;\n\t\t\t*scode = (value << 8) | pbuffer[3];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\ns32 gf_mv12_next_slice_start(unsigned char *pbuffer, u32 startoffset, u32 buflen, u32 *slice_offset)\n{\n\tu32 slicestart, code;\n\twhile (gf_mv12_next_start_code(pbuffer + startoffset, buflen - startoffset, &slicestart, &code) >= 0) {\n\t\tif ((code >= MPEG12_SLICE_MIN_START) && (code <= MPEG12_SLICE_MAX_START)) {\n\t\t\t*slice_offset = slicestart + startoffset;\n\t\t\treturn 0;\n\t\t}\n\t\tstartoffset += slicestart + 4;\n\t}\n\treturn -1;\n}\n\n\n/*\n\tMPEG-4 video (14496-2)\n*/\n\nstruct __tag_m4v_parser\n{\n\tGF_BitStream *bs;\n\tBool mpeg12, step_mode;\n\tu32 current_object_type;\n\tu32 force_next_obj_type;\n\tu64 current_object_start;\n\tu32 tc_dec, prev_tc_dec, tc_disp, prev_tc_disp;\n};\n\nGF_EXPORT\nGF_M4VParser *gf_m4v_parser_new(u8 *data, u64 data_size, Bool mpeg12video)\n{\n\tGF_M4VParser *tmp;\n\tif (!data || !data_size) return NULL;\n\tGF_SAFEALLOC(tmp, GF_M4VParser);\n\tif (!tmp) return NULL;\n\ttmp->bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\ttmp->mpeg12 = mpeg12video;\n\treturn tmp;\n}\n\nGF_M4VParser *gf_m4v_parser_bs_new(GF_BitStream *bs, Bool mpeg12video)\n{\n\tGF_M4VParser *tmp;\n\tGF_SAFEALLOC(tmp, GF_M4VParser);\n\tif (!tmp) return NULL;\n\ttmp->bs = bs;\n\ttmp->mpeg12 = mpeg12video;\n\treturn tmp;\n}\n\nGF_EXPORT\nvoid gf_m4v_parser_del(GF_M4VParser *m4v)\n{\n\tgf_bs_del(m4v->bs);\n\tgf_free(m4v);\n}\n\nGF_EXPORT\nvoid gf_m4v_parser_del_no_bs(GF_M4VParser *m4v)\n{\n\tgf_free(m4v);\n}\n\nGF_EXPORT\nvoid gf_m4v_parser_set_inspect(GF_M4VParser *m4v)\n{\n\tif (m4v) m4v->step_mode = 1;\n}\nGF_EXPORT\nu32 gf_m4v_parser_get_obj_type(GF_M4VParser *m4v)\n{\n\tif (m4v) return m4v->current_object_type;\n\treturn 0;\n}\n\n#define M4V_CACHE_SIZE\t\t4096\ns32 M4V_LoadObject(GF_M4VParser *m4v)\n{\n\tu32 v, bpos, found;\n\tchar m4v_cache[M4V_CACHE_SIZE];\n\tu64 end, cache_start, load_size;\n\tif (!m4v) return 0;\n\tif (m4v->force_next_obj_type) {\n\t\tm4v->current_object_type = m4v->force_next_obj_type - 1;\n\t\tm4v->force_next_obj_type = 0;\n\t\treturn (s32)m4v->current_object_type;\n\t}\n\n\tbpos = 0;\n\tfound = 0;\n\tload_size = 0;\n\tend = 0;\n\tcache_start = 0;\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\t/*refill cache*/\n\t\tif (bpos == (u32)load_size) {\n\t\t\tif (!gf_bs_available(m4v->bs)) break;\n\t\t\tload_size = gf_bs_available(m4v->bs);\n\t\t\tif (load_size > M4V_CACHE_SIZE) load_size = M4V_CACHE_SIZE;\n\t\t\tbpos = 0;\n\t\t\tcache_start = gf_bs_get_position(m4v->bs);\n\t\t\tgf_bs_read_data(m4v->bs, m4v_cache, (u32)load_size);\n\t\t}\n\t\tv = ((v << 8) & 0xFFFFFF00) | ((u8)m4v_cache[bpos]);\n\t\tbpos++;\n\t\tif ((v & 0xFFFFFF00) == 0x00000100) {\n\t\t\tend = cache_start + bpos - 4;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) return -1;\n\tm4v->current_object_start = end;\n\tgf_bs_seek(m4v->bs, end + 3);\n\tm4v->current_object_type = gf_bs_read_u8(m4v->bs);\n\treturn (s32)m4v->current_object_type;\n}\n\n\nGF_EXPORT\nvoid gf_m4v_rewrite_pl(u8 **o_data, u32 *o_dataLen, u8 PL)\n{\n\tu32 pos = 0;\n\tunsigned char *data = (unsigned char *)*o_data;\n\tu32 dataLen = *o_dataLen;\n\n\twhile (pos + 4 < dataLen) {\n\t\tif (!data[pos] && !data[pos + 1] && (data[pos + 2] == 0x01) && (data[pos + 3] == M4V_VOS_START_CODE)) {\n\t\t\tdata[pos + 4] = PL;\n\t\t\treturn;\n\t\t}\n\t\tpos++;\n\t}\n\t/*emulate VOS at beggining*/\n\t(*o_data) = (char *)gf_malloc(sizeof(char)*(dataLen + 5));\n\t(*o_data)[0] = 0;\n\t(*o_data)[1] = 0;\n\t(*o_data)[2] = 1;\n\t(*o_data)[3] = (char)M4V_VOS_START_CODE;\n\t(*o_data)[4] = PL;\n\tmemcpy((*o_data + 5), data, sizeof(char)*dataLen);\n\tgf_free(data);\n\t(*o_dataLen) = dataLen + 5;\n}\n\nstatic GF_Err M4V_Reset(GF_M4VParser *m4v, u64 start)\n{\n\tgf_bs_seek(m4v->bs, start);\n\n\tassert(start < (u64)1<<31);\n\tm4v->current_object_start = (u32)start;\n\tm4v->current_object_type = 0;\n\treturn GF_OK;\n}\n\nvoid gf_m4v_parser_reset(GF_M4VParser *m4v, u8 sc_type)\n{\n\tm4v->current_object_start = 0;\n\tm4v->current_object_type = 0;\n\tm4v->force_next_obj_type = sc_type;\n}\nstatic GF_Err gf_m4v_parse_config_mpeg12(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\tunsigned char p[4];\n\tu32 ext_type;\n\ts32 o_type;\n\tu8 go, par;\n\n\tif (!m4v || !dsi) return GF_BAD_PARAM;\n\n\tmemset(dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tdsi->VideoPL = 0;\n\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M2V_SEQ_START_CODE:\n\t\t\tdsi->RAP_stream = 1;\n\t\t\tgf_bs_read_data(m4v->bs, (char *)p, 4);\n\t\t\tdsi->width = (p[0] << 4) | ((p[1] >> 4) & 0xf);\n\t\t\tdsi->height = ((p[1] & 0xf) << 8) | p[2];\n\n\t\t\tdsi->VideoPL = GF_CODECID_MPEG1;\n\t\t\tpar = (p[3] >> 4) & 0xf;\n\t\t\tswitch (par) {\n\t\t\tcase 2:\n\t\t\t\tdsi->par_num = dsi->height / 3;\n\t\t\t\tdsi->par_den = dsi->width / 4;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdsi->par_num = dsi->height / 9;\n\t\t\t\tdsi->par_den = dsi->width / 16;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdsi->par_num = dsi->height / 2;\n\t\t\t\tdsi->par_den = dsi->width / 21;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdsi->par_den = dsi->par_num = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (p[3] & 0xf) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdsi->fps = 24000.0 / 1001.0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdsi->fps = 24.0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdsi->fps = 25.0;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdsi->fps = 30000.0 / 1001.0;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tdsi->fps = 30.0;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tdsi->fps = 50.0;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tdsi->fps = ((60.0*1000.0) / 1001.0);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tdsi->fps = 60.0;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tdsi->fps = 1;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tdsi->fps = 5;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tdsi->fps = 10;\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\tdsi->fps = 12;\n\t\t\t\tbreak;\n\t\t\tcase 13:\n\t\t\t\tdsi->fps = 15;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase M2V_EXT_START_CODE:\n\t\t\tgf_bs_read_data(m4v->bs, (char *)p, 4);\n\t\t\text_type = ((p[0] >> 4) & 0xf);\n\t\t\tif (ext_type == 1) {\n\t\t\t\tdsi->VideoPL = 0x65;\n\t\t\t\tdsi->height = ((p[1] & 0x1) << 13) | ((p[2] & 0x80) << 5) | (dsi->height & 0x0fff);\n\t\t\t\tdsi->width = (((p[2] >> 5) & 0x3) << 12) | (dsi->width & 0x0fff);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase M2V_PIC_START_CODE:\n\t\t\tif (dsi->width) go = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t\t/*EOS*/\n\t\tcase -1:\n\t\t\tgo = 0;\n\t\t\tm4v->current_object_start = gf_bs_get_position(m4v->bs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tM4V_Reset(m4v, 0);\n\treturn GF_OK;\n}\n\n\nstatic const struct {\n\tu32 w, h;\n} m4v_sar[6] = { { 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 }, { 16, 11 }, { 40, 33 } };\n\nstatic u8 m4v_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif ((m4v_sar[i].w == w) && (m4v_sar[i].h == h)) return i;\n\t}\n\treturn 0xF;\n}\n\nstatic void gf_m4v_parse_vol(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\tu8 verid, par;\n\ts32 clock_rate;\n\tu8 vpl = dsi->VideoPL;\n\n\tmemset(dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tdsi->VideoPL = vpl;\n\n\tverid = 0;\n\tdsi->RAP_stream = gf_bs_read_int(m4v->bs, 1);\n\tdsi->objectType = gf_bs_read_int(m4v->bs, 8);\n\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\tverid = gf_bs_read_int(m4v->bs, 4);\n\t\tgf_bs_read_int(m4v->bs, 3);\n\t}\n\tpar = gf_bs_read_int(m4v->bs, 4);\n\tif (par == 0xF) {\n\t\tdsi->par_num = gf_bs_read_int(m4v->bs, 8);\n\t\tdsi->par_den = gf_bs_read_int(m4v->bs, 8);\n\t} else if (par<6) {\n\t\tdsi->par_num = m4v_sar[par].w;\n\t\tdsi->par_den = m4v_sar[par].h;\n\t}\n\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\tgf_bs_read_int(m4v->bs, 3);\n\t\tif (gf_bs_read_int(m4v->bs, 1)) gf_bs_read_int(m4v->bs, 79);\n\t}\n\tdsi->has_shape = gf_bs_read_int(m4v->bs, 2);\n\tif (dsi->has_shape && (verid!=1) ) gf_bs_read_int(m4v->bs, 4);\n\tgf_bs_read_int(m4v->bs, 1);\n\t/*clock rate*/\n\tdsi->clock_rate = gf_bs_read_int(m4v->bs, 16);\n\t/*marker*/\n\tgf_bs_read_int(m4v->bs, 1);\n\n\tclock_rate = dsi->clock_rate-1;\n\tif (clock_rate >= 65536) clock_rate = 65535;\n\tif (clock_rate > 0) {\n\t\tfor (dsi->NumBitsTimeIncrement = 1; dsi->NumBitsTimeIncrement < 16; dsi->NumBitsTimeIncrement++)\t{\n\t\t\tif (clock_rate == 1) break;\n\t\t\tclock_rate = (clock_rate >> 1);\n\t\t}\n\t} else {\n\t\t/*fix from vivien for divX*/\n\t\tdsi->NumBitsTimeIncrement = 1;\n\t}\n\t/*fixed FPS stream*/\n\tdsi->time_increment = 0;\n\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\tdsi->time_increment = gf_bs_read_int(m4v->bs, dsi->NumBitsTimeIncrement);\n\t}\n\tif (!dsi->has_shape) {\n\t\tgf_bs_read_int(m4v->bs, 1);\n\t\tdsi->width = gf_bs_read_int(m4v->bs, 13);\n\t\tgf_bs_read_int(m4v->bs, 1);\n\t\tdsi->height = gf_bs_read_int(m4v->bs, 13);\n\t} else {\n\t\tdsi->width = dsi->height = 0;\n\t}\n\tgf_bs_align(m4v->bs);\n}\n\nstatic GF_Err gf_m4v_parse_config_mpeg4(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\ts32 o_type;\n\tu8 go;\n\n\tif (!m4v || !dsi) return GF_BAD_PARAM;\n\n\tmemset(dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\t\t/*vosh*/\n\t\tcase M4V_VOS_START_CODE:\n\t\t\tdsi->VideoPL = (u8)gf_bs_read_u8(m4v->bs);\n\t\t\tbreak;\n\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tgf_m4v_parse_vol(m4v, dsi);\n\t\t\t/*shape will be done later*/\n\t\t\tgf_bs_align(m4v->bs);\n\t\t\tbreak;\n\n\t\tcase M4V_VOP_START_CODE:\n\t\tcase M4V_GOV_START_CODE:\n\t\t\tgo = 0;\n\t\t\tbreak;\n\t\t\t/*EOS*/\n\t\tcase -1:\n\t\t\tm4v->current_object_start = gf_bs_get_position(m4v->bs);\n\t\t\treturn GF_EOS;\n\t\t\t/*don't interest us*/\n\t\tcase M4V_UDTA_START_CODE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4v_parse_config(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\tif (m4v->mpeg12) {\n\t\treturn gf_m4v_parse_config_mpeg12(m4v, dsi);\n\t}\n\telse {\n\t\treturn gf_m4v_parse_config_mpeg4(m4v, dsi);\n\t}\n}\n\nstatic GF_Err gf_m4v_parse_frame_mpeg12(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tu8 go, hasVOP, firstObj, val;\n\ts32 o_type;\n\n\tif (!m4v || !size || !start || !frame_type) return GF_BAD_PARAM;\n\n\t*size = 0;\n\tfirstObj = 1;\n\thasVOP = 0;\n\t*is_coded = GF_FALSE;\n\t*frame_type = 0;\n\n\tif (!m4v->step_mode)\n\t\tM4V_Reset(m4v, m4v->current_object_start);\n\n\tm4v->current_object_type = (u32)-1;\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M2V_PIC_START_CODE:\n\t\t\t/*done*/\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\thasVOP = 1;\n\t\t\t*is_coded = 1;\n\n\t\t\t/*val = */gf_bs_read_u8(m4v->bs);\n\t\t\tval = gf_bs_read_u8(m4v->bs);\n\t\t\t*frame_type = ((val >> 3) & 0x7) - 1;\n\t\t\tbreak;\n\t\tcase M2V_GOP_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) go = 0;\n\t\t\tbreak;\n\n\t\tcase M2V_SEQ_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/**/\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t*size = gf_bs_get_position(m4v->bs) - *start;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\tif (m4v->step_mode)\n\t\t\treturn GF_OK;\n\t}\n\t*size = m4v->current_object_start - *start;\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_m4v_parse_frame_mpeg4(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tu8 go, hasVOP, firstObj, secs;\n\ts32 o_type;\n\tu32 vop_inc = 0;\n\n\tif (!m4v || !size || !start || !frame_type) return GF_BAD_PARAM;\n\n\t*size = 0;\n\tfirstObj = 1;\n\thasVOP = 0;\n\t*is_coded = 0;\n\tm4v->current_object_type = (u32)-1;\n\t*frame_type = 0;\n\t*start = 0;\n\n\tif (!m4v->step_mode)\n\t\tM4V_Reset(m4v, m4v->current_object_start);\n\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M4V_VOP_START_CODE:\n\t\t\t/*done*/\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\thasVOP = 1;\n\n\t\t\t/*coding type*/\n\t\t\t*frame_type = gf_bs_read_int(m4v->bs, 2);\n\t\t\t/*modulo time base*/\n\t\t\tsecs = 0;\n\t\t\twhile (gf_bs_read_int(m4v->bs, 1) != 0)\n\t\t\t\tsecs++;\n\t\t\t/*no support for B frames in parsing*/\n\t\t\tsecs += (dsi->enh_layer || *frame_type!=2) ? m4v->tc_dec : m4v->tc_disp;\n\t\t\t/*marker*/\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t/*vop_time_inc*/\n\t\t\tif (dsi->NumBitsTimeIncrement)\n\t\t\t\tvop_inc = gf_bs_read_int(m4v->bs, dsi->NumBitsTimeIncrement);\n\n\t\t\tm4v->prev_tc_dec = m4v->tc_dec;\n\t\t\tm4v->prev_tc_disp = m4v->tc_disp;\n\t\t\tif (dsi->enh_layer || *frame_type!=2) {\n\t\t\t\tm4v->tc_disp = m4v->tc_dec;\n\t\t\t\tm4v->tc_dec = secs;\n\t\t\t}\n\t\t\t*time_inc = secs * dsi->clock_rate + vop_inc;\n\t\t\t/*marker*/\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t/*coded*/\n\t\t\t*is_coded = gf_bs_read_int(m4v->bs, 1);\n\t\t\tgf_bs_align(m4v->bs);\n\t\t\tbreak;\n\t\tcase M4V_GOV_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) go = 0;\n\t\t\tbreak;\n\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tif (m4v->step_mode)\n\t\t\t\tgf_m4v_parse_vol(m4v, dsi);\n\t\tcase M4V_VOS_START_CODE:\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t}\n\t\t\telse if (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase M4V_VO_START_CODE:\n\t\tdefault:\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t*size = gf_bs_get_position(m4v->bs) - *start;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\tif (m4v->step_mode)\n\t\t\treturn GF_OK;\n\t}\n\tassert(m4v->current_object_start >= *start);\n\t*size = m4v->current_object_start - *start;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4v_parse_frame(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tif (m4v->mpeg12) {\n\t\treturn gf_m4v_parse_frame_mpeg12(m4v, dsi, frame_type, time_inc, size, start, is_coded);\n\t}\n\telse {\n\t\treturn gf_m4v_parse_frame_mpeg4(m4v, dsi, frame_type, time_inc, size, start, is_coded);\n\t}\n}\n\nGF_Err gf_m4v_rewrite_par(u8 **o_data, u32 *o_dataLen, s32 par_n, s32 par_d)\n{\n\tu64 start, end, size;\n\tGF_BitStream *mod;\n\tGF_M4VParser *m4v;\n\tBool go = 1;\n\n\tm4v = gf_m4v_parser_new(*o_data, *o_dataLen, 0);\n\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tstart = 0;\n\twhile (go) {\n\t\tu32 type = M4V_LoadObject(m4v);\n\n\t\tend = gf_bs_get_position(m4v->bs) - 4;\n\t\tsize = end - start;\n\t\t/*store previous object*/\n\t\tif (size) {\n\t\t\tassert (size < (u64)1<<31);\n\t\t\tgf_bs_write_data(mod, *o_data + start, (u32)size);\n\t\t\tstart = end;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tgf_bs_write_int(mod, 0, 8);\n\t\t\tgf_bs_write_int(mod, 0, 8);\n\t\t\tgf_bs_write_int(mod, 1, 8);\n\t\t\tgf_bs_write_int(mod, M4V_VOL_START_CODE, 8);\n\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 1), 1);\n\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 8), 8);\n\t\t\tstart = gf_bs_read_int(m4v->bs, 1);\n\t\t\tgf_bs_write_int(mod, (u32)start, 1);\n\t\t\tif (start) {\n\t\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 7), 7);\n\t\t\t}\n\t\t\tstart = gf_bs_read_int(m4v->bs, 4);\n\t\t\tif (start == 0xF) {\n\t\t\t\tgf_bs_read_int(m4v->bs, 8);\n\t\t\t\tgf_bs_read_int(m4v->bs, 8);\n\t\t\t}\n\t\t\tif ((par_n >= 0) && (par_d >= 0)) {\n\t\t\t\tu8 par = m4v_get_sar_idx(par_n, par_d);\n\t\t\t\tgf_bs_write_int(mod, par, 4);\n\t\t\t\tif (par == 0xF) {\n\t\t\t\t\tgf_bs_write_int(mod, par_n, 8);\n\t\t\t\t\tgf_bs_write_int(mod, par_d, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgf_bs_write_int(mod, 0x0, 4);\n\t\t\t}\n\t\tcase -1:\n\t\t\tgo = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (gf_bs_bits_available(m4v->bs)) {\n\t\tu32 b = gf_bs_read_int(m4v->bs, 1);\n\t\tgf_bs_write_int(mod, b, 1);\n\t}\n\n\tgf_m4v_parser_del(m4v);\n\tgf_free(*o_data);\n\tgf_bs_get_content(mod, o_data, o_dataLen);\n\tgf_bs_del(mod);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu64 gf_m4v_get_object_start(GF_M4VParser *m4v)\n{\n\treturn m4v->current_object_start;\n}\n\n#if 0 //unused\nBool gf_m4v_is_valid_object_type(GF_M4VParser *m4v)\n{\n\treturn ((s32)m4v->current_object_type == -1) ? 0 : 1;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_m4v_get_config(u8 *rawdsi, u32 rawdsi_size, GF_M4VDecSpecInfo *dsi)\n{\n\tGF_Err e;\n\tGF_M4VParser *vparse;\n\tif (!rawdsi || !rawdsi_size) return GF_NON_COMPLIANT_BITSTREAM;\n\tvparse = gf_m4v_parser_new(rawdsi, rawdsi_size, 0);\n\te = gf_m4v_parse_config(vparse, dsi);\n\tdsi->next_object_start = (u32)vparse->current_object_start;\n\tgf_m4v_parser_del(vparse);\n\treturn e < 0 ? e : GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_mpegv12_get_config(u8 *rawdsi, u32 rawdsi_size, GF_M4VDecSpecInfo *dsi)\n{\n\tGF_Err e;\n\tGF_M4VParser *vparse;\n\tif (!rawdsi || !rawdsi_size) return GF_NON_COMPLIANT_BITSTREAM;\n\tvparse = gf_m4v_parser_new(rawdsi, rawdsi_size, GF_TRUE);\n\te = gf_m4v_parse_config(vparse, dsi);\n\tdsi->next_object_start = (u32)vparse->current_object_start;\n\tgf_m4v_parser_del(vparse);\n\treturn e;\n}\n\n#endif\n\n\n/*\n\tAAC parser\n*/\n\nstruct __m4a_oti\n{\n\tu32 type;\n\tconst char *name;\n} M4AObjectTypes[] = {\n\t{0, \"MPEG-4 Audio Reserved\"},\n\t{1, \"MPEG-4 Audio AAC Main\"},\n\t{2, \"MPEG-4 Audio AAC LC\"},\n\t{3, \"MPEG-4 Audio AAC SSR\"},\n\t{4, \"MPEG-4 Audio AAC LTP\"},\n\t{5, \"MPEG-4 Audio SBR\"},\n\t{6, \"MPEG-4 Audio AAC Scalable\"},\n\t{7, \"MPEG-4 Audio TwinVQ\"},\n\t{8, \"MPEG-4 Audio CELP\"},\n\t{9, \"MPEG-4 Audio HVXC\"},\n\t{10, \"MPEG-4 Audio Reserved\"},\n\t{11, \"MPEG-4 Audio Reserved\"},\n\t{12, \"MPEG-4 Audio TTSI\"},\n\t{13, \"MPEG-4 Audio Main synthetic\"},\n\t{14, \"MPEG-4 Audio Wavetable synthesis\"},\n\t{15, \"MPEG-4 Audio General MIDI\"},\n\t{16, \"MPEG-4 Audio Algorithmic Synthesis and Audio FX\"},\n\t{17, \"MPEG-4 Audio ER AAC LC\"},\n\t{18, \"MPEG-4 Audio Reserved\"},\n\t{19, \"MPEG-4 Audio ER AAC LTP\"},\n\t{20, \"MPEG-4 Audio ER AAC scalable\"},\n\t{21, \"MPEG-4 Audio ER TwinVQ\"},\n\t{22, \"MPEG-4 Audio ER BSAC\"},\n\t{23, \"MPEG-4 Audio ER AAC LD\"},\n\t{24, \"MPEG-4 Audio ER CELP\"},\n\t{25, \"MPEG-4 Audio ER HVXC\"},\n\t{26, \"MPEG-4 Audio ER HILN\"},\n\t{27, \"MPEG-4 Audio ER Parametric\"},\n\t{28, \"MPEG-4 Audio SSC\"},\n\t{29, \"MPEG-4 Audio ParametricStereo\"},\n\t{30, \"MPEG-4 Audio Reserved\"},\n\t{31, \"MPEG-4 Audio Reserved\"},\n\t{32, \"MPEG-1 Audio Layer-1\"},\n\t{33, \"MPEG-1 Audio Layer-2\"},\n\t{34, \"MPEG-1 Audio Layer-3\"},\n\t{35, \"MPEG-4 Audio DST\"},\n\t{36, \"MPEG-4 Audio ALS\"},\n\t{37, \"MPEG-4 Audio SLS\"},\n\t{42, \"MPEG Audio xHE-AAC\"},\n};\n\nGF_EXPORT\nconst char *gf_m4a_object_type_name(u32 objectType)\n{\n\tu32 i, count = GF_ARRAY_LENGTH(M4AObjectTypes);\n\tfor (i=0; i<count; i++) {\n\t\tif (objectType==M4AObjectTypes[i].type)\n\t\t\treturn M4AObjectTypes[i].name;\n\t}\n\treturn \"MPEG-4 Audio Unknown\";\n}\n\nstruct __m4a_profile\n{\n\tu32 value;\n\tconst char *name;\n} M4AProfiles[] = {\n\t{0x00, \"ISO Reserved (0x00)\"},\n\t{0x01, \"Main Audio Profile @ Level 1\"},\n\t{0x02, \"Main Audio Profile @ Level 2\"},\n\t{0x03, \"Main Audio Profile @ Level 3\"},\n\t{0x04, \"Main Audio Profile @ Level 4\"},\n\t{0x05, \"Scalable Audio Profile @ Level 1\"},\n\t{0x06, \"Scalable Audio Profile @ Level 2\"},\n\t{0x07, \"Scalable Audio Profile @ Level 3\"},\n\t{0x08, \"Scalable Audio Profile @ Level 4\"},\n\t{0x09, \"Speech Audio Profile @ Level 1\"},\n\t{0x0A, \"Speech Audio Profile @ Level 2\"},\n\t{0x0B, \"Synthetic Audio Profile @ Level 1\"},\n\t{0x0C, \"Synthetic Audio Profile @ Level 2\"},\n\t{0x0D, \"Synthetic Audio Profile @ Level 3\"},\n\t{0x0E, \"High Quality Audio Profile @ Level 1\"},\n\t{0x0F, \"High Quality Audio Profile @ Level 2\"},\n\t{0x10, \"High Quality Audio Profile @ Level 3\"},\n\t{0x11, \"High Quality Audio Profile @ Level 4\"},\n\t{0x12, \"High Quality Audio Profile @ Level 5\"},\n\t{0x13, \"High Quality Audio Profile @ Level 6\"},\n\t{0x14, \"High Quality Audio Profile @ Level 7\"},\n\t{0x15, \"High Quality Audio Profile @ Level 8\"},\n\t{0x16, \"Low Delay Audio Profile @ Level 1\"},\n\t{0x17, \"Low Delay Audio Profile @ Level 2\"},\n\t{0x18, \"Low Delay Audio Profile @ Level 3\"},\n\t{0x19, \"Low Delay Audio Profile @ Level 4\"},\n\t{0x1A, \"Low Delay Audio Profile @ Level 5\"},\n\t{0x1B, \"Low Delay Audio Profile @ Level 6\"},\n\t{0x1C, \"Low Delay Audio Profile @ Level 7\"},\n\t{0x1D, \"Low Delay Audio Profile @ Level 8\"},\n\t{0x1E, \"Natural Audio Profile @ Level 1\"},\n\t{0x1F, \"Natural Audio Profile @ Level 2\"},\n\t{0x20, \"Natural Audio Profile @ Level 3\"},\n\t{0x21, \"Natural Audio Profile @ Level 4\"},\n\t{0x22, \"Mobile Audio Internetworking Profile @ Level 1\"},\n\t{0x23, \"Mobile Audio Internetworking Profile @ Level 2\"},\n\t{0x24, \"Mobile Audio Internetworking Profile @ Level 3\"},\n\t{0x25, \"Mobile Audio Internetworking Profile @ Level 4\"},\n\t{0x26, \"Mobile Audio Internetworking Profile @ Level 5\"},\n\t{0x27, \"Mobile Audio Internetworking Profile @ Level 6\"},\n\t{0x28, \"AAC Profile @ Level 1\"},\n\t{0x29, \"AAC Profile @ Level 2\"},\n\t{0x2A, \"AAC Profile @ Level 4\"},\n\t{0x2B, \"AAC Profile @ Level 5\"},\n\t{0x2C, \"High Efficiency AAC Profile @ Level 2\"},\n\t{0x2D, \"High Efficiency AAC Profile @ Level 3\"},\n\t{0x2E, \"High Efficiency AAC Profile @ Level 4\"},\n\t{0x2F, \"High Efficiency AAC Profile @ Level 5\"},\n\t{0x30, \"High Efficiency AAC v2 Profile @ Level 2\"},\n\t{0x31, \"High Efficiency AAC v2 Profile @ Level 3\"},\n\t{0x32, \"High Efficiency AAC v2 Profile @ Level 4\"},\n\t{0x33, \"High Efficiency AAC v2 Profile @ Level 5\"},\n\t{0x34, \"Low Delay AAC Profile\"},\n\t{0x35, \"Baseline MPEG Surround Profile @ Level 1\"},\n\t{0x36, \"Baseline MPEG Surround Profile @ Level 2\"},\n\t{0x37, \"Baseline MPEG Surround Profile @ Level 3\"},\n\t{0x38, \"Baseline MPEG Surround Profile @ Level 4\"},\n\t{0x39, \"Baseline MPEG Surround Profile @ Level 5\"},\n\t{0x3A, \"Baseline MPEG Surround Profile @ Level 6\"},\n\t{0x3B, \"High Definition AAC Profile @ Level 1\"},\n\t{0x3C, \"ALS Simple Profile @ Level 1\"},\n\t{0x50, \"AAC Profile @ Level 6\"},\n\t{0x51, \"AAC Profile @ Level 7\"},\n\t{0x52, \"High Efficiency AAC Profile @ Level 6\"},\n\t{0x53, \"High Efficiency AAC Profile @ Level 7\"},\n\t{0x54, \"High Efficiency AAC v2 Profile @ Level 6\"},\n\t{0x55, \"High Efficiency AAC v2 Profile @ Level 7\"},\n\t{0x56, \"Extended High Efficiency AAC Profile @ Level 6\"},\n\t{0x57, \"Extended High Efficiency AAC Profile @ Level 7\"},\n\t{0xFE, \"Not part of MPEG-4 audio profiles\"},\n\t{0xFF, \"No audio capability required\"}\n};\n\nGF_EXPORT\nconst char *gf_m4a_get_profile_name(u8 audio_pl)\n{\n\tu32 i, count = GF_ARRAY_LENGTH(M4AProfiles);\n\tfor (i=0; i<count; i++) {\n\t\tif ((u32) audio_pl==M4AProfiles[i].value)\n\t\t\treturn M4AProfiles[i].name;\n\t}\n\treturn \"ISO Reserved / User Private\";\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nGF_EXPORT\nu32 gf_m4a_get_profile(GF_M4ADecSpecInfo *cfg)\n{\n\tswitch (cfg->base_object_type) {\n\tcase 2: /*AAC LC*/\n\t\tif (cfg->nb_chan <= 2)\n\t\t\treturn (cfg->base_sr <= 24000) ? 0x28 : 0x29; /*LC@L1 or LC@L2*/\n\t\tif (cfg->nb_chan <= 5)\n\t\t\treturn (cfg->base_sr <= 48000) ? 0x2A : 0x2B; /*LC@L4 or LC@L5*/\n\t\treturn (cfg->base_sr <= 48000) ? 0x50 : 0x51; /*LC@L4 or LC@L5*/\n\tcase 5: /*HE-AAC - SBR*/\n\t\tif (cfg->nb_chan <= 2)\n\t\t\treturn (cfg->base_sr <= 24000) ? 0x2C : 0x2D; /*HE@L2 or HE@L3*/\n\t\tif (cfg->nb_chan <= 5)\n\t\t\treturn (cfg->base_sr <= 48000) ? 0x2E : 0x2F; /*HE@L4 or HE@L5*/\n\t\treturn (cfg->base_sr <= 48000) ? 0x52 : 0x53; /*HE@L6 or HE@L7*/\n\tcase 29: /*HE-AACv2 - SBR+PS*/\n\t\tif (cfg->nb_chan <= 2)\n\t\t\treturn (cfg->base_sr <= 24000) ? 0x30 : 0x31; /*HE-AACv2@L2 or HE-AACv2@L3*/\n\t\tif (cfg->nb_chan <= 5)\n\t\t\treturn (cfg->base_sr <= 48000) ? 0x32 : 0x33; /*HE-AACv2@L4 or HE-AACv2@L5*/\n\t\treturn (cfg->base_sr <= 48000) ? 0x54 : 0x55; /*HE-AACv2@L6 or HE-AACv2@L7*/\n\t/*default to HQ*/\n\tdefault:\n\t\tif (cfg->nb_chan <= 2) return (cfg->base_sr < 24000) ? 0x0E : 0x0F; /*HQ@L1 or HQ@L2*/\n\t\treturn 0x10; /*HQ@L3*/\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_m4a_parse_program_config_element(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg)\n{\n\tu32 i;\n\n\tcfg->program_config_element_present = 1;\n\tcfg->cpe_channels = 0;\n\n\tcfg->element_instance_tag = gf_bs_read_int_log(bs, 4, \"element_instance_tag\");\n\tcfg->object_type = gf_bs_read_int_log(bs, 2, \"object_type\");\n\tcfg->sampling_frequency_index = gf_bs_read_int_log(bs, 4, \"sampling_frequency_index\");\n\tcfg->num_front_channel_elements = gf_bs_read_int_log(bs, 4, \"num_front_channel_elements\");\n\tcfg->num_side_channel_elements = gf_bs_read_int_log(bs, 4, \"num_side_channel_elements\");\n\tcfg->num_back_channel_elements = gf_bs_read_int_log(bs, 4, \"num_back_channel_elements\");\n\tcfg->num_lfe_channel_elements = gf_bs_read_int_log(bs, 2, \"num_lfe_channel_elements\");\n\tcfg->num_assoc_data_elements = gf_bs_read_int_log(bs, 3, \"num_assoc_data_elements\");\n\tcfg->num_valid_cc_elements = gf_bs_read_int_log(bs, 4, \"num_valid_cc_elements\");\n\tcfg->mono_mixdown_present = (Bool)gf_bs_read_int_log(bs, 1, \"mono_mixdown_present\");\n\tif (cfg->mono_mixdown_present) {\n\t\tcfg->mono_mixdown_element_number = gf_bs_read_int_log(bs, 4, \"mono_mixdown_element_number\");\n\t}\n\tcfg->stereo_mixdown_present = gf_bs_read_int_log(bs, 1, \"stereo_mixdown_present\");\n\tif (cfg->stereo_mixdown_present) {\n\t\tcfg->stereo_mixdown_element_number = gf_bs_read_int_log(bs, 4, \"stereo_mixdown_element_number\");\n\t}\n\tcfg->matrix_mixdown_idx_present = gf_bs_read_int_log(bs, 1, \"matrix_mixdown_idx_present\");\n\tif (cfg->matrix_mixdown_idx_present) {\n\t\tcfg->matrix_mixdown_idx = gf_bs_read_int_log(bs, 2, \"matrix_mixdown_idx\");\n\t\tcfg->pseudo_surround_enable = gf_bs_read_int_log(bs, 1, \"pseudo_surround_enable\");\n\t}\n\tfor (i = 0; i < cfg->num_front_channel_elements; i++) {\n\t\tcfg->front_element_is_cpe[i] = gf_bs_read_int_log_idx(bs, 1, \"front_element_is_cpe\", i);\n\t\tcfg->front_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"front_element_tag_select\", i);\n\t\tif (cfg->front_element_is_cpe[i]) cfg->cpe_channels++;\n\t}\n\tfor (i = 0; i < cfg->num_side_channel_elements; i++) {\n\t\tcfg->side_element_is_cpe[i] = gf_bs_read_int_log_idx(bs, 1, \"side_element_is_cpe\", i);\n\t\tcfg->side_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"side_element_tag_select\", i);\n\t\tif (cfg->side_element_is_cpe[i]) cfg->cpe_channels++;\n\t}\n\tfor (i = 0; i < cfg->num_back_channel_elements; i++) {\n\t\tcfg->back_element_is_cpe[i] = gf_bs_read_int_log_idx(bs, 1, \"back_element_is_cpe\", i);\n\t\tcfg->back_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"back_element_tag_select\", i);\n\t\tif (cfg->back_element_is_cpe[i]) cfg->cpe_channels++;\n\t}\n\tfor (i = 0; i < cfg->num_lfe_channel_elements; i++) {\n\t\tcfg->lfe_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"lfe_element_tag_select\", i);\n\t}\n\tfor (i = 0; i < cfg->num_assoc_data_elements; i++) {\n\t\tcfg->assoc_data_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"assoc_data_element_tag_select\", i);\n\t}\n\n\tfor (i = 0; i < cfg->num_valid_cc_elements; i++) {\n\t\tcfg->cc_element_is_ind_sw[i] = gf_bs_read_int_log_idx(bs, 1, \"cc_element_is_ind_sw\", i);\n\t\tcfg->valid_cc_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"valid_cc_element_tag_select\", i);\n\t}\n\tgf_bs_align(bs);\n\tcfg->comment_field_bytes = gf_bs_read_int_log(bs, 8, \"comment_field_bytes\");\n\tgf_bs_read_data(bs, (char *)cfg->comments, cfg->comment_field_bytes);\n\n\tcfg->nb_chan = cfg->num_front_channel_elements + cfg->num_back_channel_elements + cfg->num_side_channel_elements + cfg->num_lfe_channel_elements;\n\tcfg->nb_chan += cfg->cpe_channels;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_parse_config(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg, Bool size_known)\n{\n\tu32 audio_obj_type;\n\tmemset(cfg, 0, sizeof(GF_M4ADecSpecInfo));\n\tcfg->base_object_type = gf_bs_read_int_log(bs, 5, \"base_object_type\");\n\t/*extended object type*/\n\tif (cfg->base_object_type == 31) {\n\t\tcfg->base_object_type = 32 + gf_bs_read_int_log(bs, 6, \"extended_base_object_type\");\n\t}\n\tcfg->base_sr_index = gf_bs_read_int_log(bs, 4, \"base_samplerate_index\");\n\tif (cfg->base_sr_index == 0x0F) {\n\t\tcfg->base_sr = gf_bs_read_int_log(bs, 24, \"base_samplerate\");\n\t}\n\telse {\n\t\tcfg->base_sr = GF_M4ASampleRates[cfg->base_sr_index];\n\t}\n\n\tcfg->chan_cfg = gf_bs_read_int_log(bs, 4, \"channel_configuration\");\n\tif (cfg->chan_cfg) {\n\t\tcfg->nb_chan = GF_M4ANumChannels[cfg->chan_cfg - 1];\n\t}\n\n\taudio_obj_type = cfg->base_object_type;\n\tif (cfg->base_object_type == 5 || cfg->base_object_type == 29) {\n\t\tif (cfg->base_object_type == 29) {\n\t\t\tcfg->has_ps = 1;\n\t\t\tcfg->nb_chan = 1;\n\t\t}\n\t\tcfg->has_sbr = GF_TRUE;\n\t\tcfg->sbr_sr_index = gf_bs_read_int_log(bs, 4, \"sbr_samplerate_index\");\n\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\tcfg->sbr_sr = gf_bs_read_int_log(bs, 24, \"sbr_samplerate\");\n\t\t}\n\t\telse {\n\t\t\tcfg->sbr_sr = GF_M4ASampleRates[cfg->sbr_sr_index];\n\t\t}\n\t\tcfg->sbr_object_type = gf_bs_read_int_log(bs, 5, \"sbr_object_type\");\n\t\tif (cfg->sbr_object_type==31)\n\t\t\tcfg->sbr_object_type = 32 + gf_bs_read_int_log(bs, 6, \"audioObjectTypeExt\");\n\t\taudio_obj_type = cfg->sbr_object_type;\n\t\tif (cfg->sbr_object_type==22) {\n\t\t\t/*ext_chan_cfg = */gf_bs_read_int_log(bs, 4, \"channel_configuration\");\n\t\t}\n\t}\n\n\t/*object cfg*/\n\tswitch (audio_obj_type) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 6:\n\tcase 7:\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\tcase 42:\n\t{\n\t\tBool ext_flag;\n\t\tgf_bs_read_int_log(bs, 1, \"frame_length_flag\");\n\t\tif (gf_bs_read_int_log(bs, 1, \"depends_on_core_coder\"))\n\t\t\tgf_bs_read_int_log(bs, 14, \"delay\");\n\t\text_flag = gf_bs_read_int_log(bs, 1, \"extension_flag\");\n\n\t\tif (!cfg->chan_cfg) {\n\t\t\tgf_m4a_parse_program_config_element(bs, cfg);\n\t\t}\n\n\t\tif ((cfg->base_object_type == 6) || (cfg->base_object_type == 20)) {\n\t\t\tgf_bs_read_int_log(bs, 3, \"layerN\");\n\t\t}\n\t\tif (ext_flag) {\n\t\t\tif (cfg->base_object_type == 22) {\n\t\t\t\tgf_bs_read_int_log(bs, 5, \"numOfSubFrame\");\n\t\t\t\tgf_bs_read_int_log(bs, 11, \"layer_length\");\n\t\t\t}\n\t\t\tif ((cfg->base_object_type == 17)\n\t\t\t\t|| (cfg->base_object_type == 19)\n\t\t\t\t|| (cfg->base_object_type == 20)\n\t\t\t\t|| (cfg->base_object_type == 23)\n\t\t\t) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"aacSectionDataResilienceFlag\");\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"aacScalefactorDataResilienceFlag\");\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"aacSpectralDataResilienceFlag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"extensionFlag3\");\n\t\t}\n\t}\n\tbreak;\n\t}\n\t/*ER cfg*/\n\tswitch (audio_obj_type) {\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\tcase 24:\n\tcase 25:\n\tcase 26:\n\tcase 27:\n\t{\n\t\tu32 epConfig = gf_bs_read_int_log(bs, 2, \"epConfig\");\n\t\tif ((epConfig == 2) || (epConfig == 3)) {\n\t\t}\n\t\tif (epConfig == 3) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"directMapping\");\n\t\t}\n\t}\n\tbreak;\n\t}\n\n\tif (size_known && (cfg->base_object_type != 5) && (cfg->base_object_type != 29)) {\n\t\twhile (gf_bs_available(bs) >= 2) {\n\t\t\tu32 sync = gf_bs_peek_bits(bs, 11, 0);\n\t\t\tif (sync == 0x2b7) {\n\t\t\t\tgf_bs_read_int_log(bs, 11, \"syncExtensionType\");\n\t\t\t\tcfg->sbr_object_type = gf_bs_read_int_log(bs, 5, \"extensionAudioObjectType \");\n\t\t\t\tcfg->has_sbr = gf_bs_read_int_log(bs, 1, \"sbrPresentFlag\");\n\t\t\t\tif (cfg->has_sbr) {\n\t\t\t\t\tcfg->sbr_sr_index = gf_bs_read_int_log(bs, 4, \"extensionSamplingFrequencyIndex\");\n\t\t\t\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\t\t\t\tcfg->sbr_sr = gf_bs_read_int_log(bs, 24, \"extensionSamplingFrequency\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcfg->sbr_sr = GF_M4ASampleRates[cfg->sbr_sr_index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sync == 0x548) {\n\t\t\t\tgf_bs_read_int_log(bs, 11, \"syncExtensionType\");\n\t\t\t\tcfg->has_ps = gf_bs_read_int_log(bs, 1, \"hasParametricStereo\");\n\t\t\t\tif (cfg->has_ps)\n\t\t\t\t\tcfg->nb_chan = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcfg->audioPL = gf_m4a_get_profile(cfg);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_get_config(u8 *dsi, u32 dsi_size, GF_M4ADecSpecInfo *cfg)\n{\n\tGF_BitStream *bs;\n\tif (!dsi || !dsi_size || (dsi_size < 2)) return GF_NON_COMPLIANT_BITSTREAM;\n\tbs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tgf_m4a_parse_config(bs, cfg, GF_TRUE);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nu32 gf_latm_get_value(GF_BitStream *bs)\n{\n\tu32 i, tmp, value = 0;\n\tu32 bytesForValue = gf_bs_read_int(bs, 2);\n\tfor (i = 0; i <= bytesForValue; i++) {\n\t\tvalue <<= 8;\n\t\ttmp = gf_bs_read_int(bs, 8);\n\t\tvalue += tmp;\n\t}\n\treturn value;\n}\n\nGF_EXPORT\nu32 gf_m4a_get_channel_cfg(u32 nb_chan)\n{\n\tu32 i, count = sizeof(GF_M4ANumChannels) / sizeof(u32);\n\tfor (i = 0; i < count; i++) {\n\t\tif (GF_M4ANumChannels[i] == nb_chan) return i + 1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_write_program_config_element_bs(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg)\n{\n\tu32 i;\n\tgf_bs_write_int(bs, cfg->element_instance_tag, 4);\n\tgf_bs_write_int(bs, cfg->object_type, 2);\n\tgf_bs_write_int(bs, cfg->sampling_frequency_index, 4);\n\tgf_bs_write_int(bs, cfg->num_front_channel_elements, 4);\n\tgf_bs_write_int(bs, cfg->num_side_channel_elements, 4);\n\tgf_bs_write_int(bs, cfg->num_back_channel_elements, 4);\n\tgf_bs_write_int(bs, cfg->num_lfe_channel_elements, 2);\n\tgf_bs_write_int(bs, cfg->num_assoc_data_elements, 3);\n\tgf_bs_write_int(bs, cfg->num_valid_cc_elements, 4);\n\tgf_bs_write_int(bs, cfg->mono_mixdown_present, 1);\n\tif (cfg->mono_mixdown_present) {\n\t\tgf_bs_write_int(bs, cfg->mono_mixdown_element_number, 4);\n\t}\n\tgf_bs_write_int(bs, cfg->stereo_mixdown_present, 1);\n\tif (cfg->stereo_mixdown_present) {\n\t\tgf_bs_write_int(bs, cfg->stereo_mixdown_element_number, 4);\n\t}\n\tgf_bs_write_int(bs, cfg->matrix_mixdown_idx_present, 1);\n\tif (cfg->matrix_mixdown_idx_present) {\n\t\tgf_bs_write_int(bs, cfg->matrix_mixdown_idx, 2);\n\t\tgf_bs_write_int(bs, cfg->pseudo_surround_enable, 1);\n\t}\n\tfor (i = 0; i < cfg->num_front_channel_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->front_element_is_cpe[i], 1);\n\t\tgf_bs_write_int(bs, cfg->front_element_tag_select[i], 4);\n\t}\n\tfor (i = 0; i < cfg->num_side_channel_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->side_element_is_cpe[i], 1);\n\t\tgf_bs_write_int(bs, cfg->side_element_tag_select[i], 4);\n\t}\n\tfor (i = 0; i < cfg->num_back_channel_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->back_element_is_cpe[i], 1);\n\t\tgf_bs_write_int(bs, cfg->back_element_tag_select[i], 4);\n\t}\n\tfor (i = 0; i < cfg->num_lfe_channel_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->lfe_element_tag_select[i], 4);\n\t}\n\tfor (i = 0; i < cfg->num_assoc_data_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->assoc_data_element_tag_select[i], 4);\n\t}\n\n\tfor (i = 0; i < cfg->num_valid_cc_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->cc_element_is_ind_sw[i], 1);\n\t\tgf_bs_write_int(bs, cfg->valid_cc_element_tag_select[i], 4);\n\t}\n\tgf_bs_align(bs);\n\tgf_bs_write_int(bs, cfg->comment_field_bytes, 8);\n\tgf_bs_write_data(bs, (char *)cfg->comments, cfg->comment_field_bytes);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_write_config_bs(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg)\n{\n\tif (!cfg->base_sr_index) {\n\t\tif (!cfg->base_sr) return GF_BAD_PARAM;\n\t\twhile (GF_M4ASampleRates[cfg->base_sr_index]) {\n\t\t\tif (GF_M4ASampleRates[cfg->base_sr_index] == cfg->base_sr)\n\t\t\t\tbreak;\n\t\t\tcfg->base_sr_index++;\n\t\t}\n\t}\n\tif (cfg->sbr_sr && !cfg->sbr_sr_index) {\n\t\twhile (GF_M4ASampleRates[cfg->sbr_sr_index]) {\n\t\t\tif (GF_M4ASampleRates[cfg->sbr_sr_index] == cfg->sbr_sr)\n\t\t\t\tbreak;\n\t\t\tcfg->sbr_sr_index++;\n\t\t}\n\t}\n\t/*extended object type*/\n\tif (cfg->base_object_type >= 32) {\n\t\tgf_bs_write_int(bs, 31, 5);\n\t\tgf_bs_write_int(bs, cfg->base_object_type - 32, 6);\n\t}\n\telse {\n\t\tgf_bs_write_int(bs, cfg->base_object_type, 5);\n\t}\n\tgf_bs_write_int(bs, cfg->base_sr_index, 4);\n\tif (cfg->base_sr_index == 0x0F) {\n\t\tgf_bs_write_int(bs, cfg->base_sr, 24);\n\t}\n\n\tif (cfg->program_config_element_present) {\n\t\tgf_bs_write_int(bs, 0, 4);\n\t} else {\n\t\tcfg->chan_cfg = gf_m4a_get_channel_cfg(cfg->nb_chan);\n\t\tif (!cfg->chan_cfg) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AAC] Cannot write decoder config, ProgramConfigElement is missing and channel configuration is not a predefined one !\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tgf_bs_write_int(bs, cfg->chan_cfg, 4);\n\t}\n\n\tif (cfg->base_object_type == 5 || cfg->base_object_type == 29) {\n\t\tif (cfg->base_object_type == 29) {\n\t\t\tcfg->has_ps = 1;\n\t\t\tcfg->nb_chan = 1;\n\t\t}\n\t\tcfg->has_sbr = 1;\n\t\tgf_bs_write_int(bs, cfg->sbr_sr_index, 4);\n\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\tgf_bs_write_int(bs, cfg->sbr_sr, 24);\n\t\t}\n\t\tgf_bs_write_int(bs, cfg->sbr_object_type, 5);\n\t}\n\n\t/*object cfg*/\n\tswitch (cfg->base_object_type) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 6:\n\tcase 7:\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\tcase 42:\n\t{\n\t\t/*frame length flag*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\t/*depends on core coder*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\t/*ext flag*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\n\t\tif (cfg->program_config_element_present) {\n\t\t\tgf_m4a_write_program_config_element_bs(bs, cfg);\n\t\t}\n\n\t\tif ((cfg->base_object_type == 6) || (cfg->base_object_type == 20)) {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t}\n\tbreak;\n\t}\n\t/*ER cfg - not supported*/\n\n\t/*implicit sbr/ps signaling not written here, cf reframe_adts*/\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_write_config(GF_M4ADecSpecInfo *cfg, u8 **dsi, u32 *dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_m4a_write_config_bs(bs, cfg);\n\tgf_bs_get_content(bs, dsi, dsi_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\n/*AV1 parsing*/\n\nstatic u32 av1_read_ns(GF_BitStream *bs, u32 n, const char *fname)\n{\n\tu32 v, res;\n\tBool extra_bit;\n\tint w = (u32)(log(n) / log(2)) + 1;\n\tu32 m = (1 << w) - n;\n\tassert(w < 32);\n\tv = gf_bs_read_int(bs, w - 1);\n\tif (v < m) {\n\t\tif (fname) {\n\t\t\tgf_bs_log(bs, w-1, fname, v);\n\t\t}\n\t\treturn v;\n\t}\n\textra_bit = gf_bs_read_int(bs, 1);\n\tres = (v << 1) - m + extra_bit;\n\tif (fname) {\n\t\tgf_bs_log(bs, w, fname, res);\n\t}\n\treturn res;\n}\n\nstatic void av1_color_config(GF_BitStream *bs, AV1State *state)\n{\n\tstate->config->high_bitdepth = gf_bs_read_int_log(bs, 1, \"high_bitdepth\");\n\tstate->bit_depth = 8;\n\tif (state->config->seq_profile == 2 && state->config->high_bitdepth) {\n\t\tstate->config->twelve_bit = gf_bs_read_int_log(bs, 1, \"twelve_bit\");\n\t\tstate->bit_depth = state->config->twelve_bit ? 12 : 10;\n\t}\n\telse if (state->config->seq_profile <= 2) {\n\t\tstate->bit_depth = state->config->high_bitdepth ? 10 : 8;\n\t}\n\n\tstate->config->monochrome = GF_FALSE;\n\tif (state->config->seq_profile == 1) {\n\t\tstate->config->monochrome = GF_FALSE;\n\t}\n\telse {\n\t\tstate->config->monochrome = gf_bs_read_int_log(bs, 1, \"monochrome\");\n\t}\n\t/*NumPlanes = mono_chrome ? 1 : 3;*/\n\tstate->color_description_present_flag = gf_bs_read_int_log(bs, 1, \"color_description_present_flag\");\n\tif (state->color_description_present_flag) {\n\t\tstate->color_primaries = gf_bs_read_int_log(bs, 8, \"color_primaries\");\n\t\tstate->transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\tstate->matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t}\n\telse {\n\t\tstate->color_primaries = 2/*CP_UNSPECIFIED*/;\n\t\tstate->transfer_characteristics = 2/*TC_UNSPECIFIED*/;\n\t\tstate->matrix_coefficients = 2/*MC_UNSPECIFIED*/;\n\t}\n\tif (state->config->monochrome) {\n\t\tstate->color_range = gf_bs_read_int_log(bs, 1, \"color_range\");\n\t\tstate->config->chroma_subsampling_x = GF_TRUE;\n\t\tstate->config->chroma_subsampling_y = GF_TRUE;\n\t\tstate->config->chroma_sample_position = 0/*CSP_UNKNOWN*/;\n\t\tstate->separate_uv_delta_q = 0;\n\t\treturn;\n\t}\n\telse if (state->color_primaries == 0/*CP_BT_709*/ &&\n\t\tstate->transfer_characteristics == 13/*TC_SRGB*/ &&\n\t\tstate->matrix_coefficients == 0/*MC_IDENTITY*/) {\n\t\tstate->color_range = GF_TRUE;\n\t\tstate->config->chroma_subsampling_x = GF_FALSE;\n\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t}\n\telse {\n\t\tstate->config->chroma_subsampling_x = GF_FALSE;\n\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\n\t\tstate->color_range = gf_bs_read_int_log(bs, 1, \"color_range\");\n\t\tif (state->config->seq_profile == 0) {\n\t\t\tstate->config->chroma_subsampling_x = GF_TRUE;\n\t\t\tstate->config->chroma_subsampling_y = GF_TRUE;\n\t\t}\n\t\telse if (state->config->seq_profile == 1) {\n\t\t\tstate->config->chroma_subsampling_x = GF_FALSE;\n\t\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t\t}\n\t\telse {\n\t\t\tif (state->bit_depth == 12) {\n\t\t\t\tstate->config->chroma_subsampling_x = gf_bs_read_int_log(bs, 1, \"chroma_subsampling_x\");\n\t\t\t\tif (state->config->chroma_subsampling_x)\n\t\t\t\t\tstate->config->chroma_subsampling_y = gf_bs_read_int_log(bs, 1, \"chroma_subsampling_y\");\n\t\t\t\telse\n\t\t\t\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate->config->chroma_subsampling_x = GF_TRUE;\n\t\t\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (state->config->chroma_subsampling_x && state->config->chroma_subsampling_y) {\n\t\t\tstate->config->chroma_sample_position = gf_bs_read_int_log(bs, 2, \"chroma_sample_position\");\n\t\t}\n\t}\n\tstate->separate_uv_delta_q = gf_bs_read_int_log(bs, 1, \"separate_uv_delta_q\");\n}\n\n\nstatic u32 av1_uvlc(GF_BitStream *bs, const char *fname)\n{\n\tu32 res;\n\tu8 leadingZeros = 0;\n\twhile (1) {\n\t\tBool done = gf_bs_read_int(bs, 1);\n\t\tif (done)\n\t\t\tbreak;\n\t\tleadingZeros++;\n\t}\n\tif (leadingZeros >= 32) {\n\t\treturn 0xFFFFFFFF;\n\t}\n\tres = gf_bs_read_int(bs, leadingZeros) + (1 << leadingZeros) - 1;\n\tgf_bs_log(bs, 2*leadingZeros, fname, res);\n\treturn res;\n}\n\nstatic void timing_info(GF_BitStream *bs, AV1State *state) {\n\tu32 time_scale = 0;\n\tu32 num_units_in_display_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_display_tick\");\n\tif (num_units_in_display_tick == 0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] num_units_in_display_tick must be greater than 0.\\n\"));\n\t}\n\ttime_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\tif (time_scale == 0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] time_scale must be greater than 0.\\n\"));\n\t}\n\tstate->equal_picture_interval = gf_bs_read_int_log(bs, 1, \"equal_picture_interval\");\n\tif (state->equal_picture_interval) {\n\t\tu32 num_ticks_per_picture_minus_1 = av1_uvlc(bs, \"num_ticks_per_picture_minus_1\");\n\t\tstate->tb_num = time_scale;\n\t\tstate->tb_den = (num_ticks_per_picture_minus_1 + 1)*num_units_in_display_tick;\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] VFR not supported.\\n\"));\n\t\t//TODO: upload num_units_in_display_tick (eq. to the POC in H264), compute delta between frames, set it as dts_inc in gf_import_aom_av1()\n\t}\n}\n\nstatic void decoder_model_info(AV1State *state, GF_BitStream *bs) {\n\tstate->buffer_delay_length = 1 + gf_bs_read_int_log(bs, 5, \"buffer_delay_length_minus1\");\n\tgf_bs_read_int_log(bs, 32, \"num_units_in_decoding_tick\");\n\tstate->buffer_removal_time_length = gf_bs_read_int_log(bs, 5, \"buffer_removal_time_length\");\n\tstate->frame_presentation_time_length = 1 + gf_bs_read_int_log(bs, 5, \"frame_presentation_time_length_minus1\");\n}\n\nstatic void operating_parameters_info(GF_BitStream *bs, const u8 idx, const u8 buffer_delay_length_minus_1) {\n\tconst u8 n = buffer_delay_length_minus_1 + 1;\n\tgf_bs_read_int_log(bs, n, \"decoder_buffer_delay\");\n\tgf_bs_read_int_log(bs, n, \"encoder_buffer_delay\");\n\tgf_bs_read_int_log(bs, 1, \"low_delay_mode_flag\");\n}\n\nstatic void av1_parse_sequence_header_obu(GF_BitStream *bs, AV1State *state)\n{\n\tu8 buffer_delay_length_minus_1 = 0;\n\tstate->frame_state.seen_seq_header = GF_TRUE;\n\tstate->config->seq_profile = gf_bs_read_int_log(bs, 3, \"seq_profile\");\n\tstate->still_picture = gf_bs_read_int_log(bs, 1, \"still_picture\");\n\tstate->reduced_still_picture_header = gf_bs_read_int_log(bs, 1, \"reduced_still_picture_header\");\n\tif (state->reduced_still_picture_header) {\n\t\t//timing_info_present_flag = GF_FALSE;\n\t\t//initial_display_delay_present_flag = GF_FALSE;\n\t\tstate->operating_points_count = 1;\n\t\tstate->config->seq_level_idx_0 = gf_bs_read_int_log(bs, 5, \"seq_level_idx_0\");\n\t}\n\telse {\n\t\tu8 i = 0;\n\t\tBool initial_display_delay_present_flag;\n\t\tBool timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (timing_info_present_flag) {\n\t\t\ttiming_info(bs, state);\n\t\t\tstate->decoder_model_info_present_flag = gf_bs_read_int_log(bs, 1, \"decoder_model_info_present_flag\");\n\t\t\tif (state->decoder_model_info_present_flag) {\n\t\t\t\tdecoder_model_info(state, bs);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstate->decoder_model_info_present_flag = GF_FALSE;\n\t\t}\n\t\tinitial_display_delay_present_flag = gf_bs_read_int_log(bs, 1, \"initial_display_delay_present_flag\");\n\t\tstate->operating_points_count = 1 + gf_bs_read_int_log(bs, 5, \"operating_points_count_minus1\");\n\t\tfor (i = 0; i < state->operating_points_count; i++) {\n\t\t\tu8 seq_level_idx_i, seq_tier = 0;\n\n\t\t\tstate->operating_point_idc[i] = gf_bs_read_int_log_idx(bs, 12, \"operating_point_idc\", i);\n\n\t\t\tseq_level_idx_i = gf_bs_read_int_log_idx(bs, 5, \"seq_level_idx\", i);\n\t\t\tif (i == 0) state->config->seq_level_idx_0 = seq_level_idx_i;\n\n\t\t\tif (seq_level_idx_i > 7) {\n\t\t\t\tseq_tier = gf_bs_read_int_log_idx(bs, 1, \"seq_tier\", i);\n\t\t\t}\n\t\t\tif (i == 0) state->config->seq_tier_0 = seq_tier;\n\n\t\t\tif (state->decoder_model_info_present_flag) {\n\t\t\t\tstate->decoder_model_present_for_this_op[i] = gf_bs_read_int_log_idx(bs, 1, \"decoder_model_present_for_this_op\", i);\n\t\t\t\tif (state->decoder_model_present_for_this_op[i]) {\n\t\t\t\t\toperating_parameters_info(bs, i, buffer_delay_length_minus_1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate->decoder_model_present_for_this_op[i] = 0;\n\t\t\t}\n\t\t\tif (initial_display_delay_present_flag) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"initial_display_delay_present_for_this_op\", i) ) {\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 4, \"initial_display_delay_minus1\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//operatingPoint = av1_choose_operating_point(bs);\n\tstate->OperatingPointIdc = 0;//TODO: operating_point_idc[operatingPoint];\n\n\tstate->frame_width_bits_minus_1 = gf_bs_read_int_log(bs, 4, \"frame_width_bits_minus1\");\n\tstate->frame_height_bits_minus_1 = gf_bs_read_int_log(bs, 4, \"frame_height_bits_minus1\");\n\tstate->width = gf_bs_read_int_log(bs, state->frame_width_bits_minus_1 + 1, \"width_minus1\") + 1;\n\tstate->height = gf_bs_read_int_log(bs, state->frame_height_bits_minus_1 + 1, \"height_minus1\") + 1;\n\tstate->sequence_width = state->width;\n\tstate->sequence_height = state->height;\n\tstate->frame_id_numbers_present_flag = GF_FALSE;\n\tif (!state->reduced_still_picture_header) {\n\t\tstate->frame_id_numbers_present_flag = gf_bs_read_int_log(bs, 1, \"frame_id_numbers_present_flag\");\n\t}\n\tif (state->frame_id_numbers_present_flag) {\n\t\tstate->delta_frame_id_length_minus_2 = gf_bs_read_int_log(bs, 4, \"delta_frame_id_length_minus2\");\n\t\tstate->additional_frame_id_length_minus_1 = gf_bs_read_int_log(bs, 3, \"additional_frame_id_length_minus1\");\n\t}\n\tstate->use_128x128_superblock = gf_bs_read_int_log(bs, 1, \"use_128x128_superblock\");\n\tgf_bs_read_int_log(bs, 1, \"enable_filter_intra\");\n\tgf_bs_read_int_log(bs, 1, \"enable_intra_edge_filter\");\n\tif (state->reduced_still_picture_header) {\n\t\t/*enable_interintra_compound = 0;\n\t\tenable_masked_compound = 0;\n\t\tenable_dual_filter = 0;\n\t\tenable_jnt_comp = 0;\n\t\tenable_ref_frame_mvs = 0;*/\n\t\tstate->enable_warped_motion = 0;\n\t\tstate->enable_order_hint = GF_FALSE;\n\t\tstate->OrderHintBits = 0;\n\t\tstate->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;\n\t\tstate->seq_force_screen_content_tools = 2/*SELECT_SCREEN_CONTENT_TOOLS*/;\n\t}\n\telse {\n\t\tBool seq_choose_screen_content_tools;\n\t\tgf_bs_read_int_log(bs, 1, \"enable_interintra_compound\");\n\t\tgf_bs_read_int_log(bs, 1, \"enable_masked_compound\");\n\t\tstate->enable_warped_motion = gf_bs_read_int_log(bs, 1, \"enable_warped_motion\");\n\t\tgf_bs_read_int_log(bs, 1, \"enable_dual_filter\");\n\t\tstate->enable_order_hint = gf_bs_read_int_log(bs, 1, \"enable_order_hint\");\n\t\tif (state->enable_order_hint) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"enable_jnt_comp\");\n\t\t\tstate->enable_ref_frame_mvs = gf_bs_read_int_log(bs, 1, \"enable_ref_frame_mvs\");\n\t\t}\n\t\telse {\n\t\t\t/*enable_jnt_comp =  0*/;\n\t\t\t/*enable_ref_frame_mvs = 0*/;\n\t\t}\n\t\tseq_choose_screen_content_tools = gf_bs_read_int_log(bs, 1, \"seq_choose_screen_content_tools\");\n\t\tstate->seq_force_screen_content_tools = 0;\n\t\tif (seq_choose_screen_content_tools) {\n\t\t\tstate->seq_force_screen_content_tools = 2/*SELECT_SCREEN_CONTENT_TOOLS*/;\n\t\t}\n\t\telse {\n\t\t\tstate->seq_force_screen_content_tools = gf_bs_read_int_log(bs, 1, \"seq_force_screen_content_tools\");\n\t\t}\n\n\t\tstate->seq_force_integer_mv = 0;\n\t\tif (state->seq_force_screen_content_tools > 0) {\n\t\t\tconst Bool seq_choose_integer_mv = gf_bs_read_int_log(bs, 1, \"seq_choose_integer_mv\");\n\t\t\tif (seq_choose_integer_mv) {\n\t\t\t\tstate->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate->seq_force_integer_mv = gf_bs_read_int_log(bs, 1, \"seq_force_integer_mv\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstate->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;\n\t\t}\n\t\tif (state->enable_order_hint) {\n\t\t\tu8 order_hint_bits_minus_1 = gf_bs_read_int_log(bs, 3, \"order_hint_bits_minus1\");\n\t\t\tstate->OrderHintBits = order_hint_bits_minus_1 + 1;\n\t\t}\n\t\telse {\n\t\t\tstate->OrderHintBits = 0;\n\t\t}\n\t}\n\n\tstate->enable_superres = gf_bs_read_int_log(bs, 1, \"enable_superres\");\n\tstate->enable_cdef = gf_bs_read_int_log(bs, 1, \"enable_cdef\");\n\tstate->enable_restoration = gf_bs_read_int_log(bs, 1, \"enable_restoration\");\n\tav1_color_config(bs, state);\n\tstate->film_grain_params_present = gf_bs_read_int_log(bs, 1, \"film_grain_params_present\");\n}\n\n\n\n#define IVF_FILE_HEADER_SIZE 32\n\nBool gf_media_probe_ivf(GF_BitStream *bs)\n{\n\tu32 dw = 0;\n\tif (gf_bs_available(bs) < IVF_FILE_HEADER_SIZE) return GF_FALSE;\n\n\tdw = gf_bs_peek_bits(bs, 32, 0);\n\tif (dw != GF_4CC('D', 'K', 'I', 'F')) {\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\nGF_Err gf_media_parse_ivf_file_header(GF_BitStream *bs, u32 *width, u32 *height, u32 *codec_fourcc, u32 *timebase_num, u32 *timebase_den, u32 *num_frames)\n{\n\tu32 dw = 0;\n\n\tif (!width || !height || !codec_fourcc || !timebase_den || !timebase_num || !num_frames) {\n\t\tassert(0);\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (gf_bs_available(bs) < IVF_FILE_HEADER_SIZE) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[IVF] Not enough bytes available (\"LLU\").\\n\", gf_bs_available(bs)));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tdw = gf_bs_read_u32(bs);\n\tif (dw != GF_4CC('D', 'K', 'I', 'F')) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[IVF] Invalid signature\\n\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tdw = gf_bs_read_u16_le(bs);\n\tif (dw != 0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[IVF] Wrong IVF version. 0 expected, got %u\\n\", dw));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tdw = gf_bs_read_u16_le(bs); //length of header in bytes\n\tif (dw != IVF_FILE_HEADER_SIZE) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[IVF] Wrong IVF header length. Expected 32 bytes, got %u\\n\", dw));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t*codec_fourcc = gf_bs_read_u32(bs);\n\n\t*width = gf_bs_read_u16_le(bs);\n\t*height = gf_bs_read_u16_le(bs);\n\n\t*timebase_num = gf_bs_read_u32_le(bs);\n\t*timebase_den = gf_bs_read_u32_le(bs);\n\n\t*num_frames = gf_bs_read_u32_le(bs);\n\tgf_bs_read_u32_le(bs); //skip unused\n\n\treturn GF_OK;\n}\n\nGF_Err gf_media_parse_ivf_frame_header(GF_BitStream *bs, u64 *frame_size, u64 *pts)\n{\n\tif (!frame_size) return GF_BAD_PARAM;\n\tif (gf_bs_available(bs) < 12)\n\t\treturn GF_BUFFER_TOO_SMALL;\n\n\t*frame_size = gf_bs_read_u32_le(bs);\n\tif (*frame_size > 256 * 1024 * 1024) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[IVF] Wrong frame size %u\\n\", *frame_size));\n\t\t*frame_size = 0;\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t*pts = gf_bs_read_u64_le(bs);\n\n\treturn GF_OK;\n}\n\nGF_Err gf_media_vp9_parse_superframe(GF_BitStream *bs, u64 ivf_frame_size, u32 *num_frames_in_superframe, u32 frame_sizes[VP9_MAX_FRAMES_IN_SUPERFRAME], u32 *superframe_index_size)\n{\n\tu32 byte, bytes_per_framesize;\n\tu64 pos = gf_bs_get_position(bs), i = 0;\n\tGF_Err e;\n\n\tassert(bs && num_frames_in_superframe);\n\n\t/*initialize like there is no superframe*/\n\tmemset(frame_sizes, 0, VP9_MAX_FRAMES_IN_SUPERFRAME * sizeof(frame_sizes[0]));\n\t*num_frames_in_superframe = 1;\n\tframe_sizes[0] = (u32)ivf_frame_size;\n\t*superframe_index_size = 0;\n\n\te = gf_bs_seek(bs, pos + ivf_frame_size - 1);\n\tif (e) return e;\n\n\tbyte = gf_bs_read_u8(bs);\n\tif ((byte & 0xe0) != 0xc0)\n\t\tgoto exit; /*no superframe*/\n\n\tbytes_per_framesize = 1 + ((byte & 0x18) >> 3);\n\t*num_frames_in_superframe = (u32)(1 + (byte & 0x7));\n\n\t/*superframe_index()*/\n\t*superframe_index_size = 2 + bytes_per_framesize * *num_frames_in_superframe;\n\tgf_bs_seek(bs, pos + ivf_frame_size - *superframe_index_size);\n\tbyte = gf_bs_read_u8(bs);\n\tif ((byte & 0xe0) != 0xc0)\n\t\tgoto exit; /*no superframe*/\n\n\tframe_sizes[0] = 0;\n\tfor (i = 0; i < *num_frames_in_superframe; ++i) {\n\t\tgf_bs_read_data(bs, (char*)(frame_sizes + i), bytes_per_framesize);\n\t}\n\nexit:\n\tgf_bs_seek(bs, pos);\n\treturn e;\n}\n\n\nstatic Bool vp9_frame_sync_code(GF_BitStream *bs)\n{\n\tu8 val = gf_bs_read_int_log(bs, 8, \"syncbyte1\");\n\tif (val != 0x49)\n\t\treturn GF_FALSE;\n\n\tval = gf_bs_read_int_log(bs, 8, \"syncbyte2\");\n\tif (val != 0x83)\n\t\treturn GF_FALSE;\n\n\tval = gf_bs_read_int_log(bs, 8, \"syncbyte3\");\n\tif (val != 0x42)\n\t\treturn GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\ntypedef enum {\n\tCS_UNKNOWN = 0,\n\tCS_BT_601 = 1,\n\tCS_BT_709 = 2,\n\tCS_SMPTE_170 = 3,\n\tCS_SMPTE_240 = 4,\n\tCS_BT_2020 = 5,\n\tCS_RESERVED = 6,\n\tCS_RGB = 7,\n} VP9_color_space;\n\nstatic const int VP9_CS_to_23001_8_colour_primaries[] = { -1/*undefined*/, 5, 1, 6, 7, 9, -1/*reserved*/, 1 };\nstatic const int VP9_CS_to_23001_8_transfer_characteristics[] = { -1/*undefined*/, 5, 1, 6, 7, 9, -1/*reserved*/, 13 };\nstatic const int VP9_CS_to_23001_8_matrix_coefficients[] = { -1/*undefined*/, 6, 1, -1, -1, 9, -1/*reserved*/, 0 };\n\nstatic GF_Err vp9_color_config(GF_BitStream *bs, GF_VPConfig *vp9_cfg)\n{\n\tVP9_color_space color_space;\n\n\tif (vp9_cfg->profile >= 2) {\n\t\tBool ten_or_twelve_bit = gf_bs_read_int_log(bs, 1, \"ten_or_twelve_bit\");\n\t\tvp9_cfg->bit_depth = ten_or_twelve_bit ? 12 : 10;\n\t}\n\telse {\n\t\tvp9_cfg->bit_depth = 8;\n\t}\n\n\tcolor_space = gf_bs_read_int_log(bs, 3, \"color_space\");\n\tvp9_cfg->colour_primaries = VP9_CS_to_23001_8_colour_primaries[color_space];\n\tvp9_cfg->transfer_characteristics = VP9_CS_to_23001_8_transfer_characteristics[color_space];\n\tvp9_cfg->matrix_coefficients = VP9_CS_to_23001_8_matrix_coefficients[color_space];\n\tif (color_space != CS_RGB) {\n\t\tvp9_cfg->video_fullRange_flag = gf_bs_read_int_log(bs, 1, \"video_fullRange_flag\");\n\t\tif (vp9_cfg->profile == 1 || vp9_cfg->profile == 3) {\n\t\t\tu8 subsampling_x, subsampling_y, subsampling_xy_to_chroma_subsampling[2][2] = { {3, 0}, {2, 0} };\n\t\t\tsubsampling_x = gf_bs_read_int_log(bs, 1, \"subsampling_x\");\n\t\t\tsubsampling_y = gf_bs_read_int_log(bs, 1, \"subsampling_x\");\n\t\t\tvp9_cfg->chroma_subsampling = subsampling_xy_to_chroma_subsampling[subsampling_x][subsampling_y];\n\t\t\tBool reserved_zero = gf_bs_read_int_log(bs, 1, \"reserved_zero\");\n\t\t\tif (reserved_zero) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VP9] color config reserved zero (1) is not zero.\\n\"));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvp9_cfg->chroma_subsampling = 0;\n\t\t}\n\t}\n\telse {\n\t\tvp9_cfg->video_fullRange_flag = GF_TRUE;\n\t\tif (vp9_cfg->profile == 1 || vp9_cfg->profile == 3) {\n\t\t\tvp9_cfg->chroma_subsampling = 3;\n\t\t\tBool reserved_zero = gf_bs_read_int_log(bs, 1, \"reserved_zero\");\n\t\t\tif (reserved_zero) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VP9] color config reserved zero (2) is not zero.\\n\"));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nstatic void vp9_compute_image_size(int FrameWidth, int FrameHeight, int *Sb64Cols, int *Sb64Rows)\n{\n\tint MiCols = (FrameWidth + 7) >> 3;\n\tint MiRows = (FrameHeight + 7) >> 3;\n\t*Sb64Cols = (MiCols + 7) >> 3;\n\t*Sb64Rows = (MiRows + 7) >> 3;\n}\n\nstatic void vp9_frame_size(GF_BitStream *bs, int *FrameWidth, int *FrameHeight, int *Sb64Cols, int *Sb64Rows)\n{\n\tint frame_width_minus_1 = gf_bs_read_int_log(bs, 16, \"frame_width_minus_1\");\n\tint frame_height_minus_1 = gf_bs_read_int_log(bs, 16, \"frame_height_minus_1\");\n\tif (frame_width_minus_1 + 1 != *FrameWidth || frame_height_minus_1 + 1 != *FrameHeight) {\n\t\tif (*FrameWidth || *FrameHeight)\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[VP9] inconsistent frame dimensions: previous was %dx%d, new one is %dx%d.\\n\", *FrameWidth, *FrameHeight, frame_width_minus_1 + 1, frame_height_minus_1 + 1));\n\t}\n\t*FrameWidth = frame_width_minus_1 + 1;\n\t*FrameHeight = frame_height_minus_1 + 1;\n\tvp9_compute_image_size(*FrameWidth, *FrameHeight, Sb64Cols, Sb64Rows);\n}\n\nstatic void vp9_render_size(GF_BitStream *bs, int FrameWidth, int FrameHeight, int *renderWidth, int *renderHeight)\n{\n\tBool render_and_frame_size_different = gf_bs_read_int_log(bs, 1, \"render_and_frame_size_different\");\n\tif (render_and_frame_size_different == 1) {\n\t\tint render_width_minus_1 = gf_bs_read_int_log(bs, 16, \"render_width_minus_1\");\n\t\tint render_height_minus_1 = gf_bs_read_int_log(bs, 16, \"render_height_minus_1\");\n\t\t*renderWidth = render_width_minus_1 + 1;\n\t\t*renderHeight = render_height_minus_1 + 1;\n\t}\n\telse {\n\t\t*renderWidth = FrameWidth;\n\t\t*renderHeight = FrameHeight;\n\t}\n}\n\nstatic s64 vp9_s(GF_BitStream *bs, int n, const char *fname, u32 idx) {\n\ts64 value = gf_bs_read_int(bs, n);\n\tBool sign = gf_bs_read_int(bs, 1);\n\tif (sign) value = -value;\n\tgf_bs_log_idx(bs, n+1, fname, value, idx, -1, -1);\n\treturn value;\n}\n\nstatic void vp9_loop_filter_params(GF_BitStream *bs)\n{\n\t/*loop_filter_level = */gf_bs_read_int_log(bs, 6, \"loop_filter_level\");\n\t/*loop_filter_sharpness = */gf_bs_read_int_log(bs, 3, \"loop_filter_sharpness\");\n\tBool loop_filter_delta_enabled = gf_bs_read_int_log(bs, 1, \"loop_filter_delta_enabled\");\n\tif (loop_filter_delta_enabled == 1) {\n\t\tBool loop_filter_delta_update = gf_bs_read_int_log(bs, 1, \"loop_filter_delta_update\");\n\t\tif (loop_filter_delta_update == GF_TRUE) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tBool update_ref_delta = gf_bs_read_int_log_idx(bs, 1, \"update_ref_delta\", i);\n\t\t\t\tif (update_ref_delta == GF_TRUE)\n\t\t\t\t\tvp9_s(bs, 6, \"loop_filter_ref_deltas\", i);\n\t\t\t}\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tBool update_mode_delta = gf_bs_read_int_log_idx(bs, 1, \"update_mode_delta\", i);\n\t\t\t\tif (update_mode_delta == GF_TRUE)\n\t\t\t\t\tvp9_s(bs, 6, \"loop_filter_mode_deltas\", i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void vp9_quantization_params(GF_BitStream *bs)\n{\n\t/*base_q_idx = */gf_bs_read_int_log(bs, 8, \"base_q_idx\");\n}\n\n#define VP9_MAX_SEGMENTS 8\n#define VP9_SEG_LVL_MAX 4\nstatic const int segmentation_feature_bits[VP9_SEG_LVL_MAX] = { 8, 6, 2, 0 };\nstatic const int segmentation_feature_signed[VP9_SEG_LVL_MAX] = { 1, 1, 0, 0 };\n\n#define VP9_MIN_TILE_WIDTH_B64 4\n#define VP9_MAX_TILE_WIDTH_B64 64\n\nstatic void vp9_segmentation_params(GF_BitStream *bs)\n{\n\tBool segmentation_enabled = gf_bs_read_int_log(bs, 1, \"segmentation_enabled\");\n\tif (segmentation_enabled == 1) {\n\t\tint i;\n\t\tBool segmentation_update_map = gf_bs_read_int_log(bs, 1, \"segmentation_update_map\");\n\t\tif (segmentation_update_map) {\n\t\t\tfor (i = 0; i < 7; i++)\n\t\t\t\t/*segmentation_tree_probs[i] = read_prob()*/\n\t\t\t\t/*segmentation_temporal_update = */gf_bs_read_int_log(bs, 1, \"segmentation_temporal_update\");\n\t\t\t/*for (i = 0; i < 3; i++)\n\t\t\t\tsegmentation_pred_prob[i] = segmentation_temporal_update ? read_prob() : 255*/\n\t\t}\n\t\tBool segmentation_update_data = gf_bs_read_int_log(bs, 1, \"segmentation_update_data\");\n\t\tif (segmentation_update_data == 1) {\n\t\t\t/*segmentation_abs_or_delta_update =*/ gf_bs_read_int_log(bs, 1, \"segmentation_abs_or_delta_update\");\n\t\t\tfor (i = 0; i < VP9_MAX_SEGMENTS; i++) {\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < VP9_SEG_LVL_MAX; j++) {\n\t\t\t\t\t/*feature_value = 0*/\n\t\t\t\t\tBool feature_enabled = gf_bs_read_int_log(bs, 1, \"feature_enabled\");\n\t\t\t\t\t/*FeatureEnabled[i][j] = feature_enabled*/\n\t\t\t\t\tif (feature_enabled) {\n\t\t\t\t\t\tint bits_to_read = segmentation_feature_bits[j];\n\t\t\t\t\t\t/*feature_value =*/ gf_bs_read_int_log(bs, bits_to_read, \"feature_value\");\n\t\t\t\t\t\tif (segmentation_feature_signed[j] == 1) {\n\t\t\t\t\t\t\t/*Bool feature_sign = */gf_bs_read_int_log(bs, 1, \"feature_sign\");\n\t\t\t\t\t\t\t/*if (feature_sign == 1)\n\t\t\t\t\t\t\t\tfeature_value *= -1*/\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*FeatureData[i][j] = feature_value*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int calc_min_log2_tile_cols(int Sb64Cols) {\n\tint minLog2 = 0;\n\twhile ((VP9_MAX_TILE_WIDTH_B64 << minLog2) < Sb64Cols)\n\t\tminLog2++;\n\n\treturn minLog2;\n}\n\nstatic int calc_max_log2_tile_cols(int Sb64Cols) {\n\tint maxLog2 = 1;\n\twhile ((Sb64Cols >> maxLog2) >= VP9_MIN_TILE_WIDTH_B64)\n\t\tmaxLog2++;\n\n\treturn maxLog2 - 1;\n}\n\nstatic void vp9_tile_info(GF_BitStream *bs, int Sb64Cols)\n{\n\tBool tile_rows_log2;\n\tint minLog2TileCols = calc_min_log2_tile_cols(Sb64Cols);\n\tint maxLog2TileCols = calc_max_log2_tile_cols(Sb64Cols);\n\tint tile_cols_log2 = minLog2TileCols;\n\twhile (tile_cols_log2 < maxLog2TileCols) {\n\t\tBool increment_tile_cols_log2 = gf_bs_read_int_log(bs, 1, \"increment_tile_cols_log2\");\n\t\tif (increment_tile_cols_log2)\n\t\t\ttile_cols_log2++;\n\t\telse\n\t\t\tbreak;\n\t}\n\ttile_rows_log2 = gf_bs_read_int_log(bs, 1, \"tile_rows_log2\");\n\tif (tile_rows_log2) {\n\t\t/*Bool increment_tile_rows_log2 = */gf_bs_read_int_log(bs, 1, \"increment_tile_rows_log2\");\n\t\t//tile_rows_log2 += increment_tile_rows_log2;\n\t}\n}\n\nstatic void vp9_frame_size_with_refs(GF_BitStream *bs, u8 refresh_frame_flags, u8 * ref_frame_idx, int * RefFrameWidth, int *RefFrameHeight,\n\tint *FrameWidth, int *FrameHeight, int *RenderWidth, int *RenderHeight, int *Sb64Cols, int *Sb64Rows)\n{\n\tBool found_ref;\n\tint i;\n\tfor (i = 0; i < 3; i++) {\n\t\tfound_ref = gf_bs_read_int_log(bs, 1, \"found_ref\");\n\t\tif (found_ref) {\n\t\t\t*FrameWidth  = RefFrameWidth [ref_frame_idx[i]];\n\t\t\t*FrameHeight = RefFrameHeight[ref_frame_idx[i]];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found_ref == 0) {\n\t\tvp9_frame_size(bs, FrameWidth, FrameHeight, Sb64Cols, Sb64Rows);\n\t}\n\telse {\n\t\tvp9_compute_image_size(*FrameWidth, *FrameHeight, Sb64Cols, Sb64Rows);\n\t}\n\n\tvp9_render_size(bs, *FrameWidth, *FrameHeight, RenderWidth, RenderHeight);\n}\n\nstatic void vp9_read_interpolation_filter(GF_BitStream *bs)\n{\n\tBool is_filter_switchable = gf_bs_read_int_log(bs, 1, \"is_filter_switchable\");\n\tif (!is_filter_switchable) {\n\t\t/*raw_interpolation_filter = */gf_bs_read_int_log(bs, 2, \"raw_interpolation_filter\");\n\t}\n}\n\n\n#define VP9_KEY_FRAME 0\n\nGF_Err gf_media_vp9_parse_sample(GF_BitStream *bs, GF_VPConfig *vp9_cfg, Bool *key_frame, u32 *FrameWidth, u32 *FrameHeight, u32 *renderWidth, u32 *renderHeight)\n{\n\tBool FrameIsIntra = GF_FALSE, profile_low_bit, profile_high_bit, show_existing_frame = GF_FALSE, frame_type = GF_FALSE, show_frame = GF_FALSE, error_resilient_mode = GF_FALSE;\n\t/*u8 frame_context_idx = 0, reset_frame_context = 0, frame_marker = 0*/;\n\tint Sb64Cols = 0, Sb64Rows = 0, i;\n\tu8 refresh_frame_flags = 0;\n\n\tassert(bs && key_frame);\n\n\t/*uncompressed header*/\n\t/*frame_marker = */gf_bs_read_int_log(bs, 2, \"frame_marker\");\n\tprofile_low_bit = gf_bs_read_int_log(bs, 1, \"profile_low_bit\");\n\tprofile_high_bit = gf_bs_read_int_log(bs, 1, \"profile_high_bit\");\n\tvp9_cfg->profile = (profile_high_bit << 1) + profile_low_bit;\n\tif (vp9_cfg->profile == 3) {\n\t\tBool reserved_zero = gf_bs_read_int_log(bs, 1, \"reserved_zero\");\n\t\tif (reserved_zero) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VP9] uncompressed header reserved zero is not zero.\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t}\n\n\tshow_existing_frame = gf_bs_read_int_log(bs, 1, \"show_existing_frame\");\n\tif (show_existing_frame == GF_TRUE) {\n\t\t/*frame_to_show_map_idx = */gf_bs_read_int_log(bs, 3, \"frame_to_show_map_idx\");\n\t\treturn GF_OK;\n\t}\n\n\tframe_type = gf_bs_read_int_log(bs, 1, \"frame_type\");\n\tshow_frame = gf_bs_read_int_log(bs, 1, \"show_frame\");\n\terror_resilient_mode = gf_bs_read_int_log(bs, 1, \"error_resilient_mode\");\n\tif (frame_type == VP9_KEY_FRAME) {\n\t\tif (!vp9_frame_sync_code(bs))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tif (vp9_color_config(bs, vp9_cfg) != GF_OK)\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tvp9_frame_size(bs, FrameWidth, FrameHeight, &Sb64Cols, &Sb64Rows);\n\t\tvp9_render_size(bs, *FrameWidth, *FrameHeight, renderWidth, renderHeight);\n\t\trefresh_frame_flags = 0xFF;\n\t\t*key_frame = GF_TRUE;\n\t\tFrameIsIntra = GF_TRUE;\n\t}\n\telse {\n\t\tBool intra_only = GF_FALSE;\n\t\t*key_frame = GF_FALSE;\n\n\t\tif (show_frame == GF_FALSE) {\n\t\t\tintra_only = gf_bs_read_int_log(bs, 1, \"intra_only\");\n\t\t}\n\t\tFrameIsIntra = intra_only;\n\n\t\tif (error_resilient_mode == GF_FALSE) {\n\t\t\t/*reset_frame_context = */gf_bs_read_int_log(bs, 2, \"reset_frame_context\");\n\t\t}\n\n\t\tif (intra_only == GF_TRUE) {\n\t\t\tif (!vp9_frame_sync_code(bs))\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n\t\t\tif (vp9_cfg->profile > 0) {\n\t\t\t\tif (vp9_color_config(bs, vp9_cfg) != GF_OK)\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tu8 color_space = CS_BT_601;\n\t\t\t\tvp9_cfg->colour_primaries = VP9_CS_to_23001_8_colour_primaries[color_space];\n\t\t\t\tvp9_cfg->transfer_characteristics = VP9_CS_to_23001_8_transfer_characteristics[color_space];\n\t\t\t\tvp9_cfg->matrix_coefficients = VP9_CS_to_23001_8_matrix_coefficients[color_space];\n\t\t\t\tvp9_cfg->chroma_subsampling = 0;\n\t\t\t\tvp9_cfg->bit_depth = 8;\n\t\t\t}\n\t\t\trefresh_frame_flags = gf_bs_read_int_log(bs, 8, \"refresh_frame_flags\");\n\t\t\tvp9_frame_size(bs, FrameWidth, FrameHeight, &Sb64Cols, &Sb64Rows);\n\t\t\tvp9_render_size(bs, *FrameWidth, *FrameHeight, renderWidth, renderHeight);\n\t\t}\n\t\telse {\n\t\t\trefresh_frame_flags = gf_bs_read_int_log(bs, 8, \"refresh_frame_flags\");\n\t\t\tu8 ref_frame_idx[3];\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tref_frame_idx[i] = gf_bs_read_int_log_idx(bs, 3, \"ref_frame_idx\", i);\n\t\t\t\t/*ref_frame_sign_bias[LAST_FRAME + i] = */gf_bs_read_int_log_idx(bs, 1, \"ref_frame_sign_bias\", i);\n\t\t\t}\n\t\t\tvp9_frame_size_with_refs(bs, refresh_frame_flags, ref_frame_idx, vp9_cfg->RefFrameWidth, vp9_cfg->RefFrameHeight, FrameWidth, FrameHeight, renderWidth, renderHeight, &Sb64Cols, &Sb64Rows);\n\t\t\t/*allow_high_precision_mv = */gf_bs_read_int_log(bs, 1, \"allow_high_precision_mv\");\n\t\t\tvp9_read_interpolation_filter(bs);\n\t\t}\n\t}\n\n\tif (error_resilient_mode == 0) {\n\t\t/*refresh_frame_context = */gf_bs_read_int_log(bs, 1, \"refresh_frame_context\");\n\t\t/*frame_parallel_decoding_mode = */gf_bs_read_int_log(bs, 1, \"frame_parallel_decoding_mode\");\n\t}\n\n\t/*frame_context_idx = */gf_bs_read_int_log(bs, 2, \"frame_context_idx\");\n\tif (FrameIsIntra || error_resilient_mode) {\n\t\t/*setup_past_independence + save_probs ...*/\n\t\t//frame_context_idx = 0;\n\t}\n\n\tvp9_loop_filter_params(bs);\n\tvp9_quantization_params(bs);\n\tvp9_segmentation_params(bs);\n\tvp9_tile_info(bs, Sb64Cols);\n\n\t/*header_size_in_bytes = */gf_bs_read_int_log(bs, 16, \"header_size_in_bytes\");\n\n\t/*Reference frame update process (8.10 - partial)*/\n\tfor (i = 0; i < VP9_NUM_REF_FRAMES; i++) {\n\t\tif ((refresh_frame_flags >> i) & 1) {\n\t\t\tvp9_cfg->RefFrameWidth[i] = *FrameWidth;\n\t\t\tvp9_cfg->RefFrameHeight[i] = *FrameHeight;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err gf_av1_parse_obu_header(GF_BitStream *bs, ObuType *obu_type, Bool *obu_extension_flag, Bool *obu_has_size_field, u8 *temporal_id, u8 *spatial_id)\n{\n\tBool forbidden = gf_bs_read_int(bs, 1);\n\tif (forbidden) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t*obu_type = gf_bs_read_int(bs, 4);\n\t*obu_extension_flag = gf_bs_read_int(bs, 1);\n\t*obu_has_size_field = gf_bs_read_int(bs, 1);\n\tif (gf_bs_read_int(bs, 1) /*obu_reserved_1bit*/) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (*obu_extension_flag) {\n\t\t*temporal_id = gf_bs_read_int(bs, 3);\n\t\t*spatial_id = gf_bs_read_int(bs, 2);\n\t\t/*extension_header_reserved_3bits = */gf_bs_read_int(bs, 3);\n\t}\n\n\treturn GF_OK;\n}\n\n#endif // GPAC_DISABLE_AV_PARSERS\n\nGF_EXPORT\nconst char *gf_av1_get_obu_name(ObuType obu_type)\n{\n\tswitch (obu_type) {\n\tcase OBU_SEQUENCE_HEADER: return \"seq_header\";\n\tcase OBU_TEMPORAL_DELIMITER: return \"delimiter\";\n\tcase OBU_FRAME_HEADER: return \"frame_header\";\n\tcase OBU_TILE_GROUP: return \"tile_group\";\n\tcase OBU_METADATA: return \"metadata\";\n\tcase OBU_FRAME: return \"frame\";\n\tcase OBU_REDUNDANT_FRAME_HEADER: return \"redundant_frame_header\";\n\tcase OBU_TILE_LIST: return \"tile_list\";\n\tcase OBU_PADDING: return \"padding\";\n\tcase OBU_RESERVED_0:\n\tcase OBU_RESERVED_9:\n\tcase OBU_RESERVED_10:\n\tcase OBU_RESERVED_11:\n\tcase OBU_RESERVED_12:\n\tcase OBU_RESERVED_13:\n\tcase OBU_RESERVED_14:\n\t\treturn \"reserved\";\n\tdefault: return \"unknown\";\n\t}\n}\n\nBool av1_is_obu_header(ObuType obu_type) {\n\tswitch (obu_type) {\n\tcase OBU_SEQUENCE_HEADER:\n\tcase OBU_METADATA:\n\t\t// TODO add check based on the metadata type\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nstatic Bool av1_is_obu_frame(AV1State *state, ObuType obu_type)\n{\n\tswitch (obu_type) {\n\tcase OBU_PADDING:\n\tcase OBU_REDUNDANT_FRAME_HEADER:\n\t\treturn GF_FALSE;\n\tcase OBU_TEMPORAL_DELIMITER:\n\t\treturn state->keep_temporal_delim ? GF_TRUE : GF_FALSE;\n\tdefault:\n\t\treturn GF_TRUE;\n\t}\n}\n\nu64 gf_av1_leb128_read(GF_BitStream *bs, u8 *opt_Leb128Bytes) {\n\tu64 value = 0;\n\tu8 Leb128Bytes = 0, i = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tu8 leb128_byte = gf_bs_read_u8(bs);\n\t\tvalue |= ( ((u64) (leb128_byte & 0x7f)) << (i * 7));\n\t\tLeb128Bytes += 1;\n\t\tif (!(leb128_byte & 0x80)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opt_Leb128Bytes) {\n\t\t*opt_Leb128Bytes = Leb128Bytes;\n\t}\n\treturn value;\n}\n\nu32 gf_av1_leb128_size(u64 value)\n{\n\tu32 gf_av1_leb128_size = 0;\n\tdo {\n\t\t++gf_av1_leb128_size;\n\t} while ((value >>= 7) != 0);\n\n\treturn gf_av1_leb128_size;\n}\n\nu64 gf_av1_leb128_write(GF_BitStream *bs, u64 value)\n{\n\tu32 i, leb_size = gf_av1_leb128_size(value);\n\tfor (i = 0; i < leb_size; ++i) {\n\t\tu8 byte = value & 0x7f;\n\t\tvalue >>= 7;\n\t\tif (value != 0) byte |= 0x80; //more bytes follow\n\t\tgf_bs_write_u8(bs, byte);\n\t}\n\n\treturn leb_size;\n}\n\n#define OBU_BLOCK_SIZE 4096\nstatic void av1_add_obu_internal(GF_BitStream *bs, u64 pos, u64 obu_length, ObuType obu_type, GF_List **obu_list, AV1State *state)\n{\n\tchar block[OBU_BLOCK_SIZE];\n\tBool has_size_field = 0, obu_extension_flag = 0;\n\tu8 temporal_id, spatial_id;\n\tGF_AV1_OBUArrayEntry *a = NULL;\n\n\tif (state && state->mem_mode) {\n\t\tif (!state->bs) state->bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\telse gf_bs_reassign_buffer(state->bs, state->frame_obus, state->frame_obus_alloc);\n\t}\n\telse {\n\t\tGF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);\n\t\tif (!a) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] Failed to allocate OBU\\n\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tgf_bs_seek(bs, pos);\n\tgf_av1_parse_obu_header(bs, &obu_type, &obu_extension_flag, &has_size_field, &temporal_id, &spatial_id);\n\tgf_bs_seek(bs, pos);\n\n\tif (has_size_field) {\n\t\tif (a) {\n\t\t\ta->obu = gf_malloc((size_t)obu_length);\n\t\t\tgf_bs_read_data(bs, a->obu, (u32)obu_length);\n\t\t\ta->obu_length = obu_length;\n\t\t}\n\t\telse {\n\t\t\tu32 remain = (u32)obu_length;\n\t\t\twhile (remain) {\n\t\t\t\tu32 block_size = OBU_BLOCK_SIZE;\n\t\t\t\tif (block_size > remain) block_size = remain;\n\t\t\t\tgf_bs_read_data(bs, block, block_size);\n\t\t\t\tgf_bs_write_data(state->bs, block, block_size);\n\t\t\t\tremain -= block_size;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\telse {\n\t\tu8 i, hdr_size = obu_extension_flag ? 2 : 1;\n\t\tconst u32 leb_size = (u32)gf_av1_leb128_size(obu_length);\n\t\tconst u64 obu_size = obu_length - hdr_size;\n\n\t\tif (a) {\n\t\t\ta->obu = gf_malloc((size_t)obu_length + leb_size);\n\t\t\ta->obu_length = obu_length + leb_size;\n\t\t\tfor (i = 0; i < hdr_size; ++i) {\n\t\t\t\ta->obu[i] = gf_bs_read_u8(bs);\n\t\t\t\t/*add size field flag*/\n\t\t\t\tif (i == 0) a->obu[0] |= 0x02;\n\t\t\t}\n\t\t\t{\n\t\t\t\tu32 out_size = 0;\n\t\t\t\tu8 *output = NULL;\n\t\t\t\tGF_BitStream *bsLeb128 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t/*write size field*/\n\t\t\t\tgf_av1_leb128_write(bsLeb128, obu_size);\n\t\t\t\tassert(gf_bs_get_position(bsLeb128) == leb_size);\n\t\t\t\tgf_bs_get_content(bsLeb128, &output, &out_size);\n\t\t\t\tgf_bs_del(bsLeb128);\n\t\t\t\tmemcpy(a->obu + hdr_size, output, out_size);\n\t\t\t\tgf_free(output);\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, a->obu + hdr_size + leb_size, (u32)(obu_size));\n\t\t\tassert(gf_bs_get_position(bs) == pos + obu_length);\n\t\t}\n\t\telse {\n\t\t\tu32 remain;\n\t\t\tfor (i = 0; i < hdr_size; ++i) {\n\t\t\t\tu8 hdr_b = gf_bs_read_u8(bs);\n\t\t\t\tif (i == 0) hdr_b |= 0x02; /*add size field flag*/\n\t\t\t\tgf_bs_write_u8(state->bs, hdr_b);\n\t\t\t}\n\t\t\t/*add size field */\n\t\t\tgf_av1_leb128_write(state->bs, obu_size);\n\t\t\tremain = (u32)obu_length - hdr_size;\n\t\t\twhile (remain) {\n\t\t\t\tu32 block_size = OBU_BLOCK_SIZE;\n\t\t\t\tif (block_size > remain) block_size = remain;\n\t\t\t\tgf_bs_read_data(bs, block, block_size);\n\t\t\t\tgf_bs_write_data(state->bs, block, block_size);\n\t\t\t\tremain -= block_size;\n\t\t\t}\n\t\t\tassert(gf_bs_get_position(bs) == pos + obu_length);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!obu_list) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] internal error, no OBU list cannot add\\n\"));\n\t\tgf_free(a->obu);\n\t\tgf_free(a);\n\t\treturn;\n\t}\n\ta->obu_type = obu_type;\n\tif (! *obu_list)\n\t\t*obu_list = gf_list_new();\n\tgf_list_add(*obu_list, a);\n}\n\nstatic void av1_populate_state_from_obu(GF_BitStream *bs, u64 pos, u64 obu_length, ObuType obu_type, AV1State *state)\n{\n\tif (av1_is_obu_header(obu_type)) {\n\t\tav1_add_obu_internal(bs, pos, obu_length, obu_type, &state->frame_state.header_obus, NULL);\n\t}\n\tif (!state->skip_frames && av1_is_obu_frame(state, obu_type)) {\n\t\tif (!state->mem_mode) {\n\t\t\tav1_add_obu_internal(bs, pos, obu_length, obu_type, &state->frame_state.frame_obus, NULL);\n\t\t}\n\t\telse {\n\t\t\tav1_add_obu_internal(bs, pos, obu_length, obu_type, NULL, state);\n\t\t}\n\t}\n}\n\nGF_Err aom_av1_parse_temporal_unit_from_section5(GF_BitStream *bs, AV1State *state)\n{\n\tif (!state) return GF_BAD_PARAM;\n\tstate->obu_type = -1;\n\n\twhile (state->obu_type != OBU_TEMPORAL_DELIMITER) {\n\t\tGF_Err e;\n\t\tif (!gf_bs_available(bs))\n\t\t\treturn state->unframed ? GF_BUFFER_TOO_SMALL : GF_OK;\n\n\t\tu64 pos = gf_bs_get_position(bs), obu_length = 0;\n\n\t\te = gf_av1_parse_obu(bs, &state->obu_type, &obu_length, NULL, state);\n\t\tif (e)\n\t\t\treturn e;\n\n\t\tif (obu_length != gf_bs_get_position(bs) - pos) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] OBU (Section 5) frame size \"LLU\" different from consumed bytes \"LLU\".\\n\", obu_length, gf_bs_get_position(bs) - pos));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] Section5 OBU detected (size \"LLU\")\\n\", obu_length));\n\t\tav1_populate_state_from_obu(bs, pos, obu_length, state->obu_type, state);\n\t}\n\n\treturn GF_OK;\n}\n\nBool gf_media_aom_probe_annexb(GF_BitStream *bs)\n{\n\tBool res = GF_TRUE;\n\tu64 init_pos = gf_bs_get_position(bs);\n\tu64 sz = gf_av1_leb128_read(bs, NULL);\n\tif (!sz) res = GF_FALSE;\n\twhile (sz > 0) {\n\t\tu8 Leb128Bytes = 0;\n\t\tu64 frame_unit_size = gf_av1_leb128_read(bs, &Leb128Bytes);\n\n\t\tif (!frame_unit_size) {\n\t\t\tres = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sz < Leb128Bytes + frame_unit_size) {\n\t\t\tres = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tsz -= Leb128Bytes + frame_unit_size;\n\n\t\twhile (frame_unit_size > 0) {\n\t\t\tObuType obu_type;\n\t\t\tu64 pos, obu_length = gf_av1_leb128_read(bs, &Leb128Bytes);\n\t\t\tif (frame_unit_size < Leb128Bytes + obu_length) {\n\t\t\t\tres = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = gf_bs_get_position(bs);\n\t\t\tframe_unit_size -= Leb128Bytes;\n\n\t\t\tu8 tid, sid;\n\t\t\tBool extflag, has_size;\n\t\t\tGF_Err e = gf_av1_parse_obu_header(bs, &obu_type, &extflag, &has_size, &tid, &sid);\n\t\t\tif (e) {\n\t\t\t\tres = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (has_size) {\n\t\t\t\tobu_length = (u32)gf_av1_leb128_read(bs, NULL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (obu_length >= 1 + extflag) {\n\t\t\t\t\tobu_length = obu_length - 1 - extflag;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = GF_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu32 hdr_size = (u32)(gf_bs_get_position(bs) - pos);\n\t\t\tobu_length += hdr_size;\n\n\t\t\tif (frame_unit_size < obu_length) {\n\t\t\t\tres = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tframe_unit_size -= obu_length;\n\t\t\tgf_bs_skip_bytes(bs, obu_length - hdr_size);\n\t\t}\n\t\tif (!res) break;\n\t}\n\tgf_bs_seek(bs, init_pos);\n\treturn res;\n}\n\nGF_Err aom_av1_parse_temporal_unit_from_annexb(GF_BitStream *bs, AV1State *state)\n{\n\tGF_Err e;\n\tu64 tupos;\n\tu64 tusize, sz;\n\tif (!bs || !state) return GF_BAD_PARAM;\n\n\tstate->bs_overread = GF_FALSE;\n\ttusize = sz = gf_av1_leb128_read(bs, NULL);\n\ttupos = gf_bs_get_position(bs);\n\tif (!sz) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[AV1] temporal unit size is 0, likely not annex B\\n\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] Annex B temporal unit detected (size \"LLU\") ***** \\n\", sz));\n\twhile (sz > 0) {\n\t\tu8 Leb128Bytes = 0;\n\t\tu64 frame_unit_size = gf_av1_leb128_read(bs, &Leb128Bytes);\n\n\t\tif (state->bs_overread) {\n\t\t\treturn GF_BUFFER_TOO_SMALL;\n\t\t}\n\t\tif (sz < Leb128Bytes + frame_unit_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] Annex B sz(\"LLU\") < Leb128Bytes(\"LLU\") + frame_unit_size(\"LLU\")\\n\", sz, Leb128Bytes, frame_unit_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] Annex B frame unit detected (size \"LLU\")\\n\", frame_unit_size));\n\t\tsz -= Leb128Bytes + frame_unit_size;\n\n\t\twhile (frame_unit_size > 0) {\n\t\t\tu64 pos, obu_length = gf_av1_leb128_read(bs, &Leb128Bytes);\n\n\t\t\tif (state->bs_overread) {\n\t\t\t\treturn GF_BUFFER_TOO_SMALL;\n\t\t\t}\n\t\t\tif (frame_unit_size < Leb128Bytes + obu_length) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] Annex B frame_unit_size(\"LLU\") < Leb128Bytes(\"LLU\") + obu_length(\"LLU\")\\n\", frame_unit_size, Leb128Bytes, obu_length));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] Annex B OBU detected (size \"LLU\")\\n\", obu_length));\n\t\t\tpos = gf_bs_get_position(bs);\n\t\t\tframe_unit_size -= Leb128Bytes;\n\n\t\t\te = gf_av1_parse_obu(bs, &state->obu_type, &obu_length, NULL, state);\n\t\t\tif (e) return e;\n\n\t\t\tif (obu_length != gf_bs_get_position(bs) - pos) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] Annex B frame size \"LLU\" different from consumed bytes \"LLU\".\\n\", obu_length, gf_bs_get_position(bs) - pos));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\n\t\t\tav1_populate_state_from_obu(bs, pos, obu_length, state->obu_type, state);\n\t\t\tif (frame_unit_size < obu_length) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] Annex B frame_unit_size(\"LLU\") < OBU size (\"LLU\")\\n\", frame_unit_size, obu_length));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\tframe_unit_size -= obu_length;\n\t\t}\n\t}\n\tassert(sz == 0);\n\tif (tusize != gf_bs_get_position(bs) - tupos) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] Annex B TU size \"LLU\" different from consumed bytes \"LLU\".\\n\", tusize, gf_bs_get_position(bs) - tupos));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err aom_av1_parse_temporal_unit_from_ivf(GF_BitStream *bs, AV1State *state)\n{\n\tu64 frame_size, pts_ignored;\n\tGF_Err e;\n\tif (gf_bs_available(bs)<12) return GF_EOS;\n\te = gf_media_parse_ivf_frame_header(bs, &frame_size, &pts_ignored);\n\tif (e) return e;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] IVF frame detected (size \"LLU\")\\n\", frame_size));\n\n\tif (gf_bs_available(bs) < frame_size) return GF_EOS;\n\n\twhile (frame_size > 0) {\n\t\tu64 obu_size = 0, pos = gf_bs_get_position(bs);\n\n\t\te = gf_av1_parse_obu(bs, &state->obu_type, &obu_size, NULL, state);\n\t\tif (e != GF_OK)\n\t\t\treturn e;\n\n\t\tif (obu_size != gf_bs_get_position(bs) - pos) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] IVF frame size \"LLU\" different from consumed bytes \"LLU\".\\n\", obu_size, gf_bs_get_position(bs) - pos));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tav1_populate_state_from_obu(bs, pos, obu_size, state->obu_type, state);\n\n\t\tframe_size -= obu_size;\n\t}\n\treturn GF_OK;\n}\n\n#define AV1_NUM_REF_FRAMES 8\n#define AV1_ALL_FRAMES ((1 << AV1_NUM_REF_FRAMES) - 1)\n\n#define AV1_SUPERRES_DENOM_MIN 9\n#define AV1_SUPERRES_DENOM_BITS 3\n#define AV1_SUPERRES_NUM 8\n\n#define AV1_REFS_PER_FRAME 7\n#define AV1_PRIMARY_REF_NONE 7\n\n#define MAX_TILE_WIDTH 4096\n#define MAX_TILE_AREA (4096 * 2304)\n\nstatic u32 aom_av1_tile_log2(u32 blkSize, u32 target)\n{\n\tu32 k;\n\tfor (k = 0; (blkSize << k) < target; k++) {\n\t}\n\treturn k;\n}\n\nstatic u64 aom_av1_le(GF_BitStream *bs, u32 n, const char *name) {\n\tu32 i = 0;\n\tu64 t = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tu8 byte = gf_bs_read_int(bs, 8);\n\t\tt += (byte << (i * 8));\n\t}\n\tgf_bs_log(bs, n*8, name, t);\n\treturn t;\n}\n\n\nstatic void av1_parse_tile_info(GF_BitStream *bs, AV1State *state)\n{\n\tu32 i;\n\tu32 MiCols = 2 * ((state->width + 7) >> 3);\n\tu32 MiRows = 2 * ((state->height + 7) >> 3);\n\tu32 sbCols = state->use_128x128_superblock ? ((MiCols + 31) >> 5) : ((MiCols + 15) >> 4);\n\tu32 sbRows = state->use_128x128_superblock ? ((MiRows + 31) >> 5) : ((MiRows + 15) >> 4);\n\tu32 sbShift = state->use_128x128_superblock ? 5 : 4;\n\tu32 sbSize = sbShift + 2;\n\tu32 maxTileWidthSb = MAX_TILE_WIDTH >> sbSize;\n\tu32 maxTileAreaSb = MAX_TILE_AREA >> (2 * sbSize);\n\tu32 minLog2tileCols = aom_av1_tile_log2(maxTileWidthSb, sbCols);\n\tu32 maxLog2tileCols = aom_av1_tile_log2(1, MIN(sbCols, AV1_MAX_TILE_COLS));\n\tu32 maxLog2tileRows = aom_av1_tile_log2(1, MIN(sbRows, AV1_MAX_TILE_ROWS));\n\tu32 minLog2Tiles = MAX(minLog2tileCols, aom_av1_tile_log2(maxTileAreaSb, sbRows * sbCols));\n\tBool uniform_tile_spacing_flag = gf_bs_read_int_log(bs, 1, \"uniform_tile_spacing_flag\");\n\tif (uniform_tile_spacing_flag) {\n\t\tu32 startSb, tileWidthSb, tileHeightSb, minLog2tileRows;\n\t\tstate->tileColsLog2 = minLog2tileCols;\n\t\twhile (state->tileColsLog2 < maxLog2tileCols) {\n\t\t\tBool increment_tile_cols_log2 = gf_bs_read_int_log(bs, 1, \"increment_tile_cols_log2\");\n\t\t\tif (increment_tile_cols_log2 == 1)\n\t\t\t\tstate->tileColsLog2++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttileWidthSb = (sbCols + (1 << state->tileColsLog2) - 1) >> state->tileColsLog2;\n\t\ti = 0;\n\t\tfor (startSb = 0; startSb < sbCols; startSb += tileWidthSb) {\n\t\t\ti += 1;\n\t\t}\n\t\tstate->tileCols = i;\n\t\tminLog2tileRows = MAX((int)(minLog2Tiles - state->tileColsLog2), 0);\n\t\tstate->tileRowsLog2 = minLog2tileRows;\n\t\twhile (state->tileRowsLog2 < maxLog2tileRows) {\n\t\t\tBool increment_tile_rows_log2 = gf_bs_read_int_log(bs, 1, \"increment_tile_rows_log2\");\n\t\t\tif (increment_tile_rows_log2 == 1)\n\t\t\t\tstate->tileRowsLog2++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttileHeightSb = (sbRows + (1 << state->tileRowsLog2) - 1) >> state->tileRowsLog2;\n\t\ti = 0;\n\t\tfor (startSb = 0; startSb < sbRows; startSb += tileHeightSb) {\n\t\t\ti += 1;\n\t\t}\n\t\tstate->tileRows = i;\n\t}\n\telse {\n\t\tu32 startSb, maxTileHeightSb, widestTileSb;\n\t\twidestTileSb = 0;\n\t\tstartSb = 0;\n\t\tfor (i = 0; startSb < sbCols; i++) {\n\t\t\tu32 maxWidth = MIN((int)(sbCols - startSb), maxTileWidthSb);\n\t\t\tu32 width_in_sbs_minus_1 = av1_read_ns(bs, maxWidth, \"width_in_sbs_minus_1\");\n\t\t\tu32 sizeSb = width_in_sbs_minus_1 + 1;\n\t\t\twidestTileSb = MAX(sizeSb, widestTileSb);\n\t\t\tstartSb += sizeSb;\n\t\t}\n\t\tif (!widestTileSb) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] widest tile is 0, broken bitstream\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tstate->tileCols = i;\n\t\tstate->tileColsLog2 = aom_av1_tile_log2(1, state->tileCols);\n\n\t\tif (minLog2Tiles > 0)\n\t\t\tmaxTileAreaSb = (sbRows * sbCols) >> (minLog2Tiles + 1);\n\t\telse\n\t\t\tmaxTileAreaSb = sbRows * sbCols;\n\t\tmaxTileHeightSb = MAX(maxTileAreaSb / widestTileSb, 1);\n\n\t\tstartSb = 0;\n\t\tfor (i = 0; startSb < sbRows; i++) {\n\t\t\tu32 maxHeight = MIN((int)(sbRows - startSb), maxTileHeightSb);\n\t\t\tu32 height_in_sbs_minus_1 = av1_read_ns(bs, maxHeight, \"height_in_sbs_minus_1\");\n\t\t\tu32 sizeSb = height_in_sbs_minus_1 + 1;\n\t\t\tstartSb += sizeSb;\n\t\t}\n\n\t\tstate->tileRows = i;\n\t\tstate->tileRowsLog2 = aom_av1_tile_log2(1, state->tileRows);\n\t}\n\tif (state->tileColsLog2 > 0 || state->tileRowsLog2 > 0) {\n\t\tgf_bs_read_int_log(bs, state->tileRowsLog2 + state->tileColsLog2, \"context_update_tile_id\");\n\t\tstate->tile_size_bytes = gf_bs_read_int_log(bs, 2, \"tile_size_bytes_minus1\") + 1;\n\t}\n}\n\nstatic void superres_params(GF_BitStream *bs, AV1State *state)\n{\n\tu32 SuperresDenom;\n\tBool use_superres;\n\n\tif (state->enable_superres) {\n\t\tuse_superres = gf_bs_read_int_log(bs, 1, \"use_superres\");\n\t}\n\telse {\n\t\tuse_superres = GF_FALSE;\n\t}\n\tif (use_superres) {\n\t\tu8 coded_denom = gf_bs_read_int_log(bs, AV1_SUPERRES_DENOM_BITS, \"coded_denom\");\n\t\tSuperresDenom = coded_denom + AV1_SUPERRES_DENOM_MIN;\n\t}\n\telse {\n\t\tSuperresDenom = AV1_SUPERRES_NUM;\n\t}\n\tstate->UpscaledWidth = state->width;\n\tstate->width = (state->UpscaledWidth * AV1_SUPERRES_NUM + (SuperresDenom / 2)) / SuperresDenom;\n}\n\nstatic void av1_frame_size(GF_BitStream *bs, AV1State *state, Bool frame_size_override_flag)\n{\n\tif (frame_size_override_flag) {\n\t\tu32 frame_width_minus_1, frame_height_minus_1;\n\t\tu8 n = state->frame_width_bits_minus_1 + 1;\n\t\tframe_width_minus_1 = gf_bs_read_int_log(bs, n, \"frame_width_minus_1\");\n\t\tn = state->frame_height_bits_minus_1 + 1;\n\t\tframe_height_minus_1 = gf_bs_read_int_log(bs, n, \"frame_height_minus_1\");\n\t\tstate->width = frame_width_minus_1 + 1;\n\t\tstate->height = frame_height_minus_1 + 1;\n\t} else {\n\t\tstate->width = state->sequence_width;\n\t\tstate->height = state->sequence_height;\n\t}\n\tsuperres_params(bs, state);\n\t//compute_image_size(); //no bits\n}\n\nstatic void av1_render_size(GF_BitStream *bs)\n{\n\tBool render_and_frame_size_different = gf_bs_read_int_log(bs, 1, \"render_and_frame_size_different_flag\");\n\tif (render_and_frame_size_different == GF_TRUE) {\n\t\tgf_bs_read_int_log(bs, 16, \"render_width_minus_1\");\n\t\tgf_bs_read_int_log(bs, 16, \"render_height_minus_1\");\n\t\t//RenderWidth = render_width_minus_1 + 1;\n\t\t//RenderHeight = render_height_minus_1 + 1;\n\t}\n\telse {\n\t\t//RenderWidth = UpscaledWidth;\n\t\t//RenderHeight = FrameHeight;\n\t}\n}\n\nstatic void read_interpolation_filter(GF_BitStream *bs)\n{\n\tBool is_filter_switchable = gf_bs_read_int_log(bs, 1, \"is_filter_switchable\");\n\tif (!is_filter_switchable) {\n\t\t/*interpolation_filter =*/ gf_bs_read_int_log(bs, 2, \"interpolation_filter\");\n\t}\n}\n\nstatic void frame_size_with_refs(GF_BitStream *bs, AV1State *state, Bool frame_size_override_flag, s8 *ref_frame_idx)\n{\n\tBool found_ref = GF_FALSE;\n\tu32 i = 0;\n\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\tfound_ref = gf_bs_read_int_log_idx(bs, 1, \"found_ref\", i);\n\t\tif (found_ref == 1) {\n\t\t\tstate->UpscaledWidth = state->RefUpscaledWidth[ref_frame_idx[i]];\n\t\t\tstate->width = state->UpscaledWidth;\n\t\t\tstate->height = state->RefFrameHeight[ref_frame_idx[i]];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found_ref == 0) {\n\t\tav1_frame_size(bs, state, frame_size_override_flag);\n\t\tav1_render_size(bs);\n\t}\n\telse {\n\t\tsuperres_params(bs, state);\n\t\t//compute_image_size();\n\t}\n}\n\nstatic s32 av1_delta_q(GF_BitStream *bs, const char *name_flag, const char *name)\n{\n\tBool delta_coded = gf_bs_read_int_log(bs, 1, name_flag);\n\ts32 delta_q = 0;\n\tif (delta_coded) {\n\t\tu32 signMask = 1 << (7 - 1);\n\t\tdelta_q = gf_bs_read_int_log(bs, 7, name);\n\t\tif (delta_q & signMask)\n\t\t\tdelta_q = delta_q - 2 * signMask;\n\t}\n\treturn delta_q;\n}\n\nstatic u8 Segmentation_Feature_Bits[] = { 8,6,6,6,6,3,0,0 };\nstatic u8 Segmentation_Feature_Signed[] = { 1, 1, 1, 1, 1, 0, 0, 0 };\n\nstatic u8 av1_get_qindex(Bool ignoreDeltaQ, u32 segmentId, u32 base_q_idx, u32 delta_q_present, u32 CurrentQIndex, Bool segmentation_enabled, u8 *features_SEG_LVL_ALT_Q_enabled, s32 *features_SEG_LVL_ALT_Q)\n{\n\t//If seg_feature_active_idx( segmentId, SEG_LVL_ALT_Q ) is equal to 1 the following ordered steps apply:\n\tif (segmentation_enabled && features_SEG_LVL_ALT_Q_enabled[segmentId]) {\n\t\t//Set the variable data equal to FeatureData[ segmentId ][ SEG_LVL_ALT_Q ].\n\t\ts32 data = features_SEG_LVL_ALT_Q[segmentId];\n\t\ts32 qindex = base_q_idx + data;\n\t\t//If ignoreDeltaQ is equal to 0 and delta_q_present is equal to 1, set qindex equal to CurrentQIndex + data.\n\t\tif ((ignoreDeltaQ == 0) && (delta_q_present == 1)) qindex = CurrentQIndex + data;\n\t\t//Return Clip3( 0, 255, qindex ).\n\t\tif (qindex < 0) return 0;\n\t\telse if (qindex > 255) return 255;\n\t\telse return (u8)qindex;\n\t}\n\t//Otherwise, if ignoreDeltaQ is equal to 0 and delta_q_present is equal to 1, return CurrentQIndex.\n\tif ((ignoreDeltaQ == 0) && (delta_q_present == 1)) return CurrentQIndex;\n\t//otherwise\n\treturn base_q_idx;\n}\n\nenum {\n\tAV1_RESTORE_NONE = 0,\n\tAV1_RESTORE_SWITCHABLE,\n\tAV1_RESTORE_WIENER,\n\tAV1_RESTORE_SGRPROJ\n};\n\n#define AV1_GMC_IDENTITY  0\n#define AV1_GMC_TRANSLATION 1\n#define AV1_GMC_ROTZOOM 2\n#define AV1_GMC_AFFINE 3\n\n#define AV1_LAST_FRAME 1\n#define AV1_LAST2_FRAME 2\n#define AV1_LAST3_FRAME 3\n#define AV1_GOLDEN_FRAME 4\n#define AV1_BWDREF_FRAME 5\n#define AV1_ALTREF2_FRAME 6\n#define AV1_ALTREF_FRAME 7\n\n#define GM_ABS_ALPHA_BITS 12\n#define GM_ALPHA_PREC_BITS 15\n#define GM_ABS_TRANS_ONLY_BITS 9\n#define GM_TRANS_ONLY_PREC_BITS 3\n#define GM_ABS_TRANS_BITS 12\n#define GM_TRANS_PREC_BITS 6\n#define WARPEDMODEL_PREC_BITS 16\n\n\nstatic u32 av1_decode_subexp(GF_BitStream *bs, s32 numSyms)\n{\n\ts32 i = 0;\n\ts32 mk = 0;\n\ts32 k = 3;\n\twhile (1) {\n\t\ts32 b2 = i ? k + i - 1 : k;\n\t\ts32 a = 1 << b2;\n\t\tif (numSyms <= mk + 3 * a) {\n\t\t\ts32 subexp_final_bits = av1_read_ns(bs, numSyms - mk, NULL);\n\t\t\treturn subexp_final_bits + mk;\n\t\t}\n\t\telse {\n\t\t\ts32 subexp_more_bits = gf_bs_read_int(bs, 1);\n\t\t\tif (subexp_more_bits) {\n\t\t\t\ti++;\n\t\t\t\tmk += a;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts32 subexp_bits = gf_bs_read_int(bs, b2);\n\t\t\t\treturn subexp_bits + mk;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic GFINLINE s32 inverse_recenter(s32 r, u32 v)\n{\n\tif ((s64)v > (s64)(2 * r))\n\t\treturn v;\n\telse if (v & 1)\n\t\treturn r - ((v + 1) >> 1);\n\telse\n\t\treturn r + (v >> 1);\n}\n\nstatic s32 av1_decode_unsigned_subexp_with_ref(GF_BitStream *bs, s32 mx, s32 r)\n{\n\tu32 v = av1_decode_subexp(bs, mx);\n\tif ((r < 0) && (-(-r << 1) <= mx)) {\n\t\treturn inverse_recenter(r, v);\n\t}\n\telse if ((r << 1) <= mx) {\n\t\treturn inverse_recenter(r, v);\n\t}\n\telse {\n\t\treturn mx - 1 - inverse_recenter(mx - 1 - r, v);\n\t}\n}\nstatic s16 av1_decode_signed_subexp_with_ref(GF_BitStream *bs, s32 low, s32 high, s32 r)\n{\n\ts16 x = av1_decode_unsigned_subexp_with_ref(bs, high - low, r - low);\n\treturn x + low;\n}\n\nstatic void av1_read_global_param(AV1State *state, GF_BitStream *bs, u8 type, u8 ref, u8 idx)\n{\n\tu8 absBits = GM_ABS_ALPHA_BITS;\n\tu8 precBits = GM_ALPHA_PREC_BITS;\n\tif (idx < 2) {\n\t\tif (type == AV1_GMC_TRANSLATION) {\n\t\t\tabsBits = GM_ABS_TRANS_ONLY_BITS - (!state->frame_state.allow_high_precision_mv ? 1 : 0);\n\t\t\tprecBits = GM_TRANS_ONLY_PREC_BITS - (!state->frame_state.allow_high_precision_mv ? 1 : 0);\n\t\t}\n\t\telse {\n\t\t\tabsBits = GM_ABS_TRANS_BITS;\n\t\t\tprecBits = GM_TRANS_PREC_BITS;\n\t\t}\n\t}\n\ts32 precDiff = WARPEDMODEL_PREC_BITS - precBits;\n\ts32 round = (idx % 3) == 2 ? (1 << WARPEDMODEL_PREC_BITS) : 0;\n\ts32 sub = (idx % 3) == 2 ? (1 << precBits) : 0;\n\ts32 mx = (1 << absBits);\n\ts32 r = (state->PrevGmParams.coefs[ref][idx] >> precDiff) - sub;\n\ts32 val = av1_decode_signed_subexp_with_ref(bs, -mx, mx + 1, r);\n\n\tif (val < 0) {\n\t\tval = -val;\n\t\tstate->GmParams.coefs[ref][idx] = (-(val << precDiff) + round);\n\t}\n\telse {\n\t\tstate->GmParams.coefs[ref][idx] = (val << precDiff) + round;\n\t}\n}\n\nstatic s32 av1_get_relative_dist(s32 a, s32 b, AV1State *state)\n{\n\tif (!state->enable_order_hint)\n\t\treturn 0;\n\ts32 diff = a - b;\n\ts32 m = 1 << (state->OrderHintBits - 1);\n\tdiff = (diff & (m - 1)) - (diff & m);\n\treturn diff;\n}\n\nstatic void av1_setup_past_independence(AV1State *state)\n{\n\tu32 ref, i;\n\tfor (ref = AV1_LAST_FRAME; ref <= AV1_ALTREF_FRAME; ref++) {\n\t\tfor (i = 0; i <= 5; i++) {\n\t\t\tstate->PrevGmParams.coefs[ref][i] = ((i % 3 == 2) ? 1 << WARPEDMODEL_PREC_BITS : 0);\n\t\t}\n\t}\n}\n\nstatic void av1_load_previous(AV1State *state, u8 primary_ref_frame, s8 *ref_frame_idx)\n{\n\ts8 prevFrame = ref_frame_idx[primary_ref_frame];\n\tif (prevFrame < 0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] load_previous: prevFrame reference index %d is invalid\\n\", prevFrame));\n\t}\n\telse {\n\t\tstate->PrevGmParams = state->SavedGmParams[prevFrame];\n\t\t// load_loop_filter_params( prevFrame )\n\t\t// load_segmentation_params( prevFrame )\n\t}\n}\n\nstatic void av1_decode_frame_wrapup(AV1State *state)\n{\n\tu32 i;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\tif ((state->frame_state.refresh_frame_flags >> i) & 1) {\n\t\t\tstate->RefOrderHint[i] = state->frame_state.order_hint;\n\t\t\tstate->SavedGmParams[i] = state->GmParams;\n\t\t\tstate->RefFrameType[i] = state->frame_state.frame_type;\n\t\t\tstate->RefUpscaledWidth[i] = state->UpscaledWidth;\n\t\t\tstate->RefFrameHeight[i] = state->height;\n\t\t}\n\t}\n\tstate->frame_state.seen_frame_header = GF_FALSE;\n\t//Otherwise (show_existing_frame is equal to 1), if frame_type is equal to KEY_FRAME, the reference frame loading process as specified in section 7.21 is invoked\n\tif ((state->frame_state.show_existing_frame) && (state->frame_state.frame_type == AV1_KEY_FRAME)) {\n\t\tstate->frame_state.order_hint = state->RefOrderHint[state->frame_state.frame_to_show_map_idx];\n\t\t//OrderHints[ j + LAST_FRAME ] is set equal to SavedOrderHints[state->frame_to_show_map_idx ][ j + LAST_FRAME ] for j = 0..REFS_PER_FRAME-1.\n\n\t\t//gm_params[ ref ][ j ] is set equal to SavedGmParams[ frame_to_show_map_idx ][ ref ][ j ] for ref = LAST_FRAME..ALTREF_FRAME, for j = 0..5.\n\t\tstate->GmParams = state->SavedGmParams[state->frame_state.frame_to_show_map_idx];\n\n\t}\n}\n\nstatic s32 find_latest_forward(u32 curFrameHint, u8 *shiftedOrderHints, u8 *usedFrame)\n{\n\tu32 i;\n\ts32 ref = -1;\n\ts32 latestOrderHint = 0;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\ts32 hint = shiftedOrderHints[i];\n\t\tif (!usedFrame[i] && ((u32)hint < curFrameHint) && (ref < 0 || hint >= latestOrderHint)) {\n\t\t\tref = i;\n\t\t\tlatestOrderHint = hint;\n\t\t}\n\t}\n\treturn ref;\n}\n\n//see 7.8 of AV1 spec\nstatic void av1_set_frame_refs(AV1State *state, u8 last_frame_idx, u8 gold_frame_idx, s8 *ref_frame_idx)\n{\n\tu32 i;\n\tu8 usedFrame[AV1_NUM_REF_FRAMES];\n\tu8 shiftedOrderHints[AV1_NUM_REF_FRAMES];\n\n\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++)\n\t\tref_frame_idx[i] = -1;\n\n\tref_frame_idx[AV1_LAST_FRAME - AV1_LAST_FRAME] = last_frame_idx;\n\tref_frame_idx[AV1_GOLDEN_FRAME - AV1_LAST_FRAME] = gold_frame_idx;\n\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\tusedFrame[i] = 0;\n\t}\n\n\tusedFrame[last_frame_idx] = 1;\n\tusedFrame[gold_frame_idx] = 1;\n\tu32 curFrameHint = 1 << (state->OrderHintBits - 1);\n\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\tshiftedOrderHints[i] = curFrameHint + av1_get_relative_dist(state->RefOrderHint[i], state->frame_state.order_hint, state);\n\t}\n\n\tu8 lastOrderHint = shiftedOrderHints[last_frame_idx];\n\tu8 goldOrderHint = shiftedOrderHints[gold_frame_idx];\n\n\t//It is a requirement of bitstream conformance that lastOrderHint is strictly less than curFrameHint.\n\tif (lastOrderHint >= curFrameHint) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] non conformant bitstream detected while setting up frame refs: lastOrderHint(%d) shall be stricly less than curFrameHint(%d)\\n\", lastOrderHint, curFrameHint));\n\t}\n\t//It is a requirement of bitstream conformance that goldOrderHint is strictly less than curFrameHint.\n\tif (goldOrderHint >= curFrameHint) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] non conformant bitstream detected while setting up frame refs: goldOrderHint(%d) shall be stricly less than curFrameHint(%d)\\n\", lastOrderHint, curFrameHint));\n\t}\n\n\t//find_latest_backward() {\n\ts32 ref = -1;\n\ts32 latestOrderHint = 0;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\ts32 hint = shiftedOrderHints[i];\n\t\tif (!usedFrame[i] && ((u32)hint >= curFrameHint) && (ref < 0 || hint >= latestOrderHint)) {\n\t\t\tref = i;\n\t\t\tlatestOrderHint = hint;\n\t\t}\n\t}\n\tif (ref >= 0) {\n\t\tref_frame_idx[AV1_ALTREF_FRAME - AV1_LAST_FRAME] = ref;\n\t\tusedFrame[ref] = 1;\n\t}\n\t//find_earliest_backward() for BWDREF_FRAME\n\tref = -1;\n\ts32 earliestOrderHint = 0;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\ts32 hint = shiftedOrderHints[i];\n\t\tif (!usedFrame[i] && ((u32)hint >= curFrameHint) && (ref < 0 || hint < earliestOrderHint)) {\n\t\t\tref = i;\n\t\t\tearliestOrderHint = hint;\n\t\t}\n\t}\n\tif (ref >= 0) {\n\t\tref_frame_idx[AV1_BWDREF_FRAME - AV1_LAST_FRAME] = ref;\n\t\tusedFrame[ref] = 1;\n\t}\n\n\t//find_earliest_backward() for ALTREF2_FRAME\n\tref = -1;\n\tearliestOrderHint = 0;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\ts32 hint = shiftedOrderHints[i];\n\t\tif (!usedFrame[i] && ((u32)hint >= curFrameHint) && (ref < 0 || hint < earliestOrderHint)) {\n\t\t\tref = i;\n\t\t\tearliestOrderHint = hint;\n\t\t}\n\t}\n\tif (ref >= 0) {\n\t\tref_frame_idx[AV1_ALTREF2_FRAME - AV1_LAST_FRAME] = ref;\n\t\tusedFrame[ref] = 1;\n\t}\n\n\t//The remaining references are set to be forward references in anti-chronological order as follows:\n\n\tconst u8 Ref_Frame_List[AV1_REFS_PER_FRAME - 2] = {\n\t\tAV1_LAST2_FRAME, AV1_LAST3_FRAME, AV1_BWDREF_FRAME, AV1_ALTREF2_FRAME, AV1_ALTREF_FRAME\n\t};\n\n\tfor (i = 0; i < AV1_REFS_PER_FRAME - 2; i++) {\n\t\tu8 refFrame = Ref_Frame_List[i];\n\t\tif (ref_frame_idx[refFrame - AV1_LAST_FRAME] < 0) {\n\t\t\ts32 last_ref = find_latest_forward(curFrameHint, shiftedOrderHints, usedFrame);\n\t\t\tif (last_ref >= 0) {\n\t\t\t\tref_frame_idx[refFrame - AV1_LAST_FRAME] = last_ref;\n\t\t\t\tusedFrame[last_ref] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t//Finally, any remaining references are set to the reference frame with smallest output order as follows:\n\tref = -1;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\ts32 hint = shiftedOrderHints[i];\n\t\tif (ref < 0 || hint < earliestOrderHint) {\n\t\t\tref = i;\n\t\t\tearliestOrderHint = hint;\n\t\t}\n\t}\n\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\tif (ref_frame_idx[i] < 0) {\n\t\t\tref_frame_idx[i] = ref;\n\t\t}\n\t}\n}\n\n\nstatic void av1_parse_uncompressed_header(GF_BitStream *bs, AV1State *state)\n{\n\tBool error_resilient_mode = GF_FALSE, allow_screen_content_tools = GF_FALSE, force_integer_mv = GF_FALSE;\n\tBool /*use_ref_frame_mvs = GF_FALSE,*/ FrameIsIntra = GF_FALSE, frame_size_override_flag = GF_FALSE;\n\tBool disable_cdf_update = GF_FALSE;\n\tu8 showable_frame;\n\tu8 primary_ref_frame;\n\tu16 idLen = 0;\n\tu32 idx;\n\ts8 ref_frame_idx[AV1_REFS_PER_FRAME];\n\tAV1StateFrame *frame_state = &state->frame_state;\n\n\tif (state->frame_id_numbers_present_flag) {\n\t\tidLen = (state->additional_frame_id_length_minus_1 + state->delta_frame_id_length_minus_2 + 3);\n\t}\n\tframe_state->refresh_frame_flags = 0;\n\n\tshowable_frame = 0;\n\tif (state->reduced_still_picture_header) {\n\t\tframe_state->key_frame = GF_TRUE;\n\t\tFrameIsIntra = GF_TRUE;\n\t\tframe_state->frame_type = AV1_KEY_FRAME;\n\t\tframe_state->show_frame = GF_TRUE;\n\t\tframe_state->show_existing_frame = 0;\n\t}\n\telse {\n\t\tframe_state->show_existing_frame = gf_bs_read_int_log(bs, 1, \"show_existing_frame\");\n\t\tif (frame_state->show_existing_frame == GF_TRUE) {\n\t\t\tframe_state->frame_to_show_map_idx = gf_bs_read_int_log(bs, 3, \"frame_to_show_map_idx\");\n\t\t\tframe_state->frame_type = state->RefFrameType[frame_state->frame_to_show_map_idx];\n\n\t\t\tif (state->decoder_model_info_present_flag && !state->equal_picture_interval) {\n\t\t\t\tgf_bs_read_int_log(bs, state->frame_presentation_time_length, \"frame_presentation_time\");\n\t\t\t}\n\n\t\t\tframe_state->refresh_frame_flags = 0;\n\t\t\tif (state->frame_id_numbers_present_flag) {\n\t\t\t\tgf_bs_read_int_log(bs, idLen, \"display_frame_id\");\n\t\t\t}\n\t\t\tif (frame_state->frame_type == AV1_KEY_FRAME) {\n\t\t\t\tframe_state->refresh_frame_flags = AV1_ALL_FRAMES;\n\t\t\t}\n\t\t\t/*\n\t\t\tif (film_grain_params_present) {\n\t\t\t\tload_grain_params(frame_to_show_map_idx)\n\t\t\t}*/\n\t\t\treturn;\n\t\t}\n\t\tframe_state->frame_type = gf_bs_read_int_log(bs, 2, \"frame_type\");\n\t\tFrameIsIntra = (frame_state->frame_type == AV1_INTRA_ONLY_FRAME || frame_state->frame_type == AV1_KEY_FRAME);\n\t\tframe_state->show_frame = gf_bs_read_int_log(bs, 1, \"show_frame\");\n\t\tif (frame_state->is_first_frame) {\n\t\t\tframe_state->key_frame = frame_state->seen_seq_header && frame_state->show_frame && frame_state->frame_type == AV1_KEY_FRAME && frame_state->seen_frame_header;\n\t\t}\n\t\tif (frame_state->show_frame && state->decoder_model_info_present_flag && !state->equal_picture_interval) {\n\t\t\tgf_bs_read_int_log(bs, state->frame_presentation_time_length, \"frame_presentation_time\");\n\t\t}\n\t\tif (frame_state->show_frame) {\n\t\t\tshowable_frame = frame_state->frame_type != AV1_KEY_FRAME;\n\n\t\t}\n\t\telse {\n\t\t\tshowable_frame = gf_bs_read_int_log(bs, 1, \"showable_frame\");\n\t\t}\n\t\tif (frame_state->frame_type == AV1_SWITCH_FRAME || (frame_state->frame_type == AV1_KEY_FRAME && frame_state->show_frame))\n\t\t\terror_resilient_mode = GF_TRUE;\n\t\telse\n\t\t\terror_resilient_mode = gf_bs_read_int_log(bs, 1, \"error_resilient_mode\");\n\t}\n\n\tif ((frame_state->frame_type == AV1_KEY_FRAME) && frame_state->show_frame) {\n\t\tu32 i;\n\t\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\t\tstate->RefValid[i] = 0;\n\t\t\tstate->RefOrderHint[i] = 0;\n\t\t}\n\t\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\t\tstate->OrderHints[AV1_LAST_FRAME + i] = 0;\n\t\t}\n\t}\n\n\tdisable_cdf_update = gf_bs_read_int_log(bs, 1, \"disable_cdf_update\");\n\tif (state->seq_force_screen_content_tools == 2/*SELECT_SCREEN_CONTENT_TOOLS*/) {\n\t\tallow_screen_content_tools = gf_bs_read_int_log(bs, 1, \"allow_screen_content_tools\");\n\t}\n\telse {\n\t\tallow_screen_content_tools = state->seq_force_screen_content_tools;\n\t}\n\tif (allow_screen_content_tools) {\n\t\tif (state->seq_force_integer_mv == 2/*SELECT_INTEGER_MV*/) {\n\t\t\tforce_integer_mv = gf_bs_read_int_log(bs, 1, \"force_integer_mv\");\n\t\t}\n\t\telse {\n\t\t\tforce_integer_mv = state->seq_force_integer_mv;\n\t\t}\n\t}\n\telse {\n\t\tforce_integer_mv = 0;\n\t}\n\tif (FrameIsIntra) {\n\t\tforce_integer_mv = 1;\n\t}\n\tif (state->frame_id_numbers_present_flag) {\n\t\tgf_bs_read_int_log(bs, idLen, \"current_frame_id\");\n\t}\n\tif (frame_state->frame_type == AV1_SWITCH_FRAME)\n\t\tframe_size_override_flag = GF_TRUE;\n\telse if (state->reduced_still_picture_header)\n\t\tframe_size_override_flag = GF_FALSE;\n\telse\n\t\tframe_size_override_flag = gf_bs_read_int_log(bs, 1, \"frame_size_override_flag\");\n\n\tframe_state->order_hint = gf_bs_read_int_log(bs, state->OrderHintBits, \"order_hint\");\n\tif (FrameIsIntra || error_resilient_mode) {\n\t\tprimary_ref_frame = AV1_PRIMARY_REF_NONE;\n\t}\n\telse {\n\t\tprimary_ref_frame = gf_bs_read_int_log(bs, 3, \"primary_ref_frame\");\n\t}\n\n\tif (state->decoder_model_info_present_flag) {\n\t\tu8 buffer_removal_time_present_flag = gf_bs_read_int_log(bs, 1, \"buffer_removal_time_present_flag\");\n\t\tif (buffer_removal_time_present_flag) {\n\t\t\tu32 opNum;\n\t\t\tfor (opNum = 0; opNum < state->operating_points_count; opNum++) {\n\t\t\t\tif (state->decoder_model_present_for_this_op[opNum]) {\n\t\t\t\t\tu8 opPtIdc = state->operating_point_idc[opNum];\n\t\t\t\t\tu8 inTemporalLayer = (opPtIdc >> state->temporal_id) & 1;\n\t\t\t\t\tu8 inSpatialLayer = (opPtIdc >> (state->spatial_id + 8)) & 1;\n\t\t\t\t\tif (opPtIdc == 0 || (inTemporalLayer && inSpatialLayer)) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, state->buffer_removal_time_length, \"buffer_removal_time\", opNum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (frame_state->frame_type == AV1_SWITCH_FRAME || (frame_state->frame_type == AV1_KEY_FRAME && frame_state->show_frame)) {\n\t\tframe_state->refresh_frame_flags = AV1_ALL_FRAMES;\n\t}\n\telse {\n\t\tframe_state->refresh_frame_flags = gf_bs_read_int_log(bs, 8, \"refresh_frame_flags\");\n\t}\n\tif (!FrameIsIntra || frame_state->refresh_frame_flags != AV1_ALL_FRAMES) {\n\t\tif (error_resilient_mode && state->enable_order_hint) {\n\t\t\tu32 i = 0;\n\t\t\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\t\t\tu8 ref_order_hint = gf_bs_read_int_log_idx(bs, state->OrderHintBits, \"ref_order_hint\", i);\n\t\t\t\tif (ref_order_hint != state->RefOrderHint[i]) {\n\t\t\t\t\tstate->RefValid[i] = 0;\n\t\t\t\t}\n\t\t\t\tstate->RefOrderHint[i] = ref_order_hint;\n\t\t\t}\n\t\t}\n\t}\n\n\tu8 allow_intrabc = 0;\n\tif (frame_state->frame_type == AV1_KEY_FRAME) {\n\t\tav1_frame_size(bs, state, frame_size_override_flag);\n\t\tav1_render_size(bs);\n\t\tif (allow_screen_content_tools && state->UpscaledWidth == state->width) {\n\t\t\tallow_intrabc = gf_bs_read_int_log(bs, 1, \"allow_intrabc\");\n\t\t}\n\t}\n\telse {\n\t\tif (frame_state->frame_type == AV1_INTRA_ONLY_FRAME) {\n\t\t\tav1_frame_size(bs, state, frame_size_override_flag);\n\t\t\tav1_render_size(bs);\n\t\t\tif (allow_screen_content_tools && state->UpscaledWidth == state->width) {\n\t\t\t\tallow_intrabc = gf_bs_read_int_log(bs, 1, \"allow_intrabc\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tu32 i = 0;\n\t\t\tBool frame_refs_short_signaling = GF_FALSE;\n\t\t\tif (state->enable_order_hint) {\n\t\t\t\tframe_refs_short_signaling = gf_bs_read_int_log(bs, 1, \"frame_refs_short_signaling\");\n\t\t\t\tif (frame_refs_short_signaling) {\n\t\t\t\t\tu8 last_frame_idx = gf_bs_read_int_log(bs, 3, \"last_frame_idx\");\n\t\t\t\t\tu8 gold_frame_idx = gf_bs_read_int_log(bs, 3, \"gold_frame_idx\");\n\t\t\t\t\tav1_set_frame_refs(state, last_frame_idx, gold_frame_idx, ref_frame_idx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\t\t\tif (!frame_refs_short_signaling)\n\t\t\t\t\tref_frame_idx[i] = gf_bs_read_int_log_idx(bs, 3, \"ref_frame_idx\", i);\n\n\t\t\t\tif (state->frame_id_numbers_present_flag) {\n\t\t\t\t\tu32 n = state->delta_frame_id_length_minus_2 + 2;\n\t\t\t\t\t/*delta_frame_id_minus_1 =*/ gf_bs_read_int_log_idx(bs, n, \"delta_frame_id_minus1\", i);\n\t\t\t\t\t//DeltaFrameId = delta_frame_id_minus_1 + 1;\n\t\t\t\t\t//expectedFrameId[i] = ((current_frame_id + (1 << idLen) - DeltaFrameId) % (1 << idLen));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (frame_size_override_flag && !error_resilient_mode) {\n\t\t\t\tframe_size_with_refs(bs, state, frame_size_override_flag, ref_frame_idx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tav1_frame_size(bs, state, frame_size_override_flag);\n\t\t\t\tav1_render_size(bs);\n\t\t\t}\n\t\t\tframe_state->allow_high_precision_mv = 0;\n\t\t\tif (!force_integer_mv) {\n\t\t\t\tframe_state->allow_high_precision_mv = gf_bs_read_int_log(bs, 1, \"allow_high_precision_mv\");\n\t\t\t}\n\n\t\t\tread_interpolation_filter(bs);\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"is_motion_mode_switchable\");\n\t\t\tif (!(error_resilient_mode || !state->enable_ref_frame_mvs)) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"use_ref_frame_mvs\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!FrameIsIntra) {\n\t\tu32 i;\n\t\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\t\tu8 refFrame = AV1_LAST_FRAME + i;\n\t\t\tu8 ridx = ref_frame_idx[i];\n\t\t\tif (ridx >= 0) {\n\t\t\t\tu8 hint = state->RefOrderHint[ridx];\n\t\t\t\tstate->OrderHints[refFrame] = hint;\n\t\t\t\t/*\t\t\tif ( !enable_order_hint ) {\n\t\t\t\t\t\t\t\tRefFrameSignBias[ refFrame ] = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tRefFrameSignBias[ refFrame ] = get_relative_dist( hint, OrderHint) > 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (!(state->reduced_still_picture_header || disable_cdf_update))\n\t\tgf_bs_read_int_log(bs, 1, \"disable_frame_end_update_cdf\");\n\n\tif (primary_ref_frame == AV1_PRIMARY_REF_NONE) {\n\t\t//init_non_coeff_cdfs();\n\t\tav1_setup_past_independence(state);\n\t}\n\telse {\n\t\t//load_cdfs(ref_frame_idx[primary_ref_frame]);\n\t\tav1_load_previous(state, primary_ref_frame, ref_frame_idx);\n\t}\n\n\tav1_parse_tile_info(bs, state);\n\t//quantization_params( ):\n\tu8 base_q_idx = gf_bs_read_int_log(bs, 8, \"base_q_idx\");\n\ts32 DeltaQUDc = 0;\n\ts32 DeltaQUAc = 0;\n\ts32 DeltaQVDc = 0;\n\ts32 DeltaQVAc = 0;\n\ts32 DeltaQYDc = av1_delta_q(bs, \"DeltaQYDc_coded\", \"DeltaQYDc\");\n\tif (!state->config->monochrome) {\n\t\tu8 diff_uv_delta = 0;\n\t\tif (state->separate_uv_delta_q)\n\t\t\tdiff_uv_delta = gf_bs_read_int_log(bs, 1, \"diff_uv_delta\");\n\n\t\tDeltaQUDc = av1_delta_q(bs, \"DeltaQUDc_coded\", \"DeltaQUDc\");\n\t\tDeltaQUAc = av1_delta_q(bs, \"DeltaQUAc_coded\", \"DeltaQUAc\");\n\t\tif (diff_uv_delta) {\n\t\t\tDeltaQVDc = av1_delta_q(bs, \"DeltaQVDc_coded\", \"DeltaQVDc\");\n\t\t\tDeltaQVAc = av1_delta_q(bs, \"DeltaQVAc_coded\", \"DeltaQVAc\");\n\t\t}\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"using_qmatrix\")) {\n\t\tgf_bs_read_int_log(bs, 4, \"qm_y\");\n\t\tgf_bs_read_int_log(bs, 4, \"qm_u\");\n\t\tif (!state->separate_uv_delta_q) {\n\t\t\tgf_bs_read_int_log(bs, 4, \"qm_v\");\n\t\t}\n\t}\n\n\tu8 seg_features_SEG_LVL_ALT_Q_enabled[8] = { 0,0,0,0,0,0,0,0 };\n\ts32 seg_features_SEG_LVL_ALT_Q[8] = { 0,0,0,0,0,0,0,0 };\n\n\t//segmentation_params( ):\n\tu8 segmentation_enabled = gf_bs_read_int_log(bs, 1, \"segmentation_enabled\");\n\tif (segmentation_enabled) {\n\t\t/*u8 segmentation_temporal_update = 0;*/\n\t\tu8 segmentation_update_data = 1;\n\t\tif (primary_ref_frame != AV1_PRIMARY_REF_NONE) {\n\t\t\tu8 segmentation_update_map = gf_bs_read_int_log(bs, 1, \"segmentation_update_map\");\n\t\t\tif (segmentation_update_map == 1)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"segmentation_temporal_update\");\n\t\t\tsegmentation_update_data = gf_bs_read_int_log(bs, 1, \"segmentation_update_data\");\n\t\t}\n\t\tif (segmentation_update_data == 1) {\n\t\t\tu32 i, j;\n\t\t\tfor (i = 0; i < 8/*=MAX_SEGMENTS*/; i++) {\n\t\t\t\tfor (j = 0; j < 8 /*=SEG_LVL_MAX*/; j++) {\n\t\t\t\t\tif (/*feature_enabled = */gf_bs_read_int_log_idx2(bs, 1, \"feature_enabled\", i, j) == 1) {\n\t\t\t\t\t\ts32 val;\n\t\t\t\t\t\tu32 bitsToRead = Segmentation_Feature_Bits[j];\n\t\t\t\t\t\t//this is SEG_LVL_ALT_Q\n\t\t\t\t\t\tif (!j) seg_features_SEG_LVL_ALT_Q_enabled[i] = 1;\n\n\t\t\t\t\t\tif (Segmentation_Feature_Signed[j] == 1) {\n\t\t\t\t\t\t\tval = gf_bs_read_int_log_idx2(bs, 1 + bitsToRead, \"signed_feature_value\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tval = gf_bs_read_int_log_idx2(bs, bitsToRead, \"feature_value\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!j) seg_features_SEG_LVL_ALT_Q[i] = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//ignore all init steps\n\t\t}\n\n\t}\n\n\t//delta_q_params():\n\t/*u8 delta_q_res = 0;*/\n\tu8 delta_q_present = 0;\n\tif (base_q_idx > 0) {\n\t\tdelta_q_present = gf_bs_read_int_log(bs, 1, \"delta_q_present\");\n\t}\n\tif (delta_q_present) {\n\t\tgf_bs_read_int_log(bs, 2, \"delta_q_res\");\n\t}\n\n\t//delta_lf_params():\n\tu8 delta_lf_present = 0;\n\t/*u8 delta_lf_res = 0;\n\tu8 delta_lf_multi = 0;*/\n\tif (delta_q_present) {\n\t\tif (!allow_intrabc) {\n\t\t\tdelta_lf_present = gf_bs_read_int_log(bs, 1, \"delta_lf_present\");\n\t\t}\n\t\tif (delta_lf_present) {\n\t\t\tgf_bs_read_int_log(bs, 2, \"delta_lf_res\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"delta_lf_multi\");\n\t\t}\n\t}\n\n\t//init lossless stuff!\n\tu8 CodedLossless = 1;\n\tfor (idx = 0; idx < 8; idx++) {\n\t\tu8 qindex = av1_get_qindex(GF_TRUE, idx, base_q_idx, delta_q_present, 0/*CurrentQIndex always ignored at this level of parsin*/, segmentation_enabled, seg_features_SEG_LVL_ALT_Q_enabled, seg_features_SEG_LVL_ALT_Q);\n\t\tBool LosslessArray = (qindex == 0) && (DeltaQYDc == 0) && (DeltaQUAc == 0) && (DeltaQUDc == 0) && (DeltaQVAc == 0) && (DeltaQVDc == 0);\n\t\tif (!LosslessArray)\n\t\t\tCodedLossless = 0;\n\t}\n\tBool AllLossless = CodedLossless && (state->width == state->UpscaledWidth);\n\n\t//loop_filter_params():\n\tif (!CodedLossless && !allow_intrabc) {\n\t\tu8 loop_filter_level_0 = gf_bs_read_int_log(bs, 6, \"loop_filter_level_0\");\n\t\tu8 loop_filter_level_1 = gf_bs_read_int_log(bs, 6, \"loop_filter_level_1\");\n\t\tif (!state->config->monochrome) {\n\t\t\tif (loop_filter_level_0 || loop_filter_level_1) {\n\t\t\t\tgf_bs_read_int_log(bs, 6, \"loop_filter_level_2\");\n\t\t\t\tgf_bs_read_int_log(bs, 6, \"loop_filter_level_3\");\n\t\t\t}\n\t\t}\n\t\tgf_bs_read_int_log(bs, 3, \"loop_filter_sharpness\");\n\t\tu8 loop_filter_delta_enabled = gf_bs_read_int_log(bs, 1, \"loop_filter_delta_enabled\");\n\t\tif (loop_filter_delta_enabled == 1) {\n\t\t\tu8 loop_filter_delta_update = gf_bs_read_int_log(bs, 1, \"loop_filter_delta_update\");\n\t\t\tif (loop_filter_delta_update) {\n\t\t\t\tu32 i;\n\t\t\t\tfor (i = 0; i < 8/*TOTAL_REFS_PER_FRAME*/; i++) {\n\t\t\t\t\tu8 update_ref_delta = gf_bs_read_int_log_idx(bs, 1, \"update_ref_delta\", i);\n\t\t\t\t\tif (update_ref_delta == 1) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1 + 6, \"loop_filter_ref_deltas\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\t\tu8 update_mode_delta = gf_bs_read_int_log_idx(bs, 1, \"update_mode_delta\", i);\n\t\t\t\t\tif (update_mode_delta) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1 + 6, \"loop_filter_mode_deltas\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cdef_params( ):\n\tif (!CodedLossless && !allow_intrabc && state->enable_cdef) {\n\t\tgf_bs_read_int_log(bs, 2, \"cdef_damping_minus_3\");\n\t\tu8 cdef_bits = gf_bs_read_int_log(bs, 2, \"cdef_bits\");\n\t\tu32 i, num_cd = 1 << cdef_bits;\n\t\tfor (i = 0; i < num_cd; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, 4, \"cdef_y_pri_strength\", i);\n\t\t\tgf_bs_read_int_log_idx(bs, 2, \"cdef_y_sec_strength\", i);\n\t\t\tif (!state->config->monochrome) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, 4, \"cdef_uv_pri_strength\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 2, \"cdef_uv_sec_strength\", i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//lr_params( ) :\n\tif (!AllLossless && !allow_intrabc && state->enable_restoration) {\n\t\tu32 i, nb_planes = state->config->monochrome ? 1 : 3;\n\t\tu8 UsesLr = 0;\n\t\tu8 usesChromaLr = 0;\n\t\tfor (i = 0; i < nb_planes; i++) {\n\t\t\tu8 lr_type = gf_bs_read_int_log_idx(bs, 2, \"lr_type\", i);\n\t\t\t//FrameRestorationType[i] = Remap_Lr_Type[lr_type]\n\t\t\tif (lr_type != AV1_RESTORE_NONE) {\n\t\t\t\tUsesLr = 1;\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tusesChromaLr = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (UsesLr) {\n\t\t\tif (state->use_128x128_superblock) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"lr_unit_shift_minus_1\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tu8 lr_unit_shift = gf_bs_read_int_log(bs, 1, \"lr_unit_shift\");\n\t\t\t\tif (lr_unit_shift) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"lr_unit_extra_shift\");\n\t\t\t\t\t//lr_unit_shift += lr_unit_extra_shift;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (state->config->chroma_subsampling_x && state->config->chroma_subsampling_y && usesChromaLr) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"lr_uv_shift\");\n\t\t\t}\n\t\t}\n\t}\n\t//read_tx_mode():\n\tif (CodedLossless == 1) {\n\t}\n\telse {\n\t\tgf_bs_read_int_log(bs, 1, \"tx_mode_select\");\n\t}\n\n\t//frame_reference_mode( ):\n\tu8 reference_select = 0;\n\tif (FrameIsIntra) {\n\t}\n\telse {\n\t\treference_select = gf_bs_read_int_log(bs, 1, \"reference_select\");\n\t}\n\n\t//skip_mode_params( ):\n\tu8 skipModeAllowed = 0;\n\tif (FrameIsIntra || !reference_select || !state->enable_order_hint) {\n\t}\n\telse {\n\t\tu32 i;\n\t\ts32 forwardIdx = -1;\n\t\ts32 backwardIdx = -1;\n\t\ts32 forwardHint = 0;\n\t\ts32 backwardHint = 0;\n\t\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\t\tu8 refHint = state->RefOrderHint[ref_frame_idx[i]];\n\t\t\tif (av1_get_relative_dist(refHint, frame_state->order_hint, state) < 0) {\n\t\t\t\tif (forwardIdx < 0 || av1_get_relative_dist(refHint, forwardHint, state) > 0) {\n\t\t\t\t\tforwardIdx = i;\n\t\t\t\t\tforwardHint = refHint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (av1_get_relative_dist(refHint, frame_state->order_hint, state) > 0) {\n\t\t\t\tif (backwardIdx < 0 || av1_get_relative_dist(refHint, backwardHint, state) < 0) {\n\t\t\t\t\tbackwardIdx = i;\n\t\t\t\t\tbackwardHint = refHint;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (forwardIdx < 0) {\n\t\t\tskipModeAllowed = 0;\n\t\t}\n\t\telse if (backwardIdx >= 0) {\n\t\t\tskipModeAllowed = 1;\n\t\t\t//SkipModeFrame[0] = AV1_LAST_FRAME + MIN(forwardIdx, backwardIdx);\n\t\t\t//SkipModeFrame[1] = AV1_LAST_FRAME + MAX(forwardIdx, backwardIdx);\n\t\t}\n\t\telse {\n\t\t\ts32 secondForwardIdx = -1;\n\t\t\ts32 secondForwardHint = 0;\n\t\t\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\t\t\tu8 refHint = state->RefOrderHint[ref_frame_idx[i]];\n\t\t\t\tif (av1_get_relative_dist(refHint, forwardHint, state) < 0) {\n\t\t\t\t\tif (secondForwardIdx < 0 || av1_get_relative_dist(refHint, secondForwardHint, state) > 0) {\n\t\t\t\t\t\tsecondForwardIdx = i;\n\t\t\t\t\t\tsecondForwardHint = refHint;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (secondForwardIdx < 0) {\n\t\t\t\tskipModeAllowed = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tskipModeAllowed = 1;\n\t\t\t\t//SkipModeFrame[ 0 ] = LAST_FRAME + Min(forwardIdx, secondForwardIdx)\n\t\t\t\t//SkipModeFrame[ 1 ] = LAST_FRAME + Max(forwardIdx, secondForwardIdx)\n\t\t\t}\n\t\t}\n\t}\n\tif (skipModeAllowed) {\n\t\tgf_bs_read_int_log(bs, 1, \"skip_mode_present\");\n\t}\n\n\n\tif (FrameIsIntra || error_resilient_mode || !state->enable_warped_motion) {\n\n\t}\n\telse {\n\t\tgf_bs_read_int_log(bs, 1, \"allow_warped_motion\");\n\t}\n\n\tgf_bs_read_int_log(bs, 1, \"reduced_tx\");\n\n\t//global_motion_params( )\n\tu32 ref;\n\tfor (ref = AV1_LAST_FRAME; ref <= AV1_ALTREF_FRAME; ref++) {\n\t\tu32 i;\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tstate->GmParams.coefs[ref][i] = ((i % 3 == 2) ? 1 << WARPEDMODEL_PREC_BITS : 0);\n\t\t}\n\t}\n\tif (!FrameIsIntra) {\n\t\tu32 refs;\n\t\tfor (refs = AV1_LAST_FRAME; refs <= AV1_ALTREF_FRAME; refs++) {\n\t\t\tu8 type = AV1_GMC_IDENTITY;\n\t\t\tBool is_global = gf_bs_read_int_log_idx(bs, 1, \"is_global\", refs);\n\t\t\tif (is_global) {\n\t\t\t\tBool is_rot_zoom = gf_bs_read_int_log_idx(bs, 1, \"is_rot_zoom\", refs);\n\t\t\t\tif (is_rot_zoom) {\n\t\t\t\t\ttype = AV1_GMC_ROTZOOM;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tBool is_trans = gf_bs_read_int_log_idx(bs, 1, \"is_translation\", refs);\n\t\t\t\t\ttype = is_trans ? AV1_GMC_TRANSLATION : AV1_GMC_AFFINE;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (type >= AV1_GMC_ROTZOOM) {\n\t\t\t\tav1_read_global_param(state, bs, type, refs, 2);\n\t\t\t\tav1_read_global_param(state, bs, type, refs, 3);\n\t\t\t\tif (type == AV1_GMC_AFFINE) {\n\t\t\t\t\tav1_read_global_param(state, bs, type, refs, 4);\n\t\t\t\t\tav1_read_global_param(state, bs, type, refs, 5);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstate->GmParams.coefs[refs][4] = -state->GmParams.coefs[refs][3];\n\t\t\t\t\tstate->GmParams.coefs[refs][5] = state->GmParams.coefs[refs][2];\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type >= AV1_GMC_TRANSLATION) {\n\t\t\t\tav1_read_global_param(state, bs, type, refs, 0);\n\t\t\t\tav1_read_global_param(state, bs, type, refs, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t//film_grain_params()\n\tif (!state->film_grain_params_present || (!state->frame_state.show_frame && !showable_frame)) {\n\t}\n\telse {\n\t\tu8 apply_grain = gf_bs_read_int_log(bs, 1, \"apply_grain\");\n\t\tif (apply_grain) {\n\t\t\tgf_bs_read_int_log(bs, 16, \"grain_seed\");\n\t\t\tu8 update_grain = 1;\n\t\t\tif (state->frame_state.frame_type == AV1_INTER_FRAME) {\n\t\t\t\tupdate_grain = gf_bs_read_int_log(bs, 1, \"update_grain\");\n\t\t\t}\n\t\t\tif (!update_grain) {\n\t\t\t\tgf_bs_read_int_log(bs, 3, \"film_grain_params_ref_idx\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tu32 i, num_y_points = gf_bs_read_int_log(bs, 4, \"num_y_points\");\n\t\t\t\tfor (i = 0; i < num_y_points; i++) {\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_y_value\", i);\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_y_scaling\", i);\n\t\t\t\t}\n\t\t\t\tu8 chroma_scaling_from_luma = 0;\n\t\t\t\tif (!state->config->monochrome)\n\t\t\t\t\tchroma_scaling_from_luma = gf_bs_read_int_log(bs, 1, \"chroma_scaling_from_luma\");\n\n\t\t\t\tu8 num_cb_points = 0;\n\t\t\t\tu8 num_cr_points = 0;\n\t\t\t\tif (state->config->monochrome || chroma_scaling_from_luma ||\n\t\t\t\t\t((state->config->chroma_subsampling_x == 1) && (state->config->chroma_subsampling_y == 1) && (num_y_points == 0))\n\t\t\t\t\t) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum_cb_points = gf_bs_read_int_log(bs, 4, \"num_cb_points\");\n\t\t\t\t\tfor (i = 0; i < num_cb_points; i++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_cb_value\", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_cb_scaling\", i);\n\t\t\t\t\t}\n\t\t\t\t\tnum_cr_points = gf_bs_read_int_log(bs, 4, \"num_cr_points\");\n\t\t\t\t\tfor (i = 0; i < num_cr_points; i++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_cr_value\", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_cr_scaling\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"grain_scaling_minus_8\");\n\t\t\t\tu8 ar_coeff_lag = gf_bs_read_int_log(bs, 2, \"ar_coeff_lag\");\n\t\t\t\tu16 numPosLuma = 2 * ar_coeff_lag * (ar_coeff_lag + 1);\n\t\t\t\tu16 numPosChroma = numPosLuma;\n\t\t\t\tif (num_y_points) {\n\t\t\t\t\tnumPosChroma = numPosLuma + 1;\n\t\t\t\t\tfor (i = 0; i < numPosLuma; i++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"ar_coeffs_y_plus_128\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (chroma_scaling_from_luma || num_cb_points) {\n\t\t\t\t\tfor (i = 0; i < numPosChroma; i++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"ar_coeffs_cb_plus_128\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (chroma_scaling_from_luma || num_cr_points) {\n\t\t\t\t\tfor (i = 0; i < numPosChroma; i++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"ar_coeffs_cr_plus_128\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"ar_coeff_shift_minus_6\");\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"grain_scale_shift\");\n\t\t\t\tif (num_cb_points) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 8, \"cb_mult\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 8, \"cb_luma_mult\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 9, \"cb_offset\");\n\t\t\t\t}\n\t\t\t\tif (num_cr_points) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 8, \"cr_mult\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 8, \"cr_luma_mult\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 9, \"cr_offset\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"overlap_flag\");\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"clip_to_restricted_range\");\n\t\t\t}\n\t\t}\n\t}\n\n\t//end of uncompressed header !!\n}\n\nGF_EXPORT\nvoid gf_av1_init_state(AV1State *state)\n{\n\tif (!state) return;\n\tmemset(state, 0, sizeof(AV1State));\n\tstate->color_primaries = 2;\n\tstate->transfer_characteristics = 2;\n\tstate->matrix_coefficients = 2;\n}\n\nGF_EXPORT\nvoid gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tu32 size;\n\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}\n\nstatic GF_Err av1_parse_tile_group(GF_BitStream *bs, AV1State *state, u64 obu_start, u64 obu_size)\n{\n\tu32 TileNum, tg_start = 0, tg_end = 0;\n\tBool numTiles = state->tileCols * state->tileRows;\n\tBool tile_start_and_end_present_flag = GF_FALSE;\n\tGF_Err e = GF_OK;\n\tif (numTiles > 1)\n\t\ttile_start_and_end_present_flag = gf_bs_read_int_log(bs, 1, \"tile_start_and_end_present_flag\");\n\n\tif (numTiles == 1 || !tile_start_and_end_present_flag) {\n\t\ttg_start = 0;\n\t\ttg_end = numTiles - 1;\n\t\t/*state->frame_state.tg[0].start_idx = 0;\n\t\tstate->frame_state.tg[0].end_idx = numTiles - 1;*/\n\t}\n\telse {\n\t\tu32 tileBits = state->tileColsLog2 + state->tileRowsLog2;\n\t\t/*state->frame_state.tg[state->frame_state.tg_idx].start_idx*/ tg_start = gf_bs_read_int_log(bs, tileBits, \"tg_start\");\n\t\t/*state->frame_state.tg[state->frame_state.tg_idx].end_idx*/ tg_end = gf_bs_read_int_log(bs, tileBits, \"tg_end\");\n\t}\n\t/*state->frame_state.tg_idx++;*/\n\n\tgf_bs_align(bs);\n\n\tif (tg_end >= GF_ARRAY_LENGTH(state->frame_state.tiles))\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n\tstate->frame_state.nb_tiles_in_obu = 0;\n\tfor (TileNum = tg_start; TileNum <= tg_end; TileNum++) {\n\t\tu32 tile_start_offset, tile_size;\n\t\t/*u32 tileRow = TileNum / state->tileCols;\n\t\tu32 tileCol = TileNum % state->tileCols;*/\n\t\tBool lastTile = TileNum == tg_end;\n\t\tu64 pos = gf_bs_get_position(bs);\n\t\tif (lastTile) {\n\t\t\ttile_start_offset = (u32)(pos - obu_start);\n\t\t\ttile_size = (u32)(obu_size - (pos - obu_start));\n\t\t}\n\t\telse {\n\t\t\tu64 tile_size_minus_1 = aom_av1_le(bs, state->tile_size_bytes, \"tile_size_minus_1\");\n\t\t\tpos = gf_bs_get_position(bs);\n\t\t\ttile_start_offset = (u32)(pos - obu_start);\n\t\t\ttile_size = (u32)(tile_size_minus_1 + 1/* + state->tile_size_bytes*/);\n\t\t}\n\n\n\t\tif (tile_start_offset + tile_size > obu_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] Error parsing tile group, tile %d start %d + size %d exceeds OBU length %d\\n\", TileNum, tile_start_offset, tile_size, obu_size));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbreak;\n\t\t}\n\n\t\tstate->frame_state.tiles[state->frame_state.nb_tiles_in_obu].obu_start_offset = tile_start_offset;\n\t\tstate->frame_state.tiles[state->frame_state.nb_tiles_in_obu].size = tile_size;\n\t\tgf_bs_skip_bytes(bs, tile_size);\n\t\tstate->frame_state.nb_tiles_in_obu++;\n\t}\n\tif (tg_end == numTiles - 1) {\n\t\tav1_decode_frame_wrapup(state);\n\t}\n\treturn e;\n}\n\nstatic void av1_parse_frame_header(GF_BitStream *bs, AV1State *state)\n{\n\tAV1StateFrame *frame_state = &state->frame_state;\n\tif (frame_state->seen_frame_header == GF_FALSE) {\n\t\tu64 pos = gf_bs_get_position(bs);\n\t\tstate->frame_state.show_existing_frame = GF_FALSE;\n\t\tframe_state->seen_frame_header = GF_TRUE;\n\t\tav1_parse_uncompressed_header(bs, state);\n\t\tstate->frame_state.is_first_frame = GF_FALSE;\n\t\tstate->frame_state.uncompressed_header_bytes = (u32) (gf_bs_get_position(bs) - pos);\n\n\t\tif (state->frame_state.show_existing_frame) {\n\t\t\tav1_decode_frame_wrapup(state);\n\t\t\tframe_state->seen_frame_header = GF_FALSE;\n\t\t}\n\t\telse {\n\t\t\t//TileNum = 0;\n\t\t\tframe_state->seen_frame_header = GF_TRUE;\n\t\t}\n\t}\n}\n\nstatic GF_Err av1_parse_frame(GF_BitStream *bs, AV1State *state, u64 obu_start, u64 obu_size)\n{\n\tav1_parse_frame_header(bs, state);\n\t//byte alignment\n\tgf_bs_align(bs);\n\treturn av1_parse_tile_group(bs, state, obu_start, obu_size);\n}\n\nstatic void on_aom_av1_eos(void *_state)\n{\n\tAV1State *state = (AV1State *)_state;\n\tstate->bs_overread = GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_av1_parse_obu(GF_BitStream *bs, ObuType *obu_type, u64 *obu_size, u32 *obu_hdr_size, AV1State *state)\n{\n\tGF_Err e = GF_OK;\n\tu32 i, hdr_size;\n\tu64 pos = gf_bs_get_position(bs);\n\n\tif (!bs || !obu_type || !state)\n\t\treturn GF_BAD_PARAM;\n\n\tstate->bs_overread = GF_FALSE;\n\tgf_bs_set_eos_callback(bs, on_aom_av1_eos, state);\n\n\tstate->obu_extension_flag = state->obu_has_size_field = 0;\n\tstate->temporal_id = state->spatial_id = 0;\n\tstate->frame_state.uncompressed_header_bytes = 0;\n\te = gf_av1_parse_obu_header(bs, obu_type, &state->obu_extension_flag, &state->obu_has_size_field, &state->temporal_id, &state->spatial_id);\n\tif (e)\n\t\treturn e;\n\n\tif (state->obu_has_size_field) {\n\t\t*obu_size = (u32)gf_av1_leb128_read(bs, NULL);\n\t}\n\telse {\n\t\tif (*obu_size >= 1 + state->obu_extension_flag) {\n\t\t\t*obu_size = *obu_size - 1 - state->obu_extension_flag;\n\t\t}\n\t\telse {\n\t\t\tGF_LOG(state->config ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_CODING, (\"[AV1] computed OBU size \"LLD\" (input value = \"LLU\"). Skipping.\\n\", *obu_size - 1 - state->obu_extension_flag, *obu_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t}\n\thdr_size = (u32)(gf_bs_get_position(bs) - pos);\n\tif ((gf_bs_available(bs) < *obu_size) || state->bs_overread) {\n\t\tgf_bs_seek(bs, pos);\n\t\treturn GF_BUFFER_TOO_SMALL;\n\t}\n\t*obu_size += hdr_size;\n\tif (obu_hdr_size) *obu_hdr_size = hdr_size;\n\n\n\tif (*obu_type != OBU_SEQUENCE_HEADER && *obu_type != OBU_TEMPORAL_DELIMITER &&\n\t\tstate->OperatingPointIdc != 0 && state->obu_extension_flag == 1)\n\t{\n\t\tu32 inTemporalLayer = (state->OperatingPointIdc >> state->temporal_id) & 1;\n\t\tu32 inSpatialLayer = (state->OperatingPointIdc >> (state->spatial_id + 8)) & 1;\n\t\tif (!inTemporalLayer || !inSpatialLayer) {\n\t\t\t*obu_type = -1;\n\t\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\te = GF_OK;\n\n\t/* for AVIF a1lx */\n\tfor (i = state->spatial_id; i < 4; i++) {\n\t\tstate->layer_size[i] = (u32) (pos + *obu_size);\n\t}\n\n\tswitch (*obu_type) {\n\tcase OBU_SEQUENCE_HEADER:\n\t\tav1_parse_sequence_header_obu(bs, state);\n\t\tif (gf_bs_get_position(bs) > pos + *obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Sequence header parsing consumed too many bytes !\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\n\tcase OBU_METADATA:\n#if 0\n\t\t//TODO + sample groups\n\t\tconst ObuMetadataType metadata_type = (u32)read_leb128(bs, NULL); we should check for 16 bits limit(AV1MetadataSampleGroupEntry) for ISOBMFF bindings, see https ://github.com/AOMediaCodec/av1-isobmff/pull/86#issuecomment-416659538\n\t\tif (metadata_type == OBU_METADATA_TYPE_ITUT_T35) {\n\t\t}\n\t\telse if (metadata_type == OBU_METADATA_TYPE_HDR_CLL) {\n\t\t}\n\t\telse if (metadata_type == OBU_METADATA_TYPE_HDR_MDCV) {\n\t\t}\n\t\telse if (metadata_type == OBU_METADATA_TYPE_SCALABILITY) {\n\t\t}\n\t\telse if (metadata_type == METADATA_TYPE_TIMECODE) {\n\t\t}\n#endif\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[AV1] parsing for metadata is not implemented. Forwarding.\\n\"));\n\n\t\tif (gf_bs_get_position(bs) > pos + *obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Metadata parsing consumed too many bytes !\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\n\tcase OBU_FRAME_HEADER:\n\tcase OBU_REDUNDANT_FRAME_HEADER:\n\t\tif (state->config) {\n\t\t\tav1_parse_frame_header(bs, state);\n\t\t\tif (gf_bs_get_position(bs) > pos + *obu_size) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Frame header parsing consumed too many bytes !\\n\"));\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\tcase OBU_FRAME:\n\t\te = av1_parse_frame(bs, state, pos, *obu_size);\n\t\tif (gf_bs_get_position(bs) != pos + *obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Frame parsing did not consume the right number of bytes !\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\tcase OBU_TILE_GROUP:\n\t\tif (state->config) {\n\t\t\te = av1_parse_tile_group(bs, state, pos, *obu_size);\n\t\t\tif (gf_bs_get_position(bs) != pos + *obu_size) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Tile group parsing did not consume the right number of bytes !\\n\"));\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\tcase OBU_TEMPORAL_DELIMITER:\n\t\tstate->frame_state.seen_frame_header = GF_FALSE;\n\tcase OBU_PADDING:\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] unknown OBU type %u (size \"LLU\"). Skipping.\\n\", *obu_type, *obu_size));\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\t}\n\treturn e;\n}\n\n\nGF_EXPORT\nGF_Err gf_media_prores_parse_bs(GF_BitStream *bs, GF_ProResFrameInfo *prores_frame)\n{\n\tu32 i, j;\n\tu64 start, pos;\n\tmemset(prores_frame, 0, sizeof(GF_ProResFrameInfo));\n\n\tstart = gf_bs_get_position(bs);\n\tif (gf_bs_available(bs) < 10)\n\t\treturn GF_BUFFER_TOO_SMALL;\n\n\tprores_frame->frame_size = gf_bs_read_u32(bs);\n\tprores_frame->frame_identifier = gf_bs_read_u32(bs);\n\tif (prores_frame->frame_identifier != GF_4CC('i','c','p','f')) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[ProRes] Invalid frame identifier, expected \\\"icpf\\\" got \\\"%s\\\"\\n\", gf_4cc_to_str(prores_frame->frame_identifier) ));\n\t\tgf_bs_seek(bs, start);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\t/*parse frame header*/\n\tpos = gf_bs_get_position(bs);\n\tprores_frame->frame_hdr_size = gf_bs_read_u16(bs);\n\tif (gf_bs_available(bs) + 2 < prores_frame->frame_hdr_size) {\n\t\tgf_bs_seek(bs, start);\n\t\treturn GF_BUFFER_TOO_SMALL;\n\t}\n\tgf_bs_read_u8(bs);\n\tprores_frame->version = gf_bs_read_u8(bs);\n\tprores_frame->encoder_id = gf_bs_read_u32(bs);\n\tprores_frame->width = gf_bs_read_u16(bs);\n\tprores_frame->height = gf_bs_read_u16(bs);\n\tprores_frame->chroma_format = gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 2);\n\tprores_frame->interlaced_mode = gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 2);\n\tprores_frame->aspect_ratio_information = gf_bs_read_int(bs, 4);\n\tprores_frame->framerate_code = gf_bs_read_int(bs, 4);\n\tprores_frame->color_primaries = gf_bs_read_u8(bs);\n\tprores_frame->transfer_characteristics = gf_bs_read_u8(bs);\n\tprores_frame->matrix_coefficients = gf_bs_read_u8(bs);\n\tgf_bs_read_int(bs, 4);\n\tprores_frame->alpha_channel_type = gf_bs_read_int(bs, 4);\n\tgf_bs_read_int(bs, 14);\n\tprores_frame->load_luma_quant_matrix = gf_bs_read_int(bs, 1);\n\tprores_frame->load_chroma_quant_matrix = gf_bs_read_int(bs, 1);\n\tif (prores_frame->load_luma_quant_matrix) {\n\t\tfor (i=0; i<8; i++) {\n\t\t\tfor (j=0; j<8; j++) {\n\t\t\t\tprores_frame->luma_quant_matrix[i][j] = gf_bs_read_u8(bs);\n\t\t\t}\n\t\t}\n\t}\n\tif (prores_frame->load_chroma_quant_matrix) {\n\t\tfor (i=0; i<8; i++) {\n\t\t\tfor (j=0; j<8; j++) {\n\t\t\t\tprores_frame->chroma_quant_matrix[i][j] = gf_bs_read_u8(bs);\n\t\t\t}\n\t\t}\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != prores_frame->frame_hdr_size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[ProRes] Invalid frame header size, expected %d got %d\\n\", prores_frame->frame_hdr_size, (u32) pos));\n\t\tgf_bs_seek(bs, start);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tprores_frame->nb_pic = ((prores_frame->interlaced_mode==1) || (prores_frame->interlaced_mode==2)) ? 2 : 1;\n\tgf_bs_seek(bs, start);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\nGF_EXPORT\nu8 gf_mp3_version(u32 hdr)\n{\n\treturn ((hdr >> 19) & 0x3);\n}\n\nGF_EXPORT\nconst char *gf_mp3_version_name(u32 hdr)\n{\n\tu32 v = gf_mp3_version(hdr);\n\tswitch (v) {\n\tcase 0:\n\t\treturn \"MPEG-2.5\";\n\tcase 1:\n\t\treturn \"Reserved\";\n\tcase 2:\n\t\treturn \"MPEG-2\";\n\tcase 3:\n\t\treturn \"MPEG-1\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nGF_EXPORT\nu8 gf_mp3_layer(u32 hdr)\n{\n\treturn 4 - (((hdr >> 17) & 0x3));\n}\n\nGF_EXPORT\nu8 gf_mp3_num_channels(u32 hdr)\n{\n\tif (((hdr >> 6) & 0x3) == 3) return 1;\n\treturn 2;\n}\n\nGF_EXPORT\nu16 gf_mp3_sampling_rate(u32 hdr)\n{\n\tu16 res;\n\t/* extract the necessary fields from the MP3 header */\n\tu8 version = gf_mp3_version(hdr);\n\tu8 sampleRateIndex = (hdr >> 10) & 0x3;\n\n\tswitch (sampleRateIndex) {\n\tcase 0:\n\t\tres = 44100;\n\t\tbreak;\n\tcase 1:\n\t\tres = 48000;\n\t\tbreak;\n\tcase 2:\n\t\tres = 32000;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[MPEG-1/2 Audio] Samplerate index not valid\\n\"));\n\t\treturn 0;\n\t}\n\t/*reserved or MPEG-1*/\n\tif (version & 1) return res;\n\n\t/*MPEG-2*/\n\tres /= 2;\n\t/*MPEG-2.5*/\n\tif (version == 0) res /= 2;\n\treturn res;\n}\n\nGF_EXPORT\nu16 gf_mp3_window_size(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\n\tif (layer == 3) {\n\t\tif (version == 3) return 1152;\n\t\treturn 576;\n\t}\n\tif (layer == 2) return 1152;\n\treturn 384;\n}\n\nGF_EXPORT\nu8 gf_mp3_object_type_indication(u32 hdr)\n{\n\tswitch (gf_mp3_version(hdr)) {\n\tcase 3:\n\t\treturn GF_CODECID_MPEG_AUDIO;\n\tcase 2:\n\tcase 0:\n\t\treturn GF_CODECID_MPEG2_PART3;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}\n\n/*aligned bitrate parsing with libMAD*/\n\nstatic\nu32 const bitrate_table[5][15] = {\n\t/* MPEG-1 */\n\t{\t0,  32000,  64000,  96000, 128000, 160000, 192000, 224000,  /* Layer I   */\n\t\t256000, 288000, 320000, 352000, 384000, 416000, 448000\n\t},\n\t{\t0,  32000,  48000,  56000,  64000,  80000,  96000, 112000,  /* Layer II  */\n\t\t128000, 160000, 192000, 224000, 256000, 320000, 384000\n\t},\n\t{\t0,  32000,  40000,  48000,  56000,  64000,  80000,  96000,  /* Layer III */\n\t\t112000, 128000, 160000, 192000, 224000, 256000, 320000\n\t},\n\n\t/* MPEG-2 LSF */\n\t{\t0,  32000,  48000,  56000,  64000,  80000,  96000, 112000,  /* Layer I   */\n\t\t128000, 144000, 160000, 176000, 192000, 224000, 256000\n\t},\n\t{\t0,   8000,  16000,  24000,  32000,  40000,  48000,  56000,  /* Layers    */\n\t\t64000,  80000,  96000, 112000, 128000, 144000, 160000\n\t} /* II & III  */\n};\n\n\nu32 gf_mp3_bit_rate(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\tu8 bitRateIndex = (hdr >> 12) & 0xF;\n\tu32 lidx;\n\t/*MPEG-1*/\n\tif (version & 1) {\n\t\tif (!layer) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[MPEG-1/2 Audio] layer index not valid\\n\"));\n\t\t\treturn 0;\n\t\t}\n\t\tlidx = layer - 1;\n\t}\n\t/*MPEG-2/2.5*/\n\telse {\n\t\tlidx = 3 + (layer >> 1);\n\t}\n\tif (lidx>4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[MPEG-1/2 Audio] layer index not valid\\n\"));\n\t\treturn 0;\n\t}\n\treturn bitrate_table[lidx][bitRateIndex];\n}\n\n\n\nGF_EXPORT\nu16 gf_mp3_frame_size(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\tu32 pad = ((hdr >> 9) & 0x1) ? 1 : 0;\n\tu32 bitrate = gf_mp3_bit_rate(hdr);\n\tu32 samplerate = gf_mp3_sampling_rate(hdr);\n\n\tu32 frameSize = 0;\n\tif (!samplerate || !bitrate) return 0;\n\n\tif (layer == 1) {\n\t\tframeSize = ((12 * bitrate / samplerate) + pad) * 4;\n\t}\n\telse {\n\t\tu32 slots_per_frame = 144;\n\t\tif ((layer == 3) && !(version & 1)) slots_per_frame = 72;\n\t\tframeSize = (slots_per_frame * bitrate / samplerate) + pad;\n\t}\n\treturn (u16)frameSize;\n}\n\n\nGF_EXPORT\nu32 gf_mp3_get_next_header(FILE* in)\n{\n\tu8 b, state = 0;\n\tu32 dropped = 0;\n\tunsigned char bytes[4];\n\tbytes[0] = bytes[1] = bytes[2] = bytes[3] = 0;\n\n\twhile (1) {\n\t\tif (gf_fread(&b, 1, in) == 0) return 0;\n\n\t\tif (state == 3) {\n\t\t\tbytes[state] = b;\n\t\t\treturn GF_4CC((u32)bytes[0], bytes[1], bytes[2], bytes[3]);\n\t\t}\n\t\tif (state == 2) {\n\t\t\tif (((b & 0xF0) == 0) || ((b & 0xF0) == 0xF0) || ((b & 0x0C) == 0x0C)) {\n\t\t\t\tif (bytes[1] == 0xFF) state = 1;\n\t\t\t\telse state = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t}\n\t\tif (state == 1) {\n\t\t\tif (((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (state == 0) {\n\t\t\tif (b == 0xFF) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((dropped == 0) && ((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\t\tbytes[0] = (u8)0xFF;\n\t\t\t\t\tbytes[1] = b;\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdropped++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_mp3_get_next_header_mem(const u8 *buffer, u32 size, u32 *pos)\n{\n\tu32 cur;\n\tu8 b, state = 0;\n\tu32 dropped = 0;\n\tunsigned char bytes[4];\n\tbytes[0] = bytes[1] = bytes[2] = bytes[3] = 0;\n\n\tcur = 0;\n\t*pos = 0;\n\twhile (cur < size) {\n\t\tb = (u8)buffer[cur];\n\t\tcur++;\n\n\t\tif (state == 3) {\n\t\t\tu32 val;\n\t\t\tbytes[state] = b;\n\t\t\tval = GF_4CC((u32)bytes[0], bytes[1], bytes[2], bytes[3]);\n\t\t\tif (gf_mp3_frame_size(val)) {\n\t\t\t\t*pos = dropped;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t\tstate = 0;\n\t\t\tdropped = cur;\n\t\t}\n\t\tif (state == 2) {\n\t\t\tif (((b & 0xF0) == 0) || ((b & 0xF0) == 0xF0) || ((b & 0x0C) == 0x0C)) {\n\t\t\t\tif (bytes[1] == 0xFF) {\n\t\t\t\t\tstate = 1;\n\t\t\t\t\tdropped += 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tdropped = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t}\n\t\tif (state == 1) {\n\t\t\tif (((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate = 0;\n\t\t\t\tdropped = cur;\n\t\t\t}\n\t\t}\n\n\t\tif (state == 0) {\n\t\t\tif (b == 0xFF) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdropped++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n\nGF_EXPORT\nBool gf_avc_is_rext_profile(u8 profile_idc)\n{\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\tcase 138:\n\tcase 139:\n\tcase 134:\n\tcase 135:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nconst char *gf_avc_get_profile_name(u8 video_prof)\n{\n\tswitch (video_prof) {\n\tcase 0x42:\n\t\treturn \"Baseline\";\n\tcase 0x4D:\n\t\treturn \"Main\";\n\tcase 0x53:\n\t\treturn \"Scalable Baseline\";\n\tcase 0x56:\n\t\treturn \"Scalable High\";\n\tcase 0x58:\n\t\treturn \"Extended\";\n\tcase 0x64:\n\t\treturn \"High\";\n\tcase 0x6E:\n\t\treturn \"High 10\";\n\tcase 0x7A:\n\t\treturn \"High 4:2:2\";\n\tcase 0x90:\n\tcase 0xF4:\n\t\treturn \"High 4:4:4\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nGF_EXPORT\nconst char *gf_hevc_get_profile_name(u8 video_prof)\n{\n\tswitch (video_prof) {\n\tcase 0x01:\n\t\treturn \"Main\";\n\tcase 0x02:\n\t\treturn \"Main 10\";\n\tcase 0x03:\n\t\treturn \"Main Still Picture\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\nGF_EXPORT\nconst char *gf_avc_hevc_get_chroma_format_name(u8 chroma_format)\n{\n\tswitch (chroma_format) {\n\tcase 1:\n\t\treturn \"YUV 4:2:0\";\n\tcase 2:\n\t\treturn \"YUV 4:2:2\";\n\tcase 3:\n\t\treturn \"YUV 4:4:4\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nu32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\t\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n\t\t\tif (!gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead) {\n\t\tu32 leads=1;\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tleads <<= nb_lead;\n\t\tleads -= 1;\n\t\tval += leads;\n//\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}\n\n#define gf_bs_read_ue_log_idx2(_bs, _fname, _idx1, _idx2) gf_bs_read_ue_log_idx3(_bs, _fname, (s32) _idx1, (s32) _idx2, -1)\n#define gf_bs_read_ue_log_idx(_bs, _fname, _idx) gf_bs_read_ue_log_idx3(_bs, _fname, (s32) _idx, -1, -1)\n#define gf_bs_read_ue_log(_bs, _fname) gf_bs_read_ue_log_idx3(_bs, _fname, -1, -1, -1)\n\n\nu32 gf_bs_read_ue(GF_BitStream *bs)\n{\n\treturn gf_bs_read_ue_log(bs, NULL);\n}\n\ns32 gf_bs_read_se(GF_BitStream *bs)\n{\n\tu32 v = gf_bs_read_ue(bs);\n\tif ((v & 0x1) == 0) return (s32)(0 - (v >> 1));\n\treturn (v + 1) >> 1;\n}\n\ns32 gf_bs_read_se_log_idx2(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2)\n{\n\ts32 res = gf_bs_read_se(bs);\n\tif (fname)\n\t\tgf_bs_log_idx(bs, -1, fname, res, idx1, idx2, -1);\n\treturn res;\n}\n#define gf_bs_read_se_log_idx(_bs, _fname, _idx) gf_bs_read_se_log_idx2(_bs, _fname, (s32) _idx, -1)\n#define gf_bs_read_se_log(_bs, _fname) gf_bs_read_se_log_idx2(_bs, _fname, -1, -1)\n\n\n\nvoid gf_bs_write_ue(GF_BitStream *bs, u32 num) {\n\ts32 length = 1;\n\ts32 temp = ++num;\n\n\twhile (temp != 1) {\n\t\ttemp >>= 1;\n\t\tlength += 2;\n\t}\n\n\tgf_bs_write_int(bs, 0, length >> 1);\n\tgf_bs_write_int(bs, num, (length + 1) >> 1);\n}\n\nvoid gf_bs_write_se(GF_BitStream *bs, s32 num)\n{\n\tu32 v;\n\tif (num <= 0)\n\t\tv = (-1 * num) << 1;\n\telse\n\t\tv = (num << 1) - 1;\n\n\tgf_bs_write_ue(bs, v);\n}\n\nu32 gf_media_nalu_is_start_code(GF_BitStream *bs)\n{\n\tu8 s1, s2, s3, s4;\n\tBool is_sc = 0;\n\tu64 pos = gf_bs_get_position(bs);\n\ts1 = gf_bs_read_int(bs, 8);\n\ts2 = gf_bs_read_int(bs, 8);\n\tif (!s1 && !s2) {\n\t\ts3 = gf_bs_read_int(bs, 8);\n\t\tif (s3 == 0x01) is_sc = 3;\n\t\telse if (!s3) {\n\t\t\ts4 = gf_bs_read_int(bs, 8);\n\t\t\tif (s4 == 0x01) is_sc = 4;\n\t\t}\n\t}\n\tgf_bs_seek(bs, pos + is_sc);\n\treturn is_sc;\n}\n\n/*read that amount of data at each IO access rather than fetching byte by byte...*/\n#define AVC_CACHE_SIZE\t4096\n\nstatic u32 gf_media_nalu_locate_start_code_bs(GF_BitStream *bs, Bool locate_trailing)\n{\n\tu32 v, bpos, nb_cons_zeros = 0;\n\tchar avc_cache[AVC_CACHE_SIZE];\n\tu64 end, cache_start, load_size;\n\tu64 start = gf_bs_get_position(bs);\n\tif (start < 3) return 0;\n\n\tload_size = 0;\n\tbpos = 0;\n\tcache_start = 0;\n\tend = 0;\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\t/*refill cache*/\n\t\tif (bpos == (u32)load_size) {\n\t\t\tif (!gf_bs_available(bs)) break;\n\t\t\tload_size = gf_bs_available(bs);\n\t\t\tif (load_size > AVC_CACHE_SIZE) load_size = AVC_CACHE_SIZE;\n\t\t\tbpos = 0;\n\t\t\tcache_start = gf_bs_get_position(bs);\n\t\t\tgf_bs_read_data(bs, avc_cache, (u32)load_size);\n\t\t}\n\t\tv = ( (v<<8) & 0xFFFFFF00) | ((u32) avc_cache[bpos]);\n\t\tbpos++;\n\n\t\tif (locate_trailing) {\n\t\t\tif ((v & 0x000000FF) == 0) nb_cons_zeros++;\n\t\t\telse nb_cons_zeros = 0;\n\t\t}\n\n\t\tif (v == 0x00000001) end = cache_start + bpos - 4;\n\t\telse if ((v & 0x00FFFFFF) == 0x00000001) end = cache_start + bpos - 3;\n\t}\n\n\tgf_bs_seek(bs, start);\n\tif (!end) end = gf_bs_get_size(bs);\n\tif (locate_trailing) {\n\t\tif (nb_cons_zeros >= 3)\n\t\t\treturn (u32)(end - start - nb_cons_zeros);\n\t}\n\treturn (u32)(end - start);\n}\n\nGF_EXPORT\nu32 gf_media_nalu_next_start_code_bs(GF_BitStream *bs)\n{\n\treturn gf_media_nalu_locate_start_code_bs(bs, 0);\n}\n\nGF_EXPORT\nu32 gf_media_nalu_next_start_code(const u8 *data, u32 data_len, u32 *sc_size)\n{\n\tu32 avail = data_len;\n\tconst u8 *cur = data;\n\n\twhile (cur) {\n\t\tu32 v, bpos;\n\t\tu8 *next_zero = memchr(cur, 0, avail);\n\t\tif (!next_zero) return data_len;\n\n\t\tv = 0xffffff00;\n\t\tbpos = (u32)(next_zero - data) + 1;\n\t\twhile (1) {\n\t\t\tu8 cval;\n\t\t\tif (bpos == (u32)data_len)\n\t\t\t\treturn data_len;\n\n\t\t\tcval = data[bpos];\n\t\t\tv = ((v << 8) & 0xFFFFFF00) | ((u32)cval);\n\t\t\tbpos++;\n\t\t\tif (v == 0x00000001) {\n\t\t\t\t*sc_size = 4;\n\t\t\t\treturn bpos - 4;\n\t\t\t}\n\t\t\telse if ((v & 0x00FFFFFF) == 0x00000001) {\n\t\t\t\t*sc_size = 3;\n\t\t\t\treturn bpos - 3;\n\t\t\t}\n\t\t\tif (cval)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bpos >= data_len)\n\t\t\tbreak;\n\t\tcur = data + bpos;\n\t\tavail = data_len - bpos;\n\t}\n\treturn data_len;\n}\n\nBool gf_media_avc_slice_is_intra(AVCState *avc)\n{\n\tswitch (avc->s_info.slice_type) {\n\tcase GF_AVC_TYPE_I:\n\tcase GF_AVC_TYPE2_I:\n\tcase GF_AVC_TYPE_SI:\n\tcase GF_AVC_TYPE2_SI:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#if 0 //unused\nBool gf_media_avc_slice_is_IDR(AVCState *avc)\n{\n\tif (avc->sei.recovery_point.valid)\n\t{\n\t\tavc->sei.recovery_point.valid = 0;\n\t\treturn 1;\n\t}\n\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE)\n\t\treturn 0;\n\treturn gf_media_avc_slice_is_intra(avc);\n}\n#endif\n\nstatic const struct  {\n\tu32 w, h;\n} avc_hevc_sar[] = {\n\t{ 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 },\n\t{ 16, 11 }, { 40, 33 }, { 24, 11 }, { 20, 11 },\n\t{ 32, 11 }, { 80, 33 }, { 18, 11 }, { 15, 11 },\n\t{ 64, 33 }, { 160,99 }, {  4,  3 }, {  3,  2 },\n\t{  2,  1 }\n};\n\n\n/*ISO 14496-10 (N11084) E.1.2*/\nstatic void avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)\n{\n\tint i, cpb_cnt_minus1;\n\n\tcpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"cpb_cnt_minus1\");\n\tif (cpb_cnt_minus1 > 31)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\\n\", cpb_cnt_minus1));\n\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\n\t/*for( SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++ ) {*/\n\tfor (i = 0; i <= cpb_cnt_minus1; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \"bit_rate_value_minus1\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"cpb_size_value_minus1\", i);\n\t\tgf_bs_read_int_log_idx(bs, 1, \"cbr_flag\", i);\n\t}\n\tgf_bs_read_int_log(bs, 5, \"initial_cpb_removal_delay_length_minus1\");\n\thrd->cpb_removal_delay_length_minus1 = gf_bs_read_int_log(bs, 5, \"cpb_removal_delay_length_minus1\");\n\thrd->dpb_output_delay_length_minus1 = gf_bs_read_int_log(bs, 5, \"dpb_output_delay_length_minus1\");\n\thrd->time_offset_length = gf_bs_read_int_log(bs, 5, \"time_offset_length\");\n\treturn;\n}\n\n/*returns the nal_size without emulation prevention bytes*/\nu32 gf_media_nalu_emulation_bytes_add_count(u8 *buffer, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size) {\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\tother than the following sequences shall not occur at any byte-aligned position:\n\t\t\\96 0x00000300\n\t\t\\96 0x00000301\n\t\t\\96 0x00000302\n\t\t\\96 0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2 && (u8)buffer[i] < 0x04) {\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\tif (!buffer[i])\n\t\t\t\tnum_zero = 1;\n\t\t}\n\t\telse {\n\t\t\tif (!buffer[i])\n\t\t\t\tnum_zero++;\n\t\t\telse\n\t\t\t\tnum_zero = 0;\n\t\t}\n\t\ti++;\n\t}\n\treturn emulation_bytes_count;\n}\n\nu32 gf_media_nalu_add_emulation_bytes(const u8 *buffer_src, u8 *buffer_dst, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size) {\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\tother than the following sequences shall not occur at any byte-aligned position:\n\t\t0x00000300\n\t\t0x00000301\n\t\t0x00000302\n\t\t0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2 && (u8)buffer_src[i] < 0x04) {\n\t\t\t/*add emulation code*/\n\t\t\tnum_zero = 0;\n\t\t\tbuffer_dst[i + emulation_bytes_count] = 0x03;\n\t\t\temulation_bytes_count++;\n\t\t\tif (!buffer_src[i])\n\t\t\t\tnum_zero = 1;\n\t\t}\n\t\telse {\n\t\t\tif (!buffer_src[i])\n\t\t\t\tnum_zero++;\n\t\t\telse\n\t\t\t\tnum_zero = 0;\n\t\t}\n\t\tbuffer_dst[i + emulation_bytes_count] = buffer_src[i];\n\t\ti++;\n\t}\n\treturn nal_size + emulation_bytes_count;\n}\n\n/*returns the nal_size without emulation prevention bytes*/\nu32 gf_media_nalu_emulation_bytes_remove_count(const u8 *buffer, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\tif (!buffer || !nal_size) return 0;\n\n\twhile (i < nal_size)\n\t{\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\t  other than the following sequences shall not occur at any byte-aligned position:\n\t\t  \\96 0x00000300\n\t\t  \\96 0x00000301\n\t\t  \\96 0x00000302\n\t\t  \\96 0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2\n\t\t\t&& buffer[i] == 0x03\n\t\t\t&& i + 1 < nal_size /*next byte is readable*/\n\t\t\t&& (u8)buffer[i + 1] < 0x04)\n\t\t{\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\ti++;\n\t\t}\n\n\t\tif (!buffer[i])\n\t\t\tnum_zero++;\n\t\telse\n\t\t\tnum_zero = 0;\n\n\t\ti++;\n\t}\n\n\treturn emulation_bytes_count;\n}\n\n/*nal_size is updated to allow better error detection*/\nGF_EXPORT\nu32 gf_media_nalu_remove_emulation_bytes(const u8 *buffer_src, u8 *buffer_dst, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size)\n\t{\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\t  other than the following sequences shall not occur at any byte-aligned position:\n\t\t  0x00000300\n\t\t  0x00000301\n\t\t  0x00000302\n\t\t  0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2\n\t\t\t&& buffer_src[i] == 0x03\n\t\t\t&& i + 1 < nal_size /*next byte is readable*/\n\t\t\t&& (u8)buffer_src[i + 1] < 0x04)\n\t\t{\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\ti++;\n\t\t}\n\n\t\tbuffer_dst[i - emulation_bytes_count] = buffer_src[i];\n\n\t\tif (!buffer_src[i])\n\t\t\tnum_zero++;\n\t\telse\n\t\t\tnum_zero = 0;\n\n\t\ti++;\n\t}\n\n\treturn nal_size - emulation_bytes_count;\n}\n\nstatic s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif ((sps_id < 0) || (sps_id >= 32)) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tsps->poc_cycle_length = 255;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_avc_read_sps_bs(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos)\n{\n\treturn gf_avc_read_sps_bs_internal(bs, avc, subseq_sps, vui_flag_pos, 0);\n}\n\nGF_EXPORT\ns32 gf_avc_read_sps(const u8 *sps_data, u32 sps_size, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos)\n{\n\ts32 sps_id = -1;\n\tGF_BitStream *bs;\n\tchar *sps_data_without_emulation_bytes = NULL;\n\tu32 sps_data_without_emulation_bytes_size = 0;\n\n\tif (vui_flag_pos) {\n\t\t/*SPS still contains emulation bytes*/\n\t\tsps_data_without_emulation_bytes = gf_malloc(sps_size * sizeof(char));\n\t\tsps_data_without_emulation_bytes_size = gf_media_nalu_remove_emulation_bytes(sps_data, sps_data_without_emulation_bytes, sps_size);\n\t\tbs = gf_bs_new(sps_data_without_emulation_bytes, sps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\n\t\t*vui_flag_pos = 0;\n\t}\n\telse {\n\t\tbs = gf_bs_new(sps_data, sps_size, GF_BITSTREAM_READ);\n\t}\n\n\tif (!bs) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\n\tsps_id = gf_avc_read_sps_bs(bs, avc, subseq_sps, vui_flag_pos);\n\nexit:\n\tgf_bs_del(bs);\n\tif (sps_data_without_emulation_bytes) gf_free(sps_data_without_emulation_bytes);\n\treturn sps_id;\n}\n\nstatic s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)\n{\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 255)) {\n\t\treturn -1;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif ((pps->sps_id<0) || (pps->sps_id >= 32)) {\n\t\tpps->sps_id = 0;\n\t\treturn -1;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice referring to the pps*/\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\treturn -1;\n\t}\n\tavc->pps_active_idx = pps->id; /*set active sps*/\n\tavc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_mode_flag\");\n\tpps->pic_order_present = gf_bs_read_int_log(bs, 1, \"pic_order_present\");\n\tpps->slice_group_count = gf_bs_read_ue_log(bs, \"slice_group_count_minus1\") + 1;\n\tif (pps->slice_group_count > 1) {\n\t\tu32 iGroup;\n\t\tpps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, \"mb_slice_group_map_type\");\n\t\tif (pps->mb_slice_group_map_type == 0) {\n\t\t\tfor (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"run_length_minus1\", iGroup);\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 2) {\n\t\t\tfor (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"top_left\", iGroup);\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"bottom_right\", iGroup);\n\t\t\t}\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_group_change_direction_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"slice_group_change_rate_minus1\");\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 6) {\n\t\t\tu32 i;\n\t\t\tpps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, \"pic_size_in_map_units_minus1\");\n\t\t\tfor (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), \"slice_group_id\", i);\n\t\t\t}\n\t\t}\n\t}\n\tpps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active_minus1\");\n\tpps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active_minus1\");\n\n\t/*\n\tif ((pps->ref_count[0] > 32) || (pps->ref_count[1] > 32)) goto exit;\n\t*/\n\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tgf_bs_read_int_log(bs, 2, \"weighted_bipred_idc\");\n\tgf_bs_read_se_log(bs, \"init_qp_minus26\");\n\tgf_bs_read_se_log(bs, \"init_qs_minus26\");\n\tgf_bs_read_se_log(bs, \"chroma_qp_index_offset\");\n\tpps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\");\n\tgf_bs_read_int_log(bs, 1, \"constrained_intra_pred\");\n\tpps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, \"redundant_pic_cnt_present\");\n\n\treturn pps_id;\n}\n\nGF_EXPORT\ns32 gf_avc_read_pps_bs(GF_BitStream *bs, AVCState *avc)\n{\n\treturn gf_avc_read_pps_bs_internal(bs, avc, 0);\n}\n\nGF_EXPORT\ns32 gf_avc_read_pps(const u8 *pps_data, u32 pps_size, AVCState *avc)\n{\n\tGF_BitStream *bs;\n\ts32 pps_id;\n\n\t/*PPS still contains emulation bytes*/\n\tbs = gf_bs_new(pps_data, pps_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tpps_id = gf_avc_read_pps_bs(bs, avc);\n\tgf_bs_del(bs);\n\treturn pps_id;\n}\n\n#if 0 //unused\n\ns32 gf_avc_read_sps_ext(const char *spse_data, u32 spse_size)\n{\n\tGF_BitStream *bs;\n\ts32 sps_id;\n\n\tbs = gf_bs_new(spse_data, spse_size, GF_BITSTREAM_READ);\n\tsps_id = gf_avc_read_sps_ext_bs(bs);\n\n\tgf_bs_del(bs);\n\treturn sps_id;\n}\n#endif\n\nstatic s32 SVC_ReadNal_header_extension(GF_BitStream *bs, SVC_NALUHeader *NalHeader)\n{\n\tgf_bs_read_int_log(bs, 1, \"reserved_one_bit\");\n\tNalHeader->idr_pic_flag = gf_bs_read_int_log(bs, 1, \"idr_flag\");\n\tNalHeader->priority_id = gf_bs_read_int_log(bs, 6, \"priority_id\");\n\tgf_bs_read_int_log(bs, 1, \"no_inter_layer_pred_flag\");\n\tNalHeader->dependency_id = gf_bs_read_int_log(bs, 3, \"DependencyId\");\n\tNalHeader->quality_id = gf_bs_read_int_log(bs, 4, \"quality_id\");\n\tNalHeader->temporal_id = gf_bs_read_int_log(bs, 3, \"temporal_id\");\n\tgf_bs_read_int_log(bs, 1, \"use_ref_base_pic_flag\");\n\tgf_bs_read_int_log(bs, 1, \"discardable_flag\");\n\tgf_bs_read_int_log(bs, 1, \"output_flag\");\n\tgf_bs_read_int_log(bs, 2, \"reserved_three_2bits\");\n\treturn 1;\n}\n\nstatic void ref_pic_list_modification(GF_BitStream *bs, u32 slice_type) {\n\tif (slice_type % 5 != 2 && slice_type % 5 != 4) {\n\t\tif (gf_bs_read_int_log(bs, 1, \"ref_pic_list_modification_flag_l0\")) {\n\t\t\tu32 idx=0, modification_of_pic_nums_idc;\n\t\t\tdo {\n\t\t\t\tmodification_of_pic_nums_idc = gf_bs_read_ue_log_idx(bs, \"modification_of_pic_nums_idc\", idx);\n\t\t\t\tif (modification_of_pic_nums_idc == 0 || modification_of_pic_nums_idc == 1) {\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"abs_diff_pic_num_minus1\", idx);\n\t\t\t\t}\n\t\t\t\telse if (modification_of_pic_nums_idc == 2) {\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"long_term_pic_num\", idx);\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t} while ((modification_of_pic_nums_idc != 3) && gf_bs_available(bs));\n\t\t}\n\t}\n\tif (slice_type % 5 == 1) {\n\t\tif (gf_bs_read_int_log(bs, 1, \"ref_pic_list_modification_flag_l1\")) {\n\t\t\tu32 idx=0, modification_of_pic_nums_idc;\n\t\t\tdo {\n\t\t\t\tmodification_of_pic_nums_idc = gf_bs_read_ue_log_idx(bs, \"modification_of_pic_nums_idc\", idx);\n\t\t\t\tif (modification_of_pic_nums_idc == 0 || modification_of_pic_nums_idc == 1) {\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"abs_diff_pic_num_minus1\", idx);\n\t\t\t\t}\n\t\t\t\telse if (modification_of_pic_nums_idc == 2) {\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"long_term_pic_num\", idx);\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t} while ((modification_of_pic_nums_idc != 3) && gf_bs_available(bs));\n\t\t}\n\t}\n}\n\nstatic void pred_weight_table(GF_BitStream *bs, u32 slice_type, u32 ChromaArrayType, u32 num_ref_idx_l0_active_minus1, u32 num_ref_idx_l1_active_minus1) {\n\tu32 i, j;\n\tgf_bs_read_ue_log(bs, \"luma_log2_weight_denom\");\n\tif (ChromaArrayType != 0) {\n\t\tgf_bs_read_ue_log(bs, \"chroma_log2_weight_denom\");\n\t}\n\tfor (i = 0; i <= num_ref_idx_l0_active_minus1; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"luma_weight_l0_flag\", i)) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"luma_weight_l0\", i);\n\t\t\tgf_bs_read_se_log_idx(bs, \"luma_offset_l0\", i);\n\t\t}\n\t\tif (ChromaArrayType != 0) {\n\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"chroma_weight_l0_flag\", i))\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tgf_bs_read_se_log_idx2(bs, \"chroma_weight_l0\", i, j);\n\t\t\t\t\tgf_bs_read_se_log_idx2(bs, \"chroma_offset_l0\", i, j);\n\t\t\t\t}\n\t\t}\n\t}\n\tif (slice_type % 5 == 1) {\n\t\tfor (i = 0; i <= num_ref_idx_l1_active_minus1; i++) {\n\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"luma_weight_l1_flag\", i)) {\n\t\t\t\tgf_bs_read_se_log_idx(bs, \"luma_weight_l1\", i);\n\t\t\t\tgf_bs_read_se_log_idx(bs, \"luma_offset_l1\", i);\n\t\t\t}\n\t\t\tif (ChromaArrayType != 0) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"chroma_weight_l1_flag\", i)) {\n\t\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\t\tgf_bs_read_se_log_idx2(bs, \"chroma_weight_l1\", i, j);\n\t\t\t\t\t\tgf_bs_read_se_log_idx2(bs, \"chroma_offset_l1\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void dec_ref_pic_marking(GF_BitStream *bs, Bool IdrPicFlag) {\n\tif (IdrPicFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"no_output_of_prior_pics_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"long_term_reference_flag\");\n\t}\n\telse {\n\t\tif (gf_bs_read_int_log(bs, 1, \"adaptive_ref_pic_marking_mode_flag\")) {\n\t\t\tu32 idx=0, memory_management_control_operation;\n\t\t\tdo {\n\t\t\t\tmemory_management_control_operation = gf_bs_read_ue_log_idx(bs, \"memory_management_control_operation\", idx);\n\t\t\t\tif (memory_management_control_operation == 1 || memory_management_control_operation == 3)\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"difference_of_pic_nums_minus1\", idx);\n\t\t\t\tif (memory_management_control_operation == 2)\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"long_term_pic_num\", idx);\n\t\t\t\tif (memory_management_control_operation == 3 || memory_management_control_operation == 6)\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"long_term_frame_idx\", idx);\n\t\t\t\tif (memory_management_control_operation == 4)\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"max_long_term_frame_idx_plus1\", idx);\n\t\t\t\tidx++;\n\t\t\t} while (memory_management_control_operation != 0);\n\t\t}\n\t}\n}\n\nstatic s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255)) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;\n\tsi->bottom_field_flag = 0;\n\tif (!si->sps->frame_mbs_only_flag) {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag)\n\t\t\tsi->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\n\tif ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"poc_lsb\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\n\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tgf_bs_read_int_log(bs, 1, \"direct_spatial_mv_pred_flag\");\n\t}\n\n\tnum_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;\n\tnum_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;\n\n\tif (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tBool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\");\n\t\tif (num_ref_idx_active_override_flag) {\n\t\t\tnum_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active_minus1\");\n\t\t\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\t\t\tnum_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active_minus1\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (si->nal_unit_type == 20 || si->nal_unit_type == 21) {\n\t\t//ref_pic_list_mvc_modification(); /* specified in Annex H */\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\\n\"));\n\t\tassert(0);\n\t\treturn -1;\n\t}\n\telse {\n\t\tref_pic_list_modification(bs, si->slice_type);\n\t}\n\n\tif ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))\n\t\t|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {\n\t\tpred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);\n\t}\n\n\tif (si->nal_ref_idc != 0) {\n\t\tdec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));\n\t}\n\n\tif (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {\n\t\tgf_bs_read_ue_log(bs, \"cabac_init_idc\");\n\t}\n\n\t/*slice_qp_delta = */gf_bs_read_se(bs);\n\tif (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {\n\t\tif (si->slice_type % 5 == GF_AVC_TYPE_SP) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"sp_for_switch_flag\");\n\t\t}\n\t\tgf_bs_read_se_log(bs, \"slice_qs_delta\");\n\t}\n\n\tif (si->pps->deblocking_filter_control_present_flag) {\n\t\tif (gf_bs_read_ue_log(bs, \"disable_deblocking_filter_idc\") != 1) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_alpha_c0_offset_div2\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t}\n\t}\n\n\tif (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {\n\t\tgf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), \"slice_group_change_cycle\");\n\t}\n\treturn 0;\n}\n\n\nstatic s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id > 255)\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;\n\tif (si->sps->frame_mbs_only_flag) {\n\t\t/*s->picture_structure= PICT_FRAME;*/\n\t}\n\telse {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"delta_poc_bottom\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\treturn 0;\n}\n\n\nstatic s32 avc_parse_recovery_point_sei(GF_BitStream *bs, AVCState *avc)\n{\n\tAVCSeiRecoveryPoint *rp = &avc->sei.recovery_point;\n\n\trp->frame_cnt = gf_bs_read_ue_log(bs, \"frame_cnt\");\n\trp->exact_match_flag = gf_bs_read_int_log(bs, 1, \"exact_match_flag\");\n\trp->broken_link_flag = gf_bs_read_int_log(bs, 1, \"broken_link_flag\");\n\trp->changing_slice_group_idc = gf_bs_read_int_log(bs, 2, \"changing_slice_group_idc\");\n\trp->valid = 1;\n\n\treturn 0;\n}\n\n/*for interpretation see ISO 14496-10 N.11084, table D-1*/\nstatic s32 avc_parse_pic_timing_sei(GF_BitStream *bs, AVCState *avc)\n{\n\tint sps_id = avc->sps_active_idx;\n\tconst char NumClockTS[] = { 1, 1, 1, 2, 2, 3, 3, 2, 3 };\n\tAVCSeiPicTiming *pt = &avc->sei.pic_timing;\n\n\tif (sps_id < 0) {\n\t\t/*sps_active_idx equals -1 when no sps has been detected. In this case SEI should not be decoded.*/\n\t\tassert(0);\n\t\treturn 1;\n\t}\n\tif (avc->sps[sps_id].vui.nal_hrd_parameters_present_flag || avc->sps[sps_id].vui.vcl_hrd_parameters_present_flag) { /*CpbDpbDelaysPresentFlag, see 14496-10(2003) E.11*/\n\t\tgf_bs_read_int_log(bs, 1 + avc->sps[sps_id].vui.hrd.cpb_removal_delay_length_minus1, \"cpb_removal_delay_minus1\");\n\t\tgf_bs_read_int_log(bs, 1 + avc->sps[sps_id].vui.hrd.dpb_output_delay_length_minus1, \"dpb_output_delay_minus1\");\n\t}\n\n\t/*ISO 14496-10 (2003), D.8.2: we need to get pic_struct in order to know if we display top field first or bottom field first*/\n\tif (avc->sps[sps_id].vui.pic_struct_present_flag) {\n\t\tint i;\n\t\tpt->pic_struct = gf_bs_read_int_log(bs, 4, \"pic_struct\");\n\t\tif (pt->pic_struct > 8) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] invalid pic_struct value %d\\n\", pt->pic_struct));\n\t\t\treturn 1;\n\t\t}\n\n\t\tfor (i = 0; i < NumClockTS[pt->pic_struct]; i++) {\n\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"clock_timestamp_flag\", i)) {\n\t\t\t\tBool full_timestamp_flag;\n\t\t\t\tgf_bs_read_int_log_idx(bs, 2, \"ct_type\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"nuit_field_based_flag\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 5, \"counting_type\", i);\n\t\t\t\tfull_timestamp_flag = gf_bs_read_int_log_idx(bs, 1, \"full_timestamp_flag\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"discontinuity_flag\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"cnt_dropped_flag\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"n_frames\", i);\n\t\t\t\tif (full_timestamp_flag) {\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 6, \"seconds_value\", i);\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 6, \"minutes_value\", i);\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 5, \"hours_value\", i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seconds_flag\", i)) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 6, \"seconds_value\", i);\n\t\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"minutes_flag\", i)) {\n\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 6, \"minutes_value\", i);\n\t\t\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"hours_flag\", i)) {\n\t\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 5, \"hours_value\", i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (avc->sps[sps_id].vui.hrd.time_offset_length > 0)\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, avc->sps[sps_id].vui.hrd.time_offset_length, \"time_offset\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n#if !defined(GPAC_DISABLE_HEVC)\nstatic void avc_parse_itu_t_t35_sei(GF_BitStream* bs, AVCSeiItuTT35DolbyVision *dovi)\n{\n\tu8 itu_t_t35_country_code = gf_bs_read_u8(bs);\n\tu16 terminal_provider_code = gf_bs_read_u16(bs);\n\tu32 user_id = gf_bs_read_u32(bs);\n\tu8 data_type_code = gf_bs_read_u8(bs);\n\tif (itu_t_t35_country_code == 0xB5 && terminal_provider_code == 0x31 && user_id == 0x47413934 && (data_type_code == 0x8 || data_type_code == 0x9)) {\n\t\tdovi->rpu_flag = GF_TRUE;\n\t}\n}\n#endif\n\nstatic void avc_compute_poc(AVCSliceInfo *si)\n{\n\tenum {\n\t\tAVC_PIC_FRAME,\n\t\tAVC_PIC_FIELD_TOP,\n\t\tAVC_PIC_FIELD_BOTTOM,\n\t} pic_type;\n\ts32 field_poc[2] = { 0,0 };\n\ts32 max_frame_num;\n\n\tif (!si->sps) return;\n\n\tmax_frame_num = 1 << (si->sps->log2_max_frame_num);\n\n\t/* picture type */\n\tif (si->sps->frame_mbs_only_flag || !si->field_pic_flag) pic_type = AVC_PIC_FRAME;\n\telse if (si->bottom_field_flag) pic_type = AVC_PIC_FIELD_BOTTOM;\n\telse pic_type = AVC_PIC_FIELD_TOP;\n\n\t/* frame_num_offset */\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\tsi->poc_lsb_prev = 0;\n\t\tsi->poc_msb_prev = 0;\n\t\tsi->frame_num_offset = 0;\n\t}\n\telse {\n\t\tif (si->frame_num < si->frame_num_prev)\n\t\t\tsi->frame_num_offset = si->frame_num_offset_prev + max_frame_num;\n\t\telse\n\t\t\tsi->frame_num_offset = si->frame_num_offset_prev;\n\t}\n\n\t/*ISO 14496-10 N.11084 8.2.1.1*/\n\tif (si->sps->poc_type == 0)\n\t{\n\t\tconst u32 max_poc_lsb = 1 << (si->sps->log2_max_poc_lsb);\n\n\t\t/*ISO 14496-10 N.11084 eq (8-3)*/\n\t\tif ((si->poc_lsb < si->poc_lsb_prev) &&\n\t\t\t(si->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\t\telse if ((si->poc_lsb > si->poc_lsb_prev) &&\n\t\t\t(si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\t\telse\n\t\t\tsi->poc_msb = si->poc_msb_prev;\n\n\t\t/*ISO 14496-10 N.11084 eq (8-4)*/\n\t\tif (pic_type != AVC_PIC_FIELD_BOTTOM)\n\t\t\tfield_poc[0] = si->poc_msb + si->poc_lsb;\n\n\t\t/*ISO 14496-10 N.11084 eq (8-5)*/\n\t\tif (pic_type != AVC_PIC_FIELD_TOP) {\n\t\t\tif (!si->field_pic_flag)\n\t\t\t\tfield_poc[1] = field_poc[0] + si->delta_poc_bottom;\n\t\t\telse\n\t\t\t\tfield_poc[1] = si->poc_msb + si->poc_lsb;\n\t\t}\n\t}\n\t/*ISO 14496-10 N.11084 8.2.1.2*/\n\telse if (si->sps->poc_type == 1)\n\t{\n\t\tu32 i;\n\t\ts32 abs_frame_num, expected_delta_per_poc_cycle, expected_poc;\n\n\t\tif (si->sps->poc_cycle_length)\n\t\t\tabs_frame_num = si->frame_num_offset + si->frame_num;\n\t\telse\n\t\t\tabs_frame_num = 0;\n\n\t\tif (!si->nal_ref_idc && (abs_frame_num > 0)) abs_frame_num--;\n\n\t\texpected_delta_per_poc_cycle = 0;\n\t\tfor (i = 0; i < si->sps->poc_cycle_length; i++)\n\t\t\texpected_delta_per_poc_cycle += si->sps->offset_for_ref_frame[i];\n\n\t\tif (abs_frame_num > 0) {\n\t\t\tconst u32 poc_cycle_cnt = (abs_frame_num - 1) / si->sps->poc_cycle_length;\n\t\t\tconst u32 frame_num_in_poc_cycle = (abs_frame_num - 1) % si->sps->poc_cycle_length;\n\n\t\t\texpected_poc = poc_cycle_cnt * expected_delta_per_poc_cycle;\n\t\t\tfor (i = 0; i <= frame_num_in_poc_cycle; i++)\n\t\t\t\texpected_poc += si->sps->offset_for_ref_frame[i];\n\t\t}\n\t\telse {\n\t\t\texpected_poc = 0;\n\t\t}\n\n\t\tif (!si->nal_ref_idc) expected_poc += si->sps->offset_for_non_ref_pic;\n\n\t\tfield_poc[0] = expected_poc + si->delta_poc[0];\n\t\tfield_poc[1] = field_poc[0] + si->sps->offset_for_top_to_bottom_field;\n\t\tif (pic_type == AVC_PIC_FRAME) field_poc[1] += si->delta_poc[1];\n\t}\n\t/*ISO 14496-10 N.11084 8.2.1.3*/\n\telse if (si->sps->poc_type == 2)\n\t{\n\t\tint poc;\n\t\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\t\tpoc = 0;\n\t\t}\n\t\telse {\n\t\t\tconst int abs_frame_num = si->frame_num_offset + si->frame_num;\n\t\t\tpoc = 2 * abs_frame_num;\n\t\t\tif (!si->nal_ref_idc) poc -= 1;\n\t\t}\n\t\tfield_poc[0] = poc;\n\t\tfield_poc[1] = poc;\n\t}\n\n\t/*ISO 14496-10 N.11084 eq (8-1)*/\n\tif (pic_type == AVC_PIC_FRAME)\n\t\tsi->poc = MIN(field_poc[0], field_poc[1]);\n\telse if (pic_type == AVC_PIC_FIELD_TOP)\n\t\tsi->poc = field_poc[0];\n\telse\n\t\tsi->poc = field_poc[1];\n}\n\nGF_EXPORT\ns32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)\n{\n\tu8 idr_flag;\n\ts32 slice, ret;\n\tu32 nal_hdr;\n\tAVCSliceInfo n_state;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tnal_hdr = gf_bs_read_u8(bs);\n\n\tslice = 0;\n\tmemcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));\n\tavc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;\n\tn_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;\n\n\tidr_flag = 0;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\t// slice buffer - read the info and compare.\n\t\t/*ret = */svc_parse_slice(bs, avc, &n_state);\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t\tavc_compute_poc(&n_state);\n\n\t\tif (avc->s_info.poc != n_state.poc) {\n\t\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\t\treturn 1;\n\t\t}\n\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SVC_PREFIX_NALU:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_IDR_SLICE:\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\t\tslice = 1;\n\t\t/* slice buffer - read the info and compare.*/\n\t\tret = avc_parse_slice(bs, avc, idr_flag, &n_state);\n\t\tif (ret < 0) return ret;\n\t\tret = 0;\n\t\tif (\n\t\t\t((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))\n\t\t\t&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)\n\t\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\tif (avc->s_info.frame_num != n_state.frame_num) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (avc->s_info.field_pic_flag != n_state.field_pic_flag) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&\n\t\t\t(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tassert(avc->s_info.sps);\n\n\t\tif (avc->s_info.sps->poc_type == n_state.sps->poc_type) {\n\t\t\tif (!avc->s_info.sps->poc_type) {\n\t\t\t\tif (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (avc->s_info.sps->poc_type == 1) {\n\t\t\t\tif (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\t\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) { /*IdrPicFlag differs in value*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (avc->s_info.idr_pic_id != n_state.idr_pic_id) { /*both IDR and idr_pic_id differs*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tavc->last_ps_idx = (s32) gf_bs_read_ue(bs);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEI:\n\tcase GF_AVC_NALU_FILLER_DATA:\n\t\treturn 0;\n\n\tdefault:\n\t\tif (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;\n\t\t//To detect change of AU when multiple sps and pps in stream\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif (ret && avc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = avc->s_info.frame_num_offset;\n\t\tif ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))\n\t\t\tn_state.frame_num_prev = avc->s_info.frame_num;\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t}\n\tif (slice)\n\t\tavc_compute_poc(&n_state);\n\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\treturn ret;\n}\n\n\nu32 gf_media_avc_reformat_sei(u8 *buffer, u32 nal_size, Bool isobmf_rewrite, AVCState *avc)\n{\n\tu32 ptype, psize, hdr, var;\n\tu32 start;\n\tGF_BitStream *bs;\n\tGF_BitStream *bs_dest = NULL;\n\tu8 nhdr;\n\tBool sei_removed = GF_FALSE;\n\tchar store;\n\n\thdr = buffer[0];\n\tif ((hdr & 0x1F) != GF_AVC_NALU_SEI) return 0;\n\n\tif (isobmf_rewrite) bs_dest = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tbs = gf_bs_new(buffer, nal_size, GF_BITSTREAM_READ);\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tnhdr = gf_bs_read_int(bs, 8);\n\tif (bs_dest) gf_bs_write_int(bs_dest, nhdr, 8);\n\n\t/*parse SEI*/\n\twhile (gf_bs_available(bs)) {\n\t\tBool do_copy;\n\t\tptype = 0;\n\t\twhile (1) {\n\t\t\tu8 v = gf_bs_read_int(bs, 8);\n\t\t\tptype += v;\n\t\t\tif (v != 0xFF) break;\n\t\t}\n\n\t\tpsize = 0;\n\t\twhile (1) {\n\t\t\tu8 v = gf_bs_read_int(bs, 8);\n\t\t\tpsize += v;\n\t\t\tif (v != 0xFF) break;\n\t\t}\n\n\t\tstart = (u32)gf_bs_get_position(bs);\n\n\t\tdo_copy = 1;\n\n\t\tif (start + psize >= nal_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] SEI user message type %d size error (%d but %d remain), keeping full SEI untouched\\n\", ptype, psize, nal_size - start));\n\t\t\tif (bs_dest) gf_bs_del(bs_dest);\n\t\t\treturn nal_size;\n\t\t}\n\t\tswitch (ptype) {\n\t\t\t/*remove SEI messages forbidden in MP4*/\n\t\tcase 3: /*filler data*/\n\t\tcase 10: /*sub_seq info*/\n\t\tcase 11: /*sub_seq_layer char*/\n\t\tcase 12: /*sub_seq char*/\n\t\t\tdo_copy = 0;\n\t\t\tsei_removed = GF_TRUE;\n\t\t\tbreak;\n\t\tcase 5: /*user unregistered */\n\t\t\tstore = buffer[start + psize];\n\t\t\tbuffer[start + psize] = 0;\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[avc-h264] SEI user message %s\\n\", buffer + start + 16));\n\t\t\tbuffer[start + psize] = store;\n\t\t\tbreak;\n\n\t\tcase 6: /*recovery point*/\n\t\t\tavc_parse_recovery_point_sei(bs, avc);\n\t\t\tbreak;\n\n\t\tcase 1: /*pic_timing*/\n\t\t\tavc_parse_pic_timing_sei(bs, avc);\n\t\t\tbreak;\n\n\t\tcase 0: /*buffering period*/\n\t\tcase 2: /*pan scan rect*/\n\t\tcase 4: /*user registered ITU t35*/\n\t\tcase 7: /*def_rec_pic_marking_repetition*/\n\t\tcase 8: /*spare_pic*/\n\t\tcase 9: /*scene info*/\n\t\tcase 13: /*full frame freeze*/\n\t\tcase 14: /*full frame freeze release*/\n\t\tcase 15: /*full frame snapshot*/\n\t\tcase 16: /*progressive refinement segment start*/\n\t\tcase 17: /*progressive refinement segment end*/\n\t\tcase 18: /*motion constrained slice group*/\n\t\tdefault: /*add all unknown SEIs*/\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_copy && bs_dest) {\n\t\t\tvar = ptype;\n\t\t\twhile (var >= 255) {\n\t\t\t\tgf_bs_write_int(bs_dest, 0xFF, 8);\n\t\t\t\tvar -= 255;\n\t\t\t}\n\t\t\tgf_bs_write_int(bs_dest, var, 8);\n\n\t\t\tvar = psize;\n\t\t\twhile (var >= 255) {\n\t\t\t\tgf_bs_write_int(bs_dest, 0xFF, 8);\n\t\t\t\tvar -= 255;\n\t\t\t}\n\t\t\tgf_bs_write_int(bs_dest, var, 8);\n\t\t\tgf_bs_seek(bs, start);\n\n\t\t\t//bs_read_data does not skip EPB, read byte per byte\n\t\t\tvar = psize;\n\t\t\twhile (var) {\n\t\t\t\tgf_bs_write_u8(bs_dest, gf_bs_read_u8(bs));\n\t\t\t\tvar--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tgf_bs_seek(bs, start);\n\n\t\t\t//bs_skip_bytes does not skip EPB, skip byte per byte\n\t\t\twhile (psize) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tpsize--;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_available(bs) <= 2) {\n\t\t\tvar = gf_bs_read_int(bs, 8);\n\t\t\tif (var != 0x80) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] SEI user message has less than 2 bytes remaining but no end of sei found\\n\"));\n\t\t\t}\n\t\t\tif (bs_dest) gf_bs_write_int(bs_dest, 0x80, 8);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\t//we cannot compare final size and original size since original may have EPB and final does not yet have them\n\tif (bs_dest && sei_removed) {\n\t\tu8 *dst_no_epb = NULL;\n\t\tu32 dst_no_epb_size = 0;\n\t\tgf_bs_get_content(bs_dest, &dst_no_epb, &dst_no_epb_size);\n\t\tnal_size = gf_media_nalu_add_emulation_bytes(buffer, dst_no_epb, dst_no_epb_size);\n\t}\n\tif (bs_dest) gf_bs_del(bs_dest);\n\treturn nal_size;\n}\n\n\nstatic u8 avc_hevc_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i, count = GF_ARRAY_LENGTH(avc_hevc_sar);\n\tfor (i = 0; i < count; i++) {\n\t\tif ((avc_hevc_sar[i].w == w) && (avc_hevc_sar[i].h == h))\n\t\t\treturn i;\n\t}\n\treturn 0xFF;\n}\n\nstatic void avc_hevc_rewrite_vui(GF_VUIInfo *vui_info, GF_BitStream *orig, GF_BitStream *mod)\n{\n\t/* VUI present flag*/\n\tBool vui_present_flag = gf_bs_read_int(orig, 1);\n\n\t/*setup default values*/\n\tBool aspect_ratio_info_present_flag = 0;\n\ts32 aspect_ratio_idc = -1;\n\tu32 ar_n=0, ar_d=0;\n\tBool overscan_info_present_flag = 0;\n\tu32 overscan_info=0;\n\tu32 video_signal_type_present_flag=0;\n\tu32 video_format = 5;\n\tu32 video_full_range_flag = 0;\n\tu32 colour_description_present_flag = 0;\n\tu32 colour_primaries = 2;\n\tu32 transfer_characteristics = 2;\n\tu32 matrix_coefficients = 2;\n\n\t//if VUI is present, read all SAR and overscan values\n\tif (vui_present_flag) { /* VUI found in input bitstream */\n\t\taspect_ratio_info_present_flag = gf_bs_read_int(orig, 1);\n\t\tif (aspect_ratio_info_present_flag) {\n\t\t\taspect_ratio_idc = gf_bs_read_int(orig, 8); /*aspect_ratio_idc*/\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tar_n = gf_bs_read_int(orig, 16); /*sar_width*/\n\t\t\t\tar_d = gf_bs_read_int(orig, 16); /*sar_height*/\n\t\t\t}\n\t\t}\n\n\t\t/*overscan_info_present_flag */\n\t\toverscan_info_present_flag = gf_bs_read_int(orig, 1);\n\t\tif(overscan_info_present_flag) {\n\t\t\toverscan_info = gf_bs_read_int(orig, 1);\n\t\t}\n\n\t\t/* read all video signal related flags first */\n\t\tvideo_signal_type_present_flag = gf_bs_read_int(orig, 1);\n\t\tif(video_signal_type_present_flag) {\n\t\t\tvideo_format = gf_bs_read_int(orig, 3);\n\t\t\tvideo_full_range_flag = gf_bs_read_int(orig, 1);\n\t\t\tcolour_description_present_flag = gf_bs_read_int(orig, 1);\n\t\t\tif(colour_description_present_flag) {\n\t\t\t\tcolour_primaries = gf_bs_read_int(orig, 8);\n\t\t\t\ttransfer_characteristics = gf_bs_read_int(orig, 8);\n\t\t\t\tmatrix_coefficients = gf_bs_read_int(orig, 8);\n\t\t\t}\n\t\t}\n\t}\n\n\t//recompute values\n\t//no change\n\tif ((vui_info->ar_num<0) || (vui_info->ar_den<0)) {\n\t}\n\t//remove par\n\telse if ((vui_info->ar_num==0) || (vui_info->ar_den==0)) {\n\t\taspect_ratio_info_present_flag = 0;\n\t}\n\t//set par\n\telse {\n\t\taspect_ratio_info_present_flag = 1;\n\t\tar_n = vui_info->ar_num;\n\t\tar_d = vui_info->ar_den;\n\t\taspect_ratio_idc = avc_hevc_get_sar_idx((u32) ar_n, (u32) ar_d);\n\t}\n\n\tif (vui_info->remove_video_info) {\n\t\tvideo_signal_type_present_flag = 0;\n\t}\n\t/* correct the values of each flags */\n\telse if ((vui_info->fullrange==0) && (vui_info->video_format==5) && (vui_info->color_prim==2) && (vui_info->color_tfc==2) && (vui_info->color_matrix==2)) {\n\t\tvideo_signal_type_present_flag = 0; /* all default, nothing to write*/\n\t} else {\n\t\tvideo_signal_type_present_flag = 1;\n\t\tvideo_format = (vui_info->video_format < 0) ? video_format : vui_info->video_format;\n\t\tvideo_full_range_flag = (vui_info->fullrange < 0) ? video_full_range_flag : vui_info->fullrange;\n\t\tif ((vui_info->color_prim==2) && (vui_info->color_tfc==2) && (vui_info->color_matrix==2)) {\n\t\t\tcolour_description_present_flag = 0;\n\t\t} else {\n\t\t\tcolour_description_present_flag = 1;\n\t\t\tcolour_primaries = (vui_info->color_prim < 0) ? colour_primaries : vui_info->color_prim;\n\t\t\ttransfer_characteristics = (vui_info->color_tfc < 0) ? transfer_characteristics : vui_info->color_tfc;\n\t\t\tmatrix_coefficients = (vui_info->color_matrix < 0) ? matrix_coefficients : vui_info->color_matrix;\n\t\t}\n\t\tif ((colour_primaries==2) && (transfer_characteristics==2) && (matrix_coefficients==2)) {\n\t\t\tcolour_description_present_flag = 0;\n\t\t\tif ((video_format==5) && (video_full_range_flag==0))\n\t\t\t\tvideo_signal_type_present_flag = 0;\n\t\t}\n\t}\n\n\t//always rewrite VUI\n\tgf_bs_write_int(mod, 1, 1);\n\tgf_bs_write_int(mod, aspect_ratio_info_present_flag, 1);\n\tif (aspect_ratio_info_present_flag) {\n\t\tgf_bs_write_int(mod, aspect_ratio_idc, 8);\n\t\tif (aspect_ratio_idc == 255) {\n\t\t\tgf_bs_write_int(mod, ar_n, 16);\n\t\t\tgf_bs_write_int(mod, ar_d, 16);\n\t\t}\n\t\tif (vui_info->update) {\n\t\t\tvui_info->ar_num = ar_n;\n\t\t\tvui_info->ar_den = ar_d;\n\t\t}\n\t}\n\tgf_bs_write_int(mod, overscan_info_present_flag, 1);\n\tif (overscan_info_present_flag) {\n\t\tgf_bs_write_int(mod, overscan_info, 1);\n\t}\n\n\tgf_bs_write_int(mod, video_signal_type_present_flag, 1);\n\tif (video_signal_type_present_flag) {\n\t\tgf_bs_write_int(mod, video_format, 3);\n\t\tgf_bs_write_int(mod, video_full_range_flag, 1);\n\t\tgf_bs_write_int(mod, colour_description_present_flag, 1);\n\n\t\tif (colour_description_present_flag) {\n\t\t\tgf_bs_write_int(mod, colour_primaries, 8);\n\t\t\tgf_bs_write_int(mod, transfer_characteristics, 8);\n\t\t\tgf_bs_write_int(mod, matrix_coefficients, 8);\n\t\t}\n\n\t\tif (vui_info->update) {\n\t\t\tvui_info->video_format = video_format;\n\t\t\tvui_info->fullrange = video_full_range_flag;\n\t\t\tif (colour_description_present_flag) {\n\t\t\t\tvui_info->color_prim = colour_primaries;\n\t\t\t\tvui_info->color_tfc = transfer_characteristics;\n\t\t\t\tvui_info->color_matrix = matrix_coefficients;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*no VUI in input bitstream but we just inserted one, set all remaining vui flags to 0*/\n\tif (!vui_present_flag) {\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*chroma_location_info_present_flag */\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*timing_info_present_flag*/\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*nal_hrd_parameters_present*/\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*vcl_hrd_parameters_present*/\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*pic_struct_present*/\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*bitstream_restriction*/\n\t}\n\t/*otherwise we copy over th bits from the input bitrate*/\n}\n\nGF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)\n{\n\tGF_BitStream *orig, *mod;\n\tAVCState avc;\n\tu32 i, bit_offset, flag;\n\ts32 idx;\n\tGF_AVCConfigSlot *slc;\n\torig = NULL;\n\n\tmemset(&avc, 0, sizeof(AVCState));\n\tavc.sps_active_idx = -1;\n\n\ti=0;\n\twhile ((slc = (GF_AVCConfigSlot *)gf_list_enum(avcc->sequenceParameterSets, &i))) {\n\t\tu8 *no_emulation_buf = NULL;\n\t\tu32 no_emulation_buf_size = 0, emulation_bytes = 0;\n\t\tidx = gf_avc_read_sps(slc->data, slc->size, &avc, 0, &bit_offset);\n\t\tif (idx<0) {\n\t\t\tif ( orig )\n\t\t\t\tgf_bs_del(orig);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*SPS still contains emulation bytes*/\n\t\tno_emulation_buf = gf_malloc((slc->size - 1) * sizeof(char));\n\t\tno_emulation_buf_size = gf_media_nalu_remove_emulation_bytes(slc->data + 1, no_emulation_buf, slc->size - 1);\n\n\t\torig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);\n\t\tgf_bs_read_data(orig, no_emulation_buf, no_emulation_buf_size);\n\t\tgf_bs_seek(orig, 0);\n\t\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t/*copy over till vui flag*/\n\t\tassert(bit_offset >= 8);\n\t\twhile (bit_offset - 8/*bit_offset doesn't take care of the first byte (NALU type)*/) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t\tbit_offset--;\n\t\t}\n\n\t\tavc_hevc_rewrite_vui(vui_info, orig, mod);\n\n\t\t/*finally copy over remaining*/\n\t\twhile (gf_bs_bits_available(orig)) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t}\n\t\tgf_bs_del(orig);\n\t\torig = NULL;\n\t\tgf_free(no_emulation_buf);\n\n\t\t/*set anti-emulation*/\n\t\tgf_bs_get_content(mod, &no_emulation_buf, &flag);\n\t\temulation_bytes = gf_media_nalu_emulation_bytes_add_count(no_emulation_buf, flag);\n\t\tif (flag+emulation_bytes+1>slc->size)\n\t\t\tslc->data = (char*)gf_realloc(slc->data, flag+emulation_bytes+1);\n\t\tslc->size = gf_media_nalu_add_emulation_bytes(no_emulation_buf, slc->data + 1, flag) + 1;\n\n\t\tgf_bs_del(mod);\n\t\tgf_free(no_emulation_buf);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_media_avc_change_par(GF_AVCConfig *avcc, s32 ar_n, s32 ar_d)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = ar_n;\n\tvuii.ar_den = ar_d;\n\tvuii.fullrange = -1;\n\tvuii.video_format = -1;\n\tvuii.color_prim = -1;\n\tvuii.color_tfc = -1;\n\tvuii.color_matrix = -1;\n\treturn gf_avc_change_vui(avcc, &vuii);\n}\n\nGF_EXPORT\nGF_Err gf_media_avc_change_color(GF_AVCConfig *avcc, s32 fullrange, s32 vidformat, s32 colorprim, s32 transfer, s32 colmatrix)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = -1;\n\tvuii.ar_den = -1;\n\tvuii.fullrange = fullrange;\n\tvuii.video_format = vidformat;\n\tvuii.color_prim = colorprim;\n\tvuii.color_tfc = transfer;\n\tvuii.color_matrix = colmatrix;\n\treturn gf_avc_change_vui(avcc, &vuii);\n}\n\n\nGF_EXPORT\nGF_Err gf_avc_get_sps_info(u8 *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\tAVCState avc;\n\ts32 idx;\n\tmemset(&avc, 0, sizeof(AVCState));\n\tavc.sps_active_idx = -1;\n\n\tidx = gf_avc_read_sps(sps_data, sps_size, &avc, 0, NULL);\n\tif (idx < 0) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (sps_id) *sps_id = idx;\n\n\tif (width) *width = avc.sps[idx].width;\n\tif (height) *height = avc.sps[idx].height;\n\tif (par_n) *par_n = avc.sps[idx].vui.par_num ? avc.sps[idx].vui.par_num : (u32)-1;\n\tif (par_d) *par_d = avc.sps[idx].vui.par_den ? avc.sps[idx].vui.par_den : (u32)-1;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_avc_get_pps_info(u8 *pps_data, u32 pps_size, u32 *pps_id, u32 *sps_id)\n{\n\tGF_BitStream *bs;\n\tGF_Err e = GF_OK;\n\n\tbs = gf_bs_new(pps_data, pps_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto exit;\n\t}\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t/*nal hdr*/ gf_bs_read_int(bs, 8);\n\n\t*pps_id = gf_bs_read_ue(bs);\n\t*sps_id = gf_bs_read_ue(bs);\n\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_HEVC\n\n/**********\nHEVC parsing\n**********/\n\nBool gf_hevc_slice_is_intra(HEVCState *hevc)\n{\n\tswitch (hevc->s_info.nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nBool gf_hevc_slice_is_IDR(HEVCState *hevc)\n{\n\tif (hevc->sei.recovery_point.valid)\n\t{\n\t\thevc->sei.recovery_point.valid = 0;\n\t\treturn GF_TRUE;\n\t}\n\tswitch (hevc->s_info.nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nstatic Bool hevc_parse_short_term_ref_pic_set(GF_BitStream *bs, HEVC_SPS *sps, u32 idx_rps)\n{\n\tu32 i;\n\tBool inter_ref_pic_set_prediction_flag = 0;\n\tif (idx_rps != 0)\n\t\tinter_ref_pic_set_prediction_flag = gf_bs_read_int_log_idx(bs, 1, \"inter_ref_pic_set_prediction_flag\", idx_rps);\n\n\tif (inter_ref_pic_set_prediction_flag) {\n\t\tHEVC_ReferencePictureSets *ref_ps, *rps;\n\t\tu32 delta_idx_minus1 = 0;\n\t\tu32 ref_idx;\n\t\tu32 delta_rps_sign;\n\t\tu32 abs_delta_rps_minus1, nb_ref_pics;\n\t\ts32 deltaRPS;\n\t\tu32 k = 0, k0 = 0, k1 = 0;\n\t\tif (idx_rps == sps->num_short_term_ref_pic_sets)\n\t\t\tdelta_idx_minus1 = gf_bs_read_ue_log_idx(bs, \"delta_idx_minus1\", idx_rps);\n\n\t\tassert(delta_idx_minus1 <= idx_rps - 1);\n\t\tref_idx = idx_rps - 1 - delta_idx_minus1;\n\t\tdelta_rps_sign = gf_bs_read_int_log_idx(bs, 1, \"delta_rps_sign\", idx_rps);\n\t\tabs_delta_rps_minus1 = gf_bs_read_ue_log_idx(bs, \"abs_delta_rps_minus1\", idx_rps);\n\t\tdeltaRPS = (1 - (delta_rps_sign << 1)) * (abs_delta_rps_minus1 + 1);\n\n\t\trps = &sps->rps[idx_rps];\n\t\tref_ps = &sps->rps[ref_idx];\n\t\tnb_ref_pics = ref_ps->num_negative_pics + ref_ps->num_positive_pics;\n\t\tfor (i = 0; i <= nb_ref_pics; i++) {\n\t\t\ts32 ref_idc;\n\t\t\ts32 used_by_curr_pic_flag = gf_bs_read_int_log_idx2(bs, 1, \"used_by_curr_pic_flag\", idx_rps, i);\n\t\t\tref_idc = used_by_curr_pic_flag ? 1 : 0;\n\t\t\tif (!used_by_curr_pic_flag) {\n\t\t\t\tused_by_curr_pic_flag = gf_bs_read_int_log_idx2(bs, 1, \"used_by_curr_pic_flag\", idx_rps, i);\n\t\t\t\tref_idc = used_by_curr_pic_flag << 1;\n\t\t\t}\n\t\t\tif ((ref_idc == 1) || (ref_idc == 2)) {\n\t\t\t\ts32 deltaPOC = deltaRPS;\n\t\t\t\tif (i < nb_ref_pics)\n\t\t\t\t\tdeltaPOC += ref_ps->delta_poc[i];\n\n\t\t\t\trps->delta_poc[k] = deltaPOC;\n\n\t\t\t\tif (deltaPOC < 0)  k0++;\n\t\t\t\telse k1++;\n\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\trps->num_negative_pics = k0;\n\t\trps->num_positive_pics = k1;\n\t}\n\telse {\n\t\ts32 prev = 0, poc;\n\t\tsps->rps[idx_rps].num_negative_pics = gf_bs_read_ue_log_idx(bs, \"num_negative_pics\", idx_rps);\n\t\tsps->rps[idx_rps].num_positive_pics = gf_bs_read_ue_log_idx(bs, \"num_positive_pics\", idx_rps);\n\t\tif (sps->rps[idx_rps].num_negative_pics > 16)\n\t\t\treturn GF_FALSE;\n\t\tif (sps->rps[idx_rps].num_positive_pics > 16)\n\t\t\treturn GF_FALSE;\n\t\tfor (i = 0; i < sps->rps[idx_rps].num_negative_pics; i++) {\n\t\t\tu32 delta_poc_s0_minus1 = gf_bs_read_ue_log_idx2(bs, \"delta_poc_s0_minus1\", idx_rps, i);\n\t\t\tpoc = prev - delta_poc_s0_minus1 - 1;\n\t\t\tprev = poc;\n\t\t\tsps->rps[idx_rps].delta_poc[i] = poc;\n\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"delta_poc_s0_minus1\", idx_rps, i);\n\t\t}\n\t\tfor (i = 0; i < sps->rps[idx_rps].num_positive_pics; i++) {\n\t\t\tu32 delta_poc_s1_minus1 = gf_bs_read_ue_log_idx2(bs, \"delta_poc_s1_minus1\" , idx_rps, i);\n\t\t\tpoc = prev + delta_poc_s1_minus1 + 1;\n\t\t\tprev = poc;\n\t\t\tsps->rps[idx_rps].delta_poc[i] = poc;\n\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"used_by_curr_pic_s1_flag\", idx_rps, i);\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nvoid hevc_pred_weight_table(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si, HEVC_PPS *pps, HEVC_SPS *sps, u32 num_ref_idx_l0_active, u32 num_ref_idx_l1_active)\n{\n\tu32 i, num_ref_idx;\n\tBool first_pass = GF_TRUE;\n\tu8 luma_weights[20], chroma_weights[20];\n\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\n\tnum_ref_idx = num_ref_idx_l0_active;\n\n\tgf_bs_read_ue_log(bs, \"luma_log2_weight_denom\");\n\tif (ChromaArrayType != 0)\n\t\tgf_bs_read_se_log(bs, \"delta_chroma_log2_weight_denom\");\n\nparse_weights:\n\tfor (i = 0; i < num_ref_idx; i++) {\n\t\tluma_weights[i] = gf_bs_read_int_log_idx(bs, 1, \"luma_weights\", i);\n\t\t//infered to be 0 if not present\n\t\tchroma_weights[i] = 0;\n\t}\n\tif (ChromaArrayType != 0) {\n\t\tfor (i = 0; i < num_ref_idx; i++) {\n\t\t\tchroma_weights[i] = gf_bs_read_int_log_idx(bs, 1, \"chroma_weights\", i);\n\t\t}\n\t}\n\tfor (i = 0; i < num_ref_idx; i++) {\n\t\tif (luma_weights[i]) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"delta_luma_weight_l0\", i);\n\t\t\tgf_bs_read_se_log_idx(bs, \"luma_offset_l0\", i);\n\t\t}\n\t\tif (chroma_weights[i]) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"delta_chroma_weight_l0_0\", i);\n\t\t\tgf_bs_read_se_log_idx(bs, \"delta_chroma_offset_l0_0\", i);\n\n\t\t\tgf_bs_read_se_log_idx(bs, \"delta_chroma_weight_l0_1\", i);\n\t\t\tgf_bs_read_se_log_idx(bs, \"delta_chroma_offset_l0_1\", i);\n\t\t}\n\t}\n\n\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\tif (!first_pass) return;\n\t\tfirst_pass = GF_FALSE;\n\t\tnum_ref_idx = num_ref_idx_l1_active;\n\t\tgoto parse_weights;\n\t}\n}\n\nstatic\nBool ref_pic_lists_modification(GF_BitStream *bs, u32 slice_type, u32 num_ref_idx_l0_active, u32 num_ref_idx_l1_active)\n{\n\t//u32 i;\n\tBool ref_pic_list_modification_flag_l0 = gf_bs_read_int_log(bs, 1, \"ref_pic_list_modification_flag_l0\");\n\tif (ref_pic_list_modification_flag_l0) {\n\t\t/*for (i=0; i<num_ref_idx_l0_active; i++) {\n\t\t\tlist_entry_l0[i] = *//*gf_bs_read_int(bs, (u32)ceil(log(getNumPicTotalCurr())/log(2)));\n\t\t}*/\n\t\treturn GF_FALSE;\n\t}\n\tif (slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\tBool ref_pic_list_modification_flag_l1 = gf_bs_read_int_log(bs, 1, \"ref_pic_list_modification_flag_l1\");\n\t\tif (ref_pic_list_modification_flag_l1) {\n\t\t\t/*for (i=0; i<num_ref_idx_l1_active; i++) {\n\t\t\t\tlist_entry_l1[i] = *//*gf_bs_read_int(bs, (u32)ceil(log(getNumPicTotalCurr()) / log(2)));\n\t\t\t}*/\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\n\treturn GF_TRUE;\n}\n\nstatic\ns32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)\n{\n\tu32 i, j;\n\tu32 num_ref_idx_l0_active = 0, num_ref_idx_l1_active = 0;\n\tHEVC_PPS *pps;\n\tHEVC_SPS *sps;\n\ts32 pps_id;\n\tBool RapPicFlag = GF_FALSE;\n\tBool IDRPicFlag = GF_FALSE;\n\n\tsi->first_slice_segment_in_pic_flag = gf_bs_read_int_log(bs, 1, \"first_slice_segment_in_pic_flag\");\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tIDRPicFlag = GF_TRUE;\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\t}\n\n\tif (RapPicFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"no_output_of_prior_pics_flag\");\n\t}\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 64))\n\t\treturn -1;\n\n\tpps = &hevc->pps[pps_id];\n\tsps = &hevc->sps[pps->sps_id];\n\tsi->sps = sps;\n\tsi->pps = pps;\n\n\tif (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {\n\t\tsi->dependent_slice_segment_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segment_flag\");\n\t}\n\telse {\n\t\tsi->dependent_slice_segment_flag = GF_FALSE;\n\t}\n\n\tif (!si->first_slice_segment_in_pic_flag) {\n\t\tsi->slice_segment_address = gf_bs_read_int_log(bs, sps->bitsSliceSegmentAddress, \"slice_segment_address\");\n\t}\n\telse {\n\t\tsi->slice_segment_address = 0;\n\t}\n\n\tif (!si->dependent_slice_segment_flag) {\n\t\tBool deblocking_filter_override_flag = 0;\n\t\tBool slice_temporal_mvp_enabled_flag = 0;\n\t\tBool slice_sao_luma_flag = 0;\n\t\tBool slice_sao_chroma_flag = 0;\n\t\tBool slice_deblocking_filter_disabled_flag = 0;\n\n\t\t//\"slice_reserved_undetermined_flag[]\"\n\t\tgf_bs_read_int_log(bs, pps->num_extra_slice_header_bits, \"slice_reserved_undetermined_flag\");\n\n\t\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\n\t\tif (pps->output_flag_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"pic_output_flag\");\n\n\t\tif (sps->separate_colour_plane_flag == 1)\n\t\t\tgf_bs_read_int_log(bs, 2, \"colour_plane_id\");\n\n\t\tif (IDRPicFlag) {\n\t\t\tsi->poc_lsb = 0;\n\n\t\t\t//if not asked to parse full header, abort since we know the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t}\n\t\telse {\n\t\t\tsi->poc_lsb = gf_bs_read_int_log(bs, sps->log2_max_pic_order_cnt_lsb, \"poc_lsb\");\n\n\t\t\t//if not asked to parse full header, abort once we have the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"short_term_ref_pic_set_sps_flag\") == 0) {\n\t\t\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (sps->num_short_term_ref_pic_sets > 1) {\n\t\t\t\tu32 numbits = 0;\n\n\t\t\t\twhile ((u32)(1 << numbits) < sps->num_short_term_ref_pic_sets)\n\t\t\t\t\tnumbits++;\n\t\t\t\tif (numbits > 0)\n\t\t\t\t\tgf_bs_read_int_log(bs, numbits, \"short_term_ref_pic_set_idx\");\n\t\t\t\t/*else\n\t\t\t\t\tshort_term_ref_pic_set_idx = 0;*/\n\t\t\t}\n\t\t\tif (sps->long_term_ref_pics_present_flag) {\n\t\t\t\tu8 DeltaPocMsbCycleLt[32];\n\t\t\t\tu32 num_long_term_sps = 0;\n\t\t\t\tu32 num_long_term_pics = 0;\n\n\t\t\t\tmemset(DeltaPocMsbCycleLt, 0, sizeof(u8) * 32);\n\t\t\t\t\n\t\t\t\tif (sps->num_long_term_ref_pic_sps > 0) {\n\t\t\t\t\tnum_long_term_sps = gf_bs_read_ue_log(bs, \"num_long_term_sps\");\n\t\t\t\t}\n\t\t\t\tnum_long_term_pics = gf_bs_read_ue_log(bs, \"num_long_term_pics\");\n\n\t\t\t\tfor (i = 0; i < num_long_term_sps + num_long_term_pics; i++) {\n\t\t\t\t\tif (i < num_long_term_sps) {\n\t\t\t\t\t\tif (sps->num_long_term_ref_pic_sps > 1)\n\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps), \"lt_idx_sps\", i);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"PocLsbLt\", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"UsedByCurrPicLt\", i);\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"delta_poc_msb_present_flag\", i)) {\n\t\t\t\t\t\tif (i == 0 || i == num_long_term_sps)\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i) + DeltaPocMsbCycleLt[i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->temporal_mvp_enable_flag)\n\t\t\t\tslice_temporal_mvp_enabled_flag = gf_bs_read_int_log(bs, 1, \"slice_temporal_mvp_enabled_flag\");\n\t\t}\n\t\tif (sps->sample_adaptive_offset_enabled_flag) {\n\t\t\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\t\t\tslice_sao_luma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_luma_flag\");\n\t\t\tif (ChromaArrayType != 0)\n\t\t\t\tslice_sao_chroma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_chroma_flag\");\n\t\t}\n\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\t\t//u32 NumPocTotalCurr;\n\t\t\tnum_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n\t\t\tnum_ref_idx_l1_active = 0;\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tnum_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\")) {\n\t\t\t\tnum_ref_idx_l0_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active\");\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tnum_ref_idx_l1_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active\");\n\t\t\t}\n\n\t\t\tif (pps->lists_modification_present_flag /*TODO: && NumPicTotalCurr > 1*/) {\n\t\t\t\tif (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[hevc] ref_pic_lists_modification( ) not implemented\\n\"));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"mvd_l1_zero_flag\");\n\t\t\tif (pps->cabac_init_present_flag)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"cabac_init_flag\");\n\n\t\t\tif (slice_temporal_mvp_enabled_flag) {\n\t\t\t\t// When collocated_from_l0_flag is not present, it is inferred to be equal to 1.\n\t\t\t\tBool collocated_from_l0_flag = 1;\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tcollocated_from_l0_flag = gf_bs_read_int_log(bs, 1, \"collocated_from_l0_flag\");\n\n\t\t\t\tif ((collocated_from_l0_flag && (num_ref_idx_l0_active > 1))\n\t\t\t\t\t|| (!collocated_from_l0_flag && (num_ref_idx_l1_active > 1))\n\t\t\t\t) {\n\t\t\t\t\tgf_bs_read_ue_log(bs, \"collocated_ref_idx\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P)\n\t\t\t\t|| (pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t) {\n\t\t\t\thevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);\n\t\t\t}\n\t\t\tgf_bs_read_ue_log(bs, \"five_minus_max_num_merge_cand\");\n\t\t}\n\t\tsi->slice_qp_delta_start_bits = (s32) (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\t\tsi->slice_qp_delta = gf_bs_read_se_log(bs, \"slice_qp_delta\");\n\n\t\tif (pps->slice_chroma_qp_offsets_present_flag) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_cb_qp_offset\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_cr_qp_offset\");\n\t\t}\n\t\tif (pps->deblocking_filter_override_enabled_flag) {\n\t\t\tdeblocking_filter_override_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_flag\");\n\t\t}\n\n\t\tif (deblocking_filter_override_flag) {\n\t\t\tslice_deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, \"slice_deblocking_filter_disabled_flag\");\n\t\t\tif (!slice_deblocking_filter_disabled_flag) {\n\t\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t\t\tgf_bs_read_se_log(bs, \"slice_tc_offset_div2\");\n\t\t\t}\n\t\t}\n\t\tif (pps->loop_filter_across_slices_enabled_flag\n\t\t\t&& (slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag)\n\t\t) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_loop_filter_across_slices_enabled_flag\");\n\t\t}\n\t}\n\t//dependent slice segment\n\telse {\n\t\t//if not asked to parse full header, abort\n\t\tif (!hevc->full_slice_header_parse) return 0;\n\t}\n\n\tsi->entry_point_start_bits = ((u32)gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\n\tif (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {\n\t\tu32 num_entry_point_offsets = gf_bs_read_ue_log(bs, \"num_entry_point_offsets\");\n\t\tif (num_entry_point_offsets > 0) {\n\t\t\tu32 offset = gf_bs_read_ue_log(bs, \"offset\") + 1;\n\t\t\tu32 segments = offset >> 4;\n\t\t\ts32 remain = (offset & 15);\n\n\t\t\tfor (i = 0; i < num_entry_point_offsets; i++) {\n\t\t\t\t//u32 res = 0;\n\t\t\t\tfor (j = 0; j < segments; j++) {\n\t\t\t\t\t//res <<= 16;\n\t\t\t\t\t/*res +=*/ gf_bs_read_int(bs, 16);\n\t\t\t\t}\n\t\t\t\tif (remain) {\n\t\t\t\t\t//res <<= remain;\n\t\t\t\t\t/* res += */ gf_bs_read_int(bs, remain);\n\t\t\t\t}\n\t\t\t\t// entry_point_offset = val + 1; // +1; // +1 to get the size\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pps->slice_segment_header_extension_present_flag) {\n\t\tu32 size_ext = gf_bs_read_ue_log(bs, \"size_ext\");\n\t\twhile (size_ext) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tsize_ext--;\n\t\t}\n\t}\n\n\tsi->header_size_bits = (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs); // av_parser.c modified on 16 jan. 2019 \n\n\tif (gf_bs_read_int_log(bs, 1, \"byte_align\") == 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Error parsing slice header: byte_align not found at end of header !\\n\"));\n\t}\n\n\tgf_bs_align(bs);\n\tsi->payload_start_offset = (s32)gf_bs_get_position(bs);\n\treturn 0;\n}\n\nstatic void gf_hevc_vvc_parse_sei(char *buffer, u32 nal_size, HEVCState *hevc, VVCState *vvc)\n{\n\tu32 ptype, psize, hdr;\n\tu64 start;\n\tGF_BitStream *bs;\n\n\thdr = buffer[0];\n\tif (((hdr & 0x7e) >> 1) != GF_HEVC_NALU_SEI_PREFIX) return;\n\n\tbs = gf_bs_new(buffer, nal_size, GF_BITSTREAM_READ);\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tgf_bs_read_int(bs, 16);\n\n\t/*parse SEI*/\n\twhile (gf_bs_available(bs)) {\n\t\tu32 consumed;\n\t\tptype = 0;\n\t\twhile (gf_bs_peek_bits(bs, 8, 0)==0xFF) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tptype += 255;\n\t\t}\n\t\tptype += gf_bs_read_int(bs, 8);\n\t\tpsize = 0;\n\t\twhile (gf_bs_peek_bits(bs, 8, 0)==0xFF) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tpsize += 255;\n\t\t}\n\t\tpsize += gf_bs_read_int(bs, 8);\n\n\t\tstart = gf_bs_get_position(bs);\n\t\tif (start+psize >= nal_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[%s] SEI user message type %d size error (%d but %d remain), skipping SEI message\\n\", hevc ? \"HEVC\" : \"VVC\", ptype, psize, nal_size-start));\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ptype) {\n\t\tcase 4: /*user registered ITU-T T35*/\n\t\t\tif (hevc) {\n\t\t\t\tavc_parse_itu_t_t35_sei(bs, &hevc->sei.dovi);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tgf_bs_align(bs);\n\t\tconsumed = (u32) (gf_bs_get_position(bs) - start);\n\t\tpsize-=consumed;\n\t\tgf_bs_skip_bytes(bs, psize);\n\t\tif (gf_bs_available(bs) <= 2)\n\t\t\tbreak;\n\t}\n\tgf_bs_del(bs);\n}\n\nvoid gf_hevc_parse_sei(char *buffer, u32 nal_size, HEVCState *hevc)\n{\n\tgf_hevc_vvc_parse_sei(buffer, nal_size, hevc, NULL);\n}\n\nstatic void hevc_compute_poc(HEVCSliceInfo *si)\n{\n\tu32 max_poc_lsb = 1 << (si->sps->log2_max_pic_order_cnt_lsb);\n\n\t/*POC reset for IDR frames, NOT for CRA*/\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tsi->poc_lsb_prev = 0;\n\t\tsi->poc_msb_prev = 0;\n\t\tbreak;\n\t}\n\n\tif ((si->poc_lsb < si->poc_lsb_prev) && (si->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2))\n\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\telse if ((si->poc_lsb > si->poc_lsb_prev) && (si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\telse\n\t\tsi->poc_msb = si->poc_msb_prev;\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\tsi->poc_msb = 0;\n\t\tbreak;\n\t}\n\tsi->poc = si->poc_msb + si->poc_lsb;\n}\n\n\nstatic Bool hevc_parse_nal_header(GF_BitStream *bs, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tu32 val;\n\tval = gf_bs_read_int_log(bs, 1, \"forbidden_zero\");\n\tif (val) return GF_FALSE;\n\n\tval = gf_bs_read_int_log(bs, 6, \"nuh_type\");\n\tif (nal_unit_type) *nal_unit_type = val;\n\n\tval = gf_bs_read_int_log(bs, 6, \"layerID\");\n\tif (layer_id) *layer_id = val;\n\n\tval = gf_bs_read_int_log(bs, 3, \"temporalID\");\n\tif (!val)\n\t\treturn GF_FALSE;\n\tval -= 1;\n\tif (temporal_id) *temporal_id = val;\n\treturn GF_TRUE;\n}\n\n\nvoid hevc_profile_tier_level(GF_BitStream *bs, Bool ProfilePresentFlag, u8 MaxNumSubLayersMinus1, HEVC_ProfileTierLevel *ptl, u32 idx)\n{\n\tu32 i;\n\tif (ProfilePresentFlag) {\n\t\tptl->profile_space = gf_bs_read_int_log_idx(bs, 2, \"profile_space\", idx);\n\t\tptl->tier_flag = gf_bs_read_int_log_idx(bs, 1, \"tier_flag\", idx);\n\t\tptl->profile_idc = gf_bs_read_int_log_idx(bs, 5, \"profile_idc\", idx);\n\n\t\tptl->profile_compatibility_flag = gf_bs_read_int_log_idx(bs, 32, \"profile_compatibility_flag\", idx);\n\n\t\tptl->general_progressive_source_flag = gf_bs_read_int_log_idx(bs, 1, \"general_progressive_source_flag\", idx);\n\t\tptl->general_interlaced_source_flag = gf_bs_read_int_log_idx(bs, 1, \"general_interlaced_source_flag\", idx);\n\t\tptl->general_non_packed_constraint_flag = gf_bs_read_int_log_idx(bs, 1, \"general_non_packed_constraint_flag\", idx);\n\t\tptl->general_frame_only_constraint_flag = gf_bs_read_int_log_idx(bs, 1, \"general_frame_only_constraint_flag\", idx);\n\t\tptl->general_reserved_44bits = gf_bs_read_long_int(bs, 44);\n\t}\n\tptl->level_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\tfor (i = 0; i < MaxNumSubLayersMinus1; i++) {\n\t\tptl->sub_ptl[i].profile_present_flag = gf_bs_read_int_log_idx2(bs, 1, \"profile_present_flag\", idx, i);\n\t\tptl->sub_ptl[i].level_present_flag = gf_bs_read_int_log_idx2(bs, 1, \"level_present_flag\", idx, i);\n\t}\n\tif (MaxNumSubLayersMinus1 > 0) {\n\t\tfor (i = MaxNumSubLayersMinus1; i < 8; i++) {\n\t\t\t/*reserved_zero_2bits*/gf_bs_read_int(bs, 2);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MaxNumSubLayersMinus1; i++) {\n\t\tif (ptl->sub_ptl[i].profile_present_flag) {\n\t\t\tptl->sub_ptl[i].profile_space = gf_bs_read_int_log_idx2(bs, 2, \"sublayer_profile_space\", idx, i);\n\t\t\tptl->sub_ptl[i].tier_flag = gf_bs_read_int_log_idx2(bs, 1, \"sublayer_tier_flag\", idx, i);\n\t\t\tptl->sub_ptl[i].profile_idc = gf_bs_read_int_log_idx2(bs, 5, \"sublayer_profile_idc\", idx, i);\n\t\t\tptl->sub_ptl[i].profile_compatibility_flag = gf_bs_read_int_log_idx2(bs, 32, \"sublayer_profile_compatibility_flag\", idx, i);\n\t\t\t/*ptl->sub_ptl[i].progressive_source_flag =*/ gf_bs_read_int_log_idx2(bs, 1, \"sublayer_progressive_source_flag\", idx, i);\n\t\t\t/*ptl->sub_ptl[i].interlaced_source_flag =*/ gf_bs_read_int_log_idx2(bs, 1, \"sublayer_interlaced_source_flag\", idx, i);\n\t\t\t/*ptl->sub_ptl[i].non_packed_constraint_flag =*/ gf_bs_read_int_log_idx2(bs, 1, \"sublayer_non_packed_constraint_flag\", idx, i);\n\t\t\t/*ptl->sub_ptl[i].frame_only_constraint_flag =*/ gf_bs_read_int_log_idx2(bs, 1, \"sublayer_frame_only_constraint_flag\", idx, i);\n\t\t\t/*ptl->sub_ptl[i].reserved_44bits =*/ gf_bs_read_long_int(bs, 44);\n\t\t}\n\t\tif (ptl->sub_ptl[i].level_present_flag)\n\t\t\tptl->sub_ptl[i].level_idc = gf_bs_read_int_log_idx2(bs, 8, \"sublayer_level_idc\", idx, i);\n\t}\n}\n\nstatic u32 scalability_type_to_idx(HEVC_VPS *vps, u32 scalability_type)\n{\n\tu32 idx = 0, type;\n\tfor (type = 0; type < scalability_type; type++) {\n\t\tidx += (vps->scalability_mask[type] ? 1 : 0);\n\t}\n\treturn idx;\n}\n\n#define LHVC_VIEW_ORDER_INDEX  1\n#define LHVC_SCALABILITY_INDEX\t2\n\nstatic u32 lhvc_get_scalability_id(HEVC_VPS *vps, u32 layer_id_in_vps, u32 scalability_type)\n{\n\tu32 idx;\n\tif (!vps->scalability_mask[scalability_type]) return 0;\n\tidx = scalability_type_to_idx(vps, scalability_type);\n\treturn vps->dimension_id[layer_id_in_vps][idx];\n}\n\nstatic u32 lhvc_get_view_index(HEVC_VPS *vps, u32 id)\n{\n\treturn lhvc_get_scalability_id(vps, vps->layer_id_in_vps[id], LHVC_VIEW_ORDER_INDEX);\n}\n\nstatic u32 lhvc_get_num_views(HEVC_VPS *vps)\n{\n\tu32 numViews = 1, i;\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tu32 layer_id = vps->layer_id_in_nuh[i];\n\t\tif (i > 0 && (lhvc_get_view_index(vps, layer_id) != lhvc_get_scalability_id(vps, i - 1, LHVC_VIEW_ORDER_INDEX))) {\n\t\t\tnumViews++;\n\t\t}\n\t}\n\treturn numViews;\n}\n\nstatic void lhvc_parse_rep_format(HEVC_RepFormat *fmt, GF_BitStream *bs, u32 idx)\n{\n\tu8 chroma_bitdepth_present_flag;\n\tfmt->pic_width_luma_samples = gf_bs_read_int_log_idx(bs, 16, \"pic_width_luma_samples\", idx);\n\tfmt->pic_height_luma_samples = gf_bs_read_int_log_idx(bs, 16, \"pic_height_luma_samples\", idx);\n\tchroma_bitdepth_present_flag = gf_bs_read_int_log_idx(bs, 1, \"chroma_bitdepth_present_flag\", idx);\n\tif (chroma_bitdepth_present_flag) {\n\t\tfmt->chroma_format_idc = gf_bs_read_int_log_idx(bs, 2, \"chroma_format_idc\", idx);\n\n\t\tif (fmt->chroma_format_idc == 3)\n\t\t\tfmt->separate_colour_plane_flag = gf_bs_read_int_log_idx(bs, 1, \"separate_colour_plane_flag\", idx);\n\t\tfmt->bit_depth_luma = 8 + gf_bs_read_int_log_idx(bs, 4, \"bit_depth_luma_minus8\", idx);\n\t\tfmt->bit_depth_chroma = 8 + gf_bs_read_int_log_idx(bs, 4, \"bit_depth_chroma_minus8\", idx);\n\t}\n\tif (gf_bs_read_int_log_idx(bs, 1, \"conformance_window_vps_flag\", idx)) {\n\t\tgf_bs_read_ue_log_idx(bs, \"conf_win_vps_left_offset\", idx);\n\t\tgf_bs_read_ue_log_idx(bs, \"conf_win_vps_right_offset\", idx);\n\t\tgf_bs_read_ue_log_idx(bs, \"conf_win_vps_top_offset\", idx);\n\t\tgf_bs_read_ue_log_idx(bs, \"conf_win_vps_bottom_offset\", idx);\n\t}\n}\n\n\nstatic Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)\n{\n\tu8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;\n\tu32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;\n\tu8 dimension_id_len[16], dim_bit_offset[16];\n\tu8 /*avc_base_layer_flag, */NumLayerSets, /*default_one_target_output_layer_flag, */rep_format_idx_present_flag, ols_ids_to_ls_idx;\n\tu8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];\n\tu8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];\n\tu8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];\n\n\tu32 k, d, r, p, iNuhLId, jNuhLId;\n\tu8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];\n\tu8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 num_ref_layers[64];\n\t//\tu8 tree_partition_layer_id[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\t//\tu8 id_ref_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 id_direct_ref_layers[64][MAX_LHVC_LAYERS];\n\tu8 layer_id_in_list_flag[64];\n\tBool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\n\tvps->vps_extension_found = 1;\n\tif ((vps->max_layers > 1) && vps->base_layer_internal_flag)\n\t\thevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);\n\n\tsplitting_flag = gf_bs_read_int_log(bs, 1, \"splitting_flag\");\n\tnum_scalability_types = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tvps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, \"scalability_mask\", i);\n\t\tnum_scalability_types += vps->scalability_mask[i];\n\t}\n\tif (num_scalability_types >= 16) {\n\t\tnum_scalability_types = 16;\n\t}\n\tdimension_id_len[0] = 0;\n\tfor (i = 0; i < (num_scalability_types - splitting_flag); i++) {\n\t\tdimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, \"dimension_id_len_minus1\", i);\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < num_scalability_types; i++) {\n\t\t\tdim_bit_offset[i] = 0;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdim_bit_offset[i] += dimension_id_len[j];\n\t\t}\n\t\tdimension_id_len[num_scalability_types - 1] = 1 + (5 - dim_bit_offset[num_scalability_types - 1]);\n\t\tdim_bit_offset[num_scalability_types] = 6;\n\t}\n\n\tvps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, \"vps_nuh_layer_id_present_flag\");\n\tvps->layer_id_in_nuh[0] = 0;\n\tvps->layer_id_in_vps[0] = 0;\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tif (vps_nuh_layer_id_present_flag) {\n\t\t\tvps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, \"layer_id_in_nuh\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->layer_id_in_nuh[i] = i;\n\t\t}\n\t\tvps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;\n\n\t\tif (!splitting_flag) {\n\t\t\tfor (j = 0; j < num_scalability_types; j++) {\n\t\t\t\tvps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], \"dimension_id\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < vps->max_layers; i++)\n\t\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\t\tvps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);\n\t}\n\telse {\n\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\tvps->dimension_id[0][j] = 0;\n\t}\n\n\tview_id_len = gf_bs_read_int_log(bs, 4, \"view_id_len\");\n\tif (view_id_len > 0) {\n\t\tfor (i = 0; i < lhvc_get_num_views(vps); i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, view_id_len, \"view_id_val\", i);\n\t\t}\n\t}\n\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tvps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, \"direct_dependency_flag\", i);\n\t\t}\n\t}\n\n\t//we do the test on MAX_LHVC_LAYERS and break in the loop to avoid a wrong GCC 4.8 warning on array bounds\n\tfor (i = 0; i < MAX_LHVC_LAYERS; i++) {\n\t\tif (i >= vps->max_layers) break;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tdependency_flag[i][j] = vps->direct_dependency_flag[i][j];\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\tif (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])\n\t\t\t\t\tdependency_flag[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\td = r = p = 0;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tjNuhLId = vps->layer_id_in_nuh[j];\n\t\t\tif (vps->direct_dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_direct_ref_layers[iNuhLId][d] = jNuhLId;\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_ref_layers[iNuhLId][r] = jNuhLId;\n\t\t\t\tr++;\n\t\t\t}\n\n\t\t\tif (dependency_flag[j][i])\n\t\t\t\tid_pred_layers[iNuhLId][p++] = jNuhLId;\n\t\t}\n\t\tnum_direct_ref_layers[iNuhLId] = d;\n\t\t//\t\tnum_ref_layers[iNuhLId] = r;\n\t\tnum_pred_layers[iNuhLId] = p;\n\t}\n\n\tmemset(layer_id_in_list_flag, 0, 64 * sizeof(u8));\n\tk = 0; //num_indepentdent_layers\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\tif (!num_direct_ref_layers[iNuhLId]) {\n\t\t\tu32 h = 1;\n\t\t\t//tree_partition_layer_id[k][0] = iNuhLId;\n\t\t\tfor (j = 0; j < num_pred_layers[iNuhLId]; j++) {\n\t\t\t\tu32 predLId = id_pred_layers[iNuhLId][j];\n\t\t\t\tif (!layer_id_in_list_flag[predLId]) {\n\t\t\t\t\t//tree_partition_layer_id[k][h++] = predLId;\n\t\t\t\t\tlayer_id_in_list_flag[predLId] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_layers_in_tree_partition[k++] = h;\n\t\t}\n\t}\n\tnum_indepentdent_layers = k;\n\n\tnum_add_layer_set = 0;\n\tif (num_indepentdent_layers > 1)\n\t\tnum_add_layer_set = gf_bs_read_ue_log(bs, \"num_add_layer_set\");\n\n\tfor (i = 0; i < num_add_layer_set; i++)\n\t\tfor (j = 1; j < num_indepentdent_layers; j++) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))\n\t\t\t\tnb_bits++;\n\t\t\tgf_bs_read_int_log_idx2(bs, nb_bits, \"highest_layer_idx_plus1\", i, j);\n\t\t}\n\n\n\tif (gf_bs_read_int_log(bs, 1, \"vps_sub_layers_max_minus1_present_flag\")) {\n\t\tfor (i = 0; i < vps->max_layers; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, 3, \"sub_layers_vps_max_minus1\", i);\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"max_tid_ref_present_flag\")) {\n\t\tfor (i = 0; i < (vps->max_layers - 1); i++) {\n\t\t\tfor (j = i + 1; j < vps->max_layers; j++) {\n\t\t\t\tif (vps->direct_dependency_flag[j][i])\n\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"default_ref_layers_active_flag\");\n\n\tvps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, \"num_profile_tier_level\");\n\tif (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));\n\t\tvps->num_profile_tier_level = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {\n\t\tBool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_profile_present_flag\", i);\n\t\thevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);\n\t}\n\n\tNumLayerSets = vps->num_layer_sets + num_add_layer_set;\n\tnum_add_olss = 0;\n\n\tif (NumLayerSets > 1) {\n\t\tnum_add_olss = gf_bs_read_ue_log(bs, \"num_add_olss\");\n\t\tdefault_output_layer_idc = gf_bs_read_int_log(bs, 2, \"default_output_layer_idc\");\n\t\tdefault_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;\n\t}\n\tvps->num_output_layer_sets = num_add_olss + NumLayerSets;\n\n\tif (vps->num_output_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of output layer sets in VPS %d, max %d supported\\n\", vps->num_output_layer_sets, MAX_LHVC_LAYERS));\n\t\tvps->num_output_layer_sets = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tlayer_set_idx_for_ols_minus1[0] = 1;\n\tvps->output_layer_flag[0][0] = 1;\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tif ((NumLayerSets > 2) && (i >= NumLayerSets)) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (NumLayerSets - 1))\n\t\t\t\tnb_bits++;\n\t\t\tlayer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"layer_set_idx_for_ols_minus1\", i);\n\t\t}\n\t\telse\n\t\t\tlayer_set_idx_for_ols_minus1[i] = 0;\n\t\tols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;\n\n\t\tif ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\t\tvps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"output_layer_flag\", i, j);\n\t\t}\n\n\t\tif ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\t\tif ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tu32 curLayerID;\n\t\t\t\tvps->necessary_layers_flag[i][j] = GF_TRUE;\n\t\t\t\tcurLayerID = vps->LayerSetLayerIdList[i][j];\n\t\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\t\tu32 refLayerId = vps->LayerSetLayerIdList[i][k];\n\t\t\t\t\tif (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])\n\t\t\t\t\t\tvps->necessary_layers_flag[i][k] = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_necessary_layers[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (vps->necessary_layers_flag[i][j])\n\t\t\t\tvps->num_necessary_layers[i] += 1;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tif (vps->base_layer_internal_flag) {\n\t\t\t\tif (vps->max_layers > 1)\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 1;\n\t\t\t\telse\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnb_bits = 1;\n\t\twhile ((u32)(1 << nb_bits) < vps->num_profile_tier_level)\n\t\t\tnb_bits++;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\tif (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)\n\t\t\t\tvps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, \"profile_tier_level_idx\", i, j);\n\t\t\telse\n\t\t\t\tvps->profile_tier_level_idx[i][j] = 0;\n\n\n\t\tnb_output_layers_in_output_layer_set[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tnb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];\n\t\t\t}\n\t\t}\n\t\tif (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)\n\t\t\tvps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, \"alt_output_layer_flag\", i);\n\t}\n\n\tvps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, \"num_rep_formats_minus1\");\n\tif (vps->num_rep_formats > 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));\n\t\tvps->num_rep_formats = 0;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = 0; i < vps->num_rep_formats; i++) {\n\t\tlhvc_parse_rep_format(&vps->rep_formats[i], bs, i);\n\t}\n\tif (vps->num_rep_formats > 1)\n\t\trep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, \"rep_format_idx_present_flag\");\n\telse\n\t\trep_format_idx_present_flag = 0;\n\n\tvps->rep_format_idx[0] = 0;\n\tnb_bits = 1;\n\twhile ((u32)(1 << nb_bits) < vps->num_rep_formats)\n\t\tnb_bits++;\n\tfor (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {\n\t\tif (rep_format_idx_present_flag) {\n\t\t\tvps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"rep_format_idx\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;\n\t\t}\n\t}\n\t//TODO - we don't use the rest ...\n\n\treturn GF_TRUE;\n}\n\nstatic void sub_layer_hrd_parameters(GF_BitStream *bs, int subLayerId, u32 cpb_cnt, Bool sub_pic_hrd_params_present_flag, u32 idx1, u32 idx2)\n{\n\tu32 i;\n\tif (!gf_bs_available(bs)) return;\n\n\tfor (i = 0; i <= cpb_cnt; i++) {\n\t\tgf_bs_read_ue_log_idx3(bs, \"bit_rate_value_minus1\", idx1, idx2, i);\n\t\tgf_bs_read_ue_log_idx3(bs, \"cpb_size_value_minus1\", idx1, idx2, i);\n\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\tgf_bs_read_ue_log_idx3(bs, \"cpb_size_du_value_minus1\", idx1, idx2, i);\n\t\t\tgf_bs_read_ue_log_idx3(bs, \"bit_rate_du_value_minus1\", idx1, idx2, i);\n\t\t}\n\t\tgf_bs_read_int_log_idx3(bs, 1, \"cbr_flag\", idx1, idx2, i);\n\t}\n}\n\nstatic void hevc_parse_hrd_parameters(GF_BitStream *bs, Bool commonInfPresentFlag, int maxNumSubLayersMinus1, u32 idx)\n{\n\tint i;\n\tBool nal_hrd_parameters_present_flag = GF_FALSE;\n\tBool vcl_hrd_parameters_present_flag = GF_FALSE;\n\tBool sub_pic_hrd_params_present_flag = GF_FALSE;\n\n\tif (commonInfPresentFlag) {\n\t\tnal_hrd_parameters_present_flag = gf_bs_read_int_log_idx(bs, 1, \"nal_hrd_parameters_present_flag\", idx);\n\t\tvcl_hrd_parameters_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vcl_hrd_parameters_present_flag\", idx);\n\t\tif (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n\t\t\tsub_pic_hrd_params_present_flag = gf_bs_read_int_log_idx(bs, 1, \"sub_pic_hrd_params_present_flag\", idx);\n\t\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"tick_divisor_minus2\", idx);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 5, \"du_cpb_removal_delay_increment_length_minus1\", idx);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"sub_pic_cpb_params_in_pic_timing_sei_flag\", idx);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 5, \"dpb_output_delay_du_length_minus1\", idx);\n\t\t\t}\n\t\t\tgf_bs_read_int_log_idx(bs, 4, \"bit_rate_scale\", idx);\n\t\t\tgf_bs_read_int_log_idx(bs, 4, \"cpb_size_scale\", idx);\n\t\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, 4, \"cpb_size_du_scale\", idx);\n\t\t\t}\n\t\t\tgf_bs_read_int_log_idx(bs, 5, \"initial_cpb_removal_delay_length_minus1\", idx);\n\t\t\tgf_bs_read_int_log_idx(bs, 5, \"au_cpb_removal_delay_length_minus1\", idx);\n\t\t\tgf_bs_read_int_log_idx(bs, 5, \"dpb_output_delay_length_minus1\", idx);\n\t\t}\n\t}\n\tfor (i = 0; i <= maxNumSubLayersMinus1; i++) {\n\t\tBool fixed_pic_rate_general_flag_i = gf_bs_read_int_log_idx(bs, 1, \"fixed_pic_rate_general_flag\", idx);\n\t\tBool fixed_pic_rate_within_cvs_flag_i = GF_TRUE;\n\t\tBool low_delay_hrd_flag_i = GF_FALSE;\n\t\tu32 cpb_cnt_minus1_i = 0;\n\t\tif (!fixed_pic_rate_general_flag_i) {\n\t\t\tfixed_pic_rate_within_cvs_flag_i = gf_bs_read_int_log_idx(bs, 1, \"fixed_pic_rate_within_cvs_flag\", idx);\n\t\t}\n\t\tif (fixed_pic_rate_within_cvs_flag_i)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"elemental_duration_in_tc_minus1\", idx);\n\t\telse\n\t\t\tlow_delay_hrd_flag_i = gf_bs_read_int_log_idx(bs, 1, \"low_delay_hrd_flag\", idx);\n\t\tif (!low_delay_hrd_flag_i) {\n\t\t\tcpb_cnt_minus1_i = gf_bs_read_ue_log_idx(bs, \"cpb_cnt_minus1\", idx);\n\t\t}\n\t\tif (nal_hrd_parameters_present_flag) {\n\t\t\tsub_layer_hrd_parameters(bs, i, cpb_cnt_minus1_i, sub_pic_hrd_params_present_flag, idx, i);\n\t\t}\n\t\tif (vcl_hrd_parameters_present_flag) {\n\t\t\tsub_layer_hrd_parameters(bs, i, cpb_cnt_minus1_i, sub_pic_hrd_params_present_flag, idx, i);\n\t\t}\n\t}\n}\n\nstatic s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)\n{\n\tu8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;\n\tu32 i, j;\n\ts32 vps_id;\n\tHEVC_VPS *vps;\n\tu8 layer_id_included_flag[MAX_LHVC_LAYERS][64];\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\n\tif ((vps_id<0) || (vps_id >= 16)) return -1;\n\n\tvps = &hevc->vps[vps_id];\n\tvps->bit_pos_vps_extensions = -1;\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\n\tvps->base_layer_internal_flag = gf_bs_read_int_log(bs, 1, \"base_layer_internal_flag\");\n\tvps->base_layer_available_flag = gf_bs_read_int_log(bs, 1, \"base_layer_available_flag\");\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers_minus1\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\tvps->temporal_id_nesting = gf_bs_read_int_log(bs, 1, \"temporal_id_nesting\");\n\tgf_bs_read_int_log(bs, 16, \"vps_reserved_ffff_16bits\");\n\thevc_profile_tier_level(bs, 1, vps->max_sub_layers - 1, &vps->ptl, 0);\n\n\tvps_sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"vps_sub_layer_ordering_info_present_flag\");\n\tfor (i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_dec_pic_buffering_minus1\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_num_reorder_pics\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_latency_increase_plus1\", i);\n\t}\n\tvps->max_layer_id = gf_bs_read_int_log(bs, 6, \"max_layer_id\");\n\tif (vps->max_layer_id > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] VPS max layer ID %u but GPAC only supports %u\\n\", vps->max_layer_id, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->num_layer_sets = gf_bs_read_ue_log(bs, \"num_layer_sets_minus1\") + 1;\n\tif (vps->num_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of layer sets in VPS %d\\n\", vps->num_layer_sets));\n\t\treturn -1;\n\t}\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tfor (j = 0; j <= vps->max_layer_id; j++) {\n\t\t\tlayer_id_included_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"layer_id_included_flag\", i, j);\n\t\t}\n\t}\n\tvps->num_layers_in_id_list[0] = 1;\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tu32 n, m;\n\t\tn = 0;\n\t\tfor (m = 0; m <= vps->max_layer_id; m++) {\n\t\t\tif (layer_id_included_flag[i][m]) {\n\t\t\t\tvps->LayerSetLayerIdList[i][n++] = m;\n\t\t\t\tif (vps->LayerSetLayerIdListMax[i] < m)\n\t\t\t\t\tvps->LayerSetLayerIdListMax[i] = m;\n\t\t\t}\n\t\t}\n\t\tvps->num_layers_in_id_list[i] = n;\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"vps_timing_info_present_flag\")) {\n\t\tu32 vps_num_hrd_parameters;\n\t\tgf_bs_read_int_log(bs, 32, \"vps_num_units_in_tick\");\n\t\tgf_bs_read_int_log(bs, 32, \"vps_time_scale\");\n\t\tif (gf_bs_read_int_log(bs, 1, \"vps_poc_proportional_to_timing_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"vps_num_ticks_poc_diff_one_minus1\");\n\t\t}\n\t\tvps_num_hrd_parameters = gf_bs_read_ue_log(bs, \"vps_num_hrd_parameters\");\n\t\tfor (i = 0; i < vps_num_hrd_parameters; i++) {\n\t\t\tBool cprms_present_flag = GF_TRUE;\n\t\t\tgf_bs_read_ue_log_idx(bs, \"hrd_layer_set_idx\", i);\n\t\t\tif (i > 0)\n\t\t\t\tcprms_present_flag = gf_bs_read_int_log(bs, 1, \"cprms_present_flag\");\n\t\t\thevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1, i);\n\t\t}\n\t}\n\tif (stop_at_vps_ext) {\n\t\treturn vps_id;\n\t}\n\n\tvps_extension_flag = gf_bs_read_int_log(bs, 1, \"vps_extension_flag\");\n\tif (vps_extension_flag) {\n\t\tBool res;\n\t\tgf_bs_align(bs);\n\t\tres = hevc_parse_vps_extension(vps, bs);\n\t\tif (res != GF_TRUE) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Failed to parse VPS extensions\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tif (gf_bs_read_int_log(bs, 1, \"vps_extension2_flag\")) {\n#if 0\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t/*vps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\treturn vps_id;\n}\n\nGF_EXPORT\ns32 gf_hevc_read_vps_ex(u8 *data, u32 *size, HEVCState *hevc, Bool remove_extensions)\n{\n\tGF_BitStream *bs;\n\tchar *data_without_emulation_bytes = NULL;\n\tu32 data_without_emulation_bytes_size = 0;\n\ts32 vps_id = -1;\n\n\t/*still contains emulation bytes*/\n\tdata_without_emulation_bytes_size = remove_extensions ? gf_media_nalu_emulation_bytes_remove_count(data, (*size)) : 0;\n\tif (!data_without_emulation_bytes_size) {\n\t\tbs = gf_bs_new(data, (*size), GF_BITSTREAM_READ);\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\t//when removing VPS ext, we have to get the full buffer without emulation prevention bytes becuase we do a bit-by-bit copy of the vps\n\telse {\n\t\tdata_without_emulation_bytes = gf_malloc((*size) * sizeof(char));\n\t\tdata_without_emulation_bytes_size = gf_media_nalu_remove_emulation_bytes(data, data_without_emulation_bytes, (*size));\n\t\tbs = gf_bs_new(data_without_emulation_bytes, data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\t}\n\tif (!bs) goto exit;\n\n\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, NULL)) goto exit;\n\n\tvps_id = gf_hevc_read_vps_bs_internal(bs, hevc, remove_extensions);\n\tif (vps_id < 0) goto exit;\n\n\tif (remove_extensions) {\n\t\tu8 *new_vps;\n\t\tu32 new_vps_size, emulation_bytes;\n\t\tu32 bit_pos = gf_bs_get_bit_offset(bs);\n\t\tGF_BitStream *w_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_seek(bs, 0);\n\t\tgf_bs_write_u8(w_bs, gf_bs_read_u8(bs) );\n\t\tgf_bs_write_u8(w_bs, gf_bs_read_u8(bs) );\n\t\tgf_bs_write_u8(w_bs, gf_bs_read_u8(bs) );\n\t\tgf_bs_write_u8(w_bs, gf_bs_read_u8(bs) );\n\t\tgf_bs_write_u16(w_bs, gf_bs_read_u16(bs) );\n\t\tbit_pos -= 48;\n\t\twhile (bit_pos) {\n\t\t\tu32 v = gf_bs_read_int(bs, 1);\n\t\t\tgf_bs_write_int(w_bs, v, 1);\n\t\t\tbit_pos--;\n\t\t}\n\t\t/*vps extension flag*/\n\t\tgf_bs_write_int(w_bs, 0, 1);\n\t\tnew_vps = NULL;\n\t\tgf_bs_get_content(w_bs, &new_vps, &new_vps_size);\n\t\tgf_bs_del(w_bs);\n\n\t\temulation_bytes = gf_media_nalu_emulation_bytes_add_count(new_vps, new_vps_size);\n\t\tif (emulation_bytes + new_vps_size > *size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"Buffer too small to rewrite VPS - skipping rewrite\\n\"));\n\t\t}\n\t\telse {\n\t\t\t*size = gf_media_nalu_add_emulation_bytes(new_vps, data, new_vps_size);\n\t\t}\n\t\tif (new_vps)\n\t\t\tgf_free(new_vps);\n\t}\n\nexit:\n\tif (bs)\n\t\tgf_bs_del(bs);\n\tif (data_without_emulation_bytes) gf_free(data_without_emulation_bytes);\n\treturn vps_id;\n}\n\nGF_EXPORT\ns32 gf_hevc_read_vps(u8 *data, u32 size, HEVCState *hevc)\n{\n\treturn gf_hevc_read_vps_ex(data, &size, hevc, GF_FALSE);\n}\n\nGF_EXPORT\ns32 gf_hevc_read_vps_bs(GF_BitStream *bs, HEVCState *hevc)\n{\n\tif (!bs || !hevc) return -1;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, NULL)) return -1;\n\treturn gf_hevc_read_vps_bs_internal(bs, hevc, GF_FALSE);\n}\n\nstatic void hevc_scaling_list_data(GF_BitStream *bs)\n{\n\tu32 i, sizeId, matrixId;\n\tfor (sizeId = 0; sizeId < 4; sizeId++) {\n\t\tfor (matrixId = 0; matrixId < 6; matrixId += (sizeId == 3) ? 3 : 1) {\n\t\t\tu32 idx = sizeId*100 + 10*matrixId;\n\t\t\tu32 scaling_list_pred_mode_flag_sizeId_matrixId = gf_bs_read_int_log_idx(bs, 1, \"scaling_list_pred_mode_flag_sizeId_matrixId\", idx);\n\t\t\tif (!scaling_list_pred_mode_flag_sizeId_matrixId) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"scaling_list_pred_matrix_id_delta\", idx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//u32 nextCoef = 8;\n\t\t\t\tu32 coefNum = MIN(64, (1 << (4 + (sizeId << 1))));\n\t\t\t\tif (sizeId > 1) {\n\t\t\t\t\tgf_bs_read_se_log_idx(bs, \"scaling_list_dc_coef_minus8\", idx);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < coefNum; i++) {\n\t\t\t\t\tgf_bs_read_se_log_idx2(bs, \"scaling_list_delta_coef\", idx, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic const struct {\n\tu32 w, h;\n} hevc_sar[17] =\n{\n\t{ 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 },\n\t{ 16, 11 }, { 40, 33 }, { 24, 11 }, { 20, 11 },\n\t{ 32, 11 }, { 80, 33 }, { 18, 11 }, { 15, 11 },\n\t{ 64, 33 }, { 160,99 }, { 4,3}, { 3,2}, { 2,1}\n};\n\nstatic s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id = -1;\n\tu32 i, nb_CTUs, depth;\n\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"sps_ext_or_max_sub_layers_minus1\");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);\n\tif (!multiLayerExtSpsFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"temporal_id_nesting_flag\");\n\t\thevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);\n\t}\n\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif ((sps_id < 0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\n\tsps = &hevc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->ptl = ptl;\n\tvps = &hevc->vps[vps_id];\n\tsps->max_sub_layers_minus1 = 0;\n\tsps->sps_ext_or_max_sub_layers_minus1 = 0;\n\n\t/* default values */\n\tsps->colour_primaries = 2;\n\tsps->transfer_characteristic = 2;\n\tsps->matrix_coeffs = 2;\n\n\t//sps_rep_format_idx = 0;\n\tif (multiLayerExtSpsFlag) {\n\t\tsps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, \"update_rep_format_flag\");\n\t\tif (sps->update_rep_format_flag) {\n\t\t\tsps->rep_format_idx = gf_bs_read_int_log(bs, 8, \"rep_format_idx\");\n\t\t}\n\t\telse {\n\t\t\tsps->rep_format_idx = vps->rep_format_idx[layer_id];\n\t\t}\n\t\tsps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;\n\t\tsps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;\n\t\tsps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;\n\t\tsps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;\n\t\tsps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;\n\t\tsps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;\n\n\t\t//TODO this is crude ...\n\t\tsps->ptl = vps->ext_ptl[0];\n\t}\n\telse {\n\t\tsps->chroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tif (sps->chroma_format_idc == 3)\n\t\t\tsps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\t\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\t\tif ((sps->cw_flag = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\"))) {\n\t\t\tu32 SubWidthC, SubHeightC;\n\n\t\t\tif (sps->chroma_format_idc == 1) {\n\t\t\t\tSubWidthC = SubHeightC = 2;\n\t\t\t}\n\t\t\telse if (sps->chroma_format_idc == 2) {\n\t\t\t\tSubWidthC = 2;\n\t\t\t\tSubHeightC = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSubWidthC = SubHeightC = 1;\n\t\t\t}\n\n\t\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\n\t\t\tsps->width -= SubWidthC * (sps->cw_left + sps->cw_right);\n\t\t\tsps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);\n\t\t}\n\t\tsps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_luma_minus8\");\n\t\tsps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_chroma_minus8\");\n\t}\n\n\tsps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, \"log2_max_pic_order_cnt_lsb_minus4\");\n\n\tif (!multiLayerExtSpsFlag) {\n\t\tsps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"sub_layer_ordering_info_present_flag\");\n\t\tfor (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"max_dec_pic_buffering\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"max_latency_increase\", i);\n\t\t}\n\t}\n\n\tsps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, \"log2_min_luma_coding_block_size_minus3\");\n\tsps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_luma_coding_block_size\");\n\tsps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\tsps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\n\tsps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, \"log2_min_transform_block_size_minus2\");\n\tsps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, \"log2_max_transform_block_size\");\n\n\tdepth = 0;\n\tsps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_inter\");\n\tsps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_intra\");\n\twhile ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))\n\t{\n\t\tdepth++;\n\t}\n\tsps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;\n\n\tnb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);\n\tsps->bitsSliceSegmentAddress = 0;\n\twhile (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {\n\t\tsps->bitsSliceSegmentAddress++;\n\t}\n\n\tsps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_enable_flag\");\n\tif (sps->scaling_list_enable_flag) {\n\t\tsps->infer_scaling_list_flag = 0;\n\t\tsps->scaling_list_ref_layer_id = 0;\n\t\tif (multiLayerExtSpsFlag) {\n\t\t\tsps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, \"infer_scaling_list_flag\");\n\t\t}\n\t\tif (sps->infer_scaling_list_flag) {\n\t\t\tsps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, \"scaling_list_ref_layer_id\");\n\t\t}\n\t\telse {\n\t\t\tsps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_data_present_flag\");\n\t\t\tif (sps->scaling_list_data_present_flag) {\n\t\t\t\thevc_scaling_list_data(bs);\n\t\t\t}\n\t\t}\n\t}\n\tsps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, \"asymmetric_motion_partitions_enabled_flag\");\n\tsps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, \"sample_adaptive_offset_enabled_flag\");\n\tif ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, \"pcm_enabled_flag\")) ) {\n\t\tsps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_luma_minus1\");\n\t\tsps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_chroma_minus1\");\n\t\tsps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, \"log2_min_pcm_luma_coding_block_size_minus3\");\n\t\tsps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_pcm_luma_coding_block_size\");\n\t\tsps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, \"pcm_loop_filter_disable_flag\");\n\t}\n\tsps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, \"num_short_term_ref_pic_sets\");\n\tif (sps->num_short_term_ref_pic_sets > 64) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid number of short term reference picture sets %d\\n\", sps->num_short_term_ref_pic_sets));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {\n\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);\n\t\t/*cannot parse short_term_ref_pic_set, skip VUI parsing*/\n\t\tif (!ret) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid short_term_ref_pic_set\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, \"long_term_ref_pics_present_flag\");\n\tif (sps->long_term_ref_pics_present_flag) {\n\t\tsps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, \"num_long_term_ref_pic_sps\");\n\t\tfor (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"lt_ref_pic_poc_lsb_sps\", i);\n\t\t\tgf_bs_read_int_log_idx(bs, 1, \"used_by_curr_pic_lt_sps_flag\", i);\n\t\t}\n\t}\n\tsps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, \"temporal_mvp_enable_flag\");\n\tsps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, \"strong_intra_smoothing_enable_flag\");\n\n\tif (vui_flag_pos)\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\n\tif ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\")) ) {\n\t\tsps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->aspect_ratio_info_present_flag) {\n\t\t\tsps->sar_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (sps->sar_idc == 255) {\n\t\t\t\tsps->sar_width = gf_bs_read_int_log(bs, 16, \"aspect_ratio_width\");\n\t\t\t\tsps->sar_height = gf_bs_read_int_log(bs, 16, \"aspect_ratio_height\");\n\t\t\t}\n\t\t\telse if (sps->sar_idc < 17) {\n\t\t\t\tsps->sar_width = hevc_sar[sps->sar_idc].w;\n\t\t\t\tsps->sar_height = hevc_sar[sps->sar_idc].h;\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, \"overscan_info_present\")))\n\t\t\tsps->overscan_appropriate = gf_bs_read_int_log(bs, 1, \"overscan_appropriate\");\n\n\t\tsps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->video_signal_type_present_flag) {\n\t\t\tsps->video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tif ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\"))) {\n\t\t\t\tsps->colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->transfer_characteristic = gf_bs_read_int_log(bs, 8, \"transfer_characteristic\");\n\t\t\t\tsps->matrix_coeffs = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, \"chroma_loc_info_present_flag\"))) {\n\t\t\tsps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_top_field\");\n\t\t\tsps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_bottom_field\");\n\t\t}\n\n\t\tsps->neutra_chroma_indication_flag = gf_bs_read_int_log(bs, 1, \"neutra_chroma_indication_flag\");\n\t\tsps->field_seq_flag = gf_bs_read_int_log(bs, 1, \"field_seq_flag\");\n\t\tsps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, \"frame_field_info_present_flag\");\n\n\t\tif ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, \"default_display_window_flag\"))) {\n\t\t\tsps->left_offset = gf_bs_read_ue_log(bs, \"display_window_left_offset\");\n\t\t\tsps->right_offset = gf_bs_read_ue_log(bs, \"display_window_right_offset\");\n\t\t\tsps->top_offset = gf_bs_read_ue_log(bs, \"display_window_top_offset\");\n\t\t\tsps->bottom_offset = gf_bs_read_ue_log(bs, \"display_window_bottom_offset\");\n\t\t}\n\n\t\tsps->has_timing_info = gf_bs_read_int_log(bs, 1, \"has_timing_info\");\n\t\tif (sps->has_timing_info) {\n\t\t\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, \"poc_proportional_to_timing_flag\");\n\t\t\tif (sps->poc_proportional_to_timing_flag)\n\t\t\t\tsps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, \"num_ticks_poc_diff_one_minus1\");\n\t\t\tif ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"hrd_parameters_present_flag\"))) {\n\t\t\t\t//\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[HEVC] HRD param parsing not implemented\\n\"));\n\t\t\t\treturn sps_id;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"bitstream_restriction_flag\")) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"tiles_fixed_structure_flag\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"motion_vectors_over_pic_boundaries_flag\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"restricted_ref_pic_lists_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"min_spatial_segmentation_idc\");\n\t\t\tgf_bs_read_ue_log(bs, \"max_bytes_per_pic_denom\");\n\t\t\tgf_bs_read_ue_log(bs, \"max_bits_per_min_cu_denom\");\n\t\t\tgf_bs_read_ue_log(bs, \"log2_max_mv_length_horizontal\");\n\t\t\tgf_bs_read_ue_log(bs, \"log2_max_mv_length_vertical\");\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"sps_extension_flag\")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*sps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_hevc_read_sps_ex(char *data, u32 size, HEVCState *hevc, u32 *vui_flag_pos)\n{\n\tGF_BitStream *bs;\n\ts32 sps_id = -1;\n\tu8 layer_id;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tif (!bs) goto exit;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, &layer_id)) goto exit;\n\tsps_id = gf_hevc_read_sps_bs_internal(bs, hevc, layer_id, vui_flag_pos);\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_hevc_read_sps(u8 *data, u32 size, HEVCState *hevc)\n{\n\treturn gf_hevc_read_sps_ex(data, size, hevc, NULL);\n}\n\nGF_EXPORT\ns32 gf_hevc_read_sps_bs(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu8 layer_id;\n\tif (!bs || !hevc) return -1;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, &layer_id)) return -1;\n\treturn gf_hevc_read_sps_bs_internal(bs, hevc, layer_id, NULL);\n}\n\n\nstatic s32 gf_hevc_read_pps_bs_internal(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tHEVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &hevc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif (((s32)pps->sps_id<0) || (pps->sps_id >= 16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\thevc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->dependent_slice_segments_enabled_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segments_enabled_flag\");\n\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->num_extra_slice_header_bits = gf_bs_read_int_log(bs, 3, \"num_extra_slice_header_bits\");\n\tpps->sign_data_hiding_flag = gf_bs_read_int_log(bs, 1, \"sign_data_hiding_flag\");\n\tpps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, \"cabac_init_present_flag\");\n\tpps->num_ref_idx_l0_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active\");\n\tpps->num_ref_idx_l1_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active\");\n\tpps->pic_init_qp_minus26 = gf_bs_read_se_log(bs, \"pic_init_qp_minus26\");\n\tpps->constrained_intra_pred_flag = gf_bs_read_int_log(bs, 1, \"constrained_intra_pred_flag\");\n\tpps->transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"transform_skip_enabled_flag\");\n\tif ((pps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, \"cu_qp_delta_enabled_flag\")))\n\t\tpps->diff_cu_qp_delta_depth = gf_bs_read_ue_log(bs, \"diff_cu_qp_delta_depth\");\n\n\tpps->pic_cb_qp_offset = gf_bs_read_se_log(bs, \"pic_cb_qp_offset\");\n\tpps->pic_cr_qp_offset = gf_bs_read_se_log(bs, \"pic_cr_qp_offset\");\n\tpps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, \"slice_chroma_qp_offsets_present_flag\");\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tpps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, \"weighted_bipred_flag\");\n\tpps->transquant_bypass_enable_flag = gf_bs_read_int_log(bs, 1, \"transquant_bypass_enable_flag\");\n\tpps->tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"tiles_enabled_flag\");\n\tpps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tif (pps->tiles_enabled_flag) {\n\t\tpps->num_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_tile_columns_minus1\");\n\t\tpps->num_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_tile_rows_minus1\");\n\t\tpps->uniform_spacing_flag = gf_bs_read_int_log(bs, 1, \"uniform_spacing_flag\");\n\t\tif (!pps->uniform_spacing_flag) {\n\t\t\tfor (i = 0; i < pps->num_tile_columns - 1; i++) {\n\t\t\t\tpps->column_width[i] = 1 + gf_bs_read_ue_log_idx(bs, \"column_width_minus1\", i);\n\t\t\t}\n\t\t\tfor (i = 0; i < pps->num_tile_rows - 1; i++) {\n\t\t\t\tpps->row_height[i] = 1 + gf_bs_read_ue_log_idx(bs, \"row_height_minus1\", i);\n\t\t\t}\n\t\t}\n\t\tpps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_tiles_enabled_flag\");\n\t}\n\tpps->loop_filter_across_slices_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_slices_enabled_flag\");\n\tif ((pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\"))) {\n\t\tpps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_enabled_flag\");\n\t\tif (! (pps->pic_disable_deblocking_filter_flag = gf_bs_read_int_log(bs, 1, \"pic_disable_deblocking_filter_flag\"))) {\n\t\t\tpps->beta_offset_div2 = gf_bs_read_se_log(bs, \"beta_offset_div2\");\n\t\t\tpps->tc_offset_div2 = gf_bs_read_se_log(bs, \"tc_offset_div2\");\n\t\t}\n\t}\n\tif ((pps->pic_scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"pic_scaling_list_data_present_flag\"))) {\n\t\thevc_scaling_list_data(bs);\n\t}\n\tpps->lists_modification_present_flag = gf_bs_read_int_log(bs, 1, \"lists_modification_present_flag\");\n\tpps->log2_parallel_merge_level_minus2 = gf_bs_read_ue_log(bs, \"log2_parallel_merge_level_minus2\");\n\tpps->slice_segment_header_extension_present_flag = gf_bs_read_int_log(bs, 1, \"slice_segment_header_extension_present_flag\");\n\tif (gf_bs_read_int_log(bs, 1, \"pps_extension_flag\")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*pps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\treturn pps_id;\n}\n\n\nGF_EXPORT\ns32 gf_hevc_read_pps(u8 *data, u32 size, HEVCState *hevc)\n{\n\tGF_BitStream *bs;\n\ts32 pps_id = -1;\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tif (!bs) goto exit;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, NULL)) goto exit;\n\n\tpps_id = gf_hevc_read_pps_bs_internal(bs, hevc);\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\treturn pps_id;\n}\n\nGF_EXPORT\ns32 gf_hevc_read_pps_bs(GF_BitStream *bs, HEVCState *hevc)\n{\n\tif (!bs || !hevc) return -1;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, NULL)) return -1;\n\treturn gf_hevc_read_pps_bs_internal(bs, hevc);\n}\n\nGF_EXPORT\ns32 gf_hevc_parse_nalu_bs(GF_BitStream *bs, HEVCState *hevc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tBool is_slice = GF_FALSE;\n\ts32 ret = -1;\n\tHEVCSliceInfo n_state;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tmemcpy(&n_state, &hevc->s_info, sizeof(HEVCSliceInfo));\n\tif (!hevc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) return -1;\n\n\tn_state.nal_unit_type = *nal_unit_type;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\tcase GF_HEVC_NALU_END_OF_SEQ:\n\tcase GF_HEVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\t\t/*slice_segment_layer_rbsp*/\n\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\tcase GF_HEVC_NALU_SLICE_TRAIL_R:\n\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\tcase GF_HEVC_NALU_SLICE_RADL_R:\n\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\tcase GF_HEVC_NALU_SLICE_RASL_R:\n\t\tis_slice = GF_TRUE;\n\t\t/* slice - read the info and compare.*/\n\t\tret = hevc_parse_slice_segment(bs, hevc, &n_state);\n\t\tif (ret < 0) return ret;\n\n\t\thevc_compute_poc(&n_state);\n\n\t\tret = 0;\n\n\t\tif (hevc->s_info.poc != n_state.poc) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (n_state.first_slice_segment_in_pic_flag) {\n\t\t\tif (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1))) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\thevc->last_parsed_sps_id = gf_hevc_read_sps_bs_internal(bs, hevc, *layer_id, NULL);\n\t\tret = (hevc->last_parsed_sps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\thevc->last_parsed_pps_id = gf_hevc_read_pps_bs_internal(bs, hevc);\n\t\tret = (hevc->last_parsed_pps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tcase GF_HEVC_NALU_VID_PARAM:\n\t\thevc->last_parsed_vps_id = gf_hevc_read_vps_bs_internal(bs, hevc, GF_FALSE);\n\t\tret = (hevc->last_parsed_vps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif ((ret>0) && hevc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = hevc->s_info.frame_num_offset;\n\t\tn_state.frame_num_prev = hevc->s_info.frame_num;\n\n\t\tn_state.poc_lsb_prev = hevc->s_info.poc_lsb;\n\t\tn_state.poc_msb_prev = hevc->s_info.poc_msb;\n\t\tif (is_slice)\n\t\t\tn_state.prev_layer_id_plus1 = *layer_id + 1;\n\t}\n\tif (is_slice) hevc_compute_poc(&n_state);\n\tmemcpy(&hevc->s_info, &n_state, sizeof(HEVCSliceInfo));\n\n\treturn ret;\n}\n\nGF_EXPORT\ns32 gf_hevc_parse_nalu(u8 *data, u32 size, HEVCState *hevc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tGF_BitStream *bs = NULL;\n\ts32 ret = -1;\n\n\tif (!hevc) {\n\t\tif (nal_unit_type) (*nal_unit_type) = (data[0] & 0x7E) >> 1;\n\t\tif (layer_id) {\n\t\t\tu8 id = data[0] & 1;\n\t\t\tid <<= 5;\n\t\t\tid |= (data[1] >> 3) & 0x1F;\n\t\t\t(*layer_id) = id;\n\t\t}\n\t\tif (temporal_id) (*temporal_id) = (data[1] & 0x7);\n\t\treturn -1;\n\t}\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tif (!bs) return -1;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tret = gf_hevc_parse_nalu_bs(bs, hevc, nal_unit_type, temporal_id, layer_id);\n\n\tgf_bs_del(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nGF_Err gf_hevc_change_vui(GF_HEVCConfig *hvcc, GF_VUIInfo *vui_info)\n{\n\tGF_BitStream *orig, *mod;\n\tHEVCState hevc;\n\tu32 i, bit_offset, flag;\n\ts32 idx;\n\tGF_NALUFFParamArray *spss;\n\tGF_NALUFFParam *slc;\n\torig = NULL;\n\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\thevc.sps_active_idx = -1;\n\n\ti = 0;\n\tspss = NULL;\n\twhile ((spss = (GF_NALUFFParamArray *)gf_list_enum(hvcc->param_array, &i))) {\n\t\tif (spss->type == GF_HEVC_NALU_SEQ_PARAM)\n\t\t\tbreak;\n\t\tspss = NULL;\n\t}\n\tif (!spss) return GF_NON_COMPLIANT_BITSTREAM;\n\n\ti = 0;\n\twhile ((slc = (GF_NALUFFParam *)gf_list_enum(spss->nalus, &i))) {\n\t\tu8 *no_emulation_buf;\n\t\tu32 no_emulation_buf_size, emulation_bytes;\n\n\t\t/*SPS may still contains emulation bytes*/\n\t\tno_emulation_buf = gf_malloc((slc->size) * sizeof(char));\n\t\tno_emulation_buf_size = gf_media_nalu_remove_emulation_bytes(slc->data, no_emulation_buf, slc->size);\n\n\t\tidx = gf_hevc_read_sps_ex(no_emulation_buf, no_emulation_buf_size, &hevc, &bit_offset);\n\t\tif (idx < 0) {\n\t\t\tif (orig)\n\t\t\t\tgf_bs_del(orig);\n\t\t\tgf_free(no_emulation_buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\torig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);\n\t\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t/*copy over till vui flag*/\n\t\tassert(bit_offset >= 0);\n\t\twhile (bit_offset) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t\tbit_offset--;\n\t\t}\n\n\t\tavc_hevc_rewrite_vui(vui_info, orig, mod);\n\n\t\t/*finally copy over remaining*/\n\t\twhile (gf_bs_bits_available(orig)) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t}\n\t\tgf_bs_del(orig);\n\t\torig = NULL;\n\t\tgf_free(no_emulation_buf);\n\n\t\t/*set anti-emulation*/\n\t\tgf_bs_get_content(mod, &no_emulation_buf, &no_emulation_buf_size);\n\t\temulation_bytes = gf_media_nalu_emulation_bytes_add_count(no_emulation_buf, no_emulation_buf_size);\n\t\tif (no_emulation_buf_size + emulation_bytes > slc->size)\n\t\t\tslc->data = (char*)gf_realloc(slc->data, no_emulation_buf_size + emulation_bytes);\n\n\t\tslc->size = gf_media_nalu_add_emulation_bytes(no_emulation_buf, slc->data, no_emulation_buf_size);\n\n\t\tgf_bs_del(mod);\n\t\tgf_free(no_emulation_buf);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_hevc_change_par(GF_HEVCConfig *hvcc, s32 ar_n, s32 ar_d)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = ar_n;\n\tvuii.ar_den = ar_d;\n\tvuii.fullrange = -1;\n\tvuii.video_format = -1;\n\tvuii.color_prim = -1;\n\tvuii.color_tfc = -1;\n\tvuii.color_matrix = -1;\n\treturn gf_hevc_change_vui(hvcc, &vuii);\n}\n\nGF_EXPORT\nGF_Err gf_hevc_change_color(GF_HEVCConfig *hvcc, s32 fullrange, s32 vidformat, s32 colorprim, s32 transfer, s32 colmatrix)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = -1;\n\tvuii.ar_den = -1;\n\tvuii.fullrange = fullrange;\n\tvuii.video_format = vidformat;\n\tvuii.color_prim = colorprim;\n\tvuii.color_tfc = transfer;\n\tvuii.color_matrix = colmatrix;\n\treturn gf_hevc_change_vui(hvcc, &vuii);\n}\n\n\nGF_EXPORT\nGF_Err gf_hevc_get_sps_info_with_state(HEVCState *hevc, u8 *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\ts32 idx;\n\tidx = gf_hevc_read_sps(sps_data, sps_size, hevc);\n\tif (idx < 0) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (sps_id) *sps_id = idx;\n\n\tif (width) *width = hevc->sps[idx].width;\n\tif (height) *height = hevc->sps[idx].height;\n\tif (par_n) *par_n = hevc->sps[idx].aspect_ratio_info_present_flag ? hevc->sps[idx].sar_width : (u32)-1;\n\tif (par_d) *par_d = hevc->sps[idx].aspect_ratio_info_present_flag ? hevc->sps[idx].sar_height : (u32)-1;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_hevc_get_sps_info(u8 *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\tHEVCState hevc;\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\thevc.sps_active_idx = -1;\n\treturn gf_hevc_get_sps_info_with_state(&hevc, sps_data, sps_size, sps_id, width, height, par_n, par_d);\n}\n\n\n#endif //GPAC_DISABLE_HEVC\n\nstatic u32 AC3_FindSyncCode(u8 *buf, u32 buflen)\n{\n\tu32 end = buflen - 6;\n\tu32 offset = 0;\n\twhile (offset <= end) {\n\t\tif (buf[offset] == 0x0b && buf[offset + 1] == 0x77) {\n\t\t\treturn offset;\n\t\t}\n\t\toffset++;\n\t}\n\treturn buflen;\n}\n\n\nstatic Bool AC3_FindSyncCodeBS(GF_BitStream *bs)\n{\n\tu8 b1;\n\tu64 pos = gf_bs_get_position(bs);\n\tu64 end = gf_bs_get_size(bs);\n\n\tpos += 1;\n\tb1 = gf_bs_read_u8(bs);\n\twhile (pos + 1 <= end) {\n\t\tu8 b2 = gf_bs_read_u8(bs);\n\t\tif ((b1 == 0x0b) && (b2 == 0x77)) {\n\t\t\tgf_bs_seek(bs, pos - 1);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tpos++;\n\t\tb1 = b2;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic const u32 ac3_sizecod_to_bitrate[] = {\n\t32000, 40000, 48000, 56000, 64000, 80000, 96000,\n\t112000, 128000, 160000, 192000, 224000, 256000,\n\t320000, 384000, 448000, 512000, 576000, 640000\n};\n\nstatic const u32 ac3_sizecod2_to_framesize[] = {\n\t96, 120, 144, 168, 192, 240, 288, 336, 384, 480, 576, 672,\n\t768, 960, 1152, 1344, 1536, 1728, 1920\n};\n\nstatic const u32 ac3_sizecod1_to_framesize[] = {\n\t69, 87, 104, 121, 139, 174, 208, 243, 278, 348, 417, 487,\n\t557, 696, 835, 975, 1114, 1253, 1393\n};\nstatic const u32 ac3_sizecod0_to_framesize[] = {\n\t64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 448,\n\t512, 640, 768, 896, 1024, 1152, 1280\n};\n\nstatic const u32 ac3_mod_to_chans[] = {\n\t2, 1, 2, 3, 3, 4, 4, 5\n};\n\nGF_EXPORT\nu32 gf_ac3_get_channels(u32 acmod)\n{\n\tu32 nb_ch;\n\tnb_ch = ac3_mod_to_chans[acmod];\n\treturn nb_ch;\n}\n\nGF_EXPORT\nu32 gf_ac3_get_bitrate(u32 brcode)\n{\n\treturn ac3_sizecod_to_bitrate[brcode];\n}\n\nBool gf_ac3_parser(u8 *buf, u32 buflen, u32 *pos, GF_AC3Config *hdr, Bool full_parse)\n{\n\tGF_BitStream *bs;\n\tBool ret;\n\n\tif (buflen < 6) return GF_FALSE;\n\t(*pos) = AC3_FindSyncCode(buf, buflen);\n\tif (*pos >= buflen) return GF_FALSE;\n\n\tbs = gf_bs_new((const char*)(buf + *pos), buflen, GF_BITSTREAM_READ);\n\tret = gf_ac3_parser_bs(bs, hdr, full_parse);\n\tgf_bs_del(bs);\n\n\treturn ret;\n}\n\nGF_EXPORT\nBool gf_ac3_parser_bs(GF_BitStream *bs, GF_AC3Config *hdr, Bool full_parse)\n{\n\tu32 fscod, frmsizecod, bsid, ac3_mod, freq, framesize, bsmod, syncword;\n\tu64 pos;\n\tif (!hdr || (gf_bs_available(bs) < 6)) return GF_FALSE;\n\tif (!AC3_FindSyncCodeBS(bs)) return GF_FALSE;\n\n\tpos = gf_bs_get_position(bs);\n\n\tsyncword = gf_bs_read_u16(bs);\n\tif (syncword != 0x0B77) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AC3] Wrong sync word detected (0x%X - expecting 0x0B77).\\n\", syncword));\n\t\treturn GF_FALSE;\n\t}\n\tgf_bs_read_int_log(bs, 16, \"crc1\");\n\tfscod = gf_bs_read_int_log(bs, 2, \"fscod\");\n\tfrmsizecod = gf_bs_read_int_log(bs, 6, \"frmsizecod\");\n\tbsid = gf_bs_read_int_log(bs, 5, \"bsid\");\n\tbsmod = gf_bs_read_int_log(bs, 3, \"bsmod\");\n\tac3_mod = gf_bs_read_int_log(bs, 3, \"ac3_mod\");\n\tif (frmsizecod >= 2 * sizeof(ac3_sizecod_to_bitrate) / sizeof(u32))\n\t\treturn GF_FALSE;\n\n\thdr->bitrate = ac3_sizecod_to_bitrate[frmsizecod / 2];\n\tif (bsid > 8) hdr->bitrate = hdr->bitrate >> (bsid - 8);\n\n\tswitch (fscod) {\n\tcase 0:\n\t\tif (frmsizecod >=  2 * sizeof(ac3_sizecod0_to_framesize) / sizeof(u32))\n\t\t\treturn GF_FALSE;\n\t\tfreq = 48000;\n\t\tframesize = ac3_sizecod0_to_framesize[frmsizecod / 2] * 2;\n\t\tbreak;\n\tcase 1:\n\t\tif (frmsizecod >= 2 * sizeof(ac3_sizecod1_to_framesize) / sizeof(u32))\n\t\t\treturn GF_FALSE;\n\t\tfreq = 44100;\n\t\tframesize = (ac3_sizecod1_to_framesize[frmsizecod / 2] + (frmsizecod & 0x1)) * 2;\n\t\tbreak;\n\tcase 2:\n\t\tif (frmsizecod >= 2 * sizeof(ac3_sizecod2_to_framesize) / sizeof(u32))\n\t\t\treturn GF_FALSE;\n\t\tfreq = 32000;\n\t\tframesize = ac3_sizecod2_to_framesize[frmsizecod / 2] * 2;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\thdr->sample_rate = freq;\n\thdr->framesize = framesize;\n\n\tif (full_parse) {\n\t\thdr->streams[0].bsid = bsid;\n\t\thdr->streams[0].bsmod = bsmod;\n\t\thdr->streams[0].acmod = ac3_mod;\n\t\thdr->streams[0].lfon = 0;\n\t\thdr->streams[0].fscod = fscod;\n\t\thdr->brcode = frmsizecod / 2;\n\t}\n\tif (ac3_mod >= 2 * sizeof(ac3_mod_to_chans) / sizeof(u32))\n\t\treturn GF_FALSE;\n\n\thdr->channels = ac3_mod_to_chans[ac3_mod];\n\tif ((ac3_mod & 0x1) && (ac3_mod != 1)) gf_bs_read_int_log(bs, 2, \"cmixlev\");\n\tif (ac3_mod & 0x4) gf_bs_read_int_log(bs, 2, \"surmixlev\");\n\tif (ac3_mod == 0x2) gf_bs_read_int_log(bs, 2, \"dsurmod\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"lfeon\")) {\n\t\thdr->channels += 1;\n\t\thdr->streams[0].lfon = 1;\n\t}\n\n\tgf_bs_seek(bs, pos);\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_eac3_parser_bs(GF_BitStream *bs, GF_AC3Config *hdr, Bool full_parse)\n{\n\tu32 fscod, bsid, ac3_mod, freq, framesize, syncword, substreamid, lfon, channels, numblkscod, strmtyp, frmsiz;\n\tu64 pos;\n\tu16 chanmap;\n\tstatic u32 numblks[4] = {1, 2, 3, 6};\n\n\tif (!hdr || (gf_bs_available(bs) < 6))\n\t\treturn GF_FALSE;\n\tif (!AC3_FindSyncCodeBS(bs))\n\t\treturn GF_FALSE;\n\n\tpos = gf_bs_get_position(bs);\n\tframesize = 0;\n\tnumblkscod = 0;\n\tmemset(hdr, 0, sizeof(GF_AC3Config));\n\nblock:\n\tsyncword = gf_bs_read_u16(bs);\n\tif (syncword != 0x0B77) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[E-AC3] Wrong sync word detected (0x%X - expecting 0x0B77).\\n\", syncword));\n\t\treturn GF_FALSE;\n\t}\n\n\tstrmtyp = gf_bs_read_int_log(bs, 2, \"strmtyp\");\n\tsubstreamid = gf_bs_read_int_log(bs, 3, \"substreamid\");\n\t//next main (independent) AU, done with this frame\n\tif ((strmtyp!=0x1) && ((hdr->substreams >> substreamid) & 0x1)) {\n\t\thdr->framesize = framesize;\n\t\tgf_bs_seek(bs, pos);\n\t\treturn GF_TRUE;\n\t}\n\n\tfrmsiz = gf_bs_read_int_log(bs, 11, \"frmsiz\");\n\tframesize += 2 * (1 + frmsiz);\n\tfscod = gf_bs_read_int_log(bs, 2, \"fscod\");\n\tif (fscod == 0x3) {\n\t\tfscod = gf_bs_read_int_log(bs, 2, \"fscod2\");\n\t\tnumblkscod += 6;\n\t}\n\telse {\n\t\tnumblkscod += gf_bs_read_int_log(bs, 2, \"numblkscod\");\n\t}\n\tassert(numblkscod <= 9);\n\n\n\tif ((hdr->substreams >> substreamid) & 0x1) {\n\t\t//we still have sync frames following\n\t\tif (substreamid) {\n\t\t\tif (gf_bs_seek(bs, pos + framesize) != GF_OK) {\n\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t\tif ((gf_bs_available(bs) < 6) || !AC3_FindSyncCodeBS(bs)) {\n\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t\tgoto block;\n\t\t}\n\t}\n\n\thdr->substreams |= (1 << substreamid);\n\n\tswitch (fscod) {\n\tcase 0:\n\t\tfreq = 48000;\n\t\tbreak;\n\tcase 1:\n\t\tfreq = 44100;\n\t\tbreak;\n\tcase 2:\n\t\tfreq = 32000;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\n\tac3_mod = gf_bs_read_int_log(bs, 3, \"ac3_mod\");\n\tlfon = gf_bs_read_int_log(bs, 1, \"lfon\");\n\tbsid = gf_bs_read_int_log(bs, 5, \"bsid\");\n\tif (!substreamid && (bsid != 16/*E-AC3*/))\n\t\treturn GF_FALSE;\n\tgf_bs_read_int_log(bs, 5, \"dialnorm\");\n\tif (gf_bs_read_int_log(bs, 1, \"compre\")) {\n\t\tgf_bs_read_int_log(bs, 8, \"compr\");\n\t}\n\tif (ac3_mod==0) {\n\t\tgf_bs_read_int_log(bs, 5, \"dialnorm2\");\n\t\tif (gf_bs_read_int_log(bs, 1, \"compr2e\")) {\n\t\t\tgf_bs_read_int_log(bs, 8, \"compr2\");\n\t\t}\n\t}\n\tchanmap = 0;\n\tif (strmtyp==0x1) {\n\t\tif (gf_bs_read_int_log(bs, 1, \"chanmape\")) {\n\t\t\tchanmap = gf_bs_read_int_log(bs, 16, \"chanmap\");\n\t\t}\n\t}\n\n\tchannels = ac3_mod_to_chans[ac3_mod];\n\tif (lfon)\n\t\tchannels += 1;\n\n\thdr->bitrate = 0;\n\thdr->sample_rate = freq;\n\thdr->framesize = framesize;\n\tif (strmtyp != 1) {\n\t\thdr->channels = channels;\n\t\thdr->streams[substreamid].lfon = lfon;\n\t\tif (full_parse) {\n\t\t\thdr->streams[substreamid].bsid = bsid;\n\t\t\thdr->streams[substreamid].bsmod = 0;\n\t\t\thdr->streams[substreamid].acmod = ac3_mod;\n\t\t\thdr->streams[substreamid].fscod = fscod;\n\t\t\thdr->brcode = 0;\n\t\t}\n\t\thdr->nb_streams++;\n\t\t//not clear if this is only for the independent streams\n\t\thdr->brcode += ((frmsiz+1) * freq) / (numblks[numblkscod]*16) / 1000;\n\n\t\tif (lfon)\n\t\t\thdr->channels += 1;\n\n\t} else {\n\t\thdr->streams[substreamid].nb_dep_sub = substreamid;\n\t\thdr->streams[substreamid].chan_loc |= chanmap;\n\t}\n\n\tif (numblkscod < 6) { //we need 6 blocks to make a sample\n\t\tif (gf_bs_seek(bs, pos + framesize) != GF_OK) {\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\treturn GF_FALSE;\n\t\t}\n\n\t\tif ((gf_bs_available(bs) < 6) || !AC3_FindSyncCodeBS(bs))\n\t\t\treturn GF_FALSE;\n\t\tgoto block;\n\t}\n\n\tgf_bs_seek(bs, pos);\n\n\treturn GF_TRUE;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\nu32 gf_id3_read_size(GF_BitStream *bs)\n{\n\tu32 size = 0;\n\tgf_bs_read_int(bs, 1);\n\tsize |= gf_bs_read_int(bs, 7);\n\tsize<<=7;\n\tgf_bs_read_int(bs, 1);\n\tsize |= gf_bs_read_int(bs, 7);\n\tsize<<=7;\n\tgf_bs_read_int(bs, 1);\n\tsize |= gf_bs_read_int(bs, 7);\n\tsize<<=7;\n\tgf_bs_read_int(bs, 1);\n\tsize |= gf_bs_read_int(bs, 7);\n\treturn size;\n}\n\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined (GPAC_DISABLE_OGG)\n\n/*\n\tVorbis parser\n*/\n\nstatic u32 vorbis_book_maptype1_quantvals(u32 entries, u32 dim)\n{\n\tu32 vals = (u32)floor(pow(entries, 1.0 / dim));\n\twhile (1) {\n\t\tu32 acc = 1;\n\t\tu32 acc1 = 1;\n\t\tu32 i;\n\t\tfor (i = 0; i < dim; i++) {\n\t\t\tacc *= vals;\n\t\t\tacc1 *= vals + 1;\n\t\t}\n\t\tif (acc <= entries && acc1 > entries) return (vals);\n\t\telse {\n\t\t\tif (acc > entries) vals--;\n\t\t\telse vals++;\n\t\t}\n\t}\n}\n\nstatic u32 ilog(u32 v, Bool dec)\n{\n\tu32 ret = 0;\n\tif (dec && v) --v;\n\twhile (v) {\n\t\tret++;\n\t\tv >>= 1;\n\t}\n\treturn (ret);\n}\n\nstatic u32 icount(u32 v)\n{\n\tu32 ret = 0;\n\twhile (v) {\n\t\tret += v & 1;\n\t\tv >>= 1;\n\t}\n\treturn(ret);\n}\n\n\nGF_EXPORT\nBool gf_vorbis_parse_header(GF_VorbisParser *vp, u8 *data, u32 data_len)\n{\n\tu32 pack_type, i, j, k, times, nb_part, nb_books, nb_modes;\n\tu32 l;\n\tchar szNAME[8];\n\toggpack_buffer opb;\n\n\toggpack_readinit(&opb, (u8*)data, data_len);\n\tpack_type = oggpack_read(&opb, 8);\n\ti = 0;\n\twhile (i < 6) {\n\t\tszNAME[i] = oggpack_read(&opb, 8);\n\t\ti++;\n\t}\n\tszNAME[i] = 0;\n\tif (strcmp(szNAME, \"vorbis\")) {\n\t\treturn GF_FALSE;\n\t}\n\n\tswitch (pack_type) {\n\tcase 0x01:\n\t\tvp->version = oggpack_read(&opb, 32);\n\t\tif (vp->version != 0) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tvp->channels = oggpack_read(&opb, 8);\n\t\tvp->sample_rate = oggpack_read(&opb, 32);\n\t\tvp->max_r = oggpack_read(&opb, 32);\n\t\tvp->avg_r = oggpack_read(&opb, 32);\n\t\tvp->low_r = oggpack_read(&opb, 32);\n\n\t\tvp->min_block = 1<<oggpack_read(&opb, 4);\n\t\tvp->max_block = 1<<oggpack_read(&opb, 4);\n\t\tif (vp->sample_rate < 1 || vp->channels < 1 || vp->min_block < 8 || vp->max_block < vp->min_block\n\t\t    || oggpack_read(&opb, 1) != 1) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tvp->nb_init=1;\n\t\treturn GF_TRUE;\n\n\tcase 0x03:\n\t\t/*trash comments*/\n\t\tvp->nb_init++;\n\t\treturn GF_TRUE;\n\tcase 0x05:\n\t\t/*need at least bitstream header to make sure we're parsing the right thing*/\n\t\tif (!vp->nb_init) return GF_FALSE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\t/*OK parse codebook*/\n\tnb_books = oggpack_read(&opb, 8) + 1;\n\t/*skip vorbis static books*/\n\tfor (i = 0; i < nb_books; i++) {\n\t\tu32 map_type, qb, qq;\n\t\tu32 entries, dim;\n\t\toggpack_read(&opb, 24);\n\t\tdim = oggpack_read(&opb, 16);\n\t\tentries = oggpack_read(&opb, 24);\n\t\tif ((s32)entries < 0) entries = 0;\n\t\tif (oggpack_read(&opb, 1) == 0) {\n\t\t\tif (oggpack_read(&opb, 1)) {\n\t\t\t\tfor (j = 0; j < entries; j++) {\n\t\t\t\t\tif (oggpack_read(&opb, 1)) {\n\t\t\t\t\t\toggpack_read(&opb, 5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < entries; j++)\n\t\t\t\t\toggpack_read(&opb, 5);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\toggpack_read(&opb, 5);\n\t\t\tfor (j = 0; j < entries;) {\n\t\t\t\tu32 num = oggpack_read(&opb, ilog(entries - j, GF_FALSE));\n\t\t\t\tfor (k = 0; k < num && j < entries; k++, j++) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch ((map_type = oggpack_read(&opb, 4))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\toggpack_read(&opb, 32);\n\t\t\toggpack_read(&opb, 32);\n\t\t\tqq = oggpack_read(&opb, 4) + 1;\n\t\t\toggpack_read(&opb, 1);\n\t\t\tif (map_type == 1) qb = vorbis_book_maptype1_quantvals(entries, dim);\n\t\t\telse if (map_type == 2) qb = entries * dim;\n\t\t\telse qb = 0;\n\t\t\tfor (j = 0; j < qb; j++) oggpack_read(&opb, qq);\n\t\t\tbreak;\n\t\t}\n\t}\n\ttimes = oggpack_read(&opb, 6) + 1;\n\tfor (i = 0; i < times; i++) oggpack_read(&opb, 16);\n\ttimes = oggpack_read(&opb, 6) + 1;\n\tfor (i = 0; i < times; i++) {\n\t\tu32 type = oggpack_read(&opb, 16);\n\t\tif (type) {\n\t\t\tu32 *parts, *class_dims, count, rangebits;\n\t\t\tu32 max_class = 0;\n\t\t\tnb_part = oggpack_read(&opb, 5);\n\t\t\tparts = (u32*)gf_malloc(sizeof(u32) * nb_part);\n\t\t\tfor (j = 0; j < nb_part; j++) {\n\t\t\t\tparts[j] = oggpack_read(&opb, 4);\n\t\t\t\tif (max_class < parts[j]) max_class = parts[j];\n\t\t\t}\n\t\t\tclass_dims = (u32*)gf_malloc(sizeof(u32) * (max_class + 1));\n\t\t\tfor (j = 0; j < max_class + 1; j++) {\n\t\t\t\tu32 class_sub;\n\t\t\t\tclass_dims[j] = oggpack_read(&opb, 3) + 1;\n\t\t\t\tclass_sub = oggpack_read(&opb, 2);\n\t\t\t\tif (class_sub) oggpack_read(&opb, 8);\n\t\t\t\tfor (k = 0; k < (u32)(1 << class_sub); k++) oggpack_read(&opb, 8);\n\t\t\t}\n\t\t\toggpack_read(&opb, 2);\n\t\t\trangebits = oggpack_read(&opb, 4);\n\t\t\tcount = 0;\n\t\t\tfor (j = 0, k = 0; j < nb_part; j++) {\n\t\t\t\tcount += class_dims[parts[j]];\n\t\t\t\tfor (; k < count; k++) oggpack_read(&opb, rangebits);\n\t\t\t}\n\t\t\tgf_free(parts);\n\t\t\tgf_free(class_dims);\n\t\t}\n\t\telse {\n\t\t\toggpack_read(&opb, 8 + 16 + 16 + 6 + 8);\n\t\t\tnb_books = oggpack_read(&opb, 4) + 1;\n\t\t\tfor (j = 0; j < nb_books; j++)\n\t\t\t\toggpack_read(&opb, 8);\n\t\t}\n\t}\n\ttimes = oggpack_read(&opb, 6) + 1;\n\tfor (i = 0; i < times; i++) {\n\t\tu32 acc = 0;\n\t\toggpack_read(&opb, 16);/*type*/\n\t\toggpack_read(&opb, 24);\n\t\toggpack_read(&opb, 24);\n\t\toggpack_read(&opb, 24);\n\t\tnb_part = oggpack_read(&opb, 6) + 1;\n\t\toggpack_read(&opb, 8);\n\t\tfor (j = 0; j < nb_part; j++) {\n\t\t\tu32 cascade = oggpack_read(&opb, 3);\n\t\t\tif (oggpack_read(&opb, 1)) cascade |= (oggpack_read(&opb, 5) << 3);\n\t\t\tacc += icount(cascade);\n\t\t}\n\t\tfor (j = 0; j < acc; j++) oggpack_read(&opb, 8);\n\t}\n\ttimes = oggpack_read(&opb, 6) + 1;\n\tfor (i = 0; i < times; i++) {\n\t\tu32 sub_maps = 1;\n\t\toggpack_read(&opb, 16);\n\t\tif (oggpack_read(&opb, 1)) sub_maps = oggpack_read(&opb, 4) + 1;\n\t\tif (oggpack_read(&opb, 1)) {\n\t\t\tu32 nb_steps = oggpack_read(&opb, 8) + 1;\n\t\t\tfor (j = 0; j < nb_steps; j++) {\n\t\t\t\toggpack_read(&opb, ilog(vp->channels, GF_TRUE));\n\t\t\t\toggpack_read(&opb, ilog(vp->channels, GF_TRUE));\n\t\t\t}\n\t\t}\n\t\toggpack_read(&opb, 2);\n\t\tif (sub_maps>1) {\n\t\t\tfor(l=0; l<vp->channels; l++)\n\t\t\t\toggpack_read(&opb, 4);\n\t\t}\n\t\tfor (j = 0; j < sub_maps; j++) {\n\t\t\toggpack_read(&opb, 8);\n\t\t\toggpack_read(&opb, 8);\n\t\t\toggpack_read(&opb, 8);\n\t\t}\n\t}\n\tnb_modes = oggpack_read(&opb, 6) + 1;\n\tfor (i = 0; i < nb_modes; i++) {\n\t\tvp->mode_flag[i] = oggpack_read(&opb, 1);\n\t\toggpack_read(&opb, 16);\n\t\toggpack_read(&opb, 16);\n\t\toggpack_read(&opb, 8);\n\t}\n\n\tvp->modebits = 0;\n\tj = nb_modes;\n\twhile (j > 1) {\n\t\tvp->modebits++;\n\t\tj >>= 1;\n\t}\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nu32 gf_vorbis_check_frame(GF_VorbisParser *vp, u8 *data, u32 data_length)\n{\n\ts32 block_size;\n\toggpack_buffer opb;\n\tif (!vp) return 0;\n\toggpack_readinit(&opb, (unsigned char*)data, data_length);\n\t/*not audio*/\n\tif (oggpack_read(&opb, 1) != 0) return 0;\n\tblock_size = oggpack_read(&opb, vp->modebits);\n\tif (block_size == -1) return 0;\n\treturn ((vp->mode_flag[block_size]) ? vp->max_block : vp->min_block) / (2);\n}\n\n/*call with vorbis header packets - initializes the parser on success, leave it to NULL otherwise\nreturns 1 if success, 0 if error.*/\nBool gf_opus_parse_header(GF_OpusParser *opus, u8 *data, u32 data_len)\n{\n\tchar tag[9];\n\tGF_BitStream *bs = gf_bs_new(data, data_len, GF_BITSTREAM_READ);\n\tgf_bs_read_data(bs, tag, 8);\n\ttag[8]=0;\n\n\tif (memcmp(data, \"OpusHead\", sizeof(char)*8)) {\n\t\tgf_bs_del(bs);\n\t\treturn GF_FALSE;\n\t}\n\t/*Identification Header*/\n\topus->version = gf_bs_read_u8(bs); /*version*/\n\tif (opus->version != 1) {\n\t\tgf_bs_del(bs);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Opus] Unsupported version %d\\n\", opus->version));\n\t\treturn GF_FALSE;\n\t}\n\topus->OutputChannelCount = gf_bs_read_u8(bs);\n\topus->PreSkip = gf_bs_read_u16_le(bs);\n\topus->InputSampleRate = gf_bs_read_u32_le(bs);\n\topus->OutputGain = gf_bs_read_u16_le(bs);\n\topus->ChannelMappingFamily = gf_bs_read_u8(bs);\n\tif (opus->ChannelMappingFamily != 0) {\n\t\topus->StreamCount = gf_bs_read_u8(bs);\n\t\topus->CoupledCount = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) opus->ChannelMapping, opus->OutputChannelCount);\n\t}\n\tgf_bs_del(bs);\n\treturn GF_TRUE;\n}\n\n/*returns 0 if init error or not a vorbis frame, otherwise returns the number of audio samples\nin this frame*/\nu32 gf_opus_check_frame(GF_OpusParser *op, u8 *data, u32 data_length)\n{\n\tu32 block_size;\n\n\tif (!memcmp(data, \"OpusHead\", sizeof(char)*8))\n\t\treturn 0;\n\tif (!memcmp(data, \"OpusTags\", sizeof(char)*8))\n\t\treturn 0;\n\n\t/*consider the whole packet as Ogg packets and ISOBMFF samples for Opus are framed similarly*/\n\tstatic const int OpusFrameDurIn48k[] = { 480, 960, 1920, 2880, 480, 960, 1920, 2880, 480, 960, 1920, 2880,\n\t\t480, 960, 480, 960,\n\t\t120, 240, 480, 960, 120, 240, 480, 960, 120, 240, 480, 960, 120, 240, 480, 960,\n\t};\n\tint TOC_config = (data[0] & 0xf8) >> 3;\n\t//int s = (data[0] & 0x04) >> 2;\n\tblock_size = OpusFrameDurIn48k[TOC_config];\n\n\tint c = data[0] & 0x03;\n\tif (c == 1 || c == 2) {\n\t\tblock_size *= 2;\n\t} else if (c == 3) {\n\t\t/*unknown number of frames*/\n\t\tint num_frames = data[1] & 0x3f;\n\t\tblock_size *= num_frames;\n\t}\n\treturn block_size;\n}\n\n#endif /*!defined(GPAC_DISABLE_AV_PARSERS) && !defined (GPAC_DISABLE_OGG)*/\n\nu64 gf_mpegh_escaped_value(GF_BitStream *bs, u32 nBits1, u32 nBits2, u32 nBits3)\n{\n\tu64 value = gf_bs_read_int(bs, nBits1);\n\tif (value == (1<<nBits1)-1) {\n\t\tu32 vadd = gf_bs_read_int(bs, nBits2);\n\t\tvalue += vadd;\n\t\tif (vadd == (1<<nBits2)-1) {\n\t\t\tvadd = gf_bs_read_int(bs, nBits3);\n\t\t\tvalue += vadd;\n\t\t}\n\t}\n\treturn value;\n}\n\nGF_EXPORT\ns32 gf_mpegh_get_mhas_pl(u8 *ptr, u32 size, u64 *ch_layout)\n{\n\ts32 PL = -1;\n\tGF_BitStream *bs;\n\tu32 i;\n\ts32 sync_pos=-1;\n\n\tif (!ptr || !size) return 0;\n\t\n\tfor (i=0; i<size-3; i++) {\n\t\tif ((ptr[i]==0xC0) && (ptr[i+1]== 0x01) && (ptr[i+2]==0xA5)) {\n\t\t\tsync_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (sync_pos<0) return 0;\n\tif (ch_layout) *ch_layout = 0;\n\tbs = gf_bs_new(ptr, size, GF_BITSTREAM_READ);\n\tgf_bs_skip_bytes(bs, sync_pos);\n\n\twhile (gf_bs_available(bs)) {\n\t\tu32 type = (u32) gf_mpegh_escaped_value(bs, 3, 8, 8);\n\t\t/*u64 label = */gf_mpegh_escaped_value(bs, 2, 8, 32);\n\t\tu64 mh_size = gf_mpegh_escaped_value(bs, 11, 24, 24);\n\t\tif (mh_size > gf_bs_available(bs))\n\t\t\tbreak;\n\t\t//MHAS config\n\t\tif (type==1) {\n\t\t\tPL = gf_bs_read_int(bs, 8);\n\t\t\tif (ch_layout) {\n\t\t\t\tu32 idx = gf_bs_read_int(bs, 5);\n\t\t\t\tif (idx==0x1f)\n\t\t\t\t\tgf_bs_read_int(bs, 24);\n\t\t\t\t/*idx = */gf_bs_read_int(bs, 3);\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t\tgf_bs_read_int(bs, 1);\n\n\t\t\t\t//speaker config\n\t\t\t\tidx = gf_bs_read_int(bs, 2);\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\t*ch_layout = gf_audio_fmt_get_layout_from_cicp( gf_bs_read_int(bs, 6) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgf_bs_skip_bytes(bs, mh_size);\n\t}\n\tgf_bs_del(bs);\n\treturn PL;\n}\n\n\nGF_EXPORT\nvoid gf_media_vvc_parse_sei(char *buffer, u32 nal_size, VVCState *vvc)\n{\n\tgf_hevc_vvc_parse_sei(buffer, nal_size, NULL, vvc);\n}\n\nstatic Bool vvc_parse_nal_header(GF_BitStream *bs, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tu32 val;\n\tval = gf_bs_read_int_log(bs, 1, \"forbidden_zero\");\n\tif (val) return GF_FALSE;\n\tval = gf_bs_read_int_log(bs, 1, \"resevred0\");\n\tif (val) return GF_FALSE;\n\n\tval = gf_bs_read_int_log(bs, 6, \"layerID\");\n\tif (layer_id) *layer_id = val;\n\n\tval = gf_bs_read_int_log(bs, 5, \"nuh_type\");\n\tif (nal_unit_type) *nal_unit_type = val;\n\n\tval = gf_bs_read_int_log(bs, 3, \"temporalID\");\n\tif (!val) return GF_FALSE;\n\tval -= 1;\n\tif (temporal_id) *temporal_id = val;\n\treturn GF_TRUE;\n}\n\nstatic void vvc_profile_tier_level(GF_BitStream *bs, VVC_ProfileTierLevel *ptl, u32 idx)\n{\n\tu32 i;\n\tif (ptl->pt_present) {\n\t\tptl->general_profile_idc = gf_bs_read_int_log_idx(bs, 7, \"general_profile_idc\", idx);\n\t\tptl->general_tier_flag = gf_bs_read_int_log_idx(bs, 1, \"general_tier_flag\", idx);\n\t}\n\tptl->general_level_idc = gf_bs_read_int_log_idx(bs, 8, \"general_level_idc\", idx);\n\tptl->frame_only_constraint = gf_bs_read_int_log_idx(bs, 1, \"frame_only_constraint\", idx);\n\tptl->multilayer_enabled = gf_bs_read_int_log_idx(bs, 1, \"multilayer_enabled\", idx);\n\t//general constraints info - max size if 1 + 81 + 8 + 255\n\tif (ptl->pt_present) {\n\t\t//\t\tgeneral_constraints_info\n\t\tptl->gci_present = gf_bs_read_int_log_idx(bs, 1, \"gci_present\", idx);\n\t\tif (ptl->gci_present) {\n\t\t\tu8 res;\n\t\t\tptl->gci[0] = 0x80;\n\t\t\tptl->gci[0] |= gf_bs_read_int(bs, 7);\n\t\t\t//81-7 = 74 bits till reserved\n\t\t\tgf_bs_read_data(bs, ptl->gci+1, 9);\n\t\t\tptl->gci[10] = gf_bs_read_int(bs, 2)<<6;\n\t\t\t//skip extensions\n\t\t\tptl->gci[11] = 0;\n\t\t\tres = gf_bs_read_int(bs, 8);\n\t\t\tgf_bs_read_int(bs, res);\n\t\t}\n\t\tgf_bs_align(bs);\n\t}\n\tfor (i=ptl->ptl_max_tid; i>0; i--) {\n\t\tptl->sub_ptl[i-1].level_present_flag = gf_bs_read_int_log_idx2(bs, 1, \"level_present_flag\", idx, i);\n\t}\n\tgf_bs_align(bs);\n\tfor (i=ptl->ptl_max_tid; i>0; i--) {\n\t\tif (ptl->sub_ptl[i-1].level_present_flag)\n\t\t\tptl->sub_ptl[i-1].sublayer_level_idc = gf_bs_read_int_log_idx2(bs, 8, \"sublayer_level_idc\", idx, i);\n\t}\n\tif (ptl->pt_present) {\n\t\tptl->num_sub_profiles = gf_bs_read_int_log_idx(bs, 8, \"num_sub_profiles\", idx);\n\t\tfor (i=0; i<ptl->num_sub_profiles; i++) {\n\t\t\tptl->sub_profile_idc[i] = gf_bs_read_int_log_idx2(bs, 32, \"sub_profile_idc\", idx, i);\n\t\t}\n\t}\n}\n\nstatic s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)\n{\n\tu32 i, j;\n\ts32 vps_id;\n\tVVC_VPS *vps;\n\tBool vps_default_ptl_dpb_hrd_max_tid_flag=0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) return -1;\n\tif (!vps_id) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] VPS ID 0 is forbidden\\n\"));\n\t\treturn -1;\n\t}\n\tvps = &vvc->vps[vps_id];\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\n\tif ((vps->max_layers>1) && (vps->max_sub_layers>1))\n\t\tvps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, \"vps_default_ptl_dpb_hrd_max_tid_flag\");\n\n\tif (vps->max_layers>1)\n\t\tvps->all_layers_independent = gf_bs_read_int_log(bs, 1, \"all_layers_independent\");\n\n\tfor (i=0; i<vps->max_layers; i++) {\n\t\tu32 layer_id = gf_bs_read_int_log_idx(bs, 6, \"layer_id\", i);\n\t\tif (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;\n\t\tif (i && !vps->all_layers_independent) {\n\t\t\tBool layer_indep = gf_bs_read_int_log_idx(bs, 1, \"layer_independent\", i);\n\t\t\tif (!layer_indep) {\n\t\t\t\tBool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_max_tid_ref_present_flag\", i);\n\t\t\t\tfor (j=0; j<i; j++) {\n\t\t\t\t\tBool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, \"vps_direct_ref_layer_flag\", i, j);\n\t\t\t\t\tif (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"vps_max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvps->num_ptl = 1;\n\tif (vps->max_layers > 1) {\n\t\tif (vps->all_layers_independent) {\n\t\t\tvps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, \"each_layer_is_ols\");\n\t\t}\n\t\tif (!vps->each_layer_is_ols) {\n\t\t\tu32 vps_ols_mode_idc = 2;\n\t\t\tif (!vps->all_layers_independent) {\n\t\t\t\tvps_ols_mode_idc = gf_bs_read_int_log(bs, 2, \"vps_ols_mode_idc\");\n\t\t\t}\n\t\t\tif (vps_ols_mode_idc==2) {\n\t\t\t\tu8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, \"vps_num_output_layer_sets_minus2\");\n\t\t\t\tfor (i=0; i<vps_num_output_layer_sets; i++) {\n\t\t\t\t\tfor (j=0; j<vps->max_layers; j++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"vps_ols_output_layer_flag\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, \"num_ptl_minus1\");\n\t}\n\tvps->ptl[0].pt_present = 1;\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tif (i)\n\t\t\tvps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, \"pt_present\", i);\n\t\tif (!vps_default_ptl_dpb_hrd_max_tid_flag)\n\t\t\tvps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, \"ptl_max_tid\", i);\n\t\telse\n\t\t\tvps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;\n\t}\n\t//align\n\tgf_bs_align(bs);\n\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tvvc_profile_tier_level(bs, &vps->ptl[i], i);\n\t}\n\n\t//TODO, parse multilayer stuff\n\treturn vps_id;\n}\n\n\nstatic s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif ((sps_id<0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, \"max_sublayers_minus1\");\n\tsps->chroma_format_idc = gf_bs_read_int_log(bs, 2, \"chroma_format_idc\");\n\tsps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, \"log2_ctu_size_minus5\");\n\tCtbSizeY = 1<<sps->log2_ctu_size;\n\n\tsps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"sps_ptl_dpb_hrd_params_present_flag\");\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tVVC_ProfileTierLevel ptl, *p_ptl;\n\t\tif (sps->vps_id) {\n\t\t\tp_ptl = &ptl;\n\t\t} else {\n\t\t\tp_ptl = &vvc->vps[0].ptl[0];\n\t\t}\n\t\tmemset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));\n\t\tp_ptl->pt_present = 1;\n\t\tp_ptl->ptl_max_tid = sps->max_sublayers-1;\n\t\tvvc_profile_tier_level(bs, p_ptl, 0);\n\t}\n\tsps->gdr_enabled = gf_bs_read_int_log(bs, 1, \"gdr_enabled\");\n\tsps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, \"ref_pic_resampling\");\n\tif (sps->ref_pic_resampling)\n\t\tsps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, \"res_change_in_clvs\");\n\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\tsps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_present_flag\");\n\tif (sps->conf_window) {\n\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\t}\n\tsps->subpic_info_present = gf_bs_read_int_log(bs, 1, \"subpic_info_present\");\n\tif (sps->subpic_info_present) {\n\t\tsps->nb_subpics = 1 + gf_bs_read_ue_log(bs, \"nb_subpics_minus1\");\n\t\tif (sps->nb_subpics>1) {\n\t\t\tu32 tmpWidthVal, tmpHeightVal;\n\t\t\tsps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, \"independent_subpic_flags\");\n\t\t\tsps->subpic_same_size = gf_bs_read_int_log(bs, 1, \"subpic_same_size\");\n\n\t\t\ttmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpWidthVal = gf_get_bit_size(tmpWidthVal);\n\t\t\ttmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpHeightVal = gf_get_bit_size(tmpHeightVal);\n\n\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\tif( !sps->subpic_same_size || !i) {\n\t\t\t\t\tif (i && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_ctu_top_left_x\");\n\t\t\t\t\tif (i && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_ctu_top_left_y\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_width_minus1\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_height_minus1\");\n\t\t\t\t}\n\t\t\t\tif (!sps->independent_subpic_flags) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"subpic_treated_as_pic_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"loop_filter_across_subpic_enabled_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsps->subpicid_len = gf_bs_read_ue_log(bs, \"subpic_id_len_minus1\") + 1;\n\t\t\tsps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_explicitly_signalled_flag\");\n\t\t\tif (sps->subpicid_mapping_explicit) {\n\t\t\t\tsps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\t\t\t\tif (sps->subpicid_mapping_present) {\n\t\t\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\t\t\tgf_bs_read_ue_log(bs, \"subpic_id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsps->bitdepth = gf_bs_read_ue_log(bs, \"bitdepth_minus8\") + 8;\n\tgf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tgf_bs_read_int_log(bs, 1, \"entry_point_offsets_present_flag\");\n\tsps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, \"log2_max_poc_lsb_minus4\");\n\tif ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_flag\")))\n\t\tsps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, \"poc_msb_cycle_len_minus1\");\n\n\tu8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, \"sps_num_extra_ph_bytes\");\n\tfor (i=0; i<sps_num_extra_ph_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_ph_bit_present_flag\", 1))\n\t\t\tsps->ph_num_extra_bits++;\n\t}\n\tu8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, \"num_extra_sh_bytes\");\n\tfor (i=0; i<sps_num_extra_sh_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_sh_bit_present_flag\", i))\n\t\t\tsps->sh_num_extra_bits++;\n\t}\n\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tu8 sps_sublayer_dpb_params_flag = 0;\n\t\tif (sps->max_sublayers>1) {\n\t\t\tsps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, \"sps_sublayer_dpb_params_flag\");\n\t\t}\n\t\tfor (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_dec_pic_buffering_minus1\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_latency_increase_plus1\", i);\n\t\t}\n\t}\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tgf_bs_read_int_log(bs, 1, \"sps_partition_constraints_override_enabled_flag\");\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tu8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_luma\");\n\tif (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_luma\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_luma\");\n\t}\n\tu8 sps_qtbtt_dual_tree_intra_flag = 0;\n\tif (sps->chroma_format_idc) {\n\t\tsps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, \"sps_qtbtt_dual_tree_intra_flag\");\n\t}\n\tif (sps_qtbtt_dual_tree_intra_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_intra_slice_chroma\");\n\t\tu8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_chroma\");\n\t\tif( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_chroma\");\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_chroma\");\n\t\t}\n\t}\n\n\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_inter_slice\");\n\tu8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_inter_slice\");\n\tif (sps_max_mtt_hierarchy_depth_inter_slice != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_inter_slice\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_inter_slice\");\n\t}\n\t//u8 sps_max_luma_transform_size_64_flag = 0;\n\tif (CtbSizeY > 32) {\n\t\t/*sps_max_luma_transform_size_64_flag = */gf_bs_read_int_log(bs, 1, \"sps_max_luma_transform_size_64_flag\");\n\t}\n\tu8 sps_transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_transform_skip_enabled_flag\");\n\n\tif (sps_transform_skip_enabled_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_transform_skip_max_size_minus2\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_bdpcm_enabled_flag\");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"sps_mts_enabled_flag\")) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_intra_enabled_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_inter_enabled_flag\");\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_lfnst_enabled_flag\");\n\tif (sps->chroma_format_idc) {\n\t\tu8 sps_joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_joint_cbcr_enabled_flag\");\n\t\tu8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, \"sps_same_qp_table_for_chroma_flag\");\n\t\tu32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps_joint_cbcr_enabled_flag ? 3 : 2);\n\t\tfor (i=0; i<numQpTables; i++) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"sps_qp_table_start_minus26\", i);\n\t\t\tu32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, \"sps_num_points_in_qp_table_minus1\", i);\n\t\t\tfor (j=0; j<sps_num_points_in_qp_table; j++) {\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_in_val_minus1\", i, j);\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_diff_val\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_sao_enabled_flag\");\n\tsps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_alf_enabled_flag\");\n\tif (sps->alf_enabled_flag && sps->chroma_format_idc) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_ccalf_enabled_flag\");\n\t}\n\t/*! TODO parse the rest !*/\n\n\treturn sps_id;\n}\n\nstatic s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tVVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_int_log(bs, 6, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (((s32)pps->sps_id<0) || (pps->sps_id >= 16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {\n\t\tpps->cw_left = gf_bs_read_ue_log(bs, \"conf_win_left_offset\");\n\t\tpps->cw_right = gf_bs_read_ue_log(bs, \"conf_win_right_offset\");\n\t\tpps->cw_top = gf_bs_read_ue_log(bs, \"conf_win_top_offset\");\n\t\tpps->cw_bottom = gf_bs_read_ue_log(bs, \"conf_win_bottom_offset\");\n\t}\n\t//scaling window\n\tif (gf_bs_read_int_log(bs, 1, \"scaling_window_explicit_signaling_flag\")) {\n\t\tgf_bs_read_se_log(bs, \"scaling_win_left_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_right_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_top_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_bottom_offset\");\n\t}\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \"no_pic_partition_flag\");\n\tpps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\tif (pps->subpic_id_mapping_present_flag) {\n\t\tu32 pps_subpic_id_len, pps_num_subpics=0;\n\t\tif (!pps->no_pic_partition_flag) {\n\t\t\tpps_num_subpics = 1+gf_bs_read_ue_log(bs, \"pps_num_subpics_minus1\");\n\t\t}\n\t\tpps_subpic_id_len = 1 + gf_bs_read_ue(bs);\n\t\tfor (i=0; i<pps_num_subpics; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, pps_subpic_id_len, \"subpic_id\", i);\n\t\t}\n\t}\n\tif (!pps->no_pic_partition_flag) {\n\t\tgf_bs_read_int_log(bs, 2, \"pps_log2_ctu_size_minus5\");\n\t\tu32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_columns_minus1\");\n\t\tu32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_rows_minus1\");\n\t\tfor (i=0; i<num_exp_tile_columns; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_column_width_minus1\", i);\n\t\tfor (i=0; i<num_exp_tile_rows; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_row_height_minus1\", i);\n\n\t\t//todo parse the rest\n\t\treturn pps_id;\n\t}\n\n\n\t//todo parse the rest\n\n\treturn pps_id;\n}\n\nstatic\ns32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\tsi->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, \"irap_or_gdr_pic\");\n\tsi->non_ref_pic = gf_bs_read_int_log(bs, 1, \"non_ref_pic\");\n\tif (si->irap_or_gdr_pic)\n\t\tsi->gdr_pic = gf_bs_read_int_log(bs, 1, \"gdr_pic\");\n\tif ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"inter_slice_allowed_flag\")))\n\t\tsi->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"intra_slice_allowed_flag\");\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 64))\n\t\treturn -1;\n\tsi->pps = &vvc->pps[pps_id];\n\tsi->sps = &vvc->sps[si->pps->sps_id];\n\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\n\tsi->recovery_point_valid = 0;\n\tsi->gdr_recovery_count = 0;\n\tif (si->gdr_pic) {\n\t\tsi->recovery_point_valid = 1;\n\t\tsi->gdr_recovery_count = gf_bs_read_ue_log(bs, \"gdr_recovery_count\");\n\t}\n\tgf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, \"ph_extra_bits\");\n\n\tif (si->sps->poc_msb_cycle_flag) {\n\t\tif ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_present_flag\"))) {\n\t\t\tsi->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, \"poc_msb_cycle\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic s32 vvc_parse_slice(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n//\tu32 CurrSubpicIdx = 0;\n\n\tsi->picture_header_in_slice_header_flag = gf_bs_read_int_log(bs, 1, \"picture_header_in_slice_header_flag\");\n\tif (si->picture_header_in_slice_header_flag) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[VVC] Picture header in slice header incomplete support, cannot guess slice type\\n\"));\n\t\tsi->slice_type = GF_VVC_SLICE_TYPE_UNKNOWN;\n\t\treturn vvc_parse_picture_header(bs, vvc, si);\n\t}\n\tif (!si->sps) return -1;\n\tsi->slice_type = GF_VVC_SLICE_TYPE_I;\n\tif (gf_bs_read_int_log(bs, 1, \"sps_subpic_info_present_flag\")) {\n\t\tgf_bs_read_int_log(bs, si->sps->subpicid_len, \"subpic_id\");\n\t\t//todo update CurrSubpicIdx\n\t}\n\n\tif (si->pps->rect_slice_flag ) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[VVC] tiling parsing not supported - patch welcome\\n\"));\n\t\treturn 0;\n\t}\n\tgf_bs_read_int_log(bs, si->sps->sh_num_extra_bits, \"num_extra_bits\");\n\t/*\n\t\tif( !pps_rect_slice_flag  &&  NumTilesInPic \u2212 sh_slice_address > 1 )\n\t\tsh_num_tiles_in_slice_minus1\n\n\t */\n\n\tif (si->inter_slice_allowed_flag )\n\t\tsi->slice_type = gf_bs_read_int_log(bs, 2, \"slice_type\");\n\n\treturn 0;\n}\n\nstatic void vvc_compute_poc(VVCSliceInfo *si)\n{\n\tu32 max_poc_lsb = 1 << (si->sps->log2_max_poc_lsb);\n\n\tif (si->poc_msb_cycle_present_flag) {\n\t\tsi->poc_msb = si->poc_msb_cycle;\n\t} else {\n\t\tif ((si->poc_lsb < si->poc_lsb_prev) && (si->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\t\telse if ((si->poc_lsb > si->poc_lsb_prev) && (si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\t\telse\n\t\t\tsi->poc_msb = si->poc_msb_prev;\n\t}\n\n\tsi->poc = si->poc_msb + si->poc_lsb;\n}\n\n\nGF_EXPORT\ns32 gf_media_vvc_parse_nalu_bs(GF_BitStream *bs, VVCState *vvc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tBool is_slice = GF_FALSE;\n\ts32 ret = -1;\n\tBool poc_reset = GF_FALSE;\n\tVVCSliceInfo n_state;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tmemcpy(&n_state, &vvc->s_info, sizeof(VVCSliceInfo));\n\tif (!vvc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) return -1;\n\n\tn_state.nal_unit_type = *nal_unit_type;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_VVC_NALU_ACCESS_UNIT:\n\tcase GF_VVC_NALU_END_OF_SEQ:\n\tcase GF_VVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\t\tpoc_reset = GF_TRUE;\n\tcase GF_VVC_NALU_SLICE_TRAIL:\n\tcase GF_VVC_NALU_SLICE_STSA:\n\tcase GF_VVC_NALU_SLICE_RADL:\n\tcase GF_VVC_NALU_SLICE_RASL:\n\tcase GF_VVC_NALU_SLICE_CRA:\n\tcase GF_VVC_NALU_SLICE_GDR:\n\t\t/* slice - read the info and compare.*/\n\t\tret = vvc_parse_slice(bs, vvc, &n_state);\n\t\tif (ret < 0) return ret;\n\n\t\tret = 0;\n\t\tif (n_state.compute_poc_defer || n_state.picture_header_in_slice_header_flag) {\n\t\t\tis_slice = GF_TRUE;\n\t\t\tn_state.compute_poc_defer = 0;\n\t\t\tif (poc_reset) {\n\t\t\t\tn_state.poc_lsb_prev = 0;\n\t\t\t\tn_state.poc_msb_prev = 0;\n\t\t\t}\n\n\t\t\tvvc_compute_poc(&n_state);\n\t\t\tif (vvc->s_info.poc != n_state.poc) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1))) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_VVC_NALU_PIC_HEADER:\n\t\tif (vvc_parse_picture_header(bs, vvc, &n_state)<0) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tis_slice = GF_TRUE;\n\n\t\t/*POC reset for IDR frames, NOT for CRA*/\n\t\tif (n_state.irap_or_gdr_pic && !n_state.gdr_pic) {\n\t\t\tn_state.poc_lsb_prev = 0;\n\t\t\tn_state.poc_msb_prev = 0;\n\t\t\tvvc_compute_poc(&n_state);\n\t\t} else {\n\t\t\t//we cannot compute poc until we know the first picture unit type, since IDR will reset poc count\n\t\t\t//and irap_or_gdr_pic=0 does not prevent IDR from following\n\t\t\tn_state.compute_poc_defer = 1;\n\t\t}\n\n\t\tif (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1))) {\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\tvvc->last_parsed_sps_id = gf_media_vvc_read_sps_bs_internal(bs, vvc, *layer_id, NULL);\n\t\tret = (vvc->last_parsed_sps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tcase GF_VVC_NALU_PIC_PARAM:\n\t\tvvc->last_parsed_pps_id = gf_media_vvc_read_pps_bs_internal(bs, vvc);\n\t\tret = (vvc->last_parsed_pps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tcase GF_VVC_NALU_VID_PARAM:\n\t\tvvc->last_parsed_vps_id = gf_media_vvc_read_vps_bs_internal(bs, vvc, GF_FALSE);\n\t\tret = (vvc->last_parsed_vps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tcase GF_VVC_NALU_DEC_PARAM:\n\t\tret = 0;\n\t\tbreak;\n\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t//we use the mix aps type + aps id (first 8 bits) as unique identifier\n\t\tvvc->last_parsed_aps_id = gf_bs_read_int_log(bs, 8, \"aps_id\");\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif ((ret>0) && vvc->s_info.sps) {\n//\t\tn_state.frame_num_offset_prev = vvc->s_info.frame_num_offset;\n//\t\tn_state.frame_num_prev = vvc->s_info.frame_num;\n\n\t\tn_state.poc_lsb_prev = vvc->s_info.poc_lsb;\n\t\tn_state.poc_msb_prev = vvc->s_info.poc_msb;\n\t\tif (is_slice)\n\t\t\tn_state.prev_layer_id_plus1 = *layer_id + 1;\n\t}\n\n\tmemcpy(&vvc->s_info, &n_state, sizeof(VVCSliceInfo));\n\n\treturn ret;\n}\n\nGF_EXPORT\ns32 gf_media_vvc_parse_nalu(u8 *data, u32 size, VVCState *vvc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tGF_BitStream *bs = NULL;\n\ts32 ret;\n\n\tif (!vvc) {\n\t\tif (nal_unit_type) (*nal_unit_type) = data[1] >> 3;\n\t\tif (layer_id) (*layer_id) = data[0] & 0x3f;\n\t\tif (temporal_id) (*temporal_id) = (data[1] & 0x7);\n\t\treturn -1;\n\t}\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tif (!bs) return -1;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tret = gf_media_vvc_parse_nalu_bs(bs, vvc, nal_unit_type, temporal_id, layer_id);\n\tgf_bs_del(bs);\n\treturn ret;\n}\n\nBool gf_media_vvc_slice_is_ref(VVCState *vvc)\n{\n\tif (!vvc->s_info.irap_or_gdr_pic) {\n\t\treturn GF_FALSE;\n\t}\n\tif (vvc->s_info.gdr_pic) {\n\t\tif (vvc->s_info.recovery_point_valid) {\n\t\t\tvvc->s_info.recovery_point_valid = 0;\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre, Romain Bouqueau, Cyril Concolato\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/constants.h>\n#include <gpac/mpeg4_odf.h>\n#include <gpac/maths.h>\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_OGG\n#include <gpac/internal/ogg.h>\n#endif\n\n//uncomment/define globally to remove all bitstream parsing logging from code (this will break inspect mode ananlyze=bs)\n//#define GPAC_DISABLE_AVPARSE_LOGS\n\n#ifndef GPAC_DISABLE_AVPARSE_LOGS\nvoid gf_bs_log_idx(GF_BitStream *bs, u32 nBits, const char *fname, s64 val, s32 idx1, s32 idx2, s32 idx3);\n\n#define gf_bs_log(_bs, _nBits, _fname, _val) gf_bs_log_idx(_bs, _nBits, _fname, _val, -1, -1, -1)\n\nu32 gf_bs_read_int_log_idx3(GF_BitStream *bs, u32 nBits, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val = gf_bs_read_int(bs, nBits);\n\tgf_bs_log_idx(bs, nBits, fname, val, idx1, idx2, idx3);\n\treturn val;\n}\n\n#define gf_bs_read_int_log(_bs, _nBits, _fname) gf_bs_read_int_log_idx3(_bs, _nBits, _fname, -1, -1, -1)\n#define gf_bs_read_int_log_idx(_bs, _nBits, _fname, _idx) gf_bs_read_int_log_idx3(_bs, _nBits, _fname, _idx, -1, -1)\n#define gf_bs_read_int_log_idx2(_bs, _nBits, _fname, _idx1, _idx2) gf_bs_read_int_log_idx3(_bs, _nBits, _fname, (s32) _idx1, (s32) _idx2, -1)\n\n\n#else\n\n#define gf_bs_log(_bs, _nBits, _fname, _val)\n#define gf_bs_log_idx(_bs, _nBits, _fname, _val, _idx1, _idx2, _idx3)\n\n#define gf_bs_read_int_log(_bs, _nbb, _f) gf_bs_read_int(_bs, _nbb)\n#define gf_bs_read_int_log_idx(_bs, _nbb, _f, _idx) gf_bs_read_int(_bs, _nbb)\n#define gf_bs_read_int_log_idx2(_bs, _nbb, _f, _idx1, _idx2) gf_bs_read_int(_bs, _nbb)\n#define gf_bs_read_int_log_idx3(_bs, _nbb, _f, _idx1, _idx2, _idx3) gf_bs_read_int(_bs, _nbb)\n\n#endif\n\n\n\n\nstatic const struct {\n\tu32 w, h;\n} std_par[] =\n{\n\t{ 4, 3}, {3, 2}, {16, 9}, {5, 3}, {5, 4}, {8, 5}, {2, 1}, {1, 1},\n\t{0, 0},\n};\n\nGF_EXPORT\nvoid gf_media_reduce_aspect_ratio(u32 *width, u32 *height)\n{\n\tu32 i = 0;\n\tu32 w = *width;\n\tu32 h = *height;\n\twhile (std_par[i].w) {\n\t\tif (std_par[i].w * h == std_par[i].h * w) {\n\t\t\t*width = std_par[i].w;\n\t\t\t*height = std_par[i].h;\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t}\n\t//not standard one, reduce by power of 2\n\ti = 2;\n\twhile (1) {\n\t\tif (w <= i) return;\n\t\tif (h <= i) return;\n\n\t\tif (w % i) return;\n\t\tif (h % i) return;\n\t\t*width = w / i;\n\t\t*height = h / i;\n\t\ti *= 2;\n\t}\n}\n\nGF_EXPORT\nvoid gf_media_get_reduced_frame_rate(u32 *timescale, u32 *sample_dur)\n{\n\tu32 res;\n\tif (!*sample_dur) return;\n\tres = *timescale / *sample_dur;\n\tif (res * (*sample_dur) == *timescale) {\n\t\t*timescale = res;\n\t\t*sample_dur = 1;\n\t}\n\telse if ((double)(*timescale * 1001 - (res + 1) * *sample_dur * 1000) / ((res + 1) * *sample_dur * 1000) < 0.001) {\n\t\t*timescale = (res + 1) * 1000;\n\t\t*sample_dur = 1001;\n\t}\n}\n\nstruct __m4v_profile\n{\n\tu32 value;\n\tconst char *name;\n} M4VProfiles[] = {\n\t{0x00, \"Reserved (0x00) Profile\"},\n\t{0x01, \"Simple Profile @ Level 1\"},\n\t{0x02, \"Simple Profile @ Level 2\"},\n\t{0x03, \"Simple Profile @ Level 3\"},\n\t{0x08, \"Simple Profile @ Level 0\"},\n\t{0x10, \"Simple Scalable Profile @ Level 0\"},\n\t{0x11, \"Simple Scalable Profile @ Level 1\"},\n\t{0x12, \"Simple Scalable Profile @ Level 2\"},\n\t{0x21, \"Core Profile @ Level 1\"},\n\t{0x22, \"Core Profile @ Level 2\"},\n\t{0x32, \"Main Profile @ Level 2\"},\n\t{0x33, \"Main Profile @ Level 3\"},\n\t{0x34, \"Main Profile @ Level 4\"},\n\t{0x42, \"N-bit Profile @ Level 2\"},\n\t{0x51, \"Scalable Texture Profile @ Level 1\"},\n\t{0x61, \"Simple Face Animation Profile @ Level 1\"},\n\t{0x62, \"Simple Face Animation Profile @ Level 2\"},\n\t{0x63, \"Simple FBA Profile @ Level 1\"},\n\t{0x64, \"Simple FBA Profile @ Level 2\"},\n\t{0x71, \"Basic Animated Texture Profile @ Level 1\"},\n\t{0x72, \"Basic Animated Texture Profile @ Level 2\"},\n\t{0x7F, \"AVC/H264 Profile\"},\n\t{0x81, \"Hybrid Profile @ Level 1\"},\n\t{0x82, \"Hybrid Profile @ Level 2\"},\n\t{0x91, \"Advanced Real Time Simple Profile @ Level 1\"},\n\t{0x92, \"Advanced Real Time Simple Profile @ Level 2\"},\n\t{0x93, \"Advanced Real Time Simple Profile @ Level 3\"},\n\t{0x94, \"Advanced Real Time Simple Profile @ Level 4\"},\n\t{0xA1, \"Core Scalable Profile @ Level1\"},\n\t{0xA2, \"Core Scalable Profile @ Level2\"},\n\t{0xA3, \"Core Scalable Profile @ Level3\"},\n\t{0xB1, \"Advanced Coding Efficiency Profile @ Level 1\"},\n\t{0xB2, \"Advanced Coding Efficiency Profile @ Level 2\"},\n\t{0xB3, \"Advanced Coding Efficiency Profile @ Level 3\"},\n\t{0xB4, \"Advanced Coding Efficiency Profile @ Level 4\"},\n\t{0xC1, \"Advanced Core Profile @ Level 1\"},\n\t{0xC2, \"Advanced Core Profile @ Level 2\"},\n\t{0xD1, \"Advanced Scalable Texture @ Level1\"},\n\t{0xD2, \"Advanced Scalable Texture @ Level2\"},\n\t{0xE1, \"Simple Studio Profile @ Level 1\"},\n\t{0xE2, \"Simple Studio Profile @ Level 2\"},\n\t{0xE3, \"Simple Studio Profile @ Level 3\"},\n\t{0xE4, \"Simple Studio Profile @ Level 4\"},\n\t{0xE5, \"Core Studio Profile @ Level 1\"},\n\t{0xE6, \"Core Studio Profile @ Level 2\"},\n\t{0xE7, \"Core Studio Profile @ Level 3\"},\n\t{0xE8, \"Core Studio Profile @ Level 4\"},\n\t{0xF0, \"Advanced Simple Profile @ Level 0\"},\n\t{0xF1, \"Advanced Simple Profile @ Level 1\"},\n\t{0xF2, \"Advanced Simple Profile @ Level 2\"},\n\t{0xF3, \"Advanced Simple Profile @ Level 3\"},\n\t{0xF4, \"Advanced Simple Profile @ Level 4\"},\n\t{0xF5, \"Advanced Simple Profile @ Level 5\"},\n\t{0xF7, \"Advanced Simple Profile @ Level 3b\"},\n\t{0xF8, \"Fine Granularity Scalable Profile @ Level 0\"},\n\t{0xF9, \"Fine Granularity Scalable Profile @ Level 1\"},\n\t{0xFA, \"Fine Granularity Scalable Profile @ Level 2\"},\n\t{0xFB, \"Fine Granularity Scalable Profile @ Level 3\"},\n\t{0xFC, \"Fine Granularity Scalable Profile @ Level 4\"},\n\t{0xFD, \"Fine Granularity Scalable Profile @ Level 5\"},\n\t{0xFE, \"Not part of MPEG-4 Visual profiles\"},\n\t{0xFF, \"No visual capability required\"}\n};\n\nGF_EXPORT\nconst char *gf_m4v_get_profile_name(u8 video_pl)\n{\n\tu32 i, count = GF_ARRAY_LENGTH(M4VProfiles);\n\tfor (i=0; i<count; i++) {\n\t\tif ((u32)video_pl == M4VProfiles[i].value)\n\t\t\treturn M4VProfiles[i].name;\n\t}\n\treturn \"ISO Reserved Profile\";\n}\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n#define MPEG12_START_CODE_PREFIX\t\t0x000001\n#define MPEG12_PICTURE_START_CODE\t\t0x00000100\n#define MPEG12_SLICE_MIN_START\t\t\t0x00000101\n#define MPEG12_SLICE_MAX_START\t\t\t0x000001af\n#define MPEG12_USER_DATA_START_CODE\t\t0x000001b2\n#define MPEG12_SEQUENCE_START_CODE\t\t0x000001b3\n#define MPEG12_SEQUENCE_ERR_START_CODE\t0x000001b4\n#define MPEG12_EXT_START_CODE\t\t\t0x000001b5\n#define MPEG12_SEQUENCE_END_START_CODE\t0x000001b7\n#define MPEG12_GOP_START_CODE\t\t\t0x000001b8\n\ns32 gf_mv12_next_start_code(unsigned char *pbuffer, u32 buflen, u32 *optr, u32 *scode)\n{\n\tu32 value;\n\tu32 offset;\n\n\tif (buflen < 4) return -1;\n\tfor (offset = 0; offset < buflen - 3; offset++, pbuffer++) {\n#ifdef GPAC_BIG_ENDIAN\n\t\tvalue = *(u32 *)pbuffer >> 8;\n#else\n\t\tvalue = (pbuffer[0] << 16) | (pbuffer[1] << 8) | (pbuffer[2] << 0);\n#endif\n\n\t\tif (value == MPEG12_START_CODE_PREFIX) {\n\t\t\t*optr = offset;\n\t\t\t*scode = (value << 8) | pbuffer[3];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\ns32 gf_mv12_next_slice_start(unsigned char *pbuffer, u32 startoffset, u32 buflen, u32 *slice_offset)\n{\n\tu32 slicestart, code;\n\twhile (gf_mv12_next_start_code(pbuffer + startoffset, buflen - startoffset, &slicestart, &code) >= 0) {\n\t\tif ((code >= MPEG12_SLICE_MIN_START) && (code <= MPEG12_SLICE_MAX_START)) {\n\t\t\t*slice_offset = slicestart + startoffset;\n\t\t\treturn 0;\n\t\t}\n\t\tstartoffset += slicestart + 4;\n\t}\n\treturn -1;\n}\n\n\n/*\n\tMPEG-4 video (14496-2)\n*/\n\nstruct __tag_m4v_parser\n{\n\tGF_BitStream *bs;\n\tBool mpeg12, step_mode;\n\tu32 current_object_type;\n\tu32 force_next_obj_type;\n\tu64 current_object_start;\n\tu32 tc_dec, prev_tc_dec, tc_disp, prev_tc_disp;\n};\n\nGF_EXPORT\nGF_M4VParser *gf_m4v_parser_new(u8 *data, u64 data_size, Bool mpeg12video)\n{\n\tGF_M4VParser *tmp;\n\tif (!data || !data_size) return NULL;\n\tGF_SAFEALLOC(tmp, GF_M4VParser);\n\tif (!tmp) return NULL;\n\ttmp->bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\ttmp->mpeg12 = mpeg12video;\n\treturn tmp;\n}\n\nGF_M4VParser *gf_m4v_parser_bs_new(GF_BitStream *bs, Bool mpeg12video)\n{\n\tGF_M4VParser *tmp;\n\tGF_SAFEALLOC(tmp, GF_M4VParser);\n\tif (!tmp) return NULL;\n\ttmp->bs = bs;\n\ttmp->mpeg12 = mpeg12video;\n\treturn tmp;\n}\n\nGF_EXPORT\nvoid gf_m4v_parser_del(GF_M4VParser *m4v)\n{\n\tgf_bs_del(m4v->bs);\n\tgf_free(m4v);\n}\n\nGF_EXPORT\nvoid gf_m4v_parser_del_no_bs(GF_M4VParser *m4v)\n{\n\tgf_free(m4v);\n}\n\nGF_EXPORT\nvoid gf_m4v_parser_set_inspect(GF_M4VParser *m4v)\n{\n\tif (m4v) m4v->step_mode = 1;\n}\nGF_EXPORT\nu32 gf_m4v_parser_get_obj_type(GF_M4VParser *m4v)\n{\n\tif (m4v) return m4v->current_object_type;\n\treturn 0;\n}\n\n#define M4V_CACHE_SIZE\t\t4096\ns32 M4V_LoadObject(GF_M4VParser *m4v)\n{\n\tu32 v, bpos, found;\n\tchar m4v_cache[M4V_CACHE_SIZE];\n\tu64 end, cache_start, load_size;\n\tif (!m4v) return 0;\n\tif (m4v->force_next_obj_type) {\n\t\tm4v->current_object_type = m4v->force_next_obj_type - 1;\n\t\tm4v->force_next_obj_type = 0;\n\t\treturn (s32)m4v->current_object_type;\n\t}\n\n\tbpos = 0;\n\tfound = 0;\n\tload_size = 0;\n\tend = 0;\n\tcache_start = 0;\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\t/*refill cache*/\n\t\tif (bpos == (u32)load_size) {\n\t\t\tif (!gf_bs_available(m4v->bs)) break;\n\t\t\tload_size = gf_bs_available(m4v->bs);\n\t\t\tif (load_size > M4V_CACHE_SIZE) load_size = M4V_CACHE_SIZE;\n\t\t\tbpos = 0;\n\t\t\tcache_start = gf_bs_get_position(m4v->bs);\n\t\t\tgf_bs_read_data(m4v->bs, m4v_cache, (u32)load_size);\n\t\t}\n\t\tv = ((v << 8) & 0xFFFFFF00) | ((u8)m4v_cache[bpos]);\n\t\tbpos++;\n\t\tif ((v & 0xFFFFFF00) == 0x00000100) {\n\t\t\tend = cache_start + bpos - 4;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) return -1;\n\tm4v->current_object_start = end;\n\tgf_bs_seek(m4v->bs, end + 3);\n\tm4v->current_object_type = gf_bs_read_u8(m4v->bs);\n\treturn (s32)m4v->current_object_type;\n}\n\n\nGF_EXPORT\nvoid gf_m4v_rewrite_pl(u8 **o_data, u32 *o_dataLen, u8 PL)\n{\n\tu32 pos = 0;\n\tunsigned char *data = (unsigned char *)*o_data;\n\tu32 dataLen = *o_dataLen;\n\n\twhile (pos + 4 < dataLen) {\n\t\tif (!data[pos] && !data[pos + 1] && (data[pos + 2] == 0x01) && (data[pos + 3] == M4V_VOS_START_CODE)) {\n\t\t\tdata[pos + 4] = PL;\n\t\t\treturn;\n\t\t}\n\t\tpos++;\n\t}\n\t/*emulate VOS at beggining*/\n\t(*o_data) = (char *)gf_malloc(sizeof(char)*(dataLen + 5));\n\t(*o_data)[0] = 0;\n\t(*o_data)[1] = 0;\n\t(*o_data)[2] = 1;\n\t(*o_data)[3] = (char)M4V_VOS_START_CODE;\n\t(*o_data)[4] = PL;\n\tmemcpy((*o_data + 5), data, sizeof(char)*dataLen);\n\tgf_free(data);\n\t(*o_dataLen) = dataLen + 5;\n}\n\nstatic GF_Err M4V_Reset(GF_M4VParser *m4v, u64 start)\n{\n\tgf_bs_seek(m4v->bs, start);\n\n\tassert(start < (u64)1<<31);\n\tm4v->current_object_start = (u32)start;\n\tm4v->current_object_type = 0;\n\treturn GF_OK;\n}\n\nvoid gf_m4v_parser_reset(GF_M4VParser *m4v, u8 sc_type)\n{\n\tm4v->current_object_start = 0;\n\tm4v->current_object_type = 0;\n\tm4v->force_next_obj_type = sc_type;\n}\nstatic GF_Err gf_m4v_parse_config_mpeg12(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\tunsigned char p[4];\n\tu32 ext_type;\n\ts32 o_type;\n\tu8 go, par;\n\n\tif (!m4v || !dsi) return GF_BAD_PARAM;\n\n\tmemset(dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tdsi->VideoPL = 0;\n\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M2V_SEQ_START_CODE:\n\t\t\tdsi->RAP_stream = 1;\n\t\t\tgf_bs_read_data(m4v->bs, (char *)p, 4);\n\t\t\tdsi->width = (p[0] << 4) | ((p[1] >> 4) & 0xf);\n\t\t\tdsi->height = ((p[1] & 0xf) << 8) | p[2];\n\n\t\t\tdsi->VideoPL = GF_CODECID_MPEG1;\n\t\t\tpar = (p[3] >> 4) & 0xf;\n\t\t\tswitch (par) {\n\t\t\tcase 2:\n\t\t\t\tdsi->par_num = dsi->height / 3;\n\t\t\t\tdsi->par_den = dsi->width / 4;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdsi->par_num = dsi->height / 9;\n\t\t\t\tdsi->par_den = dsi->width / 16;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdsi->par_num = dsi->height / 2;\n\t\t\t\tdsi->par_den = dsi->width / 21;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdsi->par_den = dsi->par_num = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (p[3] & 0xf) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdsi->fps = 24000.0 / 1001.0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdsi->fps = 24.0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdsi->fps = 25.0;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdsi->fps = 30000.0 / 1001.0;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tdsi->fps = 30.0;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tdsi->fps = 50.0;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tdsi->fps = ((60.0*1000.0) / 1001.0);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tdsi->fps = 60.0;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tdsi->fps = 1;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tdsi->fps = 5;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tdsi->fps = 10;\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\tdsi->fps = 12;\n\t\t\t\tbreak;\n\t\t\tcase 13:\n\t\t\t\tdsi->fps = 15;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase M2V_EXT_START_CODE:\n\t\t\tgf_bs_read_data(m4v->bs, (char *)p, 4);\n\t\t\text_type = ((p[0] >> 4) & 0xf);\n\t\t\tif (ext_type == 1) {\n\t\t\t\tdsi->VideoPL = 0x65;\n\t\t\t\tdsi->height = ((p[1] & 0x1) << 13) | ((p[2] & 0x80) << 5) | (dsi->height & 0x0fff);\n\t\t\t\tdsi->width = (((p[2] >> 5) & 0x3) << 12) | (dsi->width & 0x0fff);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase M2V_PIC_START_CODE:\n\t\t\tif (dsi->width) go = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t\t/*EOS*/\n\t\tcase -1:\n\t\t\tgo = 0;\n\t\t\tm4v->current_object_start = gf_bs_get_position(m4v->bs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tM4V_Reset(m4v, 0);\n\treturn GF_OK;\n}\n\n\nstatic const struct {\n\tu32 w, h;\n} m4v_sar[6] = { { 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 }, { 16, 11 }, { 40, 33 } };\n\nstatic u8 m4v_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif ((m4v_sar[i].w == w) && (m4v_sar[i].h == h)) return i;\n\t}\n\treturn 0xF;\n}\n\nstatic void gf_m4v_parse_vol(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\tu8 verid, par;\n\ts32 clock_rate;\n\tu8 vpl = dsi->VideoPL;\n\n\tmemset(dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tdsi->VideoPL = vpl;\n\n\tverid = 0;\n\tdsi->RAP_stream = gf_bs_read_int(m4v->bs, 1);\n\tdsi->objectType = gf_bs_read_int(m4v->bs, 8);\n\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\tverid = gf_bs_read_int(m4v->bs, 4);\n\t\tgf_bs_read_int(m4v->bs, 3);\n\t}\n\tpar = gf_bs_read_int(m4v->bs, 4);\n\tif (par == 0xF) {\n\t\tdsi->par_num = gf_bs_read_int(m4v->bs, 8);\n\t\tdsi->par_den = gf_bs_read_int(m4v->bs, 8);\n\t} else if (par<6) {\n\t\tdsi->par_num = m4v_sar[par].w;\n\t\tdsi->par_den = m4v_sar[par].h;\n\t}\n\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\tgf_bs_read_int(m4v->bs, 3);\n\t\tif (gf_bs_read_int(m4v->bs, 1)) gf_bs_read_int(m4v->bs, 79);\n\t}\n\tdsi->has_shape = gf_bs_read_int(m4v->bs, 2);\n\tif (dsi->has_shape && (verid!=1) ) gf_bs_read_int(m4v->bs, 4);\n\tgf_bs_read_int(m4v->bs, 1);\n\t/*clock rate*/\n\tdsi->clock_rate = gf_bs_read_int(m4v->bs, 16);\n\t/*marker*/\n\tgf_bs_read_int(m4v->bs, 1);\n\n\tclock_rate = dsi->clock_rate-1;\n\tif (clock_rate >= 65536) clock_rate = 65535;\n\tif (clock_rate > 0) {\n\t\tfor (dsi->NumBitsTimeIncrement = 1; dsi->NumBitsTimeIncrement < 16; dsi->NumBitsTimeIncrement++)\t{\n\t\t\tif (clock_rate == 1) break;\n\t\t\tclock_rate = (clock_rate >> 1);\n\t\t}\n\t} else {\n\t\t/*fix from vivien for divX*/\n\t\tdsi->NumBitsTimeIncrement = 1;\n\t}\n\t/*fixed FPS stream*/\n\tdsi->time_increment = 0;\n\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\tdsi->time_increment = gf_bs_read_int(m4v->bs, dsi->NumBitsTimeIncrement);\n\t}\n\tif (!dsi->has_shape) {\n\t\tgf_bs_read_int(m4v->bs, 1);\n\t\tdsi->width = gf_bs_read_int(m4v->bs, 13);\n\t\tgf_bs_read_int(m4v->bs, 1);\n\t\tdsi->height = gf_bs_read_int(m4v->bs, 13);\n\t} else {\n\t\tdsi->width = dsi->height = 0;\n\t}\n\tgf_bs_align(m4v->bs);\n}\n\nstatic GF_Err gf_m4v_parse_config_mpeg4(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\ts32 o_type;\n\tu8 go;\n\n\tif (!m4v || !dsi) return GF_BAD_PARAM;\n\n\tmemset(dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\t\t/*vosh*/\n\t\tcase M4V_VOS_START_CODE:\n\t\t\tdsi->VideoPL = (u8)gf_bs_read_u8(m4v->bs);\n\t\t\tbreak;\n\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tgf_m4v_parse_vol(m4v, dsi);\n\t\t\t/*shape will be done later*/\n\t\t\tgf_bs_align(m4v->bs);\n\t\t\tbreak;\n\n\t\tcase M4V_VOP_START_CODE:\n\t\tcase M4V_GOV_START_CODE:\n\t\t\tgo = 0;\n\t\t\tbreak;\n\t\t\t/*EOS*/\n\t\tcase -1:\n\t\t\tm4v->current_object_start = gf_bs_get_position(m4v->bs);\n\t\t\treturn GF_EOS;\n\t\t\t/*don't interest us*/\n\t\tcase M4V_UDTA_START_CODE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4v_parse_config(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\tif (m4v->mpeg12) {\n\t\treturn gf_m4v_parse_config_mpeg12(m4v, dsi);\n\t}\n\telse {\n\t\treturn gf_m4v_parse_config_mpeg4(m4v, dsi);\n\t}\n}\n\nstatic GF_Err gf_m4v_parse_frame_mpeg12(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tu8 go, hasVOP, firstObj, val;\n\ts32 o_type;\n\n\tif (!m4v || !size || !start || !frame_type) return GF_BAD_PARAM;\n\n\t*size = 0;\n\tfirstObj = 1;\n\thasVOP = 0;\n\t*is_coded = GF_FALSE;\n\t*frame_type = 0;\n\n\tif (!m4v->step_mode)\n\t\tM4V_Reset(m4v, m4v->current_object_start);\n\n\tm4v->current_object_type = (u32)-1;\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M2V_PIC_START_CODE:\n\t\t\t/*done*/\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\thasVOP = 1;\n\t\t\t*is_coded = 1;\n\n\t\t\t/*val = */gf_bs_read_u8(m4v->bs);\n\t\t\tval = gf_bs_read_u8(m4v->bs);\n\t\t\t*frame_type = ((val >> 3) & 0x7) - 1;\n\t\t\tbreak;\n\t\tcase M2V_GOP_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) go = 0;\n\t\t\tbreak;\n\n\t\tcase M2V_SEQ_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/**/\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t*size = gf_bs_get_position(m4v->bs) - *start;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\tif (m4v->step_mode)\n\t\t\treturn GF_OK;\n\t}\n\t*size = m4v->current_object_start - *start;\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_m4v_parse_frame_mpeg4(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tu8 go, hasVOP, firstObj, secs;\n\ts32 o_type;\n\tu32 vop_inc = 0;\n\n\tif (!m4v || !size || !start || !frame_type) return GF_BAD_PARAM;\n\n\t*size = 0;\n\tfirstObj = 1;\n\thasVOP = 0;\n\t*is_coded = 0;\n\tm4v->current_object_type = (u32)-1;\n\t*frame_type = 0;\n\t*start = 0;\n\n\tif (!m4v->step_mode)\n\t\tM4V_Reset(m4v, m4v->current_object_start);\n\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M4V_VOP_START_CODE:\n\t\t\t/*done*/\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\thasVOP = 1;\n\n\t\t\t/*coding type*/\n\t\t\t*frame_type = gf_bs_read_int(m4v->bs, 2);\n\t\t\t/*modulo time base*/\n\t\t\tsecs = 0;\n\t\t\twhile (gf_bs_read_int(m4v->bs, 1) != 0)\n\t\t\t\tsecs++;\n\t\t\t/*no support for B frames in parsing*/\n\t\t\tsecs += (dsi->enh_layer || *frame_type!=2) ? m4v->tc_dec : m4v->tc_disp;\n\t\t\t/*marker*/\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t/*vop_time_inc*/\n\t\t\tif (dsi->NumBitsTimeIncrement)\n\t\t\t\tvop_inc = gf_bs_read_int(m4v->bs, dsi->NumBitsTimeIncrement);\n\n\t\t\tm4v->prev_tc_dec = m4v->tc_dec;\n\t\t\tm4v->prev_tc_disp = m4v->tc_disp;\n\t\t\tif (dsi->enh_layer || *frame_type!=2) {\n\t\t\t\tm4v->tc_disp = m4v->tc_dec;\n\t\t\t\tm4v->tc_dec = secs;\n\t\t\t}\n\t\t\t*time_inc = secs * dsi->clock_rate + vop_inc;\n\t\t\t/*marker*/\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t/*coded*/\n\t\t\t*is_coded = gf_bs_read_int(m4v->bs, 1);\n\t\t\tgf_bs_align(m4v->bs);\n\t\t\tbreak;\n\t\tcase M4V_GOV_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) go = 0;\n\t\t\tbreak;\n\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tif (m4v->step_mode)\n\t\t\t\tgf_m4v_parse_vol(m4v, dsi);\n\t\tcase M4V_VOS_START_CODE:\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t}\n\t\t\telse if (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase M4V_VO_START_CODE:\n\t\tdefault:\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t*size = gf_bs_get_position(m4v->bs) - *start;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\tif (m4v->step_mode)\n\t\t\treturn GF_OK;\n\t}\n\tassert(m4v->current_object_start >= *start);\n\t*size = m4v->current_object_start - *start;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4v_parse_frame(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tif (m4v->mpeg12) {\n\t\treturn gf_m4v_parse_frame_mpeg12(m4v, dsi, frame_type, time_inc, size, start, is_coded);\n\t}\n\telse {\n\t\treturn gf_m4v_parse_frame_mpeg4(m4v, dsi, frame_type, time_inc, size, start, is_coded);\n\t}\n}\n\nGF_Err gf_m4v_rewrite_par(u8 **o_data, u32 *o_dataLen, s32 par_n, s32 par_d)\n{\n\tu64 start, end, size;\n\tGF_BitStream *mod;\n\tGF_M4VParser *m4v;\n\tBool go = 1;\n\n\tm4v = gf_m4v_parser_new(*o_data, *o_dataLen, 0);\n\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tstart = 0;\n\twhile (go) {\n\t\tu32 type = M4V_LoadObject(m4v);\n\n\t\tend = gf_bs_get_position(m4v->bs) - 4;\n\t\tsize = end - start;\n\t\t/*store previous object*/\n\t\tif (size) {\n\t\t\tassert (size < (u64)1<<31);\n\t\t\tgf_bs_write_data(mod, *o_data + start, (u32)size);\n\t\t\tstart = end;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tgf_bs_write_int(mod, 0, 8);\n\t\t\tgf_bs_write_int(mod, 0, 8);\n\t\t\tgf_bs_write_int(mod, 1, 8);\n\t\t\tgf_bs_write_int(mod, M4V_VOL_START_CODE, 8);\n\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 1), 1);\n\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 8), 8);\n\t\t\tstart = gf_bs_read_int(m4v->bs, 1);\n\t\t\tgf_bs_write_int(mod, (u32)start, 1);\n\t\t\tif (start) {\n\t\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 7), 7);\n\t\t\t}\n\t\t\tstart = gf_bs_read_int(m4v->bs, 4);\n\t\t\tif (start == 0xF) {\n\t\t\t\tgf_bs_read_int(m4v->bs, 8);\n\t\t\t\tgf_bs_read_int(m4v->bs, 8);\n\t\t\t}\n\t\t\tif ((par_n >= 0) && (par_d >= 0)) {\n\t\t\t\tu8 par = m4v_get_sar_idx(par_n, par_d);\n\t\t\t\tgf_bs_write_int(mod, par, 4);\n\t\t\t\tif (par == 0xF) {\n\t\t\t\t\tgf_bs_write_int(mod, par_n, 8);\n\t\t\t\t\tgf_bs_write_int(mod, par_d, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgf_bs_write_int(mod, 0x0, 4);\n\t\t\t}\n\t\tcase -1:\n\t\t\tgo = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (gf_bs_bits_available(m4v->bs)) {\n\t\tu32 b = gf_bs_read_int(m4v->bs, 1);\n\t\tgf_bs_write_int(mod, b, 1);\n\t}\n\n\tgf_m4v_parser_del(m4v);\n\tgf_free(*o_data);\n\tgf_bs_get_content(mod, o_data, o_dataLen);\n\tgf_bs_del(mod);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu64 gf_m4v_get_object_start(GF_M4VParser *m4v)\n{\n\treturn m4v->current_object_start;\n}\n\n#if 0 //unused\nBool gf_m4v_is_valid_object_type(GF_M4VParser *m4v)\n{\n\treturn ((s32)m4v->current_object_type == -1) ? 0 : 1;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_m4v_get_config(u8 *rawdsi, u32 rawdsi_size, GF_M4VDecSpecInfo *dsi)\n{\n\tGF_Err e;\n\tGF_M4VParser *vparse;\n\tif (!rawdsi || !rawdsi_size) return GF_NON_COMPLIANT_BITSTREAM;\n\tvparse = gf_m4v_parser_new(rawdsi, rawdsi_size, 0);\n\te = gf_m4v_parse_config(vparse, dsi);\n\tdsi->next_object_start = (u32)vparse->current_object_start;\n\tgf_m4v_parser_del(vparse);\n\treturn e < 0 ? e : GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_mpegv12_get_config(u8 *rawdsi, u32 rawdsi_size, GF_M4VDecSpecInfo *dsi)\n{\n\tGF_Err e;\n\tGF_M4VParser *vparse;\n\tif (!rawdsi || !rawdsi_size) return GF_NON_COMPLIANT_BITSTREAM;\n\tvparse = gf_m4v_parser_new(rawdsi, rawdsi_size, GF_TRUE);\n\te = gf_m4v_parse_config(vparse, dsi);\n\tdsi->next_object_start = (u32)vparse->current_object_start;\n\tgf_m4v_parser_del(vparse);\n\treturn e;\n}\n\n#endif\n\n\n/*\n\tAAC parser\n*/\n\nstruct __m4a_oti\n{\n\tu32 type;\n\tconst char *name;\n} M4AObjectTypes[] = {\n\t{0, \"MPEG-4 Audio Reserved\"},\n\t{1, \"MPEG-4 Audio AAC Main\"},\n\t{2, \"MPEG-4 Audio AAC LC\"},\n\t{3, \"MPEG-4 Audio AAC SSR\"},\n\t{4, \"MPEG-4 Audio AAC LTP\"},\n\t{5, \"MPEG-4 Audio SBR\"},\n\t{6, \"MPEG-4 Audio AAC Scalable\"},\n\t{7, \"MPEG-4 Audio TwinVQ\"},\n\t{8, \"MPEG-4 Audio CELP\"},\n\t{9, \"MPEG-4 Audio HVXC\"},\n\t{10, \"MPEG-4 Audio Reserved\"},\n\t{11, \"MPEG-4 Audio Reserved\"},\n\t{12, \"MPEG-4 Audio TTSI\"},\n\t{13, \"MPEG-4 Audio Main synthetic\"},\n\t{14, \"MPEG-4 Audio Wavetable synthesis\"},\n\t{15, \"MPEG-4 Audio General MIDI\"},\n\t{16, \"MPEG-4 Audio Algorithmic Synthesis and Audio FX\"},\n\t{17, \"MPEG-4 Audio ER AAC LC\"},\n\t{18, \"MPEG-4 Audio Reserved\"},\n\t{19, \"MPEG-4 Audio ER AAC LTP\"},\n\t{20, \"MPEG-4 Audio ER AAC scalable\"},\n\t{21, \"MPEG-4 Audio ER TwinVQ\"},\n\t{22, \"MPEG-4 Audio ER BSAC\"},\n\t{23, \"MPEG-4 Audio ER AAC LD\"},\n\t{24, \"MPEG-4 Audio ER CELP\"},\n\t{25, \"MPEG-4 Audio ER HVXC\"},\n\t{26, \"MPEG-4 Audio ER HILN\"},\n\t{27, \"MPEG-4 Audio ER Parametric\"},\n\t{28, \"MPEG-4 Audio SSC\"},\n\t{29, \"MPEG-4 Audio ParametricStereo\"},\n\t{30, \"MPEG-4 Audio Reserved\"},\n\t{31, \"MPEG-4 Audio Reserved\"},\n\t{32, \"MPEG-1 Audio Layer-1\"},\n\t{33, \"MPEG-1 Audio Layer-2\"},\n\t{34, \"MPEG-1 Audio Layer-3\"},\n\t{35, \"MPEG-4 Audio DST\"},\n\t{36, \"MPEG-4 Audio ALS\"},\n\t{37, \"MPEG-4 Audio SLS\"},\n\t{42, \"MPEG Audio xHE-AAC\"},\n};\n\nGF_EXPORT\nconst char *gf_m4a_object_type_name(u32 objectType)\n{\n\tu32 i, count = GF_ARRAY_LENGTH(M4AObjectTypes);\n\tfor (i=0; i<count; i++) {\n\t\tif (objectType==M4AObjectTypes[i].type)\n\t\t\treturn M4AObjectTypes[i].name;\n\t}\n\treturn \"MPEG-4 Audio Unknown\";\n}\n\nstruct __m4a_profile\n{\n\tu32 value;\n\tconst char *name;\n} M4AProfiles[] = {\n\t{0x00, \"ISO Reserved (0x00)\"},\n\t{0x01, \"Main Audio Profile @ Level 1\"},\n\t{0x02, \"Main Audio Profile @ Level 2\"},\n\t{0x03, \"Main Audio Profile @ Level 3\"},\n\t{0x04, \"Main Audio Profile @ Level 4\"},\n\t{0x05, \"Scalable Audio Profile @ Level 1\"},\n\t{0x06, \"Scalable Audio Profile @ Level 2\"},\n\t{0x07, \"Scalable Audio Profile @ Level 3\"},\n\t{0x08, \"Scalable Audio Profile @ Level 4\"},\n\t{0x09, \"Speech Audio Profile @ Level 1\"},\n\t{0x0A, \"Speech Audio Profile @ Level 2\"},\n\t{0x0B, \"Synthetic Audio Profile @ Level 1\"},\n\t{0x0C, \"Synthetic Audio Profile @ Level 2\"},\n\t{0x0D, \"Synthetic Audio Profile @ Level 3\"},\n\t{0x0E, \"High Quality Audio Profile @ Level 1\"},\n\t{0x0F, \"High Quality Audio Profile @ Level 2\"},\n\t{0x10, \"High Quality Audio Profile @ Level 3\"},\n\t{0x11, \"High Quality Audio Profile @ Level 4\"},\n\t{0x12, \"High Quality Audio Profile @ Level 5\"},\n\t{0x13, \"High Quality Audio Profile @ Level 6\"},\n\t{0x14, \"High Quality Audio Profile @ Level 7\"},\n\t{0x15, \"High Quality Audio Profile @ Level 8\"},\n\t{0x16, \"Low Delay Audio Profile @ Level 1\"},\n\t{0x17, \"Low Delay Audio Profile @ Level 2\"},\n\t{0x18, \"Low Delay Audio Profile @ Level 3\"},\n\t{0x19, \"Low Delay Audio Profile @ Level 4\"},\n\t{0x1A, \"Low Delay Audio Profile @ Level 5\"},\n\t{0x1B, \"Low Delay Audio Profile @ Level 6\"},\n\t{0x1C, \"Low Delay Audio Profile @ Level 7\"},\n\t{0x1D, \"Low Delay Audio Profile @ Level 8\"},\n\t{0x1E, \"Natural Audio Profile @ Level 1\"},\n\t{0x1F, \"Natural Audio Profile @ Level 2\"},\n\t{0x20, \"Natural Audio Profile @ Level 3\"},\n\t{0x21, \"Natural Audio Profile @ Level 4\"},\n\t{0x22, \"Mobile Audio Internetworking Profile @ Level 1\"},\n\t{0x23, \"Mobile Audio Internetworking Profile @ Level 2\"},\n\t{0x24, \"Mobile Audio Internetworking Profile @ Level 3\"},\n\t{0x25, \"Mobile Audio Internetworking Profile @ Level 4\"},\n\t{0x26, \"Mobile Audio Internetworking Profile @ Level 5\"},\n\t{0x27, \"Mobile Audio Internetworking Profile @ Level 6\"},\n\t{0x28, \"AAC Profile @ Level 1\"},\n\t{0x29, \"AAC Profile @ Level 2\"},\n\t{0x2A, \"AAC Profile @ Level 4\"},\n\t{0x2B, \"AAC Profile @ Level 5\"},\n\t{0x2C, \"High Efficiency AAC Profile @ Level 2\"},\n\t{0x2D, \"High Efficiency AAC Profile @ Level 3\"},\n\t{0x2E, \"High Efficiency AAC Profile @ Level 4\"},\n\t{0x2F, \"High Efficiency AAC Profile @ Level 5\"},\n\t{0x30, \"High Efficiency AAC v2 Profile @ Level 2\"},\n\t{0x31, \"High Efficiency AAC v2 Profile @ Level 3\"},\n\t{0x32, \"High Efficiency AAC v2 Profile @ Level 4\"},\n\t{0x33, \"High Efficiency AAC v2 Profile @ Level 5\"},\n\t{0x34, \"Low Delay AAC Profile\"},\n\t{0x35, \"Baseline MPEG Surround Profile @ Level 1\"},\n\t{0x36, \"Baseline MPEG Surround Profile @ Level 2\"},\n\t{0x37, \"Baseline MPEG Surround Profile @ Level 3\"},\n\t{0x38, \"Baseline MPEG Surround Profile @ Level 4\"},\n\t{0x39, \"Baseline MPEG Surround Profile @ Level 5\"},\n\t{0x3A, \"Baseline MPEG Surround Profile @ Level 6\"},\n\t{0x3B, \"High Definition AAC Profile @ Level 1\"},\n\t{0x3C, \"ALS Simple Profile @ Level 1\"},\n\t{0x50, \"AAC Profile @ Level 6\"},\n\t{0x51, \"AAC Profile @ Level 7\"},\n\t{0x52, \"High Efficiency AAC Profile @ Level 6\"},\n\t{0x53, \"High Efficiency AAC Profile @ Level 7\"},\n\t{0x54, \"High Efficiency AAC v2 Profile @ Level 6\"},\n\t{0x55, \"High Efficiency AAC v2 Profile @ Level 7\"},\n\t{0x56, \"Extended High Efficiency AAC Profile @ Level 6\"},\n\t{0x57, \"Extended High Efficiency AAC Profile @ Level 7\"},\n\t{0xFE, \"Not part of MPEG-4 audio profiles\"},\n\t{0xFF, \"No audio capability required\"}\n};\n\nGF_EXPORT\nconst char *gf_m4a_get_profile_name(u8 audio_pl)\n{\n\tu32 i, count = GF_ARRAY_LENGTH(M4AProfiles);\n\tfor (i=0; i<count; i++) {\n\t\tif ((u32) audio_pl==M4AProfiles[i].value)\n\t\t\treturn M4AProfiles[i].name;\n\t}\n\treturn \"ISO Reserved / User Private\";\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nGF_EXPORT\nu32 gf_m4a_get_profile(GF_M4ADecSpecInfo *cfg)\n{\n\tswitch (cfg->base_object_type) {\n\tcase 2: /*AAC LC*/\n\t\tif (cfg->nb_chan <= 2)\n\t\t\treturn (cfg->base_sr <= 24000) ? 0x28 : 0x29; /*LC@L1 or LC@L2*/\n\t\tif (cfg->nb_chan <= 5)\n\t\t\treturn (cfg->base_sr <= 48000) ? 0x2A : 0x2B; /*LC@L4 or LC@L5*/\n\t\treturn (cfg->base_sr <= 48000) ? 0x50 : 0x51; /*LC@L4 or LC@L5*/\n\tcase 5: /*HE-AAC - SBR*/\n\t\tif (cfg->nb_chan <= 2)\n\t\t\treturn (cfg->base_sr <= 24000) ? 0x2C : 0x2D; /*HE@L2 or HE@L3*/\n\t\tif (cfg->nb_chan <= 5)\n\t\t\treturn (cfg->base_sr <= 48000) ? 0x2E : 0x2F; /*HE@L4 or HE@L5*/\n\t\treturn (cfg->base_sr <= 48000) ? 0x52 : 0x53; /*HE@L6 or HE@L7*/\n\tcase 29: /*HE-AACv2 - SBR+PS*/\n\t\tif (cfg->nb_chan <= 2)\n\t\t\treturn (cfg->base_sr <= 24000) ? 0x30 : 0x31; /*HE-AACv2@L2 or HE-AACv2@L3*/\n\t\tif (cfg->nb_chan <= 5)\n\t\t\treturn (cfg->base_sr <= 48000) ? 0x32 : 0x33; /*HE-AACv2@L4 or HE-AACv2@L5*/\n\t\treturn (cfg->base_sr <= 48000) ? 0x54 : 0x55; /*HE-AACv2@L6 or HE-AACv2@L7*/\n\t/*default to HQ*/\n\tdefault:\n\t\tif (cfg->nb_chan <= 2) return (cfg->base_sr < 24000) ? 0x0E : 0x0F; /*HQ@L1 or HQ@L2*/\n\t\treturn 0x10; /*HQ@L3*/\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_m4a_parse_program_config_element(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg)\n{\n\tu32 i;\n\n\tcfg->program_config_element_present = 1;\n\tcfg->cpe_channels = 0;\n\n\tcfg->element_instance_tag = gf_bs_read_int_log(bs, 4, \"element_instance_tag\");\n\tcfg->object_type = gf_bs_read_int_log(bs, 2, \"object_type\");\n\tcfg->sampling_frequency_index = gf_bs_read_int_log(bs, 4, \"sampling_frequency_index\");\n\tcfg->num_front_channel_elements = gf_bs_read_int_log(bs, 4, \"num_front_channel_elements\");\n\tcfg->num_side_channel_elements = gf_bs_read_int_log(bs, 4, \"num_side_channel_elements\");\n\tcfg->num_back_channel_elements = gf_bs_read_int_log(bs, 4, \"num_back_channel_elements\");\n\tcfg->num_lfe_channel_elements = gf_bs_read_int_log(bs, 2, \"num_lfe_channel_elements\");\n\tcfg->num_assoc_data_elements = gf_bs_read_int_log(bs, 3, \"num_assoc_data_elements\");\n\tcfg->num_valid_cc_elements = gf_bs_read_int_log(bs, 4, \"num_valid_cc_elements\");\n\tcfg->mono_mixdown_present = (Bool)gf_bs_read_int_log(bs, 1, \"mono_mixdown_present\");\n\tif (cfg->mono_mixdown_present) {\n\t\tcfg->mono_mixdown_element_number = gf_bs_read_int_log(bs, 4, \"mono_mixdown_element_number\");\n\t}\n\tcfg->stereo_mixdown_present = gf_bs_read_int_log(bs, 1, \"stereo_mixdown_present\");\n\tif (cfg->stereo_mixdown_present) {\n\t\tcfg->stereo_mixdown_element_number = gf_bs_read_int_log(bs, 4, \"stereo_mixdown_element_number\");\n\t}\n\tcfg->matrix_mixdown_idx_present = gf_bs_read_int_log(bs, 1, \"matrix_mixdown_idx_present\");\n\tif (cfg->matrix_mixdown_idx_present) {\n\t\tcfg->matrix_mixdown_idx = gf_bs_read_int_log(bs, 2, \"matrix_mixdown_idx\");\n\t\tcfg->pseudo_surround_enable = gf_bs_read_int_log(bs, 1, \"pseudo_surround_enable\");\n\t}\n\tfor (i = 0; i < cfg->num_front_channel_elements; i++) {\n\t\tcfg->front_element_is_cpe[i] = gf_bs_read_int_log_idx(bs, 1, \"front_element_is_cpe\", i);\n\t\tcfg->front_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"front_element_tag_select\", i);\n\t\tif (cfg->front_element_is_cpe[i]) cfg->cpe_channels++;\n\t}\n\tfor (i = 0; i < cfg->num_side_channel_elements; i++) {\n\t\tcfg->side_element_is_cpe[i] = gf_bs_read_int_log_idx(bs, 1, \"side_element_is_cpe\", i);\n\t\tcfg->side_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"side_element_tag_select\", i);\n\t\tif (cfg->side_element_is_cpe[i]) cfg->cpe_channels++;\n\t}\n\tfor (i = 0; i < cfg->num_back_channel_elements; i++) {\n\t\tcfg->back_element_is_cpe[i] = gf_bs_read_int_log_idx(bs, 1, \"back_element_is_cpe\", i);\n\t\tcfg->back_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"back_element_tag_select\", i);\n\t\tif (cfg->back_element_is_cpe[i]) cfg->cpe_channels++;\n\t}\n\tfor (i = 0; i < cfg->num_lfe_channel_elements; i++) {\n\t\tcfg->lfe_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"lfe_element_tag_select\", i);\n\t}\n\tfor (i = 0; i < cfg->num_assoc_data_elements; i++) {\n\t\tcfg->assoc_data_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"assoc_data_element_tag_select\", i);\n\t}\n\n\tfor (i = 0; i < cfg->num_valid_cc_elements; i++) {\n\t\tcfg->cc_element_is_ind_sw[i] = gf_bs_read_int_log_idx(bs, 1, \"cc_element_is_ind_sw\", i);\n\t\tcfg->valid_cc_element_tag_select[i] = gf_bs_read_int_log_idx(bs, 4, \"valid_cc_element_tag_select\", i);\n\t}\n\tgf_bs_align(bs);\n\tcfg->comment_field_bytes = gf_bs_read_int_log(bs, 8, \"comment_field_bytes\");\n\tgf_bs_read_data(bs, (char *)cfg->comments, cfg->comment_field_bytes);\n\n\tcfg->nb_chan = cfg->num_front_channel_elements + cfg->num_back_channel_elements + cfg->num_side_channel_elements + cfg->num_lfe_channel_elements;\n\tcfg->nb_chan += cfg->cpe_channels;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_parse_config(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg, Bool size_known)\n{\n\tu32 audio_obj_type;\n\tmemset(cfg, 0, sizeof(GF_M4ADecSpecInfo));\n\tcfg->base_object_type = gf_bs_read_int_log(bs, 5, \"base_object_type\");\n\t/*extended object type*/\n\tif (cfg->base_object_type == 31) {\n\t\tcfg->base_object_type = 32 + gf_bs_read_int_log(bs, 6, \"extended_base_object_type\");\n\t}\n\tcfg->base_sr_index = gf_bs_read_int_log(bs, 4, \"base_samplerate_index\");\n\tif (cfg->base_sr_index == 0x0F) {\n\t\tcfg->base_sr = gf_bs_read_int_log(bs, 24, \"base_samplerate\");\n\t}\n\telse {\n\t\tcfg->base_sr = GF_M4ASampleRates[cfg->base_sr_index];\n\t}\n\n\tcfg->chan_cfg = gf_bs_read_int_log(bs, 4, \"channel_configuration\");\n\tif (cfg->chan_cfg) {\n\t\tcfg->nb_chan = GF_M4ANumChannels[cfg->chan_cfg - 1];\n\t}\n\n\taudio_obj_type = cfg->base_object_type;\n\tif (cfg->base_object_type == 5 || cfg->base_object_type == 29) {\n\t\tif (cfg->base_object_type == 29) {\n\t\t\tcfg->has_ps = 1;\n\t\t\tcfg->nb_chan = 1;\n\t\t}\n\t\tcfg->has_sbr = GF_TRUE;\n\t\tcfg->sbr_sr_index = gf_bs_read_int_log(bs, 4, \"sbr_samplerate_index\");\n\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\tcfg->sbr_sr = gf_bs_read_int_log(bs, 24, \"sbr_samplerate\");\n\t\t}\n\t\telse {\n\t\t\tcfg->sbr_sr = GF_M4ASampleRates[cfg->sbr_sr_index];\n\t\t}\n\t\tcfg->sbr_object_type = gf_bs_read_int_log(bs, 5, \"sbr_object_type\");\n\t\tif (cfg->sbr_object_type==31)\n\t\t\tcfg->sbr_object_type = 32 + gf_bs_read_int_log(bs, 6, \"audioObjectTypeExt\");\n\t\taudio_obj_type = cfg->sbr_object_type;\n\t\tif (cfg->sbr_object_type==22) {\n\t\t\t/*ext_chan_cfg = */gf_bs_read_int_log(bs, 4, \"channel_configuration\");\n\t\t}\n\t}\n\n\t/*object cfg*/\n\tswitch (audio_obj_type) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 6:\n\tcase 7:\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\tcase 42:\n\t{\n\t\tBool ext_flag;\n\t\tgf_bs_read_int_log(bs, 1, \"frame_length_flag\");\n\t\tif (gf_bs_read_int_log(bs, 1, \"depends_on_core_coder\"))\n\t\t\tgf_bs_read_int_log(bs, 14, \"delay\");\n\t\text_flag = gf_bs_read_int_log(bs, 1, \"extension_flag\");\n\n\t\tif (!cfg->chan_cfg) {\n\t\t\tgf_m4a_parse_program_config_element(bs, cfg);\n\t\t}\n\n\t\tif ((cfg->base_object_type == 6) || (cfg->base_object_type == 20)) {\n\t\t\tgf_bs_read_int_log(bs, 3, \"layerN\");\n\t\t}\n\t\tif (ext_flag) {\n\t\t\tif (cfg->base_object_type == 22) {\n\t\t\t\tgf_bs_read_int_log(bs, 5, \"numOfSubFrame\");\n\t\t\t\tgf_bs_read_int_log(bs, 11, \"layer_length\");\n\t\t\t}\n\t\t\tif ((cfg->base_object_type == 17)\n\t\t\t\t|| (cfg->base_object_type == 19)\n\t\t\t\t|| (cfg->base_object_type == 20)\n\t\t\t\t|| (cfg->base_object_type == 23)\n\t\t\t) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"aacSectionDataResilienceFlag\");\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"aacScalefactorDataResilienceFlag\");\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"aacSpectralDataResilienceFlag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"extensionFlag3\");\n\t\t}\n\t}\n\tbreak;\n\t}\n\t/*ER cfg*/\n\tswitch (audio_obj_type) {\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\tcase 24:\n\tcase 25:\n\tcase 26:\n\tcase 27:\n\t{\n\t\tu32 epConfig = gf_bs_read_int_log(bs, 2, \"epConfig\");\n\t\tif ((epConfig == 2) || (epConfig == 3)) {\n\t\t}\n\t\tif (epConfig == 3) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"directMapping\");\n\t\t}\n\t}\n\tbreak;\n\t}\n\n\tif (size_known && (cfg->base_object_type != 5) && (cfg->base_object_type != 29)) {\n\t\twhile (gf_bs_available(bs) >= 2) {\n\t\t\tu32 sync = gf_bs_peek_bits(bs, 11, 0);\n\t\t\tif (sync == 0x2b7) {\n\t\t\t\tgf_bs_read_int_log(bs, 11, \"syncExtensionType\");\n\t\t\t\tcfg->sbr_object_type = gf_bs_read_int_log(bs, 5, \"extensionAudioObjectType \");\n\t\t\t\tcfg->has_sbr = gf_bs_read_int_log(bs, 1, \"sbrPresentFlag\");\n\t\t\t\tif (cfg->has_sbr) {\n\t\t\t\t\tcfg->sbr_sr_index = gf_bs_read_int_log(bs, 4, \"extensionSamplingFrequencyIndex\");\n\t\t\t\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\t\t\t\tcfg->sbr_sr = gf_bs_read_int_log(bs, 24, \"extensionSamplingFrequency\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcfg->sbr_sr = GF_M4ASampleRates[cfg->sbr_sr_index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sync == 0x548) {\n\t\t\t\tgf_bs_read_int_log(bs, 11, \"syncExtensionType\");\n\t\t\t\tcfg->has_ps = gf_bs_read_int_log(bs, 1, \"hasParametricStereo\");\n\t\t\t\tif (cfg->has_ps)\n\t\t\t\t\tcfg->nb_chan = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcfg->audioPL = gf_m4a_get_profile(cfg);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_get_config(u8 *dsi, u32 dsi_size, GF_M4ADecSpecInfo *cfg)\n{\n\tGF_BitStream *bs;\n\tif (!dsi || !dsi_size || (dsi_size < 2)) return GF_NON_COMPLIANT_BITSTREAM;\n\tbs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tgf_m4a_parse_config(bs, cfg, GF_TRUE);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nu32 gf_latm_get_value(GF_BitStream *bs)\n{\n\tu32 i, tmp, value = 0;\n\tu32 bytesForValue = gf_bs_read_int(bs, 2);\n\tfor (i = 0; i <= bytesForValue; i++) {\n\t\tvalue <<= 8;\n\t\ttmp = gf_bs_read_int(bs, 8);\n\t\tvalue += tmp;\n\t}\n\treturn value;\n}\n\nGF_EXPORT\nu32 gf_m4a_get_channel_cfg(u32 nb_chan)\n{\n\tu32 i, count = sizeof(GF_M4ANumChannels) / sizeof(u32);\n\tfor (i = 0; i < count; i++) {\n\t\tif (GF_M4ANumChannels[i] == nb_chan) return i + 1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_write_program_config_element_bs(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg)\n{\n\tu32 i;\n\tgf_bs_write_int(bs, cfg->element_instance_tag, 4);\n\tgf_bs_write_int(bs, cfg->object_type, 2);\n\tgf_bs_write_int(bs, cfg->sampling_frequency_index, 4);\n\tgf_bs_write_int(bs, cfg->num_front_channel_elements, 4);\n\tgf_bs_write_int(bs, cfg->num_side_channel_elements, 4);\n\tgf_bs_write_int(bs, cfg->num_back_channel_elements, 4);\n\tgf_bs_write_int(bs, cfg->num_lfe_channel_elements, 2);\n\tgf_bs_write_int(bs, cfg->num_assoc_data_elements, 3);\n\tgf_bs_write_int(bs, cfg->num_valid_cc_elements, 4);\n\tgf_bs_write_int(bs, cfg->mono_mixdown_present, 1);\n\tif (cfg->mono_mixdown_present) {\n\t\tgf_bs_write_int(bs, cfg->mono_mixdown_element_number, 4);\n\t}\n\tgf_bs_write_int(bs, cfg->stereo_mixdown_present, 1);\n\tif (cfg->stereo_mixdown_present) {\n\t\tgf_bs_write_int(bs, cfg->stereo_mixdown_element_number, 4);\n\t}\n\tgf_bs_write_int(bs, cfg->matrix_mixdown_idx_present, 1);\n\tif (cfg->matrix_mixdown_idx_present) {\n\t\tgf_bs_write_int(bs, cfg->matrix_mixdown_idx, 2);\n\t\tgf_bs_write_int(bs, cfg->pseudo_surround_enable, 1);\n\t}\n\tfor (i = 0; i < cfg->num_front_channel_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->front_element_is_cpe[i], 1);\n\t\tgf_bs_write_int(bs, cfg->front_element_tag_select[i], 4);\n\t}\n\tfor (i = 0; i < cfg->num_side_channel_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->side_element_is_cpe[i], 1);\n\t\tgf_bs_write_int(bs, cfg->side_element_tag_select[i], 4);\n\t}\n\tfor (i = 0; i < cfg->num_back_channel_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->back_element_is_cpe[i], 1);\n\t\tgf_bs_write_int(bs, cfg->back_element_tag_select[i], 4);\n\t}\n\tfor (i = 0; i < cfg->num_lfe_channel_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->lfe_element_tag_select[i], 4);\n\t}\n\tfor (i = 0; i < cfg->num_assoc_data_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->assoc_data_element_tag_select[i], 4);\n\t}\n\n\tfor (i = 0; i < cfg->num_valid_cc_elements; i++) {\n\t\tgf_bs_write_int(bs, cfg->cc_element_is_ind_sw[i], 1);\n\t\tgf_bs_write_int(bs, cfg->valid_cc_element_tag_select[i], 4);\n\t}\n\tgf_bs_align(bs);\n\tgf_bs_write_int(bs, cfg->comment_field_bytes, 8);\n\tgf_bs_write_data(bs, (char *)cfg->comments, cfg->comment_field_bytes);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_write_config_bs(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg)\n{\n\tif (!cfg->base_sr_index) {\n\t\tif (!cfg->base_sr) return GF_BAD_PARAM;\n\t\twhile (GF_M4ASampleRates[cfg->base_sr_index]) {\n\t\t\tif (GF_M4ASampleRates[cfg->base_sr_index] == cfg->base_sr)\n\t\t\t\tbreak;\n\t\t\tcfg->base_sr_index++;\n\t\t}\n\t}\n\tif (cfg->sbr_sr && !cfg->sbr_sr_index) {\n\t\twhile (GF_M4ASampleRates[cfg->sbr_sr_index]) {\n\t\t\tif (GF_M4ASampleRates[cfg->sbr_sr_index] == cfg->sbr_sr)\n\t\t\t\tbreak;\n\t\t\tcfg->sbr_sr_index++;\n\t\t}\n\t}\n\t/*extended object type*/\n\tif (cfg->base_object_type >= 32) {\n\t\tgf_bs_write_int(bs, 31, 5);\n\t\tgf_bs_write_int(bs, cfg->base_object_type - 32, 6);\n\t}\n\telse {\n\t\tgf_bs_write_int(bs, cfg->base_object_type, 5);\n\t}\n\tgf_bs_write_int(bs, cfg->base_sr_index, 4);\n\tif (cfg->base_sr_index == 0x0F) {\n\t\tgf_bs_write_int(bs, cfg->base_sr, 24);\n\t}\n\n\tif (cfg->program_config_element_present) {\n\t\tgf_bs_write_int(bs, 0, 4);\n\t} else {\n\t\tcfg->chan_cfg = gf_m4a_get_channel_cfg(cfg->nb_chan);\n\t\tif (!cfg->chan_cfg) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AAC] Cannot write decoder config, ProgramConfigElement is missing and channel configuration is not a predefined one !\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tgf_bs_write_int(bs, cfg->chan_cfg, 4);\n\t}\n\n\tif (cfg->base_object_type == 5 || cfg->base_object_type == 29) {\n\t\tif (cfg->base_object_type == 29) {\n\t\t\tcfg->has_ps = 1;\n\t\t\tcfg->nb_chan = 1;\n\t\t}\n\t\tcfg->has_sbr = 1;\n\t\tgf_bs_write_int(bs, cfg->sbr_sr_index, 4);\n\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\tgf_bs_write_int(bs, cfg->sbr_sr, 24);\n\t\t}\n\t\tgf_bs_write_int(bs, cfg->sbr_object_type, 5);\n\t}\n\n\t/*object cfg*/\n\tswitch (cfg->base_object_type) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 6:\n\tcase 7:\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\tcase 42:\n\t{\n\t\t/*frame length flag*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\t/*depends on core coder*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\t/*ext flag*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\n\t\tif (cfg->program_config_element_present) {\n\t\t\tgf_m4a_write_program_config_element_bs(bs, cfg);\n\t\t}\n\n\t\tif ((cfg->base_object_type == 6) || (cfg->base_object_type == 20)) {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t}\n\tbreak;\n\t}\n\t/*ER cfg - not supported*/\n\n\t/*implicit sbr/ps signaling not written here, cf reframe_adts*/\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_write_config(GF_M4ADecSpecInfo *cfg, u8 **dsi, u32 *dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_m4a_write_config_bs(bs, cfg);\n\tgf_bs_get_content(bs, dsi, dsi_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\n/*AV1 parsing*/\n\nstatic u32 av1_read_ns(GF_BitStream *bs, u32 n, const char *fname)\n{\n\tu32 v, res;\n\tBool extra_bit;\n\tint w = (u32)(log(n) / log(2)) + 1;\n\tu32 m = (1 << w) - n;\n\tassert(w < 32);\n\tv = gf_bs_read_int(bs, w - 1);\n\tif (v < m) {\n\t\tif (fname) {\n\t\t\tgf_bs_log(bs, w-1, fname, v);\n\t\t}\n\t\treturn v;\n\t}\n\textra_bit = gf_bs_read_int(bs, 1);\n\tres = (v << 1) - m + extra_bit;\n\tif (fname) {\n\t\tgf_bs_log(bs, w, fname, res);\n\t}\n\treturn res;\n}\n\nstatic void av1_color_config(GF_BitStream *bs, AV1State *state)\n{\n\tstate->config->high_bitdepth = gf_bs_read_int_log(bs, 1, \"high_bitdepth\");\n\tstate->bit_depth = 8;\n\tif (state->config->seq_profile == 2 && state->config->high_bitdepth) {\n\t\tstate->config->twelve_bit = gf_bs_read_int_log(bs, 1, \"twelve_bit\");\n\t\tstate->bit_depth = state->config->twelve_bit ? 12 : 10;\n\t}\n\telse if (state->config->seq_profile <= 2) {\n\t\tstate->bit_depth = state->config->high_bitdepth ? 10 : 8;\n\t}\n\n\tstate->config->monochrome = GF_FALSE;\n\tif (state->config->seq_profile == 1) {\n\t\tstate->config->monochrome = GF_FALSE;\n\t}\n\telse {\n\t\tstate->config->monochrome = gf_bs_read_int_log(bs, 1, \"monochrome\");\n\t}\n\t/*NumPlanes = mono_chrome ? 1 : 3;*/\n\tstate->color_description_present_flag = gf_bs_read_int_log(bs, 1, \"color_description_present_flag\");\n\tif (state->color_description_present_flag) {\n\t\tstate->color_primaries = gf_bs_read_int_log(bs, 8, \"color_primaries\");\n\t\tstate->transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\tstate->matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t}\n\telse {\n\t\tstate->color_primaries = 2/*CP_UNSPECIFIED*/;\n\t\tstate->transfer_characteristics = 2/*TC_UNSPECIFIED*/;\n\t\tstate->matrix_coefficients = 2/*MC_UNSPECIFIED*/;\n\t}\n\tif (state->config->monochrome) {\n\t\tstate->color_range = gf_bs_read_int_log(bs, 1, \"color_range\");\n\t\tstate->config->chroma_subsampling_x = GF_TRUE;\n\t\tstate->config->chroma_subsampling_y = GF_TRUE;\n\t\tstate->config->chroma_sample_position = 0/*CSP_UNKNOWN*/;\n\t\tstate->separate_uv_delta_q = 0;\n\t\treturn;\n\t}\n\telse if (state->color_primaries == 0/*CP_BT_709*/ &&\n\t\tstate->transfer_characteristics == 13/*TC_SRGB*/ &&\n\t\tstate->matrix_coefficients == 0/*MC_IDENTITY*/) {\n\t\tstate->color_range = GF_TRUE;\n\t\tstate->config->chroma_subsampling_x = GF_FALSE;\n\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t}\n\telse {\n\t\tstate->config->chroma_subsampling_x = GF_FALSE;\n\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\n\t\tstate->color_range = gf_bs_read_int_log(bs, 1, \"color_range\");\n\t\tif (state->config->seq_profile == 0) {\n\t\t\tstate->config->chroma_subsampling_x = GF_TRUE;\n\t\t\tstate->config->chroma_subsampling_y = GF_TRUE;\n\t\t}\n\t\telse if (state->config->seq_profile == 1) {\n\t\t\tstate->config->chroma_subsampling_x = GF_FALSE;\n\t\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t\t}\n\t\telse {\n\t\t\tif (state->bit_depth == 12) {\n\t\t\t\tstate->config->chroma_subsampling_x = gf_bs_read_int_log(bs, 1, \"chroma_subsampling_x\");\n\t\t\t\tif (state->config->chroma_subsampling_x)\n\t\t\t\t\tstate->config->chroma_subsampling_y = gf_bs_read_int_log(bs, 1, \"chroma_subsampling_y\");\n\t\t\t\telse\n\t\t\t\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate->config->chroma_subsampling_x = GF_TRUE;\n\t\t\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (state->config->chroma_subsampling_x && state->config->chroma_subsampling_y) {\n\t\t\tstate->config->chroma_sample_position = gf_bs_read_int_log(bs, 2, \"chroma_sample_position\");\n\t\t}\n\t}\n\tstate->separate_uv_delta_q = gf_bs_read_int_log(bs, 1, \"separate_uv_delta_q\");\n}\n\n\nstatic u32 av1_uvlc(GF_BitStream *bs, const char *fname)\n{\n\tu32 res;\n\tu8 leadingZeros = 0;\n\twhile (1) {\n\t\tBool done = gf_bs_read_int(bs, 1);\n\t\tif (done)\n\t\t\tbreak;\n\t\tleadingZeros++;\n\t}\n\tif (leadingZeros >= 32) {\n\t\treturn 0xFFFFFFFF;\n\t}\n\tres = gf_bs_read_int(bs, leadingZeros) + (1 << leadingZeros) - 1;\n\tgf_bs_log(bs, 2*leadingZeros, fname, res);\n\treturn res;\n}\n\nstatic void timing_info(GF_BitStream *bs, AV1State *state) {\n\tu32 time_scale = 0;\n\tu32 num_units_in_display_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_display_tick\");\n\tif (num_units_in_display_tick == 0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] num_units_in_display_tick must be greater than 0.\\n\"));\n\t}\n\ttime_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\tif (time_scale == 0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] time_scale must be greater than 0.\\n\"));\n\t}\n\tstate->equal_picture_interval = gf_bs_read_int_log(bs, 1, \"equal_picture_interval\");\n\tif (state->equal_picture_interval) {\n\t\tu32 num_ticks_per_picture_minus_1 = av1_uvlc(bs, \"num_ticks_per_picture_minus_1\");\n\t\tstate->tb_num = time_scale;\n\t\tstate->tb_den = (num_ticks_per_picture_minus_1 + 1)*num_units_in_display_tick;\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] VFR not supported.\\n\"));\n\t\t//TODO: upload num_units_in_display_tick (eq. to the POC in H264), compute delta between frames, set it as dts_inc in gf_import_aom_av1()\n\t}\n}\n\nstatic void decoder_model_info(AV1State *state, GF_BitStream *bs) {\n\tstate->buffer_delay_length = 1 + gf_bs_read_int_log(bs, 5, \"buffer_delay_length_minus1\");\n\tgf_bs_read_int_log(bs, 32, \"num_units_in_decoding_tick\");\n\tstate->buffer_removal_time_length = gf_bs_read_int_log(bs, 5, \"buffer_removal_time_length\");\n\tstate->frame_presentation_time_length = 1 + gf_bs_read_int_log(bs, 5, \"frame_presentation_time_length_minus1\");\n}\n\nstatic void operating_parameters_info(GF_BitStream *bs, const u8 idx, const u8 buffer_delay_length_minus_1) {\n\tconst u8 n = buffer_delay_length_minus_1 + 1;\n\tgf_bs_read_int_log(bs, n, \"decoder_buffer_delay\");\n\tgf_bs_read_int_log(bs, n, \"encoder_buffer_delay\");\n\tgf_bs_read_int_log(bs, 1, \"low_delay_mode_flag\");\n}\n\nstatic void av1_parse_sequence_header_obu(GF_BitStream *bs, AV1State *state)\n{\n\tu8 buffer_delay_length_minus_1 = 0;\n\tstate->frame_state.seen_seq_header = GF_TRUE;\n\tstate->config->seq_profile = gf_bs_read_int_log(bs, 3, \"seq_profile\");\n\tstate->still_picture = gf_bs_read_int_log(bs, 1, \"still_picture\");\n\tstate->reduced_still_picture_header = gf_bs_read_int_log(bs, 1, \"reduced_still_picture_header\");\n\tif (state->reduced_still_picture_header) {\n\t\t//timing_info_present_flag = GF_FALSE;\n\t\t//initial_display_delay_present_flag = GF_FALSE;\n\t\tstate->operating_points_count = 1;\n\t\tstate->config->seq_level_idx_0 = gf_bs_read_int_log(bs, 5, \"seq_level_idx_0\");\n\t}\n\telse {\n\t\tu8 i = 0;\n\t\tBool initial_display_delay_present_flag;\n\t\tBool timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (timing_info_present_flag) {\n\t\t\ttiming_info(bs, state);\n\t\t\tstate->decoder_model_info_present_flag = gf_bs_read_int_log(bs, 1, \"decoder_model_info_present_flag\");\n\t\t\tif (state->decoder_model_info_present_flag) {\n\t\t\t\tdecoder_model_info(state, bs);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstate->decoder_model_info_present_flag = GF_FALSE;\n\t\t}\n\t\tinitial_display_delay_present_flag = gf_bs_read_int_log(bs, 1, \"initial_display_delay_present_flag\");\n\t\tstate->operating_points_count = 1 + gf_bs_read_int_log(bs, 5, \"operating_points_count_minus1\");\n\t\tfor (i = 0; i < state->operating_points_count; i++) {\n\t\t\tu8 seq_level_idx_i, seq_tier = 0;\n\n\t\t\tstate->operating_point_idc[i] = gf_bs_read_int_log_idx(bs, 12, \"operating_point_idc\", i);\n\n\t\t\tseq_level_idx_i = gf_bs_read_int_log_idx(bs, 5, \"seq_level_idx\", i);\n\t\t\tif (i == 0) state->config->seq_level_idx_0 = seq_level_idx_i;\n\n\t\t\tif (seq_level_idx_i > 7) {\n\t\t\t\tseq_tier = gf_bs_read_int_log_idx(bs, 1, \"seq_tier\", i);\n\t\t\t}\n\t\t\tif (i == 0) state->config->seq_tier_0 = seq_tier;\n\n\t\t\tif (state->decoder_model_info_present_flag) {\n\t\t\t\tstate->decoder_model_present_for_this_op[i] = gf_bs_read_int_log_idx(bs, 1, \"decoder_model_present_for_this_op\", i);\n\t\t\t\tif (state->decoder_model_present_for_this_op[i]) {\n\t\t\t\t\toperating_parameters_info(bs, i, buffer_delay_length_minus_1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate->decoder_model_present_for_this_op[i] = 0;\n\t\t\t}\n\t\t\tif (initial_display_delay_present_flag) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"initial_display_delay_present_for_this_op\", i) ) {\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 4, \"initial_display_delay_minus1\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//operatingPoint = av1_choose_operating_point(bs);\n\tstate->OperatingPointIdc = 0;//TODO: operating_point_idc[operatingPoint];\n\n\tstate->frame_width_bits_minus_1 = gf_bs_read_int_log(bs, 4, \"frame_width_bits_minus1\");\n\tstate->frame_height_bits_minus_1 = gf_bs_read_int_log(bs, 4, \"frame_height_bits_minus1\");\n\tstate->width = gf_bs_read_int_log(bs, state->frame_width_bits_minus_1 + 1, \"width_minus1\") + 1;\n\tstate->height = gf_bs_read_int_log(bs, state->frame_height_bits_minus_1 + 1, \"height_minus1\") + 1;\n\tstate->sequence_width = state->width;\n\tstate->sequence_height = state->height;\n\tstate->frame_id_numbers_present_flag = GF_FALSE;\n\tif (!state->reduced_still_picture_header) {\n\t\tstate->frame_id_numbers_present_flag = gf_bs_read_int_log(bs, 1, \"frame_id_numbers_present_flag\");\n\t}\n\tif (state->frame_id_numbers_present_flag) {\n\t\tstate->delta_frame_id_length_minus_2 = gf_bs_read_int_log(bs, 4, \"delta_frame_id_length_minus2\");\n\t\tstate->additional_frame_id_length_minus_1 = gf_bs_read_int_log(bs, 3, \"additional_frame_id_length_minus1\");\n\t}\n\tstate->use_128x128_superblock = gf_bs_read_int_log(bs, 1, \"use_128x128_superblock\");\n\tgf_bs_read_int_log(bs, 1, \"enable_filter_intra\");\n\tgf_bs_read_int_log(bs, 1, \"enable_intra_edge_filter\");\n\tif (state->reduced_still_picture_header) {\n\t\t/*enable_interintra_compound = 0;\n\t\tenable_masked_compound = 0;\n\t\tenable_dual_filter = 0;\n\t\tenable_jnt_comp = 0;\n\t\tenable_ref_frame_mvs = 0;*/\n\t\tstate->enable_warped_motion = 0;\n\t\tstate->enable_order_hint = GF_FALSE;\n\t\tstate->OrderHintBits = 0;\n\t\tstate->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;\n\t\tstate->seq_force_screen_content_tools = 2/*SELECT_SCREEN_CONTENT_TOOLS*/;\n\t}\n\telse {\n\t\tBool seq_choose_screen_content_tools;\n\t\tgf_bs_read_int_log(bs, 1, \"enable_interintra_compound\");\n\t\tgf_bs_read_int_log(bs, 1, \"enable_masked_compound\");\n\t\tstate->enable_warped_motion = gf_bs_read_int_log(bs, 1, \"enable_warped_motion\");\n\t\tgf_bs_read_int_log(bs, 1, \"enable_dual_filter\");\n\t\tstate->enable_order_hint = gf_bs_read_int_log(bs, 1, \"enable_order_hint\");\n\t\tif (state->enable_order_hint) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"enable_jnt_comp\");\n\t\t\tstate->enable_ref_frame_mvs = gf_bs_read_int_log(bs, 1, \"enable_ref_frame_mvs\");\n\t\t}\n\t\telse {\n\t\t\t/*enable_jnt_comp =  0*/;\n\t\t\t/*enable_ref_frame_mvs = 0*/;\n\t\t}\n\t\tseq_choose_screen_content_tools = gf_bs_read_int_log(bs, 1, \"seq_choose_screen_content_tools\");\n\t\tstate->seq_force_screen_content_tools = 0;\n\t\tif (seq_choose_screen_content_tools) {\n\t\t\tstate->seq_force_screen_content_tools = 2/*SELECT_SCREEN_CONTENT_TOOLS*/;\n\t\t}\n\t\telse {\n\t\t\tstate->seq_force_screen_content_tools = gf_bs_read_int_log(bs, 1, \"seq_force_screen_content_tools\");\n\t\t}\n\n\t\tstate->seq_force_integer_mv = 0;\n\t\tif (state->seq_force_screen_content_tools > 0) {\n\t\t\tconst Bool seq_choose_integer_mv = gf_bs_read_int_log(bs, 1, \"seq_choose_integer_mv\");\n\t\t\tif (seq_choose_integer_mv) {\n\t\t\t\tstate->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate->seq_force_integer_mv = gf_bs_read_int_log(bs, 1, \"seq_force_integer_mv\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstate->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;\n\t\t}\n\t\tif (state->enable_order_hint) {\n\t\t\tu8 order_hint_bits_minus_1 = gf_bs_read_int_log(bs, 3, \"order_hint_bits_minus1\");\n\t\t\tstate->OrderHintBits = order_hint_bits_minus_1 + 1;\n\t\t}\n\t\telse {\n\t\t\tstate->OrderHintBits = 0;\n\t\t}\n\t}\n\n\tstate->enable_superres = gf_bs_read_int_log(bs, 1, \"enable_superres\");\n\tstate->enable_cdef = gf_bs_read_int_log(bs, 1, \"enable_cdef\");\n\tstate->enable_restoration = gf_bs_read_int_log(bs, 1, \"enable_restoration\");\n\tav1_color_config(bs, state);\n\tstate->film_grain_params_present = gf_bs_read_int_log(bs, 1, \"film_grain_params_present\");\n}\n\n\n\n#define IVF_FILE_HEADER_SIZE 32\n\nBool gf_media_probe_ivf(GF_BitStream *bs)\n{\n\tu32 dw = 0;\n\tif (gf_bs_available(bs) < IVF_FILE_HEADER_SIZE) return GF_FALSE;\n\n\tdw = gf_bs_peek_bits(bs, 32, 0);\n\tif (dw != GF_4CC('D', 'K', 'I', 'F')) {\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\nGF_Err gf_media_parse_ivf_file_header(GF_BitStream *bs, u32 *width, u32 *height, u32 *codec_fourcc, u32 *timebase_num, u32 *timebase_den, u32 *num_frames)\n{\n\tu32 dw = 0;\n\n\tif (!width || !height || !codec_fourcc || !timebase_den || !timebase_num || !num_frames) {\n\t\tassert(0);\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (gf_bs_available(bs) < IVF_FILE_HEADER_SIZE) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[IVF] Not enough bytes available (\"LLU\").\\n\", gf_bs_available(bs)));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tdw = gf_bs_read_u32(bs);\n\tif (dw != GF_4CC('D', 'K', 'I', 'F')) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[IVF] Invalid signature\\n\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tdw = gf_bs_read_u16_le(bs);\n\tif (dw != 0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[IVF] Wrong IVF version. 0 expected, got %u\\n\", dw));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tdw = gf_bs_read_u16_le(bs); //length of header in bytes\n\tif (dw != IVF_FILE_HEADER_SIZE) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[IVF] Wrong IVF header length. Expected 32 bytes, got %u\\n\", dw));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t*codec_fourcc = gf_bs_read_u32(bs);\n\n\t*width = gf_bs_read_u16_le(bs);\n\t*height = gf_bs_read_u16_le(bs);\n\n\t*timebase_num = gf_bs_read_u32_le(bs);\n\t*timebase_den = gf_bs_read_u32_le(bs);\n\n\t*num_frames = gf_bs_read_u32_le(bs);\n\tgf_bs_read_u32_le(bs); //skip unused\n\n\treturn GF_OK;\n}\n\nGF_Err gf_media_parse_ivf_frame_header(GF_BitStream *bs, u64 *frame_size, u64 *pts)\n{\n\tif (!frame_size) return GF_BAD_PARAM;\n\tif (gf_bs_available(bs) < 12)\n\t\treturn GF_BUFFER_TOO_SMALL;\n\n\t*frame_size = gf_bs_read_u32_le(bs);\n\tif (*frame_size > 256 * 1024 * 1024) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[IVF] Wrong frame size %u\\n\", *frame_size));\n\t\t*frame_size = 0;\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t*pts = gf_bs_read_u64_le(bs);\n\n\treturn GF_OK;\n}\n\nGF_Err gf_media_vp9_parse_superframe(GF_BitStream *bs, u64 ivf_frame_size, u32 *num_frames_in_superframe, u32 frame_sizes[VP9_MAX_FRAMES_IN_SUPERFRAME], u32 *superframe_index_size)\n{\n\tu32 byte, bytes_per_framesize;\n\tu64 pos = gf_bs_get_position(bs), i = 0;\n\tGF_Err e;\n\n\tassert(bs && num_frames_in_superframe);\n\n\t/*initialize like there is no superframe*/\n\tmemset(frame_sizes, 0, VP9_MAX_FRAMES_IN_SUPERFRAME * sizeof(frame_sizes[0]));\n\t*num_frames_in_superframe = 1;\n\tframe_sizes[0] = (u32)ivf_frame_size;\n\t*superframe_index_size = 0;\n\n\te = gf_bs_seek(bs, pos + ivf_frame_size - 1);\n\tif (e) return e;\n\n\tbyte = gf_bs_read_u8(bs);\n\tif ((byte & 0xe0) != 0xc0)\n\t\tgoto exit; /*no superframe*/\n\n\tbytes_per_framesize = 1 + ((byte & 0x18) >> 3);\n\t*num_frames_in_superframe = (u32)(1 + (byte & 0x7));\n\n\t/*superframe_index()*/\n\t*superframe_index_size = 2 + bytes_per_framesize * *num_frames_in_superframe;\n\tgf_bs_seek(bs, pos + ivf_frame_size - *superframe_index_size);\n\tbyte = gf_bs_read_u8(bs);\n\tif ((byte & 0xe0) != 0xc0)\n\t\tgoto exit; /*no superframe*/\n\n\tframe_sizes[0] = 0;\n\tfor (i = 0; i < *num_frames_in_superframe; ++i) {\n\t\tgf_bs_read_data(bs, (char*)(frame_sizes + i), bytes_per_framesize);\n\t}\n\nexit:\n\tgf_bs_seek(bs, pos);\n\treturn e;\n}\n\n\nstatic Bool vp9_frame_sync_code(GF_BitStream *bs)\n{\n\tu8 val = gf_bs_read_int_log(bs, 8, \"syncbyte1\");\n\tif (val != 0x49)\n\t\treturn GF_FALSE;\n\n\tval = gf_bs_read_int_log(bs, 8, \"syncbyte2\");\n\tif (val != 0x83)\n\t\treturn GF_FALSE;\n\n\tval = gf_bs_read_int_log(bs, 8, \"syncbyte3\");\n\tif (val != 0x42)\n\t\treturn GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\ntypedef enum {\n\tCS_UNKNOWN = 0,\n\tCS_BT_601 = 1,\n\tCS_BT_709 = 2,\n\tCS_SMPTE_170 = 3,\n\tCS_SMPTE_240 = 4,\n\tCS_BT_2020 = 5,\n\tCS_RESERVED = 6,\n\tCS_RGB = 7,\n} VP9_color_space;\n\nstatic const int VP9_CS_to_23001_8_colour_primaries[] = { -1/*undefined*/, 5, 1, 6, 7, 9, -1/*reserved*/, 1 };\nstatic const int VP9_CS_to_23001_8_transfer_characteristics[] = { -1/*undefined*/, 5, 1, 6, 7, 9, -1/*reserved*/, 13 };\nstatic const int VP9_CS_to_23001_8_matrix_coefficients[] = { -1/*undefined*/, 6, 1, -1, -1, 9, -1/*reserved*/, 0 };\n\nstatic GF_Err vp9_color_config(GF_BitStream *bs, GF_VPConfig *vp9_cfg)\n{\n\tVP9_color_space color_space;\n\n\tif (vp9_cfg->profile >= 2) {\n\t\tBool ten_or_twelve_bit = gf_bs_read_int_log(bs, 1, \"ten_or_twelve_bit\");\n\t\tvp9_cfg->bit_depth = ten_or_twelve_bit ? 12 : 10;\n\t}\n\telse {\n\t\tvp9_cfg->bit_depth = 8;\n\t}\n\n\tcolor_space = gf_bs_read_int_log(bs, 3, \"color_space\");\n\tvp9_cfg->colour_primaries = VP9_CS_to_23001_8_colour_primaries[color_space];\n\tvp9_cfg->transfer_characteristics = VP9_CS_to_23001_8_transfer_characteristics[color_space];\n\tvp9_cfg->matrix_coefficients = VP9_CS_to_23001_8_matrix_coefficients[color_space];\n\tif (color_space != CS_RGB) {\n\t\tvp9_cfg->video_fullRange_flag = gf_bs_read_int_log(bs, 1, \"video_fullRange_flag\");\n\t\tif (vp9_cfg->profile == 1 || vp9_cfg->profile == 3) {\n\t\t\tu8 subsampling_x, subsampling_y, subsampling_xy_to_chroma_subsampling[2][2] = { {3, 0}, {2, 0} };\n\t\t\tsubsampling_x = gf_bs_read_int_log(bs, 1, \"subsampling_x\");\n\t\t\tsubsampling_y = gf_bs_read_int_log(bs, 1, \"subsampling_x\");\n\t\t\tvp9_cfg->chroma_subsampling = subsampling_xy_to_chroma_subsampling[subsampling_x][subsampling_y];\n\t\t\tBool reserved_zero = gf_bs_read_int_log(bs, 1, \"reserved_zero\");\n\t\t\tif (reserved_zero) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VP9] color config reserved zero (1) is not zero.\\n\"));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvp9_cfg->chroma_subsampling = 0;\n\t\t}\n\t}\n\telse {\n\t\tvp9_cfg->video_fullRange_flag = GF_TRUE;\n\t\tif (vp9_cfg->profile == 1 || vp9_cfg->profile == 3) {\n\t\t\tvp9_cfg->chroma_subsampling = 3;\n\t\t\tBool reserved_zero = gf_bs_read_int_log(bs, 1, \"reserved_zero\");\n\t\t\tif (reserved_zero) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VP9] color config reserved zero (2) is not zero.\\n\"));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nstatic void vp9_compute_image_size(int FrameWidth, int FrameHeight, int *Sb64Cols, int *Sb64Rows)\n{\n\tint MiCols = (FrameWidth + 7) >> 3;\n\tint MiRows = (FrameHeight + 7) >> 3;\n\t*Sb64Cols = (MiCols + 7) >> 3;\n\t*Sb64Rows = (MiRows + 7) >> 3;\n}\n\nstatic void vp9_frame_size(GF_BitStream *bs, int *FrameWidth, int *FrameHeight, int *Sb64Cols, int *Sb64Rows)\n{\n\tint frame_width_minus_1 = gf_bs_read_int_log(bs, 16, \"frame_width_minus_1\");\n\tint frame_height_minus_1 = gf_bs_read_int_log(bs, 16, \"frame_height_minus_1\");\n\tif (frame_width_minus_1 + 1 != *FrameWidth || frame_height_minus_1 + 1 != *FrameHeight) {\n\t\tif (*FrameWidth || *FrameHeight)\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[VP9] inconsistent frame dimensions: previous was %dx%d, new one is %dx%d.\\n\", *FrameWidth, *FrameHeight, frame_width_minus_1 + 1, frame_height_minus_1 + 1));\n\t}\n\t*FrameWidth = frame_width_minus_1 + 1;\n\t*FrameHeight = frame_height_minus_1 + 1;\n\tvp9_compute_image_size(*FrameWidth, *FrameHeight, Sb64Cols, Sb64Rows);\n}\n\nstatic void vp9_render_size(GF_BitStream *bs, int FrameWidth, int FrameHeight, int *renderWidth, int *renderHeight)\n{\n\tBool render_and_frame_size_different = gf_bs_read_int_log(bs, 1, \"render_and_frame_size_different\");\n\tif (render_and_frame_size_different == 1) {\n\t\tint render_width_minus_1 = gf_bs_read_int_log(bs, 16, \"render_width_minus_1\");\n\t\tint render_height_minus_1 = gf_bs_read_int_log(bs, 16, \"render_height_minus_1\");\n\t\t*renderWidth = render_width_minus_1 + 1;\n\t\t*renderHeight = render_height_minus_1 + 1;\n\t}\n\telse {\n\t\t*renderWidth = FrameWidth;\n\t\t*renderHeight = FrameHeight;\n\t}\n}\n\nstatic s64 vp9_s(GF_BitStream *bs, int n, const char *fname, u32 idx) {\n\ts64 value = gf_bs_read_int(bs, n);\n\tBool sign = gf_bs_read_int(bs, 1);\n\tif (sign) value = -value;\n\tgf_bs_log_idx(bs, n+1, fname, value, idx, -1, -1);\n\treturn value;\n}\n\nstatic void vp9_loop_filter_params(GF_BitStream *bs)\n{\n\t/*loop_filter_level = */gf_bs_read_int_log(bs, 6, \"loop_filter_level\");\n\t/*loop_filter_sharpness = */gf_bs_read_int_log(bs, 3, \"loop_filter_sharpness\");\n\tBool loop_filter_delta_enabled = gf_bs_read_int_log(bs, 1, \"loop_filter_delta_enabled\");\n\tif (loop_filter_delta_enabled == 1) {\n\t\tBool loop_filter_delta_update = gf_bs_read_int_log(bs, 1, \"loop_filter_delta_update\");\n\t\tif (loop_filter_delta_update == GF_TRUE) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tBool update_ref_delta = gf_bs_read_int_log_idx(bs, 1, \"update_ref_delta\", i);\n\t\t\t\tif (update_ref_delta == GF_TRUE)\n\t\t\t\t\tvp9_s(bs, 6, \"loop_filter_ref_deltas\", i);\n\t\t\t}\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tBool update_mode_delta = gf_bs_read_int_log_idx(bs, 1, \"update_mode_delta\", i);\n\t\t\t\tif (update_mode_delta == GF_TRUE)\n\t\t\t\t\tvp9_s(bs, 6, \"loop_filter_mode_deltas\", i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void vp9_quantization_params(GF_BitStream *bs)\n{\n\t/*base_q_idx = */gf_bs_read_int_log(bs, 8, \"base_q_idx\");\n}\n\n#define VP9_MAX_SEGMENTS 8\n#define VP9_SEG_LVL_MAX 4\nstatic const int segmentation_feature_bits[VP9_SEG_LVL_MAX] = { 8, 6, 2, 0 };\nstatic const int segmentation_feature_signed[VP9_SEG_LVL_MAX] = { 1, 1, 0, 0 };\n\n#define VP9_MIN_TILE_WIDTH_B64 4\n#define VP9_MAX_TILE_WIDTH_B64 64\n\nstatic void vp9_segmentation_params(GF_BitStream *bs)\n{\n\tBool segmentation_enabled = gf_bs_read_int_log(bs, 1, \"segmentation_enabled\");\n\tif (segmentation_enabled == 1) {\n\t\tint i;\n\t\tBool segmentation_update_map = gf_bs_read_int_log(bs, 1, \"segmentation_update_map\");\n\t\tif (segmentation_update_map) {\n\t\t\tfor (i = 0; i < 7; i++)\n\t\t\t\t/*segmentation_tree_probs[i] = read_prob()*/\n\t\t\t\t/*segmentation_temporal_update = */gf_bs_read_int_log(bs, 1, \"segmentation_temporal_update\");\n\t\t\t/*for (i = 0; i < 3; i++)\n\t\t\t\tsegmentation_pred_prob[i] = segmentation_temporal_update ? read_prob() : 255*/\n\t\t}\n\t\tBool segmentation_update_data = gf_bs_read_int_log(bs, 1, \"segmentation_update_data\");\n\t\tif (segmentation_update_data == 1) {\n\t\t\t/*segmentation_abs_or_delta_update =*/ gf_bs_read_int_log(bs, 1, \"segmentation_abs_or_delta_update\");\n\t\t\tfor (i = 0; i < VP9_MAX_SEGMENTS; i++) {\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < VP9_SEG_LVL_MAX; j++) {\n\t\t\t\t\t/*feature_value = 0*/\n\t\t\t\t\tBool feature_enabled = gf_bs_read_int_log(bs, 1, \"feature_enabled\");\n\t\t\t\t\t/*FeatureEnabled[i][j] = feature_enabled*/\n\t\t\t\t\tif (feature_enabled) {\n\t\t\t\t\t\tint bits_to_read = segmentation_feature_bits[j];\n\t\t\t\t\t\t/*feature_value =*/ gf_bs_read_int_log(bs, bits_to_read, \"feature_value\");\n\t\t\t\t\t\tif (segmentation_feature_signed[j] == 1) {\n\t\t\t\t\t\t\t/*Bool feature_sign = */gf_bs_read_int_log(bs, 1, \"feature_sign\");\n\t\t\t\t\t\t\t/*if (feature_sign == 1)\n\t\t\t\t\t\t\t\tfeature_value *= -1*/\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*FeatureData[i][j] = feature_value*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int calc_min_log2_tile_cols(int Sb64Cols) {\n\tint minLog2 = 0;\n\twhile ((VP9_MAX_TILE_WIDTH_B64 << minLog2) < Sb64Cols)\n\t\tminLog2++;\n\n\treturn minLog2;\n}\n\nstatic int calc_max_log2_tile_cols(int Sb64Cols) {\n\tint maxLog2 = 1;\n\twhile ((Sb64Cols >> maxLog2) >= VP9_MIN_TILE_WIDTH_B64)\n\t\tmaxLog2++;\n\n\treturn maxLog2 - 1;\n}\n\nstatic void vp9_tile_info(GF_BitStream *bs, int Sb64Cols)\n{\n\tBool tile_rows_log2;\n\tint minLog2TileCols = calc_min_log2_tile_cols(Sb64Cols);\n\tint maxLog2TileCols = calc_max_log2_tile_cols(Sb64Cols);\n\tint tile_cols_log2 = minLog2TileCols;\n\twhile (tile_cols_log2 < maxLog2TileCols) {\n\t\tBool increment_tile_cols_log2 = gf_bs_read_int_log(bs, 1, \"increment_tile_cols_log2\");\n\t\tif (increment_tile_cols_log2)\n\t\t\ttile_cols_log2++;\n\t\telse\n\t\t\tbreak;\n\t}\n\ttile_rows_log2 = gf_bs_read_int_log(bs, 1, \"tile_rows_log2\");\n\tif (tile_rows_log2) {\n\t\t/*Bool increment_tile_rows_log2 = */gf_bs_read_int_log(bs, 1, \"increment_tile_rows_log2\");\n\t\t//tile_rows_log2 += increment_tile_rows_log2;\n\t}\n}\n\nstatic void vp9_frame_size_with_refs(GF_BitStream *bs, u8 refresh_frame_flags, u8 * ref_frame_idx, int * RefFrameWidth, int *RefFrameHeight,\n\tint *FrameWidth, int *FrameHeight, int *RenderWidth, int *RenderHeight, int *Sb64Cols, int *Sb64Rows)\n{\n\tBool found_ref;\n\tint i;\n\tfor (i = 0; i < 3; i++) {\n\t\tfound_ref = gf_bs_read_int_log(bs, 1, \"found_ref\");\n\t\tif (found_ref) {\n\t\t\t*FrameWidth  = RefFrameWidth [ref_frame_idx[i]];\n\t\t\t*FrameHeight = RefFrameHeight[ref_frame_idx[i]];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found_ref == 0) {\n\t\tvp9_frame_size(bs, FrameWidth, FrameHeight, Sb64Cols, Sb64Rows);\n\t}\n\telse {\n\t\tvp9_compute_image_size(*FrameWidth, *FrameHeight, Sb64Cols, Sb64Rows);\n\t}\n\n\tvp9_render_size(bs, *FrameWidth, *FrameHeight, RenderWidth, RenderHeight);\n}\n\nstatic void vp9_read_interpolation_filter(GF_BitStream *bs)\n{\n\tBool is_filter_switchable = gf_bs_read_int_log(bs, 1, \"is_filter_switchable\");\n\tif (!is_filter_switchable) {\n\t\t/*raw_interpolation_filter = */gf_bs_read_int_log(bs, 2, \"raw_interpolation_filter\");\n\t}\n}\n\n\n#define VP9_KEY_FRAME 0\n\nGF_Err gf_media_vp9_parse_sample(GF_BitStream *bs, GF_VPConfig *vp9_cfg, Bool *key_frame, u32 *FrameWidth, u32 *FrameHeight, u32 *renderWidth, u32 *renderHeight)\n{\n\tBool FrameIsIntra = GF_FALSE, profile_low_bit, profile_high_bit, show_existing_frame = GF_FALSE, frame_type = GF_FALSE, show_frame = GF_FALSE, error_resilient_mode = GF_FALSE;\n\t/*u8 frame_context_idx = 0, reset_frame_context = 0, frame_marker = 0*/;\n\tint Sb64Cols = 0, Sb64Rows = 0, i;\n\tu8 refresh_frame_flags = 0;\n\n\tassert(bs && key_frame);\n\n\t/*uncompressed header*/\n\t/*frame_marker = */gf_bs_read_int_log(bs, 2, \"frame_marker\");\n\tprofile_low_bit = gf_bs_read_int_log(bs, 1, \"profile_low_bit\");\n\tprofile_high_bit = gf_bs_read_int_log(bs, 1, \"profile_high_bit\");\n\tvp9_cfg->profile = (profile_high_bit << 1) + profile_low_bit;\n\tif (vp9_cfg->profile == 3) {\n\t\tBool reserved_zero = gf_bs_read_int_log(bs, 1, \"reserved_zero\");\n\t\tif (reserved_zero) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VP9] uncompressed header reserved zero is not zero.\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t}\n\n\tshow_existing_frame = gf_bs_read_int_log(bs, 1, \"show_existing_frame\");\n\tif (show_existing_frame == GF_TRUE) {\n\t\t/*frame_to_show_map_idx = */gf_bs_read_int_log(bs, 3, \"frame_to_show_map_idx\");\n\t\treturn GF_OK;\n\t}\n\n\tframe_type = gf_bs_read_int_log(bs, 1, \"frame_type\");\n\tshow_frame = gf_bs_read_int_log(bs, 1, \"show_frame\");\n\terror_resilient_mode = gf_bs_read_int_log(bs, 1, \"error_resilient_mode\");\n\tif (frame_type == VP9_KEY_FRAME) {\n\t\tif (!vp9_frame_sync_code(bs))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tif (vp9_color_config(bs, vp9_cfg) != GF_OK)\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tvp9_frame_size(bs, FrameWidth, FrameHeight, &Sb64Cols, &Sb64Rows);\n\t\tvp9_render_size(bs, *FrameWidth, *FrameHeight, renderWidth, renderHeight);\n\t\trefresh_frame_flags = 0xFF;\n\t\t*key_frame = GF_TRUE;\n\t\tFrameIsIntra = GF_TRUE;\n\t}\n\telse {\n\t\tBool intra_only = GF_FALSE;\n\t\t*key_frame = GF_FALSE;\n\n\t\tif (show_frame == GF_FALSE) {\n\t\t\tintra_only = gf_bs_read_int_log(bs, 1, \"intra_only\");\n\t\t}\n\t\tFrameIsIntra = intra_only;\n\n\t\tif (error_resilient_mode == GF_FALSE) {\n\t\t\t/*reset_frame_context = */gf_bs_read_int_log(bs, 2, \"reset_frame_context\");\n\t\t}\n\n\t\tif (intra_only == GF_TRUE) {\n\t\t\tif (!vp9_frame_sync_code(bs))\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n\t\t\tif (vp9_cfg->profile > 0) {\n\t\t\t\tif (vp9_color_config(bs, vp9_cfg) != GF_OK)\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tu8 color_space = CS_BT_601;\n\t\t\t\tvp9_cfg->colour_primaries = VP9_CS_to_23001_8_colour_primaries[color_space];\n\t\t\t\tvp9_cfg->transfer_characteristics = VP9_CS_to_23001_8_transfer_characteristics[color_space];\n\t\t\t\tvp9_cfg->matrix_coefficients = VP9_CS_to_23001_8_matrix_coefficients[color_space];\n\t\t\t\tvp9_cfg->chroma_subsampling = 0;\n\t\t\t\tvp9_cfg->bit_depth = 8;\n\t\t\t}\n\t\t\trefresh_frame_flags = gf_bs_read_int_log(bs, 8, \"refresh_frame_flags\");\n\t\t\tvp9_frame_size(bs, FrameWidth, FrameHeight, &Sb64Cols, &Sb64Rows);\n\t\t\tvp9_render_size(bs, *FrameWidth, *FrameHeight, renderWidth, renderHeight);\n\t\t}\n\t\telse {\n\t\t\trefresh_frame_flags = gf_bs_read_int_log(bs, 8, \"refresh_frame_flags\");\n\t\t\tu8 ref_frame_idx[3];\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tref_frame_idx[i] = gf_bs_read_int_log_idx(bs, 3, \"ref_frame_idx\", i);\n\t\t\t\t/*ref_frame_sign_bias[LAST_FRAME + i] = */gf_bs_read_int_log_idx(bs, 1, \"ref_frame_sign_bias\", i);\n\t\t\t}\n\t\t\tvp9_frame_size_with_refs(bs, refresh_frame_flags, ref_frame_idx, vp9_cfg->RefFrameWidth, vp9_cfg->RefFrameHeight, FrameWidth, FrameHeight, renderWidth, renderHeight, &Sb64Cols, &Sb64Rows);\n\t\t\t/*allow_high_precision_mv = */gf_bs_read_int_log(bs, 1, \"allow_high_precision_mv\");\n\t\t\tvp9_read_interpolation_filter(bs);\n\t\t}\n\t}\n\n\tif (error_resilient_mode == 0) {\n\t\t/*refresh_frame_context = */gf_bs_read_int_log(bs, 1, \"refresh_frame_context\");\n\t\t/*frame_parallel_decoding_mode = */gf_bs_read_int_log(bs, 1, \"frame_parallel_decoding_mode\");\n\t}\n\n\t/*frame_context_idx = */gf_bs_read_int_log(bs, 2, \"frame_context_idx\");\n\tif (FrameIsIntra || error_resilient_mode) {\n\t\t/*setup_past_independence + save_probs ...*/\n\t\t//frame_context_idx = 0;\n\t}\n\n\tvp9_loop_filter_params(bs);\n\tvp9_quantization_params(bs);\n\tvp9_segmentation_params(bs);\n\tvp9_tile_info(bs, Sb64Cols);\n\n\t/*header_size_in_bytes = */gf_bs_read_int_log(bs, 16, \"header_size_in_bytes\");\n\n\t/*Reference frame update process (8.10 - partial)*/\n\tfor (i = 0; i < VP9_NUM_REF_FRAMES; i++) {\n\t\tif ((refresh_frame_flags >> i) & 1) {\n\t\t\tvp9_cfg->RefFrameWidth[i] = *FrameWidth;\n\t\t\tvp9_cfg->RefFrameHeight[i] = *FrameHeight;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err gf_av1_parse_obu_header(GF_BitStream *bs, ObuType *obu_type, Bool *obu_extension_flag, Bool *obu_has_size_field, u8 *temporal_id, u8 *spatial_id)\n{\n\tBool forbidden = gf_bs_read_int(bs, 1);\n\tif (forbidden) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t*obu_type = gf_bs_read_int(bs, 4);\n\t*obu_extension_flag = gf_bs_read_int(bs, 1);\n\t*obu_has_size_field = gf_bs_read_int(bs, 1);\n\tif (gf_bs_read_int(bs, 1) /*obu_reserved_1bit*/) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (*obu_extension_flag) {\n\t\t*temporal_id = gf_bs_read_int(bs, 3);\n\t\t*spatial_id = gf_bs_read_int(bs, 2);\n\t\t/*extension_header_reserved_3bits = */gf_bs_read_int(bs, 3);\n\t}\n\n\treturn GF_OK;\n}\n\n#endif // GPAC_DISABLE_AV_PARSERS\n\nGF_EXPORT\nconst char *gf_av1_get_obu_name(ObuType obu_type)\n{\n\tswitch (obu_type) {\n\tcase OBU_SEQUENCE_HEADER: return \"seq_header\";\n\tcase OBU_TEMPORAL_DELIMITER: return \"delimiter\";\n\tcase OBU_FRAME_HEADER: return \"frame_header\";\n\tcase OBU_TILE_GROUP: return \"tile_group\";\n\tcase OBU_METADATA: return \"metadata\";\n\tcase OBU_FRAME: return \"frame\";\n\tcase OBU_REDUNDANT_FRAME_HEADER: return \"redundant_frame_header\";\n\tcase OBU_TILE_LIST: return \"tile_list\";\n\tcase OBU_PADDING: return \"padding\";\n\tcase OBU_RESERVED_0:\n\tcase OBU_RESERVED_9:\n\tcase OBU_RESERVED_10:\n\tcase OBU_RESERVED_11:\n\tcase OBU_RESERVED_12:\n\tcase OBU_RESERVED_13:\n\tcase OBU_RESERVED_14:\n\t\treturn \"reserved\";\n\tdefault: return \"unknown\";\n\t}\n}\n\nBool av1_is_obu_header(ObuType obu_type) {\n\tswitch (obu_type) {\n\tcase OBU_SEQUENCE_HEADER:\n\tcase OBU_METADATA:\n\t\t// TODO add check based on the metadata type\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nstatic Bool av1_is_obu_frame(AV1State *state, ObuType obu_type)\n{\n\tswitch (obu_type) {\n\tcase OBU_PADDING:\n\tcase OBU_REDUNDANT_FRAME_HEADER:\n\t\treturn GF_FALSE;\n\tcase OBU_TEMPORAL_DELIMITER:\n\t\treturn state->keep_temporal_delim ? GF_TRUE : GF_FALSE;\n\tdefault:\n\t\treturn GF_TRUE;\n\t}\n}\n\nu64 gf_av1_leb128_read(GF_BitStream *bs, u8 *opt_Leb128Bytes) {\n\tu64 value = 0;\n\tu8 Leb128Bytes = 0, i = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tu8 leb128_byte = gf_bs_read_u8(bs);\n\t\tvalue |= ( ((u64) (leb128_byte & 0x7f)) << (i * 7));\n\t\tLeb128Bytes += 1;\n\t\tif (!(leb128_byte & 0x80)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opt_Leb128Bytes) {\n\t\t*opt_Leb128Bytes = Leb128Bytes;\n\t}\n\treturn value;\n}\n\nu32 gf_av1_leb128_size(u64 value)\n{\n\tu32 gf_av1_leb128_size = 0;\n\tdo {\n\t\t++gf_av1_leb128_size;\n\t} while ((value >>= 7) != 0);\n\n\treturn gf_av1_leb128_size;\n}\n\nu64 gf_av1_leb128_write(GF_BitStream *bs, u64 value)\n{\n\tu32 i, leb_size = gf_av1_leb128_size(value);\n\tfor (i = 0; i < leb_size; ++i) {\n\t\tu8 byte = value & 0x7f;\n\t\tvalue >>= 7;\n\t\tif (value != 0) byte |= 0x80; //more bytes follow\n\t\tgf_bs_write_u8(bs, byte);\n\t}\n\n\treturn leb_size;\n}\n\n#define OBU_BLOCK_SIZE 4096\nstatic void av1_add_obu_internal(GF_BitStream *bs, u64 pos, u64 obu_length, ObuType obu_type, GF_List **obu_list, AV1State *state)\n{\n\tchar block[OBU_BLOCK_SIZE];\n\tBool has_size_field = 0, obu_extension_flag = 0;\n\tu8 temporal_id, spatial_id;\n\tGF_AV1_OBUArrayEntry *a = NULL;\n\n\tif (state && state->mem_mode) {\n\t\tif (!state->bs) state->bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\telse gf_bs_reassign_buffer(state->bs, state->frame_obus, state->frame_obus_alloc);\n\t}\n\telse {\n\t\tGF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);\n\t\tif (!a) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] Failed to allocate OBU\\n\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tgf_bs_seek(bs, pos);\n\tgf_av1_parse_obu_header(bs, &obu_type, &obu_extension_flag, &has_size_field, &temporal_id, &spatial_id);\n\tgf_bs_seek(bs, pos);\n\n\tif (has_size_field) {\n\t\tif (a) {\n\t\t\ta->obu = gf_malloc((size_t)obu_length);\n\t\t\tgf_bs_read_data(bs, a->obu, (u32)obu_length);\n\t\t\ta->obu_length = obu_length;\n\t\t}\n\t\telse {\n\t\t\tu32 remain = (u32)obu_length;\n\t\t\twhile (remain) {\n\t\t\t\tu32 block_size = OBU_BLOCK_SIZE;\n\t\t\t\tif (block_size > remain) block_size = remain;\n\t\t\t\tgf_bs_read_data(bs, block, block_size);\n\t\t\t\tgf_bs_write_data(state->bs, block, block_size);\n\t\t\t\tremain -= block_size;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\telse {\n\t\tu8 i, hdr_size = obu_extension_flag ? 2 : 1;\n\t\tconst u32 leb_size = (u32)gf_av1_leb128_size(obu_length);\n\t\tconst u64 obu_size = obu_length - hdr_size;\n\n\t\tif (a) {\n\t\t\ta->obu = gf_malloc((size_t)obu_length + leb_size);\n\t\t\ta->obu_length = obu_length + leb_size;\n\t\t\tfor (i = 0; i < hdr_size; ++i) {\n\t\t\t\ta->obu[i] = gf_bs_read_u8(bs);\n\t\t\t\t/*add size field flag*/\n\t\t\t\tif (i == 0) a->obu[0] |= 0x02;\n\t\t\t}\n\t\t\t{\n\t\t\t\tu32 out_size = 0;\n\t\t\t\tu8 *output = NULL;\n\t\t\t\tGF_BitStream *bsLeb128 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t/*write size field*/\n\t\t\t\tgf_av1_leb128_write(bsLeb128, obu_size);\n\t\t\t\tassert(gf_bs_get_position(bsLeb128) == leb_size);\n\t\t\t\tgf_bs_get_content(bsLeb128, &output, &out_size);\n\t\t\t\tgf_bs_del(bsLeb128);\n\t\t\t\tmemcpy(a->obu + hdr_size, output, out_size);\n\t\t\t\tgf_free(output);\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, a->obu + hdr_size + leb_size, (u32)(obu_size));\n\t\t\tassert(gf_bs_get_position(bs) == pos + obu_length);\n\t\t}\n\t\telse {\n\t\t\tu32 remain;\n\t\t\tfor (i = 0; i < hdr_size; ++i) {\n\t\t\t\tu8 hdr_b = gf_bs_read_u8(bs);\n\t\t\t\tif (i == 0) hdr_b |= 0x02; /*add size field flag*/\n\t\t\t\tgf_bs_write_u8(state->bs, hdr_b);\n\t\t\t}\n\t\t\t/*add size field */\n\t\t\tgf_av1_leb128_write(state->bs, obu_size);\n\t\t\tremain = (u32)obu_length - hdr_size;\n\t\t\twhile (remain) {\n\t\t\t\tu32 block_size = OBU_BLOCK_SIZE;\n\t\t\t\tif (block_size > remain) block_size = remain;\n\t\t\t\tgf_bs_read_data(bs, block, block_size);\n\t\t\t\tgf_bs_write_data(state->bs, block, block_size);\n\t\t\t\tremain -= block_size;\n\t\t\t}\n\t\t\tassert(gf_bs_get_position(bs) == pos + obu_length);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!obu_list) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] internal error, no OBU list cannot add\\n\"));\n\t\tgf_free(a->obu);\n\t\tgf_free(a);\n\t\treturn;\n\t}\n\ta->obu_type = obu_type;\n\tif (! *obu_list)\n\t\t*obu_list = gf_list_new();\n\tgf_list_add(*obu_list, a);\n}\n\nstatic void av1_populate_state_from_obu(GF_BitStream *bs, u64 pos, u64 obu_length, ObuType obu_type, AV1State *state)\n{\n\tif (av1_is_obu_header(obu_type)) {\n\t\tav1_add_obu_internal(bs, pos, obu_length, obu_type, &state->frame_state.header_obus, NULL);\n\t}\n\tif (!state->skip_frames && av1_is_obu_frame(state, obu_type)) {\n\t\tif (!state->mem_mode) {\n\t\t\tav1_add_obu_internal(bs, pos, obu_length, obu_type, &state->frame_state.frame_obus, NULL);\n\t\t}\n\t\telse {\n\t\t\tav1_add_obu_internal(bs, pos, obu_length, obu_type, NULL, state);\n\t\t}\n\t}\n}\n\nGF_Err aom_av1_parse_temporal_unit_from_section5(GF_BitStream *bs, AV1State *state)\n{\n\tif (!state) return GF_BAD_PARAM;\n\tstate->obu_type = -1;\n\n\twhile (state->obu_type != OBU_TEMPORAL_DELIMITER) {\n\t\tGF_Err e;\n\t\tif (!gf_bs_available(bs))\n\t\t\treturn state->unframed ? GF_BUFFER_TOO_SMALL : GF_OK;\n\n\t\tu64 pos = gf_bs_get_position(bs), obu_length = 0;\n\n\t\te = gf_av1_parse_obu(bs, &state->obu_type, &obu_length, NULL, state);\n\t\tif (e)\n\t\t\treturn e;\n\n\t\tif (obu_length != gf_bs_get_position(bs) - pos) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] OBU (Section 5) frame size \"LLU\" different from consumed bytes \"LLU\".\\n\", obu_length, gf_bs_get_position(bs) - pos));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] Section5 OBU detected (size \"LLU\")\\n\", obu_length));\n\t\tav1_populate_state_from_obu(bs, pos, obu_length, state->obu_type, state);\n\t}\n\n\treturn GF_OK;\n}\n\nBool gf_media_aom_probe_annexb(GF_BitStream *bs)\n{\n\tBool res = GF_TRUE;\n\tu64 init_pos = gf_bs_get_position(bs);\n\tu64 sz = gf_av1_leb128_read(bs, NULL);\n\tif (!sz) res = GF_FALSE;\n\twhile (sz > 0) {\n\t\tu8 Leb128Bytes = 0;\n\t\tu64 frame_unit_size = gf_av1_leb128_read(bs, &Leb128Bytes);\n\n\t\tif (!frame_unit_size) {\n\t\t\tres = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sz < Leb128Bytes + frame_unit_size) {\n\t\t\tres = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tsz -= Leb128Bytes + frame_unit_size;\n\n\t\twhile (frame_unit_size > 0) {\n\t\t\tObuType obu_type;\n\t\t\tu64 pos, obu_length = gf_av1_leb128_read(bs, &Leb128Bytes);\n\t\t\tif (frame_unit_size < Leb128Bytes + obu_length) {\n\t\t\t\tres = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = gf_bs_get_position(bs);\n\t\t\tframe_unit_size -= Leb128Bytes;\n\n\t\t\tu8 tid, sid;\n\t\t\tBool extflag, has_size;\n\t\t\tGF_Err e = gf_av1_parse_obu_header(bs, &obu_type, &extflag, &has_size, &tid, &sid);\n\t\t\tif (e) {\n\t\t\t\tres = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (has_size) {\n\t\t\t\tobu_length = (u32)gf_av1_leb128_read(bs, NULL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (obu_length >= 1 + extflag) {\n\t\t\t\t\tobu_length = obu_length - 1 - extflag;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = GF_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu32 hdr_size = (u32)(gf_bs_get_position(bs) - pos);\n\t\t\tobu_length += hdr_size;\n\n\t\t\tif (frame_unit_size < obu_length) {\n\t\t\t\tres = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tframe_unit_size -= obu_length;\n\t\t\tgf_bs_skip_bytes(bs, obu_length - hdr_size);\n\t\t}\n\t\tif (!res) break;\n\t}\n\tgf_bs_seek(bs, init_pos);\n\treturn res;\n}\n\nGF_Err aom_av1_parse_temporal_unit_from_annexb(GF_BitStream *bs, AV1State *state)\n{\n\tGF_Err e;\n\tu64 tupos;\n\tu64 tusize, sz;\n\tif (!bs || !state) return GF_BAD_PARAM;\n\n\tstate->bs_overread = GF_FALSE;\n\ttusize = sz = gf_av1_leb128_read(bs, NULL);\n\ttupos = gf_bs_get_position(bs);\n\tif (!sz) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[AV1] temporal unit size is 0, likely not annex B\\n\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] Annex B temporal unit detected (size \"LLU\") ***** \\n\", sz));\n\twhile (sz > 0) {\n\t\tu8 Leb128Bytes = 0;\n\t\tu64 frame_unit_size = gf_av1_leb128_read(bs, &Leb128Bytes);\n\n\t\tif (state->bs_overread) {\n\t\t\treturn GF_BUFFER_TOO_SMALL;\n\t\t}\n\t\tif (sz < Leb128Bytes + frame_unit_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] Annex B sz(\"LLU\") < Leb128Bytes(\"LLU\") + frame_unit_size(\"LLU\")\\n\", sz, Leb128Bytes, frame_unit_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] Annex B frame unit detected (size \"LLU\")\\n\", frame_unit_size));\n\t\tsz -= Leb128Bytes + frame_unit_size;\n\n\t\twhile (frame_unit_size > 0) {\n\t\t\tu64 pos, obu_length = gf_av1_leb128_read(bs, &Leb128Bytes);\n\n\t\t\tif (state->bs_overread) {\n\t\t\t\treturn GF_BUFFER_TOO_SMALL;\n\t\t\t}\n\t\t\tif (frame_unit_size < Leb128Bytes + obu_length) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] Annex B frame_unit_size(\"LLU\") < Leb128Bytes(\"LLU\") + obu_length(\"LLU\")\\n\", frame_unit_size, Leb128Bytes, obu_length));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] Annex B OBU detected (size \"LLU\")\\n\", obu_length));\n\t\t\tpos = gf_bs_get_position(bs);\n\t\t\tframe_unit_size -= Leb128Bytes;\n\n\t\t\te = gf_av1_parse_obu(bs, &state->obu_type, &obu_length, NULL, state);\n\t\t\tif (e) return e;\n\n\t\t\tif (obu_length != gf_bs_get_position(bs) - pos) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] Annex B frame size \"LLU\" different from consumed bytes \"LLU\".\\n\", obu_length, gf_bs_get_position(bs) - pos));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\n\t\t\tav1_populate_state_from_obu(bs, pos, obu_length, state->obu_type, state);\n\t\t\tif (frame_unit_size < obu_length) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] Annex B frame_unit_size(\"LLU\") < OBU size (\"LLU\")\\n\", frame_unit_size, obu_length));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\tframe_unit_size -= obu_length;\n\t\t}\n\t}\n\tassert(sz == 0);\n\tif (tusize != gf_bs_get_position(bs) - tupos) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] Annex B TU size \"LLU\" different from consumed bytes \"LLU\".\\n\", tusize, gf_bs_get_position(bs) - tupos));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err aom_av1_parse_temporal_unit_from_ivf(GF_BitStream *bs, AV1State *state)\n{\n\tu64 frame_size, pts_ignored;\n\tGF_Err e;\n\tif (gf_bs_available(bs)<12) return GF_EOS;\n\te = gf_media_parse_ivf_frame_header(bs, &frame_size, &pts_ignored);\n\tif (e) return e;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] IVF frame detected (size \"LLU\")\\n\", frame_size));\n\n\tif (gf_bs_available(bs) < frame_size) return GF_EOS;\n\n\twhile (frame_size > 0) {\n\t\tu64 obu_size = 0, pos = gf_bs_get_position(bs);\n\n\t\te = gf_av1_parse_obu(bs, &state->obu_type, &obu_size, NULL, state);\n\t\tif (e != GF_OK)\n\t\t\treturn e;\n\n\t\tif (obu_size != gf_bs_get_position(bs) - pos) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] IVF frame size \"LLU\" different from consumed bytes \"LLU\".\\n\", obu_size, gf_bs_get_position(bs) - pos));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tav1_populate_state_from_obu(bs, pos, obu_size, state->obu_type, state);\n\n\t\tframe_size -= obu_size;\n\t}\n\treturn GF_OK;\n}\n\n#define AV1_NUM_REF_FRAMES 8\n#define AV1_ALL_FRAMES ((1 << AV1_NUM_REF_FRAMES) - 1)\n\n#define AV1_SUPERRES_DENOM_MIN 9\n#define AV1_SUPERRES_DENOM_BITS 3\n#define AV1_SUPERRES_NUM 8\n\n#define AV1_REFS_PER_FRAME 7\n#define AV1_PRIMARY_REF_NONE 7\n\n#define MAX_TILE_WIDTH 4096\n#define MAX_TILE_AREA (4096 * 2304)\n\nstatic u32 aom_av1_tile_log2(u32 blkSize, u32 target)\n{\n\tu32 k;\n\tfor (k = 0; (blkSize << k) < target; k++) {\n\t}\n\treturn k;\n}\n\nstatic u64 aom_av1_le(GF_BitStream *bs, u32 n, const char *name) {\n\tu32 i = 0;\n\tu64 t = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tu8 byte = gf_bs_read_int(bs, 8);\n\t\tt += (byte << (i * 8));\n\t}\n\tgf_bs_log(bs, n*8, name, t);\n\treturn t;\n}\n\n\nstatic void av1_parse_tile_info(GF_BitStream *bs, AV1State *state)\n{\n\tu32 i;\n\tu32 MiCols = 2 * ((state->width + 7) >> 3);\n\tu32 MiRows = 2 * ((state->height + 7) >> 3);\n\tu32 sbCols = state->use_128x128_superblock ? ((MiCols + 31) >> 5) : ((MiCols + 15) >> 4);\n\tu32 sbRows = state->use_128x128_superblock ? ((MiRows + 31) >> 5) : ((MiRows + 15) >> 4);\n\tu32 sbShift = state->use_128x128_superblock ? 5 : 4;\n\tu32 sbSize = sbShift + 2;\n\tu32 maxTileWidthSb = MAX_TILE_WIDTH >> sbSize;\n\tu32 maxTileAreaSb = MAX_TILE_AREA >> (2 * sbSize);\n\tu32 minLog2tileCols = aom_av1_tile_log2(maxTileWidthSb, sbCols);\n\tu32 maxLog2tileCols = aom_av1_tile_log2(1, MIN(sbCols, AV1_MAX_TILE_COLS));\n\tu32 maxLog2tileRows = aom_av1_tile_log2(1, MIN(sbRows, AV1_MAX_TILE_ROWS));\n\tu32 minLog2Tiles = MAX(minLog2tileCols, aom_av1_tile_log2(maxTileAreaSb, sbRows * sbCols));\n\tBool uniform_tile_spacing_flag = gf_bs_read_int_log(bs, 1, \"uniform_tile_spacing_flag\");\n\tif (uniform_tile_spacing_flag) {\n\t\tu32 startSb, tileWidthSb, tileHeightSb, minLog2tileRows;\n\t\tstate->tileColsLog2 = minLog2tileCols;\n\t\twhile (state->tileColsLog2 < maxLog2tileCols) {\n\t\t\tBool increment_tile_cols_log2 = gf_bs_read_int_log(bs, 1, \"increment_tile_cols_log2\");\n\t\t\tif (increment_tile_cols_log2 == 1)\n\t\t\t\tstate->tileColsLog2++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttileWidthSb = (sbCols + (1 << state->tileColsLog2) - 1) >> state->tileColsLog2;\n\t\ti = 0;\n\t\tfor (startSb = 0; startSb < sbCols; startSb += tileWidthSb) {\n\t\t\ti += 1;\n\t\t}\n\t\tstate->tileCols = i;\n\t\tminLog2tileRows = MAX((int)(minLog2Tiles - state->tileColsLog2), 0);\n\t\tstate->tileRowsLog2 = minLog2tileRows;\n\t\twhile (state->tileRowsLog2 < maxLog2tileRows) {\n\t\t\tBool increment_tile_rows_log2 = gf_bs_read_int_log(bs, 1, \"increment_tile_rows_log2\");\n\t\t\tif (increment_tile_rows_log2 == 1)\n\t\t\t\tstate->tileRowsLog2++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttileHeightSb = (sbRows + (1 << state->tileRowsLog2) - 1) >> state->tileRowsLog2;\n\t\ti = 0;\n\t\tfor (startSb = 0; startSb < sbRows; startSb += tileHeightSb) {\n\t\t\ti += 1;\n\t\t}\n\t\tstate->tileRows = i;\n\t}\n\telse {\n\t\tu32 startSb, maxTileHeightSb, widestTileSb;\n\t\twidestTileSb = 0;\n\t\tstartSb = 0;\n\t\tfor (i = 0; startSb < sbCols; i++) {\n\t\t\tu32 maxWidth = MIN((int)(sbCols - startSb), maxTileWidthSb);\n\t\t\tu32 width_in_sbs_minus_1 = av1_read_ns(bs, maxWidth, \"width_in_sbs_minus_1\");\n\t\t\tu32 sizeSb = width_in_sbs_minus_1 + 1;\n\t\t\twidestTileSb = MAX(sizeSb, widestTileSb);\n\t\t\tstartSb += sizeSb;\n\t\t}\n\t\tif (!widestTileSb) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] widest tile is 0, broken bitstream\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tstate->tileCols = i;\n\t\tstate->tileColsLog2 = aom_av1_tile_log2(1, state->tileCols);\n\n\t\tif (minLog2Tiles > 0)\n\t\t\tmaxTileAreaSb = (sbRows * sbCols) >> (minLog2Tiles + 1);\n\t\telse\n\t\t\tmaxTileAreaSb = sbRows * sbCols;\n\t\tmaxTileHeightSb = MAX(maxTileAreaSb / widestTileSb, 1);\n\n\t\tstartSb = 0;\n\t\tfor (i = 0; startSb < sbRows; i++) {\n\t\t\tu32 maxHeight = MIN((int)(sbRows - startSb), maxTileHeightSb);\n\t\t\tu32 height_in_sbs_minus_1 = av1_read_ns(bs, maxHeight, \"height_in_sbs_minus_1\");\n\t\t\tu32 sizeSb = height_in_sbs_minus_1 + 1;\n\t\t\tstartSb += sizeSb;\n\t\t}\n\n\t\tstate->tileRows = i;\n\t\tstate->tileRowsLog2 = aom_av1_tile_log2(1, state->tileRows);\n\t}\n\tif (state->tileColsLog2 > 0 || state->tileRowsLog2 > 0) {\n\t\tgf_bs_read_int_log(bs, state->tileRowsLog2 + state->tileColsLog2, \"context_update_tile_id\");\n\t\tstate->tile_size_bytes = gf_bs_read_int_log(bs, 2, \"tile_size_bytes_minus1\") + 1;\n\t}\n}\n\nstatic void superres_params(GF_BitStream *bs, AV1State *state)\n{\n\tu32 SuperresDenom;\n\tBool use_superres;\n\n\tif (state->enable_superres) {\n\t\tuse_superres = gf_bs_read_int_log(bs, 1, \"use_superres\");\n\t}\n\telse {\n\t\tuse_superres = GF_FALSE;\n\t}\n\tif (use_superres) {\n\t\tu8 coded_denom = gf_bs_read_int_log(bs, AV1_SUPERRES_DENOM_BITS, \"coded_denom\");\n\t\tSuperresDenom = coded_denom + AV1_SUPERRES_DENOM_MIN;\n\t}\n\telse {\n\t\tSuperresDenom = AV1_SUPERRES_NUM;\n\t}\n\tstate->UpscaledWidth = state->width;\n\tstate->width = (state->UpscaledWidth * AV1_SUPERRES_NUM + (SuperresDenom / 2)) / SuperresDenom;\n}\n\nstatic void av1_frame_size(GF_BitStream *bs, AV1State *state, Bool frame_size_override_flag)\n{\n\tif (frame_size_override_flag) {\n\t\tu32 frame_width_minus_1, frame_height_minus_1;\n\t\tu8 n = state->frame_width_bits_minus_1 + 1;\n\t\tframe_width_minus_1 = gf_bs_read_int_log(bs, n, \"frame_width_minus_1\");\n\t\tn = state->frame_height_bits_minus_1 + 1;\n\t\tframe_height_minus_1 = gf_bs_read_int_log(bs, n, \"frame_height_minus_1\");\n\t\tstate->width = frame_width_minus_1 + 1;\n\t\tstate->height = frame_height_minus_1 + 1;\n\t} else {\n\t\tstate->width = state->sequence_width;\n\t\tstate->height = state->sequence_height;\n\t}\n\tsuperres_params(bs, state);\n\t//compute_image_size(); //no bits\n}\n\nstatic void av1_render_size(GF_BitStream *bs)\n{\n\tBool render_and_frame_size_different = gf_bs_read_int_log(bs, 1, \"render_and_frame_size_different_flag\");\n\tif (render_and_frame_size_different == GF_TRUE) {\n\t\tgf_bs_read_int_log(bs, 16, \"render_width_minus_1\");\n\t\tgf_bs_read_int_log(bs, 16, \"render_height_minus_1\");\n\t\t//RenderWidth = render_width_minus_1 + 1;\n\t\t//RenderHeight = render_height_minus_1 + 1;\n\t}\n\telse {\n\t\t//RenderWidth = UpscaledWidth;\n\t\t//RenderHeight = FrameHeight;\n\t}\n}\n\nstatic void read_interpolation_filter(GF_BitStream *bs)\n{\n\tBool is_filter_switchable = gf_bs_read_int_log(bs, 1, \"is_filter_switchable\");\n\tif (!is_filter_switchable) {\n\t\t/*interpolation_filter =*/ gf_bs_read_int_log(bs, 2, \"interpolation_filter\");\n\t}\n}\n\nstatic void frame_size_with_refs(GF_BitStream *bs, AV1State *state, Bool frame_size_override_flag, s8 *ref_frame_idx)\n{\n\tBool found_ref = GF_FALSE;\n\tu32 i = 0;\n\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\tfound_ref = gf_bs_read_int_log_idx(bs, 1, \"found_ref\", i);\n\t\tif (found_ref == 1) {\n\t\t\tstate->UpscaledWidth = state->RefUpscaledWidth[ref_frame_idx[i]];\n\t\t\tstate->width = state->UpscaledWidth;\n\t\t\tstate->height = state->RefFrameHeight[ref_frame_idx[i]];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found_ref == 0) {\n\t\tav1_frame_size(bs, state, frame_size_override_flag);\n\t\tav1_render_size(bs);\n\t}\n\telse {\n\t\tsuperres_params(bs, state);\n\t\t//compute_image_size();\n\t}\n}\n\nstatic s32 av1_delta_q(GF_BitStream *bs, const char *name_flag, const char *name)\n{\n\tBool delta_coded = gf_bs_read_int_log(bs, 1, name_flag);\n\ts32 delta_q = 0;\n\tif (delta_coded) {\n\t\tu32 signMask = 1 << (7 - 1);\n\t\tdelta_q = gf_bs_read_int_log(bs, 7, name);\n\t\tif (delta_q & signMask)\n\t\t\tdelta_q = delta_q - 2 * signMask;\n\t}\n\treturn delta_q;\n}\n\nstatic u8 Segmentation_Feature_Bits[] = { 8,6,6,6,6,3,0,0 };\nstatic u8 Segmentation_Feature_Signed[] = { 1, 1, 1, 1, 1, 0, 0, 0 };\n\nstatic u8 av1_get_qindex(Bool ignoreDeltaQ, u32 segmentId, u32 base_q_idx, u32 delta_q_present, u32 CurrentQIndex, Bool segmentation_enabled, u8 *features_SEG_LVL_ALT_Q_enabled, s32 *features_SEG_LVL_ALT_Q)\n{\n\t//If seg_feature_active_idx( segmentId, SEG_LVL_ALT_Q ) is equal to 1 the following ordered steps apply:\n\tif (segmentation_enabled && features_SEG_LVL_ALT_Q_enabled[segmentId]) {\n\t\t//Set the variable data equal to FeatureData[ segmentId ][ SEG_LVL_ALT_Q ].\n\t\ts32 data = features_SEG_LVL_ALT_Q[segmentId];\n\t\ts32 qindex = base_q_idx + data;\n\t\t//If ignoreDeltaQ is equal to 0 and delta_q_present is equal to 1, set qindex equal to CurrentQIndex + data.\n\t\tif ((ignoreDeltaQ == 0) && (delta_q_present == 1)) qindex = CurrentQIndex + data;\n\t\t//Return Clip3( 0, 255, qindex ).\n\t\tif (qindex < 0) return 0;\n\t\telse if (qindex > 255) return 255;\n\t\telse return (u8)qindex;\n\t}\n\t//Otherwise, if ignoreDeltaQ is equal to 0 and delta_q_present is equal to 1, return CurrentQIndex.\n\tif ((ignoreDeltaQ == 0) && (delta_q_present == 1)) return CurrentQIndex;\n\t//otherwise\n\treturn base_q_idx;\n}\n\nenum {\n\tAV1_RESTORE_NONE = 0,\n\tAV1_RESTORE_SWITCHABLE,\n\tAV1_RESTORE_WIENER,\n\tAV1_RESTORE_SGRPROJ\n};\n\n#define AV1_GMC_IDENTITY  0\n#define AV1_GMC_TRANSLATION 1\n#define AV1_GMC_ROTZOOM 2\n#define AV1_GMC_AFFINE 3\n\n#define AV1_LAST_FRAME 1\n#define AV1_LAST2_FRAME 2\n#define AV1_LAST3_FRAME 3\n#define AV1_GOLDEN_FRAME 4\n#define AV1_BWDREF_FRAME 5\n#define AV1_ALTREF2_FRAME 6\n#define AV1_ALTREF_FRAME 7\n\n#define GM_ABS_ALPHA_BITS 12\n#define GM_ALPHA_PREC_BITS 15\n#define GM_ABS_TRANS_ONLY_BITS 9\n#define GM_TRANS_ONLY_PREC_BITS 3\n#define GM_ABS_TRANS_BITS 12\n#define GM_TRANS_PREC_BITS 6\n#define WARPEDMODEL_PREC_BITS 16\n\n\nstatic u32 av1_decode_subexp(GF_BitStream *bs, s32 numSyms)\n{\n\ts32 i = 0;\n\ts32 mk = 0;\n\ts32 k = 3;\n\twhile (1) {\n\t\ts32 b2 = i ? k + i - 1 : k;\n\t\ts32 a = 1 << b2;\n\t\tif (numSyms <= mk + 3 * a) {\n\t\t\ts32 subexp_final_bits = av1_read_ns(bs, numSyms - mk, NULL);\n\t\t\treturn subexp_final_bits + mk;\n\t\t}\n\t\telse {\n\t\t\ts32 subexp_more_bits = gf_bs_read_int(bs, 1);\n\t\t\tif (subexp_more_bits) {\n\t\t\t\ti++;\n\t\t\t\tmk += a;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts32 subexp_bits = gf_bs_read_int(bs, b2);\n\t\t\t\treturn subexp_bits + mk;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic GFINLINE s32 inverse_recenter(s32 r, u32 v)\n{\n\tif ((s64)v > (s64)(2 * r))\n\t\treturn v;\n\telse if (v & 1)\n\t\treturn r - ((v + 1) >> 1);\n\telse\n\t\treturn r + (v >> 1);\n}\n\nstatic s32 av1_decode_unsigned_subexp_with_ref(GF_BitStream *bs, s32 mx, s32 r)\n{\n\tu32 v = av1_decode_subexp(bs, mx);\n\tif ((r < 0) && (-(-r << 1) <= mx)) {\n\t\treturn inverse_recenter(r, v);\n\t}\n\telse if ((r << 1) <= mx) {\n\t\treturn inverse_recenter(r, v);\n\t}\n\telse {\n\t\treturn mx - 1 - inverse_recenter(mx - 1 - r, v);\n\t}\n}\nstatic s16 av1_decode_signed_subexp_with_ref(GF_BitStream *bs, s32 low, s32 high, s32 r)\n{\n\ts16 x = av1_decode_unsigned_subexp_with_ref(bs, high - low, r - low);\n\treturn x + low;\n}\n\nstatic void av1_read_global_param(AV1State *state, GF_BitStream *bs, u8 type, u8 ref, u8 idx)\n{\n\tu8 absBits = GM_ABS_ALPHA_BITS;\n\tu8 precBits = GM_ALPHA_PREC_BITS;\n\tif (idx < 2) {\n\t\tif (type == AV1_GMC_TRANSLATION) {\n\t\t\tabsBits = GM_ABS_TRANS_ONLY_BITS - (!state->frame_state.allow_high_precision_mv ? 1 : 0);\n\t\t\tprecBits = GM_TRANS_ONLY_PREC_BITS - (!state->frame_state.allow_high_precision_mv ? 1 : 0);\n\t\t}\n\t\telse {\n\t\t\tabsBits = GM_ABS_TRANS_BITS;\n\t\t\tprecBits = GM_TRANS_PREC_BITS;\n\t\t}\n\t}\n\ts32 precDiff = WARPEDMODEL_PREC_BITS - precBits;\n\ts32 round = (idx % 3) == 2 ? (1 << WARPEDMODEL_PREC_BITS) : 0;\n\ts32 sub = (idx % 3) == 2 ? (1 << precBits) : 0;\n\ts32 mx = (1 << absBits);\n\ts32 r = (state->PrevGmParams.coefs[ref][idx] >> precDiff) - sub;\n\ts32 val = av1_decode_signed_subexp_with_ref(bs, -mx, mx + 1, r);\n\n\tif (val < 0) {\n\t\tval = -val;\n\t\tstate->GmParams.coefs[ref][idx] = (-(val << precDiff) + round);\n\t}\n\telse {\n\t\tstate->GmParams.coefs[ref][idx] = (val << precDiff) + round;\n\t}\n}\n\nstatic s32 av1_get_relative_dist(s32 a, s32 b, AV1State *state)\n{\n\tif (!state->enable_order_hint)\n\t\treturn 0;\n\ts32 diff = a - b;\n\ts32 m = 1 << (state->OrderHintBits - 1);\n\tdiff = (diff & (m - 1)) - (diff & m);\n\treturn diff;\n}\n\nstatic void av1_setup_past_independence(AV1State *state)\n{\n\tu32 ref, i;\n\tfor (ref = AV1_LAST_FRAME; ref <= AV1_ALTREF_FRAME; ref++) {\n\t\tfor (i = 0; i <= 5; i++) {\n\t\t\tstate->PrevGmParams.coefs[ref][i] = ((i % 3 == 2) ? 1 << WARPEDMODEL_PREC_BITS : 0);\n\t\t}\n\t}\n}\n\nstatic void av1_load_previous(AV1State *state, u8 primary_ref_frame, s8 *ref_frame_idx)\n{\n\ts8 prevFrame = ref_frame_idx[primary_ref_frame];\n\tif (prevFrame < 0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] load_previous: prevFrame reference index %d is invalid\\n\", prevFrame));\n\t}\n\telse {\n\t\tstate->PrevGmParams = state->SavedGmParams[prevFrame];\n\t\t// load_loop_filter_params( prevFrame )\n\t\t// load_segmentation_params( prevFrame )\n\t}\n}\n\nstatic void av1_decode_frame_wrapup(AV1State *state)\n{\n\tu32 i;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\tif ((state->frame_state.refresh_frame_flags >> i) & 1) {\n\t\t\tstate->RefOrderHint[i] = state->frame_state.order_hint;\n\t\t\tstate->SavedGmParams[i] = state->GmParams;\n\t\t\tstate->RefFrameType[i] = state->frame_state.frame_type;\n\t\t\tstate->RefUpscaledWidth[i] = state->UpscaledWidth;\n\t\t\tstate->RefFrameHeight[i] = state->height;\n\t\t}\n\t}\n\tstate->frame_state.seen_frame_header = GF_FALSE;\n\t//Otherwise (show_existing_frame is equal to 1), if frame_type is equal to KEY_FRAME, the reference frame loading process as specified in section 7.21 is invoked\n\tif ((state->frame_state.show_existing_frame) && (state->frame_state.frame_type == AV1_KEY_FRAME)) {\n\t\tstate->frame_state.order_hint = state->RefOrderHint[state->frame_state.frame_to_show_map_idx];\n\t\t//OrderHints[ j + LAST_FRAME ] is set equal to SavedOrderHints[state->frame_to_show_map_idx ][ j + LAST_FRAME ] for j = 0..REFS_PER_FRAME-1.\n\n\t\t//gm_params[ ref ][ j ] is set equal to SavedGmParams[ frame_to_show_map_idx ][ ref ][ j ] for ref = LAST_FRAME..ALTREF_FRAME, for j = 0..5.\n\t\tstate->GmParams = state->SavedGmParams[state->frame_state.frame_to_show_map_idx];\n\n\t}\n}\n\nstatic s32 find_latest_forward(u32 curFrameHint, u8 *shiftedOrderHints, u8 *usedFrame)\n{\n\tu32 i;\n\ts32 ref = -1;\n\ts32 latestOrderHint = 0;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\ts32 hint = shiftedOrderHints[i];\n\t\tif (!usedFrame[i] && ((u32)hint < curFrameHint) && (ref < 0 || hint >= latestOrderHint)) {\n\t\t\tref = i;\n\t\t\tlatestOrderHint = hint;\n\t\t}\n\t}\n\treturn ref;\n}\n\n//see 7.8 of AV1 spec\nstatic void av1_set_frame_refs(AV1State *state, u8 last_frame_idx, u8 gold_frame_idx, s8 *ref_frame_idx)\n{\n\tu32 i;\n\tu8 usedFrame[AV1_NUM_REF_FRAMES];\n\tu8 shiftedOrderHints[AV1_NUM_REF_FRAMES];\n\n\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++)\n\t\tref_frame_idx[i] = -1;\n\n\tref_frame_idx[AV1_LAST_FRAME - AV1_LAST_FRAME] = last_frame_idx;\n\tref_frame_idx[AV1_GOLDEN_FRAME - AV1_LAST_FRAME] = gold_frame_idx;\n\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\tusedFrame[i] = 0;\n\t}\n\n\tusedFrame[last_frame_idx] = 1;\n\tusedFrame[gold_frame_idx] = 1;\n\tu32 curFrameHint = 1 << (state->OrderHintBits - 1);\n\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\tshiftedOrderHints[i] = curFrameHint + av1_get_relative_dist(state->RefOrderHint[i], state->frame_state.order_hint, state);\n\t}\n\n\tu8 lastOrderHint = shiftedOrderHints[last_frame_idx];\n\tu8 goldOrderHint = shiftedOrderHints[gold_frame_idx];\n\n\t//It is a requirement of bitstream conformance that lastOrderHint is strictly less than curFrameHint.\n\tif (lastOrderHint >= curFrameHint) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] non conformant bitstream detected while setting up frame refs: lastOrderHint(%d) shall be stricly less than curFrameHint(%d)\\n\", lastOrderHint, curFrameHint));\n\t}\n\t//It is a requirement of bitstream conformance that goldOrderHint is strictly less than curFrameHint.\n\tif (goldOrderHint >= curFrameHint) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] non conformant bitstream detected while setting up frame refs: goldOrderHint(%d) shall be stricly less than curFrameHint(%d)\\n\", lastOrderHint, curFrameHint));\n\t}\n\n\t//find_latest_backward() {\n\ts32 ref = -1;\n\ts32 latestOrderHint = 0;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\ts32 hint = shiftedOrderHints[i];\n\t\tif (!usedFrame[i] && ((u32)hint >= curFrameHint) && (ref < 0 || hint >= latestOrderHint)) {\n\t\t\tref = i;\n\t\t\tlatestOrderHint = hint;\n\t\t}\n\t}\n\tif (ref >= 0) {\n\t\tref_frame_idx[AV1_ALTREF_FRAME - AV1_LAST_FRAME] = ref;\n\t\tusedFrame[ref] = 1;\n\t}\n\t//find_earliest_backward() for BWDREF_FRAME\n\tref = -1;\n\ts32 earliestOrderHint = 0;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\ts32 hint = shiftedOrderHints[i];\n\t\tif (!usedFrame[i] && ((u32)hint >= curFrameHint) && (ref < 0 || hint < earliestOrderHint)) {\n\t\t\tref = i;\n\t\t\tearliestOrderHint = hint;\n\t\t}\n\t}\n\tif (ref >= 0) {\n\t\tref_frame_idx[AV1_BWDREF_FRAME - AV1_LAST_FRAME] = ref;\n\t\tusedFrame[ref] = 1;\n\t}\n\n\t//find_earliest_backward() for ALTREF2_FRAME\n\tref = -1;\n\tearliestOrderHint = 0;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\ts32 hint = shiftedOrderHints[i];\n\t\tif (!usedFrame[i] && ((u32)hint >= curFrameHint) && (ref < 0 || hint < earliestOrderHint)) {\n\t\t\tref = i;\n\t\t\tearliestOrderHint = hint;\n\t\t}\n\t}\n\tif (ref >= 0) {\n\t\tref_frame_idx[AV1_ALTREF2_FRAME - AV1_LAST_FRAME] = ref;\n\t\tusedFrame[ref] = 1;\n\t}\n\n\t//The remaining references are set to be forward references in anti-chronological order as follows:\n\n\tconst u8 Ref_Frame_List[AV1_REFS_PER_FRAME - 2] = {\n\t\tAV1_LAST2_FRAME, AV1_LAST3_FRAME, AV1_BWDREF_FRAME, AV1_ALTREF2_FRAME, AV1_ALTREF_FRAME\n\t};\n\n\tfor (i = 0; i < AV1_REFS_PER_FRAME - 2; i++) {\n\t\tu8 refFrame = Ref_Frame_List[i];\n\t\tif (ref_frame_idx[refFrame - AV1_LAST_FRAME] < 0) {\n\t\t\ts32 last_ref = find_latest_forward(curFrameHint, shiftedOrderHints, usedFrame);\n\t\t\tif (last_ref >= 0) {\n\t\t\t\tref_frame_idx[refFrame - AV1_LAST_FRAME] = last_ref;\n\t\t\t\tusedFrame[last_ref] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t//Finally, any remaining references are set to the reference frame with smallest output order as follows:\n\tref = -1;\n\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\ts32 hint = shiftedOrderHints[i];\n\t\tif (ref < 0 || hint < earliestOrderHint) {\n\t\t\tref = i;\n\t\t\tearliestOrderHint = hint;\n\t\t}\n\t}\n\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\tif (ref_frame_idx[i] < 0) {\n\t\t\tref_frame_idx[i] = ref;\n\t\t}\n\t}\n}\n\n\nstatic void av1_parse_uncompressed_header(GF_BitStream *bs, AV1State *state)\n{\n\tBool error_resilient_mode = GF_FALSE, allow_screen_content_tools = GF_FALSE, force_integer_mv = GF_FALSE;\n\tBool /*use_ref_frame_mvs = GF_FALSE,*/ FrameIsIntra = GF_FALSE, frame_size_override_flag = GF_FALSE;\n\tBool disable_cdf_update = GF_FALSE;\n\tu8 showable_frame;\n\tu8 primary_ref_frame;\n\tu16 idLen = 0;\n\tu32 idx;\n\ts8 ref_frame_idx[AV1_REFS_PER_FRAME];\n\tAV1StateFrame *frame_state = &state->frame_state;\n\n\tif (state->frame_id_numbers_present_flag) {\n\t\tidLen = (state->additional_frame_id_length_minus_1 + state->delta_frame_id_length_minus_2 + 3);\n\t}\n\tframe_state->refresh_frame_flags = 0;\n\n\tshowable_frame = 0;\n\tif (state->reduced_still_picture_header) {\n\t\tframe_state->key_frame = GF_TRUE;\n\t\tFrameIsIntra = GF_TRUE;\n\t\tframe_state->frame_type = AV1_KEY_FRAME;\n\t\tframe_state->show_frame = GF_TRUE;\n\t\tframe_state->show_existing_frame = 0;\n\t}\n\telse {\n\t\tframe_state->show_existing_frame = gf_bs_read_int_log(bs, 1, \"show_existing_frame\");\n\t\tif (frame_state->show_existing_frame == GF_TRUE) {\n\t\t\tframe_state->frame_to_show_map_idx = gf_bs_read_int_log(bs, 3, \"frame_to_show_map_idx\");\n\t\t\tframe_state->frame_type = state->RefFrameType[frame_state->frame_to_show_map_idx];\n\n\t\t\tif (state->decoder_model_info_present_flag && !state->equal_picture_interval) {\n\t\t\t\tgf_bs_read_int_log(bs, state->frame_presentation_time_length, \"frame_presentation_time\");\n\t\t\t}\n\n\t\t\tframe_state->refresh_frame_flags = 0;\n\t\t\tif (state->frame_id_numbers_present_flag) {\n\t\t\t\tgf_bs_read_int_log(bs, idLen, \"display_frame_id\");\n\t\t\t}\n\t\t\tif (frame_state->frame_type == AV1_KEY_FRAME) {\n\t\t\t\tframe_state->refresh_frame_flags = AV1_ALL_FRAMES;\n\t\t\t}\n\t\t\t/*\n\t\t\tif (film_grain_params_present) {\n\t\t\t\tload_grain_params(frame_to_show_map_idx)\n\t\t\t}*/\n\t\t\treturn;\n\t\t}\n\t\tframe_state->frame_type = gf_bs_read_int_log(bs, 2, \"frame_type\");\n\t\tFrameIsIntra = (frame_state->frame_type == AV1_INTRA_ONLY_FRAME || frame_state->frame_type == AV1_KEY_FRAME);\n\t\tframe_state->show_frame = gf_bs_read_int_log(bs, 1, \"show_frame\");\n\t\tif (frame_state->is_first_frame) {\n\t\t\tframe_state->key_frame = frame_state->seen_seq_header && frame_state->show_frame && frame_state->frame_type == AV1_KEY_FRAME && frame_state->seen_frame_header;\n\t\t}\n\t\tif (frame_state->show_frame && state->decoder_model_info_present_flag && !state->equal_picture_interval) {\n\t\t\tgf_bs_read_int_log(bs, state->frame_presentation_time_length, \"frame_presentation_time\");\n\t\t}\n\t\tif (frame_state->show_frame) {\n\t\t\tshowable_frame = frame_state->frame_type != AV1_KEY_FRAME;\n\n\t\t}\n\t\telse {\n\t\t\tshowable_frame = gf_bs_read_int_log(bs, 1, \"showable_frame\");\n\t\t}\n\t\tif (frame_state->frame_type == AV1_SWITCH_FRAME || (frame_state->frame_type == AV1_KEY_FRAME && frame_state->show_frame))\n\t\t\terror_resilient_mode = GF_TRUE;\n\t\telse\n\t\t\terror_resilient_mode = gf_bs_read_int_log(bs, 1, \"error_resilient_mode\");\n\t}\n\n\tif ((frame_state->frame_type == AV1_KEY_FRAME) && frame_state->show_frame) {\n\t\tu32 i;\n\t\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\t\tstate->RefValid[i] = 0;\n\t\t\tstate->RefOrderHint[i] = 0;\n\t\t}\n\t\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\t\tstate->OrderHints[AV1_LAST_FRAME + i] = 0;\n\t\t}\n\t}\n\n\tdisable_cdf_update = gf_bs_read_int_log(bs, 1, \"disable_cdf_update\");\n\tif (state->seq_force_screen_content_tools == 2/*SELECT_SCREEN_CONTENT_TOOLS*/) {\n\t\tallow_screen_content_tools = gf_bs_read_int_log(bs, 1, \"allow_screen_content_tools\");\n\t}\n\telse {\n\t\tallow_screen_content_tools = state->seq_force_screen_content_tools;\n\t}\n\tif (allow_screen_content_tools) {\n\t\tif (state->seq_force_integer_mv == 2/*SELECT_INTEGER_MV*/) {\n\t\t\tforce_integer_mv = gf_bs_read_int_log(bs, 1, \"force_integer_mv\");\n\t\t}\n\t\telse {\n\t\t\tforce_integer_mv = state->seq_force_integer_mv;\n\t\t}\n\t}\n\telse {\n\t\tforce_integer_mv = 0;\n\t}\n\tif (FrameIsIntra) {\n\t\tforce_integer_mv = 1;\n\t}\n\tif (state->frame_id_numbers_present_flag) {\n\t\tgf_bs_read_int_log(bs, idLen, \"current_frame_id\");\n\t}\n\tif (frame_state->frame_type == AV1_SWITCH_FRAME)\n\t\tframe_size_override_flag = GF_TRUE;\n\telse if (state->reduced_still_picture_header)\n\t\tframe_size_override_flag = GF_FALSE;\n\telse\n\t\tframe_size_override_flag = gf_bs_read_int_log(bs, 1, \"frame_size_override_flag\");\n\n\tframe_state->order_hint = gf_bs_read_int_log(bs, state->OrderHintBits, \"order_hint\");\n\tif (FrameIsIntra || error_resilient_mode) {\n\t\tprimary_ref_frame = AV1_PRIMARY_REF_NONE;\n\t}\n\telse {\n\t\tprimary_ref_frame = gf_bs_read_int_log(bs, 3, \"primary_ref_frame\");\n\t}\n\n\tif (state->decoder_model_info_present_flag) {\n\t\tu8 buffer_removal_time_present_flag = gf_bs_read_int_log(bs, 1, \"buffer_removal_time_present_flag\");\n\t\tif (buffer_removal_time_present_flag) {\n\t\t\tu32 opNum;\n\t\t\tfor (opNum = 0; opNum < state->operating_points_count; opNum++) {\n\t\t\t\tif (state->decoder_model_present_for_this_op[opNum]) {\n\t\t\t\t\tu8 opPtIdc = state->operating_point_idc[opNum];\n\t\t\t\t\tu8 inTemporalLayer = (opPtIdc >> state->temporal_id) & 1;\n\t\t\t\t\tu8 inSpatialLayer = (opPtIdc >> (state->spatial_id + 8)) & 1;\n\t\t\t\t\tif (opPtIdc == 0 || (inTemporalLayer && inSpatialLayer)) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, state->buffer_removal_time_length, \"buffer_removal_time\", opNum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (frame_state->frame_type == AV1_SWITCH_FRAME || (frame_state->frame_type == AV1_KEY_FRAME && frame_state->show_frame)) {\n\t\tframe_state->refresh_frame_flags = AV1_ALL_FRAMES;\n\t}\n\telse {\n\t\tframe_state->refresh_frame_flags = gf_bs_read_int_log(bs, 8, \"refresh_frame_flags\");\n\t}\n\tif (!FrameIsIntra || frame_state->refresh_frame_flags != AV1_ALL_FRAMES) {\n\t\tif (error_resilient_mode && state->enable_order_hint) {\n\t\t\tu32 i = 0;\n\t\t\tfor (i = 0; i < AV1_NUM_REF_FRAMES; i++) {\n\t\t\t\tu8 ref_order_hint = gf_bs_read_int_log_idx(bs, state->OrderHintBits, \"ref_order_hint\", i);\n\t\t\t\tif (ref_order_hint != state->RefOrderHint[i]) {\n\t\t\t\t\tstate->RefValid[i] = 0;\n\t\t\t\t}\n\t\t\t\tstate->RefOrderHint[i] = ref_order_hint;\n\t\t\t}\n\t\t}\n\t}\n\n\tu8 allow_intrabc = 0;\n\tif (frame_state->frame_type == AV1_KEY_FRAME) {\n\t\tav1_frame_size(bs, state, frame_size_override_flag);\n\t\tav1_render_size(bs);\n\t\tif (allow_screen_content_tools && state->UpscaledWidth == state->width) {\n\t\t\tallow_intrabc = gf_bs_read_int_log(bs, 1, \"allow_intrabc\");\n\t\t}\n\t}\n\telse {\n\t\tif (frame_state->frame_type == AV1_INTRA_ONLY_FRAME) {\n\t\t\tav1_frame_size(bs, state, frame_size_override_flag);\n\t\t\tav1_render_size(bs);\n\t\t\tif (allow_screen_content_tools && state->UpscaledWidth == state->width) {\n\t\t\t\tallow_intrabc = gf_bs_read_int_log(bs, 1, \"allow_intrabc\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tu32 i = 0;\n\t\t\tBool frame_refs_short_signaling = GF_FALSE;\n\t\t\tif (state->enable_order_hint) {\n\t\t\t\tframe_refs_short_signaling = gf_bs_read_int_log(bs, 1, \"frame_refs_short_signaling\");\n\t\t\t\tif (frame_refs_short_signaling) {\n\t\t\t\t\tu8 last_frame_idx = gf_bs_read_int_log(bs, 3, \"last_frame_idx\");\n\t\t\t\t\tu8 gold_frame_idx = gf_bs_read_int_log(bs, 3, \"gold_frame_idx\");\n\t\t\t\t\tav1_set_frame_refs(state, last_frame_idx, gold_frame_idx, ref_frame_idx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\t\t\tif (!frame_refs_short_signaling)\n\t\t\t\t\tref_frame_idx[i] = gf_bs_read_int_log_idx(bs, 3, \"ref_frame_idx\", i);\n\n\t\t\t\tif (state->frame_id_numbers_present_flag) {\n\t\t\t\t\tu32 n = state->delta_frame_id_length_minus_2 + 2;\n\t\t\t\t\t/*delta_frame_id_minus_1 =*/ gf_bs_read_int_log_idx(bs, n, \"delta_frame_id_minus1\", i);\n\t\t\t\t\t//DeltaFrameId = delta_frame_id_minus_1 + 1;\n\t\t\t\t\t//expectedFrameId[i] = ((current_frame_id + (1 << idLen) - DeltaFrameId) % (1 << idLen));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (frame_size_override_flag && !error_resilient_mode) {\n\t\t\t\tframe_size_with_refs(bs, state, frame_size_override_flag, ref_frame_idx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tav1_frame_size(bs, state, frame_size_override_flag);\n\t\t\t\tav1_render_size(bs);\n\t\t\t}\n\t\t\tframe_state->allow_high_precision_mv = 0;\n\t\t\tif (!force_integer_mv) {\n\t\t\t\tframe_state->allow_high_precision_mv = gf_bs_read_int_log(bs, 1, \"allow_high_precision_mv\");\n\t\t\t}\n\n\t\t\tread_interpolation_filter(bs);\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"is_motion_mode_switchable\");\n\t\t\tif (!(error_resilient_mode || !state->enable_ref_frame_mvs)) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"use_ref_frame_mvs\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!FrameIsIntra) {\n\t\tu32 i;\n\t\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\t\tu8 refFrame = AV1_LAST_FRAME + i;\n\t\t\tu8 ridx = ref_frame_idx[i];\n\t\t\tif (ridx >= 0) {\n\t\t\t\tu8 hint = state->RefOrderHint[ridx];\n\t\t\t\tstate->OrderHints[refFrame] = hint;\n\t\t\t\t/*\t\t\tif ( !enable_order_hint ) {\n\t\t\t\t\t\t\t\tRefFrameSignBias[ refFrame ] = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tRefFrameSignBias[ refFrame ] = get_relative_dist( hint, OrderHint) > 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (!(state->reduced_still_picture_header || disable_cdf_update))\n\t\tgf_bs_read_int_log(bs, 1, \"disable_frame_end_update_cdf\");\n\n\tif (primary_ref_frame == AV1_PRIMARY_REF_NONE) {\n\t\t//init_non_coeff_cdfs();\n\t\tav1_setup_past_independence(state);\n\t}\n\telse {\n\t\t//load_cdfs(ref_frame_idx[primary_ref_frame]);\n\t\tav1_load_previous(state, primary_ref_frame, ref_frame_idx);\n\t}\n\n\tav1_parse_tile_info(bs, state);\n\t//quantization_params( ):\n\tu8 base_q_idx = gf_bs_read_int_log(bs, 8, \"base_q_idx\");\n\ts32 DeltaQUDc = 0;\n\ts32 DeltaQUAc = 0;\n\ts32 DeltaQVDc = 0;\n\ts32 DeltaQVAc = 0;\n\ts32 DeltaQYDc = av1_delta_q(bs, \"DeltaQYDc_coded\", \"DeltaQYDc\");\n\tif (!state->config->monochrome) {\n\t\tu8 diff_uv_delta = 0;\n\t\tif (state->separate_uv_delta_q)\n\t\t\tdiff_uv_delta = gf_bs_read_int_log(bs, 1, \"diff_uv_delta\");\n\n\t\tDeltaQUDc = av1_delta_q(bs, \"DeltaQUDc_coded\", \"DeltaQUDc\");\n\t\tDeltaQUAc = av1_delta_q(bs, \"DeltaQUAc_coded\", \"DeltaQUAc\");\n\t\tif (diff_uv_delta) {\n\t\t\tDeltaQVDc = av1_delta_q(bs, \"DeltaQVDc_coded\", \"DeltaQVDc\");\n\t\t\tDeltaQVAc = av1_delta_q(bs, \"DeltaQVAc_coded\", \"DeltaQVAc\");\n\t\t}\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"using_qmatrix\")) {\n\t\tgf_bs_read_int_log(bs, 4, \"qm_y\");\n\t\tgf_bs_read_int_log(bs, 4, \"qm_u\");\n\t\tif (!state->separate_uv_delta_q) {\n\t\t\tgf_bs_read_int_log(bs, 4, \"qm_v\");\n\t\t}\n\t}\n\n\tu8 seg_features_SEG_LVL_ALT_Q_enabled[8] = { 0,0,0,0,0,0,0,0 };\n\ts32 seg_features_SEG_LVL_ALT_Q[8] = { 0,0,0,0,0,0,0,0 };\n\n\t//segmentation_params( ):\n\tu8 segmentation_enabled = gf_bs_read_int_log(bs, 1, \"segmentation_enabled\");\n\tif (segmentation_enabled) {\n\t\t/*u8 segmentation_temporal_update = 0;*/\n\t\tu8 segmentation_update_data = 1;\n\t\tif (primary_ref_frame != AV1_PRIMARY_REF_NONE) {\n\t\t\tu8 segmentation_update_map = gf_bs_read_int_log(bs, 1, \"segmentation_update_map\");\n\t\t\tif (segmentation_update_map == 1)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"segmentation_temporal_update\");\n\t\t\tsegmentation_update_data = gf_bs_read_int_log(bs, 1, \"segmentation_update_data\");\n\t\t}\n\t\tif (segmentation_update_data == 1) {\n\t\t\tu32 i, j;\n\t\t\tfor (i = 0; i < 8/*=MAX_SEGMENTS*/; i++) {\n\t\t\t\tfor (j = 0; j < 8 /*=SEG_LVL_MAX*/; j++) {\n\t\t\t\t\tif (/*feature_enabled = */gf_bs_read_int_log_idx2(bs, 1, \"feature_enabled\", i, j) == 1) {\n\t\t\t\t\t\ts32 val;\n\t\t\t\t\t\tu32 bitsToRead = Segmentation_Feature_Bits[j];\n\t\t\t\t\t\t//this is SEG_LVL_ALT_Q\n\t\t\t\t\t\tif (!j) seg_features_SEG_LVL_ALT_Q_enabled[i] = 1;\n\n\t\t\t\t\t\tif (Segmentation_Feature_Signed[j] == 1) {\n\t\t\t\t\t\t\tval = gf_bs_read_int_log_idx2(bs, 1 + bitsToRead, \"signed_feature_value\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tval = gf_bs_read_int_log_idx2(bs, bitsToRead, \"feature_value\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!j) seg_features_SEG_LVL_ALT_Q[i] = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//ignore all init steps\n\t\t}\n\n\t}\n\n\t//delta_q_params():\n\t/*u8 delta_q_res = 0;*/\n\tu8 delta_q_present = 0;\n\tif (base_q_idx > 0) {\n\t\tdelta_q_present = gf_bs_read_int_log(bs, 1, \"delta_q_present\");\n\t}\n\tif (delta_q_present) {\n\t\tgf_bs_read_int_log(bs, 2, \"delta_q_res\");\n\t}\n\n\t//delta_lf_params():\n\tu8 delta_lf_present = 0;\n\t/*u8 delta_lf_res = 0;\n\tu8 delta_lf_multi = 0;*/\n\tif (delta_q_present) {\n\t\tif (!allow_intrabc) {\n\t\t\tdelta_lf_present = gf_bs_read_int_log(bs, 1, \"delta_lf_present\");\n\t\t}\n\t\tif (delta_lf_present) {\n\t\t\tgf_bs_read_int_log(bs, 2, \"delta_lf_res\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"delta_lf_multi\");\n\t\t}\n\t}\n\n\t//init lossless stuff!\n\tu8 CodedLossless = 1;\n\tfor (idx = 0; idx < 8; idx++) {\n\t\tu8 qindex = av1_get_qindex(GF_TRUE, idx, base_q_idx, delta_q_present, 0/*CurrentQIndex always ignored at this level of parsin*/, segmentation_enabled, seg_features_SEG_LVL_ALT_Q_enabled, seg_features_SEG_LVL_ALT_Q);\n\t\tBool LosslessArray = (qindex == 0) && (DeltaQYDc == 0) && (DeltaQUAc == 0) && (DeltaQUDc == 0) && (DeltaQVAc == 0) && (DeltaQVDc == 0);\n\t\tif (!LosslessArray)\n\t\t\tCodedLossless = 0;\n\t}\n\tBool AllLossless = CodedLossless && (state->width == state->UpscaledWidth);\n\n\t//loop_filter_params():\n\tif (!CodedLossless && !allow_intrabc) {\n\t\tu8 loop_filter_level_0 = gf_bs_read_int_log(bs, 6, \"loop_filter_level_0\");\n\t\tu8 loop_filter_level_1 = gf_bs_read_int_log(bs, 6, \"loop_filter_level_1\");\n\t\tif (!state->config->monochrome) {\n\t\t\tif (loop_filter_level_0 || loop_filter_level_1) {\n\t\t\t\tgf_bs_read_int_log(bs, 6, \"loop_filter_level_2\");\n\t\t\t\tgf_bs_read_int_log(bs, 6, \"loop_filter_level_3\");\n\t\t\t}\n\t\t}\n\t\tgf_bs_read_int_log(bs, 3, \"loop_filter_sharpness\");\n\t\tu8 loop_filter_delta_enabled = gf_bs_read_int_log(bs, 1, \"loop_filter_delta_enabled\");\n\t\tif (loop_filter_delta_enabled == 1) {\n\t\t\tu8 loop_filter_delta_update = gf_bs_read_int_log(bs, 1, \"loop_filter_delta_update\");\n\t\t\tif (loop_filter_delta_update) {\n\t\t\t\tu32 i;\n\t\t\t\tfor (i = 0; i < 8/*TOTAL_REFS_PER_FRAME*/; i++) {\n\t\t\t\t\tu8 update_ref_delta = gf_bs_read_int_log_idx(bs, 1, \"update_ref_delta\", i);\n\t\t\t\t\tif (update_ref_delta == 1) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1 + 6, \"loop_filter_ref_deltas\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\t\tu8 update_mode_delta = gf_bs_read_int_log_idx(bs, 1, \"update_mode_delta\", i);\n\t\t\t\t\tif (update_mode_delta) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1 + 6, \"loop_filter_mode_deltas\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cdef_params( ):\n\tif (!CodedLossless && !allow_intrabc && state->enable_cdef) {\n\t\tgf_bs_read_int_log(bs, 2, \"cdef_damping_minus_3\");\n\t\tu8 cdef_bits = gf_bs_read_int_log(bs, 2, \"cdef_bits\");\n\t\tu32 i, num_cd = 1 << cdef_bits;\n\t\tfor (i = 0; i < num_cd; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, 4, \"cdef_y_pri_strength\", i);\n\t\t\tgf_bs_read_int_log_idx(bs, 2, \"cdef_y_sec_strength\", i);\n\t\t\tif (!state->config->monochrome) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, 4, \"cdef_uv_pri_strength\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 2, \"cdef_uv_sec_strength\", i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//lr_params( ) :\n\tif (!AllLossless && !allow_intrabc && state->enable_restoration) {\n\t\tu32 i, nb_planes = state->config->monochrome ? 1 : 3;\n\t\tu8 UsesLr = 0;\n\t\tu8 usesChromaLr = 0;\n\t\tfor (i = 0; i < nb_planes; i++) {\n\t\t\tu8 lr_type = gf_bs_read_int_log_idx(bs, 2, \"lr_type\", i);\n\t\t\t//FrameRestorationType[i] = Remap_Lr_Type[lr_type]\n\t\t\tif (lr_type != AV1_RESTORE_NONE) {\n\t\t\t\tUsesLr = 1;\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tusesChromaLr = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (UsesLr) {\n\t\t\tif (state->use_128x128_superblock) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"lr_unit_shift_minus_1\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tu8 lr_unit_shift = gf_bs_read_int_log(bs, 1, \"lr_unit_shift\");\n\t\t\t\tif (lr_unit_shift) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"lr_unit_extra_shift\");\n\t\t\t\t\t//lr_unit_shift += lr_unit_extra_shift;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (state->config->chroma_subsampling_x && state->config->chroma_subsampling_y && usesChromaLr) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"lr_uv_shift\");\n\t\t\t}\n\t\t}\n\t}\n\t//read_tx_mode():\n\tif (CodedLossless == 1) {\n\t}\n\telse {\n\t\tgf_bs_read_int_log(bs, 1, \"tx_mode_select\");\n\t}\n\n\t//frame_reference_mode( ):\n\tu8 reference_select = 0;\n\tif (FrameIsIntra) {\n\t}\n\telse {\n\t\treference_select = gf_bs_read_int_log(bs, 1, \"reference_select\");\n\t}\n\n\t//skip_mode_params( ):\n\tu8 skipModeAllowed = 0;\n\tif (FrameIsIntra || !reference_select || !state->enable_order_hint) {\n\t}\n\telse {\n\t\tu32 i;\n\t\ts32 forwardIdx = -1;\n\t\ts32 backwardIdx = -1;\n\t\ts32 forwardHint = 0;\n\t\ts32 backwardHint = 0;\n\t\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\t\tu8 refHint = state->RefOrderHint[ref_frame_idx[i]];\n\t\t\tif (av1_get_relative_dist(refHint, frame_state->order_hint, state) < 0) {\n\t\t\t\tif (forwardIdx < 0 || av1_get_relative_dist(refHint, forwardHint, state) > 0) {\n\t\t\t\t\tforwardIdx = i;\n\t\t\t\t\tforwardHint = refHint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (av1_get_relative_dist(refHint, frame_state->order_hint, state) > 0) {\n\t\t\t\tif (backwardIdx < 0 || av1_get_relative_dist(refHint, backwardHint, state) < 0) {\n\t\t\t\t\tbackwardIdx = i;\n\t\t\t\t\tbackwardHint = refHint;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (forwardIdx < 0) {\n\t\t\tskipModeAllowed = 0;\n\t\t}\n\t\telse if (backwardIdx >= 0) {\n\t\t\tskipModeAllowed = 1;\n\t\t\t//SkipModeFrame[0] = AV1_LAST_FRAME + MIN(forwardIdx, backwardIdx);\n\t\t\t//SkipModeFrame[1] = AV1_LAST_FRAME + MAX(forwardIdx, backwardIdx);\n\t\t}\n\t\telse {\n\t\t\ts32 secondForwardIdx = -1;\n\t\t\ts32 secondForwardHint = 0;\n\t\t\tfor (i = 0; i < AV1_REFS_PER_FRAME; i++) {\n\t\t\t\tu8 refHint = state->RefOrderHint[ref_frame_idx[i]];\n\t\t\t\tif (av1_get_relative_dist(refHint, forwardHint, state) < 0) {\n\t\t\t\t\tif (secondForwardIdx < 0 || av1_get_relative_dist(refHint, secondForwardHint, state) > 0) {\n\t\t\t\t\t\tsecondForwardIdx = i;\n\t\t\t\t\t\tsecondForwardHint = refHint;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (secondForwardIdx < 0) {\n\t\t\t\tskipModeAllowed = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tskipModeAllowed = 1;\n\t\t\t\t//SkipModeFrame[ 0 ] = LAST_FRAME + Min(forwardIdx, secondForwardIdx)\n\t\t\t\t//SkipModeFrame[ 1 ] = LAST_FRAME + Max(forwardIdx, secondForwardIdx)\n\t\t\t}\n\t\t}\n\t}\n\tif (skipModeAllowed) {\n\t\tgf_bs_read_int_log(bs, 1, \"skip_mode_present\");\n\t}\n\n\n\tif (FrameIsIntra || error_resilient_mode || !state->enable_warped_motion) {\n\n\t}\n\telse {\n\t\tgf_bs_read_int_log(bs, 1, \"allow_warped_motion\");\n\t}\n\n\tgf_bs_read_int_log(bs, 1, \"reduced_tx\");\n\n\t//global_motion_params( )\n\tu32 ref;\n\tfor (ref = AV1_LAST_FRAME; ref <= AV1_ALTREF_FRAME; ref++) {\n\t\tu32 i;\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tstate->GmParams.coefs[ref][i] = ((i % 3 == 2) ? 1 << WARPEDMODEL_PREC_BITS : 0);\n\t\t}\n\t}\n\tif (!FrameIsIntra) {\n\t\tu32 refs;\n\t\tfor (refs = AV1_LAST_FRAME; refs <= AV1_ALTREF_FRAME; refs++) {\n\t\t\tu8 type = AV1_GMC_IDENTITY;\n\t\t\tBool is_global = gf_bs_read_int_log_idx(bs, 1, \"is_global\", refs);\n\t\t\tif (is_global) {\n\t\t\t\tBool is_rot_zoom = gf_bs_read_int_log_idx(bs, 1, \"is_rot_zoom\", refs);\n\t\t\t\tif (is_rot_zoom) {\n\t\t\t\t\ttype = AV1_GMC_ROTZOOM;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tBool is_trans = gf_bs_read_int_log_idx(bs, 1, \"is_translation\", refs);\n\t\t\t\t\ttype = is_trans ? AV1_GMC_TRANSLATION : AV1_GMC_AFFINE;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (type >= AV1_GMC_ROTZOOM) {\n\t\t\t\tav1_read_global_param(state, bs, type, refs, 2);\n\t\t\t\tav1_read_global_param(state, bs, type, refs, 3);\n\t\t\t\tif (type == AV1_GMC_AFFINE) {\n\t\t\t\t\tav1_read_global_param(state, bs, type, refs, 4);\n\t\t\t\t\tav1_read_global_param(state, bs, type, refs, 5);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstate->GmParams.coefs[refs][4] = -state->GmParams.coefs[refs][3];\n\t\t\t\t\tstate->GmParams.coefs[refs][5] = state->GmParams.coefs[refs][2];\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type >= AV1_GMC_TRANSLATION) {\n\t\t\t\tav1_read_global_param(state, bs, type, refs, 0);\n\t\t\t\tav1_read_global_param(state, bs, type, refs, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t//film_grain_params()\n\tif (!state->film_grain_params_present || (!state->frame_state.show_frame && !showable_frame)) {\n\t}\n\telse {\n\t\tu8 apply_grain = gf_bs_read_int_log(bs, 1, \"apply_grain\");\n\t\tif (apply_grain) {\n\t\t\tgf_bs_read_int_log(bs, 16, \"grain_seed\");\n\t\t\tu8 update_grain = 1;\n\t\t\tif (state->frame_state.frame_type == AV1_INTER_FRAME) {\n\t\t\t\tupdate_grain = gf_bs_read_int_log(bs, 1, \"update_grain\");\n\t\t\t}\n\t\t\tif (!update_grain) {\n\t\t\t\tgf_bs_read_int_log(bs, 3, \"film_grain_params_ref_idx\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tu32 i, num_y_points = gf_bs_read_int_log(bs, 4, \"num_y_points\");\n\t\t\t\tfor (i = 0; i < num_y_points; i++) {\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_y_value\", i);\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_y_scaling\", i);\n\t\t\t\t}\n\t\t\t\tu8 chroma_scaling_from_luma = 0;\n\t\t\t\tif (!state->config->monochrome)\n\t\t\t\t\tchroma_scaling_from_luma = gf_bs_read_int_log(bs, 1, \"chroma_scaling_from_luma\");\n\n\t\t\t\tu8 num_cb_points = 0;\n\t\t\t\tu8 num_cr_points = 0;\n\t\t\t\tif (state->config->monochrome || chroma_scaling_from_luma ||\n\t\t\t\t\t((state->config->chroma_subsampling_x == 1) && (state->config->chroma_subsampling_y == 1) && (num_y_points == 0))\n\t\t\t\t\t) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum_cb_points = gf_bs_read_int_log(bs, 4, \"num_cb_points\");\n\t\t\t\t\tfor (i = 0; i < num_cb_points; i++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_cb_value\", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_cb_scaling\", i);\n\t\t\t\t\t}\n\t\t\t\t\tnum_cr_points = gf_bs_read_int_log(bs, 4, \"num_cr_points\");\n\t\t\t\t\tfor (i = 0; i < num_cr_points; i++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_cr_value\", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"point_cr_scaling\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"grain_scaling_minus_8\");\n\t\t\t\tu8 ar_coeff_lag = gf_bs_read_int_log(bs, 2, \"ar_coeff_lag\");\n\t\t\t\tu16 numPosLuma = 2 * ar_coeff_lag * (ar_coeff_lag + 1);\n\t\t\t\tu16 numPosChroma = numPosLuma;\n\t\t\t\tif (num_y_points) {\n\t\t\t\t\tnumPosChroma = numPosLuma + 1;\n\t\t\t\t\tfor (i = 0; i < numPosLuma; i++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"ar_coeffs_y_plus_128\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (chroma_scaling_from_luma || num_cb_points) {\n\t\t\t\t\tfor (i = 0; i < numPosChroma; i++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"ar_coeffs_cb_plus_128\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (chroma_scaling_from_luma || num_cr_points) {\n\t\t\t\t\tfor (i = 0; i < numPosChroma; i++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"ar_coeffs_cr_plus_128\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"ar_coeff_shift_minus_6\");\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"grain_scale_shift\");\n\t\t\t\tif (num_cb_points) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 8, \"cb_mult\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 8, \"cb_luma_mult\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 9, \"cb_offset\");\n\t\t\t\t}\n\t\t\t\tif (num_cr_points) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 8, \"cr_mult\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 8, \"cr_luma_mult\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 9, \"cr_offset\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"overlap_flag\");\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"clip_to_restricted_range\");\n\t\t\t}\n\t\t}\n\t}\n\n\t//end of uncompressed header !!\n}\n\nGF_EXPORT\nvoid gf_av1_init_state(AV1State *state)\n{\n\tif (!state) return;\n\tmemset(state, 0, sizeof(AV1State));\n\tstate->color_primaries = 2;\n\tstate->transfer_characteristics = 2;\n\tstate->matrix_coefficients = 2;\n}\n\nGF_EXPORT\nvoid gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tu32 size;\n\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}\n\nstatic GF_Err av1_parse_tile_group(GF_BitStream *bs, AV1State *state, u64 obu_start, u64 obu_size)\n{\n\tu32 TileNum, tg_start = 0, tg_end = 0;\n\tBool numTiles = state->tileCols * state->tileRows;\n\tBool tile_start_and_end_present_flag = GF_FALSE;\n\tGF_Err e = GF_OK;\n\tif (numTiles > 1)\n\t\ttile_start_and_end_present_flag = gf_bs_read_int_log(bs, 1, \"tile_start_and_end_present_flag\");\n\n\tif (numTiles == 1 || !tile_start_and_end_present_flag) {\n\t\ttg_start = 0;\n\t\ttg_end = numTiles - 1;\n\t\t/*state->frame_state.tg[0].start_idx = 0;\n\t\tstate->frame_state.tg[0].end_idx = numTiles - 1;*/\n\t}\n\telse {\n\t\tu32 tileBits = state->tileColsLog2 + state->tileRowsLog2;\n\t\t/*state->frame_state.tg[state->frame_state.tg_idx].start_idx*/ tg_start = gf_bs_read_int_log(bs, tileBits, \"tg_start\");\n\t\t/*state->frame_state.tg[state->frame_state.tg_idx].end_idx*/ tg_end = gf_bs_read_int_log(bs, tileBits, \"tg_end\");\n\t}\n\t/*state->frame_state.tg_idx++;*/\n\n\tgf_bs_align(bs);\n\n\tif (tg_end >= GF_ARRAY_LENGTH(state->frame_state.tiles))\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n\tstate->frame_state.nb_tiles_in_obu = 0;\n\tfor (TileNum = tg_start; TileNum <= tg_end; TileNum++) {\n\t\tu32 tile_start_offset, tile_size;\n\t\t/*u32 tileRow = TileNum / state->tileCols;\n\t\tu32 tileCol = TileNum % state->tileCols;*/\n\t\tBool lastTile = TileNum == tg_end;\n\t\tu64 pos = gf_bs_get_position(bs);\n\t\tif (lastTile) {\n\t\t\ttile_start_offset = (u32)(pos - obu_start);\n\t\t\ttile_size = (u32)(obu_size - (pos - obu_start));\n\t\t}\n\t\telse {\n\t\t\tu64 tile_size_minus_1 = aom_av1_le(bs, state->tile_size_bytes, \"tile_size_minus_1\");\n\t\t\tpos = gf_bs_get_position(bs);\n\t\t\ttile_start_offset = (u32)(pos - obu_start);\n\t\t\ttile_size = (u32)(tile_size_minus_1 + 1/* + state->tile_size_bytes*/);\n\t\t}\n\n\n\t\tif (tile_start_offset + tile_size > obu_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] Error parsing tile group, tile %d start %d + size %d exceeds OBU length %d\\n\", TileNum, tile_start_offset, tile_size, obu_size));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbreak;\n\t\t}\n\n\t\tstate->frame_state.tiles[state->frame_state.nb_tiles_in_obu].obu_start_offset = tile_start_offset;\n\t\tstate->frame_state.tiles[state->frame_state.nb_tiles_in_obu].size = tile_size;\n\t\tgf_bs_skip_bytes(bs, tile_size);\n\t\tstate->frame_state.nb_tiles_in_obu++;\n\t}\n\tif (tg_end == numTiles - 1) {\n\t\tav1_decode_frame_wrapup(state);\n\t}\n\treturn e;\n}\n\nstatic void av1_parse_frame_header(GF_BitStream *bs, AV1State *state)\n{\n\tAV1StateFrame *frame_state = &state->frame_state;\n\tif (frame_state->seen_frame_header == GF_FALSE) {\n\t\tu64 pos = gf_bs_get_position(bs);\n\t\tstate->frame_state.show_existing_frame = GF_FALSE;\n\t\tframe_state->seen_frame_header = GF_TRUE;\n\t\tav1_parse_uncompressed_header(bs, state);\n\t\tstate->frame_state.is_first_frame = GF_FALSE;\n\t\tstate->frame_state.uncompressed_header_bytes = (u32) (gf_bs_get_position(bs) - pos);\n\n\t\tif (state->frame_state.show_existing_frame) {\n\t\t\tav1_decode_frame_wrapup(state);\n\t\t\tframe_state->seen_frame_header = GF_FALSE;\n\t\t}\n\t\telse {\n\t\t\t//TileNum = 0;\n\t\t\tframe_state->seen_frame_header = GF_TRUE;\n\t\t}\n\t}\n}\n\nstatic GF_Err av1_parse_frame(GF_BitStream *bs, AV1State *state, u64 obu_start, u64 obu_size)\n{\n\tav1_parse_frame_header(bs, state);\n\t//byte alignment\n\tgf_bs_align(bs);\n\treturn av1_parse_tile_group(bs, state, obu_start, obu_size);\n}\n\nstatic void on_aom_av1_eos(void *_state)\n{\n\tAV1State *state = (AV1State *)_state;\n\tstate->bs_overread = GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_av1_parse_obu(GF_BitStream *bs, ObuType *obu_type, u64 *obu_size, u32 *obu_hdr_size, AV1State *state)\n{\n\tGF_Err e = GF_OK;\n\tu32 i, hdr_size;\n\tu64 pos = gf_bs_get_position(bs);\n\n\tif (!bs || !obu_type || !state)\n\t\treturn GF_BAD_PARAM;\n\n\tstate->bs_overread = GF_FALSE;\n\tgf_bs_set_eos_callback(bs, on_aom_av1_eos, state);\n\n\tstate->obu_extension_flag = state->obu_has_size_field = 0;\n\tstate->temporal_id = state->spatial_id = 0;\n\tstate->frame_state.uncompressed_header_bytes = 0;\n\te = gf_av1_parse_obu_header(bs, obu_type, &state->obu_extension_flag, &state->obu_has_size_field, &state->temporal_id, &state->spatial_id);\n\tif (e)\n\t\treturn e;\n\n\tif (state->obu_has_size_field) {\n\t\t*obu_size = (u32)gf_av1_leb128_read(bs, NULL);\n\t}\n\telse {\n\t\tif (*obu_size >= 1 + state->obu_extension_flag) {\n\t\t\t*obu_size = *obu_size - 1 - state->obu_extension_flag;\n\t\t}\n\t\telse {\n\t\t\tGF_LOG(state->config ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_CODING, (\"[AV1] computed OBU size \"LLD\" (input value = \"LLU\"). Skipping.\\n\", *obu_size - 1 - state->obu_extension_flag, *obu_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t}\n\thdr_size = (u32)(gf_bs_get_position(bs) - pos);\n\tif ((gf_bs_available(bs) < *obu_size) || state->bs_overread) {\n\t\tgf_bs_seek(bs, pos);\n\t\treturn GF_BUFFER_TOO_SMALL;\n\t}\n\t*obu_size += hdr_size;\n\tif (obu_hdr_size) *obu_hdr_size = hdr_size;\n\n\n\tif (*obu_type != OBU_SEQUENCE_HEADER && *obu_type != OBU_TEMPORAL_DELIMITER &&\n\t\tstate->OperatingPointIdc != 0 && state->obu_extension_flag == 1)\n\t{\n\t\tu32 inTemporalLayer = (state->OperatingPointIdc >> state->temporal_id) & 1;\n\t\tu32 inSpatialLayer = (state->OperatingPointIdc >> (state->spatial_id + 8)) & 1;\n\t\tif (!inTemporalLayer || !inSpatialLayer) {\n\t\t\t*obu_type = -1;\n\t\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\te = GF_OK;\n\n\t/* for AVIF a1lx */\n\tfor (i = state->spatial_id; i < 4; i++) {\n\t\tstate->layer_size[i] = (u32) (pos + *obu_size);\n\t}\n\n\tswitch (*obu_type) {\n\tcase OBU_SEQUENCE_HEADER:\n\t\tav1_parse_sequence_header_obu(bs, state);\n\t\tif (gf_bs_get_position(bs) > pos + *obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Sequence header parsing consumed too many bytes !\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\n\tcase OBU_METADATA:\n#if 0\n\t\t//TODO + sample groups\n\t\tconst ObuMetadataType metadata_type = (u32)read_leb128(bs, NULL); we should check for 16 bits limit(AV1MetadataSampleGroupEntry) for ISOBMFF bindings, see https ://github.com/AOMediaCodec/av1-isobmff/pull/86#issuecomment-416659538\n\t\tif (metadata_type == OBU_METADATA_TYPE_ITUT_T35) {\n\t\t}\n\t\telse if (metadata_type == OBU_METADATA_TYPE_HDR_CLL) {\n\t\t}\n\t\telse if (metadata_type == OBU_METADATA_TYPE_HDR_MDCV) {\n\t\t}\n\t\telse if (metadata_type == OBU_METADATA_TYPE_SCALABILITY) {\n\t\t}\n\t\telse if (metadata_type == METADATA_TYPE_TIMECODE) {\n\t\t}\n#endif\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[AV1] parsing for metadata is not implemented. Forwarding.\\n\"));\n\n\t\tif (gf_bs_get_position(bs) > pos + *obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Metadata parsing consumed too many bytes !\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\n\tcase OBU_FRAME_HEADER:\n\tcase OBU_REDUNDANT_FRAME_HEADER:\n\t\tif (state->config) {\n\t\t\tav1_parse_frame_header(bs, state);\n\t\t\tif (gf_bs_get_position(bs) > pos + *obu_size) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Frame header parsing consumed too many bytes !\\n\"));\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\tcase OBU_FRAME:\n\t\te = av1_parse_frame(bs, state, pos, *obu_size);\n\t\tif (gf_bs_get_position(bs) != pos + *obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Frame parsing did not consume the right number of bytes !\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\tcase OBU_TILE_GROUP:\n\t\tif (state->config) {\n\t\t\te = av1_parse_tile_group(bs, state, pos, *obu_size);\n\t\t\tif (gf_bs_get_position(bs) != pos + *obu_size) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Tile group parsing did not consume the right number of bytes !\\n\"));\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\tcase OBU_TEMPORAL_DELIMITER:\n\t\tstate->frame_state.seen_frame_header = GF_FALSE;\n\tcase OBU_PADDING:\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] unknown OBU type %u (size \"LLU\"). Skipping.\\n\", *obu_type, *obu_size));\n\t\tgf_bs_seek(bs, pos + *obu_size);\n\t\tbreak;\n\t}\n\treturn e;\n}\n\n\nGF_EXPORT\nGF_Err gf_media_prores_parse_bs(GF_BitStream *bs, GF_ProResFrameInfo *prores_frame)\n{\n\tu32 i, j;\n\tu64 start, pos;\n\tmemset(prores_frame, 0, sizeof(GF_ProResFrameInfo));\n\n\tstart = gf_bs_get_position(bs);\n\tif (gf_bs_available(bs) < 10)\n\t\treturn GF_BUFFER_TOO_SMALL;\n\n\tprores_frame->frame_size = gf_bs_read_u32(bs);\n\tprores_frame->frame_identifier = gf_bs_read_u32(bs);\n\tif (prores_frame->frame_identifier != GF_4CC('i','c','p','f')) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[ProRes] Invalid frame identifier, expected \\\"icpf\\\" got \\\"%s\\\"\\n\", gf_4cc_to_str(prores_frame->frame_identifier) ));\n\t\tgf_bs_seek(bs, start);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\t/*parse frame header*/\n\tpos = gf_bs_get_position(bs);\n\tprores_frame->frame_hdr_size = gf_bs_read_u16(bs);\n\tif (gf_bs_available(bs) + 2 < prores_frame->frame_hdr_size) {\n\t\tgf_bs_seek(bs, start);\n\t\treturn GF_BUFFER_TOO_SMALL;\n\t}\n\tgf_bs_read_u8(bs);\n\tprores_frame->version = gf_bs_read_u8(bs);\n\tprores_frame->encoder_id = gf_bs_read_u32(bs);\n\tprores_frame->width = gf_bs_read_u16(bs);\n\tprores_frame->height = gf_bs_read_u16(bs);\n\tprores_frame->chroma_format = gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 2);\n\tprores_frame->interlaced_mode = gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 2);\n\tprores_frame->aspect_ratio_information = gf_bs_read_int(bs, 4);\n\tprores_frame->framerate_code = gf_bs_read_int(bs, 4);\n\tprores_frame->color_primaries = gf_bs_read_u8(bs);\n\tprores_frame->transfer_characteristics = gf_bs_read_u8(bs);\n\tprores_frame->matrix_coefficients = gf_bs_read_u8(bs);\n\tgf_bs_read_int(bs, 4);\n\tprores_frame->alpha_channel_type = gf_bs_read_int(bs, 4);\n\tgf_bs_read_int(bs, 14);\n\tprores_frame->load_luma_quant_matrix = gf_bs_read_int(bs, 1);\n\tprores_frame->load_chroma_quant_matrix = gf_bs_read_int(bs, 1);\n\tif (prores_frame->load_luma_quant_matrix) {\n\t\tfor (i=0; i<8; i++) {\n\t\t\tfor (j=0; j<8; j++) {\n\t\t\t\tprores_frame->luma_quant_matrix[i][j] = gf_bs_read_u8(bs);\n\t\t\t}\n\t\t}\n\t}\n\tif (prores_frame->load_chroma_quant_matrix) {\n\t\tfor (i=0; i<8; i++) {\n\t\t\tfor (j=0; j<8; j++) {\n\t\t\t\tprores_frame->chroma_quant_matrix[i][j] = gf_bs_read_u8(bs);\n\t\t\t}\n\t\t}\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != prores_frame->frame_hdr_size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[ProRes] Invalid frame header size, expected %d got %d\\n\", prores_frame->frame_hdr_size, (u32) pos));\n\t\tgf_bs_seek(bs, start);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tprores_frame->nb_pic = ((prores_frame->interlaced_mode==1) || (prores_frame->interlaced_mode==2)) ? 2 : 1;\n\tgf_bs_seek(bs, start);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\nGF_EXPORT\nu8 gf_mp3_version(u32 hdr)\n{\n\treturn ((hdr >> 19) & 0x3);\n}\n\nGF_EXPORT\nconst char *gf_mp3_version_name(u32 hdr)\n{\n\tu32 v = gf_mp3_version(hdr);\n\tswitch (v) {\n\tcase 0:\n\t\treturn \"MPEG-2.5\";\n\tcase 1:\n\t\treturn \"Reserved\";\n\tcase 2:\n\t\treturn \"MPEG-2\";\n\tcase 3:\n\t\treturn \"MPEG-1\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nGF_EXPORT\nu8 gf_mp3_layer(u32 hdr)\n{\n\treturn 4 - (((hdr >> 17) & 0x3));\n}\n\nGF_EXPORT\nu8 gf_mp3_num_channels(u32 hdr)\n{\n\tif (((hdr >> 6) & 0x3) == 3) return 1;\n\treturn 2;\n}\n\nGF_EXPORT\nu16 gf_mp3_sampling_rate(u32 hdr)\n{\n\tu16 res;\n\t/* extract the necessary fields from the MP3 header */\n\tu8 version = gf_mp3_version(hdr);\n\tu8 sampleRateIndex = (hdr >> 10) & 0x3;\n\n\tswitch (sampleRateIndex) {\n\tcase 0:\n\t\tres = 44100;\n\t\tbreak;\n\tcase 1:\n\t\tres = 48000;\n\t\tbreak;\n\tcase 2:\n\t\tres = 32000;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[MPEG-1/2 Audio] Samplerate index not valid\\n\"));\n\t\treturn 0;\n\t}\n\t/*reserved or MPEG-1*/\n\tif (version & 1) return res;\n\n\t/*MPEG-2*/\n\tres /= 2;\n\t/*MPEG-2.5*/\n\tif (version == 0) res /= 2;\n\treturn res;\n}\n\nGF_EXPORT\nu16 gf_mp3_window_size(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\n\tif (layer == 3) {\n\t\tif (version == 3) return 1152;\n\t\treturn 576;\n\t}\n\tif (layer == 2) return 1152;\n\treturn 384;\n}\n\nGF_EXPORT\nu8 gf_mp3_object_type_indication(u32 hdr)\n{\n\tswitch (gf_mp3_version(hdr)) {\n\tcase 3:\n\t\treturn GF_CODECID_MPEG_AUDIO;\n\tcase 2:\n\tcase 0:\n\t\treturn GF_CODECID_MPEG2_PART3;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}\n\n/*aligned bitrate parsing with libMAD*/\n\nstatic\nu32 const bitrate_table[5][15] = {\n\t/* MPEG-1 */\n\t{\t0,  32000,  64000,  96000, 128000, 160000, 192000, 224000,  /* Layer I   */\n\t\t256000, 288000, 320000, 352000, 384000, 416000, 448000\n\t},\n\t{\t0,  32000,  48000,  56000,  64000,  80000,  96000, 112000,  /* Layer II  */\n\t\t128000, 160000, 192000, 224000, 256000, 320000, 384000\n\t},\n\t{\t0,  32000,  40000,  48000,  56000,  64000,  80000,  96000,  /* Layer III */\n\t\t112000, 128000, 160000, 192000, 224000, 256000, 320000\n\t},\n\n\t/* MPEG-2 LSF */\n\t{\t0,  32000,  48000,  56000,  64000,  80000,  96000, 112000,  /* Layer I   */\n\t\t128000, 144000, 160000, 176000, 192000, 224000, 256000\n\t},\n\t{\t0,   8000,  16000,  24000,  32000,  40000,  48000,  56000,  /* Layers    */\n\t\t64000,  80000,  96000, 112000, 128000, 144000, 160000\n\t} /* II & III  */\n};\n\n\nu32 gf_mp3_bit_rate(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\tu8 bitRateIndex = (hdr >> 12) & 0xF;\n\tu32 lidx;\n\t/*MPEG-1*/\n\tif (version & 1) {\n\t\tif (!layer) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[MPEG-1/2 Audio] layer index not valid\\n\"));\n\t\t\treturn 0;\n\t\t}\n\t\tlidx = layer - 1;\n\t}\n\t/*MPEG-2/2.5*/\n\telse {\n\t\tlidx = 3 + (layer >> 1);\n\t}\n\tif (lidx>4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[MPEG-1/2 Audio] layer index not valid\\n\"));\n\t\treturn 0;\n\t}\n\treturn bitrate_table[lidx][bitRateIndex];\n}\n\n\n\nGF_EXPORT\nu16 gf_mp3_frame_size(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\tu32 pad = ((hdr >> 9) & 0x1) ? 1 : 0;\n\tu32 bitrate = gf_mp3_bit_rate(hdr);\n\tu32 samplerate = gf_mp3_sampling_rate(hdr);\n\n\tu32 frameSize = 0;\n\tif (!samplerate || !bitrate) return 0;\n\n\tif (layer == 1) {\n\t\tframeSize = ((12 * bitrate / samplerate) + pad) * 4;\n\t}\n\telse {\n\t\tu32 slots_per_frame = 144;\n\t\tif ((layer == 3) && !(version & 1)) slots_per_frame = 72;\n\t\tframeSize = (slots_per_frame * bitrate / samplerate) + pad;\n\t}\n\treturn (u16)frameSize;\n}\n\n\nGF_EXPORT\nu32 gf_mp3_get_next_header(FILE* in)\n{\n\tu8 b, state = 0;\n\tu32 dropped = 0;\n\tunsigned char bytes[4];\n\tbytes[0] = bytes[1] = bytes[2] = bytes[3] = 0;\n\n\twhile (1) {\n\t\tif (gf_fread(&b, 1, in) == 0) return 0;\n\n\t\tif (state == 3) {\n\t\t\tbytes[state] = b;\n\t\t\treturn GF_4CC((u32)bytes[0], bytes[1], bytes[2], bytes[3]);\n\t\t}\n\t\tif (state == 2) {\n\t\t\tif (((b & 0xF0) == 0) || ((b & 0xF0) == 0xF0) || ((b & 0x0C) == 0x0C)) {\n\t\t\t\tif (bytes[1] == 0xFF) state = 1;\n\t\t\t\telse state = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t}\n\t\tif (state == 1) {\n\t\t\tif (((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (state == 0) {\n\t\t\tif (b == 0xFF) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((dropped == 0) && ((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\t\tbytes[0] = (u8)0xFF;\n\t\t\t\t\tbytes[1] = b;\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdropped++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_mp3_get_next_header_mem(const u8 *buffer, u32 size, u32 *pos)\n{\n\tu32 cur;\n\tu8 b, state = 0;\n\tu32 dropped = 0;\n\tunsigned char bytes[4];\n\tbytes[0] = bytes[1] = bytes[2] = bytes[3] = 0;\n\n\tcur = 0;\n\t*pos = 0;\n\twhile (cur < size) {\n\t\tb = (u8)buffer[cur];\n\t\tcur++;\n\n\t\tif (state == 3) {\n\t\t\tu32 val;\n\t\t\tbytes[state] = b;\n\t\t\tval = GF_4CC((u32)bytes[0], bytes[1], bytes[2], bytes[3]);\n\t\t\tif (gf_mp3_frame_size(val)) {\n\t\t\t\t*pos = dropped;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t\tstate = 0;\n\t\t\tdropped = cur;\n\t\t}\n\t\tif (state == 2) {\n\t\t\tif (((b & 0xF0) == 0) || ((b & 0xF0) == 0xF0) || ((b & 0x0C) == 0x0C)) {\n\t\t\t\tif (bytes[1] == 0xFF) {\n\t\t\t\t\tstate = 1;\n\t\t\t\t\tdropped += 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tdropped = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t}\n\t\tif (state == 1) {\n\t\t\tif (((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate = 0;\n\t\t\t\tdropped = cur;\n\t\t\t}\n\t\t}\n\n\t\tif (state == 0) {\n\t\t\tif (b == 0xFF) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdropped++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n\nGF_EXPORT\nBool gf_avc_is_rext_profile(u8 profile_idc)\n{\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\tcase 138:\n\tcase 139:\n\tcase 134:\n\tcase 135:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nconst char *gf_avc_get_profile_name(u8 video_prof)\n{\n\tswitch (video_prof) {\n\tcase 0x42:\n\t\treturn \"Baseline\";\n\tcase 0x4D:\n\t\treturn \"Main\";\n\tcase 0x53:\n\t\treturn \"Scalable Baseline\";\n\tcase 0x56:\n\t\treturn \"Scalable High\";\n\tcase 0x58:\n\t\treturn \"Extended\";\n\tcase 0x64:\n\t\treturn \"High\";\n\tcase 0x6E:\n\t\treturn \"High 10\";\n\tcase 0x7A:\n\t\treturn \"High 4:2:2\";\n\tcase 0x90:\n\tcase 0xF4:\n\t\treturn \"High 4:4:4\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nGF_EXPORT\nconst char *gf_hevc_get_profile_name(u8 video_prof)\n{\n\tswitch (video_prof) {\n\tcase 0x01:\n\t\treturn \"Main\";\n\tcase 0x02:\n\t\treturn \"Main 10\";\n\tcase 0x03:\n\t\treturn \"Main Still Picture\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\nGF_EXPORT\nconst char *gf_avc_hevc_get_chroma_format_name(u8 chroma_format)\n{\n\tswitch (chroma_format) {\n\tcase 1:\n\t\treturn \"YUV 4:2:0\";\n\tcase 2:\n\t\treturn \"YUV 4:2:2\";\n\tcase 3:\n\t\treturn \"YUV 4:4:4\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nu32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\tbreak;\n\t\t}\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead>=32) {\n\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n\t\tif (!gf_bs_available(bs)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (nb_lead) {\n\t\tu32 leads=1;\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tleads <<= nb_lead;\n\t\tleads -= 1;\n\t\tval += leads;\n//\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}\n\n#define gf_bs_read_ue_log_idx2(_bs, _fname, _idx1, _idx2) gf_bs_read_ue_log_idx3(_bs, _fname, (s32) _idx1, (s32) _idx2, -1)\n#define gf_bs_read_ue_log_idx(_bs, _fname, _idx) gf_bs_read_ue_log_idx3(_bs, _fname, (s32) _idx, -1, -1)\n#define gf_bs_read_ue_log(_bs, _fname) gf_bs_read_ue_log_idx3(_bs, _fname, -1, -1, -1)\n\n\nu32 gf_bs_read_ue(GF_BitStream *bs)\n{\n\treturn gf_bs_read_ue_log(bs, NULL);\n}\n\ns32 gf_bs_read_se(GF_BitStream *bs)\n{\n\tu32 v = gf_bs_read_ue(bs);\n\tif ((v & 0x1) == 0) return (s32)(0 - (v >> 1));\n\treturn (v + 1) >> 1;\n}\n\ns32 gf_bs_read_se_log_idx2(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2)\n{\n\ts32 res = gf_bs_read_se(bs);\n\tif (fname)\n\t\tgf_bs_log_idx(bs, -1, fname, res, idx1, idx2, -1);\n\treturn res;\n}\n#define gf_bs_read_se_log_idx(_bs, _fname, _idx) gf_bs_read_se_log_idx2(_bs, _fname, (s32) _idx, -1)\n#define gf_bs_read_se_log(_bs, _fname) gf_bs_read_se_log_idx2(_bs, _fname, -1, -1)\n\n\n\nvoid gf_bs_write_ue(GF_BitStream *bs, u32 num) {\n\ts32 length = 1;\n\ts32 temp = ++num;\n\n\twhile (temp != 1) {\n\t\ttemp >>= 1;\n\t\tlength += 2;\n\t}\n\n\tgf_bs_write_int(bs, 0, length >> 1);\n\tgf_bs_write_int(bs, num, (length + 1) >> 1);\n}\n\nvoid gf_bs_write_se(GF_BitStream *bs, s32 num)\n{\n\tu32 v;\n\tif (num <= 0)\n\t\tv = (-1 * num) << 1;\n\telse\n\t\tv = (num << 1) - 1;\n\n\tgf_bs_write_ue(bs, v);\n}\n\nu32 gf_media_nalu_is_start_code(GF_BitStream *bs)\n{\n\tu8 s1, s2, s3, s4;\n\tBool is_sc = 0;\n\tu64 pos = gf_bs_get_position(bs);\n\ts1 = gf_bs_read_int(bs, 8);\n\ts2 = gf_bs_read_int(bs, 8);\n\tif (!s1 && !s2) {\n\t\ts3 = gf_bs_read_int(bs, 8);\n\t\tif (s3 == 0x01) is_sc = 3;\n\t\telse if (!s3) {\n\t\t\ts4 = gf_bs_read_int(bs, 8);\n\t\t\tif (s4 == 0x01) is_sc = 4;\n\t\t}\n\t}\n\tgf_bs_seek(bs, pos + is_sc);\n\treturn is_sc;\n}\n\n/*read that amount of data at each IO access rather than fetching byte by byte...*/\n#define AVC_CACHE_SIZE\t4096\n\nstatic u32 gf_media_nalu_locate_start_code_bs(GF_BitStream *bs, Bool locate_trailing)\n{\n\tu32 v, bpos, nb_cons_zeros = 0;\n\tchar avc_cache[AVC_CACHE_SIZE];\n\tu64 end, cache_start, load_size;\n\tu64 start = gf_bs_get_position(bs);\n\tif (start < 3) return 0;\n\n\tload_size = 0;\n\tbpos = 0;\n\tcache_start = 0;\n\tend = 0;\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\t/*refill cache*/\n\t\tif (bpos == (u32)load_size) {\n\t\t\tif (!gf_bs_available(bs)) break;\n\t\t\tload_size = gf_bs_available(bs);\n\t\t\tif (load_size > AVC_CACHE_SIZE) load_size = AVC_CACHE_SIZE;\n\t\t\tbpos = 0;\n\t\t\tcache_start = gf_bs_get_position(bs);\n\t\t\tgf_bs_read_data(bs, avc_cache, (u32)load_size);\n\t\t}\n\t\tv = ( (v<<8) & 0xFFFFFF00) | ((u32) avc_cache[bpos]);\n\t\tbpos++;\n\n\t\tif (locate_trailing) {\n\t\t\tif ((v & 0x000000FF) == 0) nb_cons_zeros++;\n\t\t\telse nb_cons_zeros = 0;\n\t\t}\n\n\t\tif (v == 0x00000001) end = cache_start + bpos - 4;\n\t\telse if ((v & 0x00FFFFFF) == 0x00000001) end = cache_start + bpos - 3;\n\t}\n\n\tgf_bs_seek(bs, start);\n\tif (!end) end = gf_bs_get_size(bs);\n\tif (locate_trailing) {\n\t\tif (nb_cons_zeros >= 3)\n\t\t\treturn (u32)(end - start - nb_cons_zeros);\n\t}\n\treturn (u32)(end - start);\n}\n\nGF_EXPORT\nu32 gf_media_nalu_next_start_code_bs(GF_BitStream *bs)\n{\n\treturn gf_media_nalu_locate_start_code_bs(bs, 0);\n}\n\nGF_EXPORT\nu32 gf_media_nalu_next_start_code(const u8 *data, u32 data_len, u32 *sc_size)\n{\n\tu32 avail = data_len;\n\tconst u8 *cur = data;\n\n\twhile (cur) {\n\t\tu32 v, bpos;\n\t\tu8 *next_zero = memchr(cur, 0, avail);\n\t\tif (!next_zero) return data_len;\n\n\t\tv = 0xffffff00;\n\t\tbpos = (u32)(next_zero - data) + 1;\n\t\twhile (1) {\n\t\t\tu8 cval;\n\t\t\tif (bpos == (u32)data_len)\n\t\t\t\treturn data_len;\n\n\t\t\tcval = data[bpos];\n\t\t\tv = ((v << 8) & 0xFFFFFF00) | ((u32)cval);\n\t\t\tbpos++;\n\t\t\tif (v == 0x00000001) {\n\t\t\t\t*sc_size = 4;\n\t\t\t\treturn bpos - 4;\n\t\t\t}\n\t\t\telse if ((v & 0x00FFFFFF) == 0x00000001) {\n\t\t\t\t*sc_size = 3;\n\t\t\t\treturn bpos - 3;\n\t\t\t}\n\t\t\tif (cval)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bpos >= data_len)\n\t\t\tbreak;\n\t\tcur = data + bpos;\n\t\tavail = data_len - bpos;\n\t}\n\treturn data_len;\n}\n\nBool gf_media_avc_slice_is_intra(AVCState *avc)\n{\n\tswitch (avc->s_info.slice_type) {\n\tcase GF_AVC_TYPE_I:\n\tcase GF_AVC_TYPE2_I:\n\tcase GF_AVC_TYPE_SI:\n\tcase GF_AVC_TYPE2_SI:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#if 0 //unused\nBool gf_media_avc_slice_is_IDR(AVCState *avc)\n{\n\tif (avc->sei.recovery_point.valid)\n\t{\n\t\tavc->sei.recovery_point.valid = 0;\n\t\treturn 1;\n\t}\n\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE)\n\t\treturn 0;\n\treturn gf_media_avc_slice_is_intra(avc);\n}\n#endif\n\nstatic const struct  {\n\tu32 w, h;\n} avc_hevc_sar[] = {\n\t{ 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 },\n\t{ 16, 11 }, { 40, 33 }, { 24, 11 }, { 20, 11 },\n\t{ 32, 11 }, { 80, 33 }, { 18, 11 }, { 15, 11 },\n\t{ 64, 33 }, { 160,99 }, {  4,  3 }, {  3,  2 },\n\t{  2,  1 }\n};\n\n\n/*ISO 14496-10 (N11084) E.1.2*/\nstatic void avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)\n{\n\tint i, cpb_cnt_minus1;\n\n\tcpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"cpb_cnt_minus1\");\n\tif (cpb_cnt_minus1 > 31)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\\n\", cpb_cnt_minus1));\n\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\n\t/*for( SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++ ) {*/\n\tfor (i = 0; i <= cpb_cnt_minus1; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \"bit_rate_value_minus1\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"cpb_size_value_minus1\", i);\n\t\tgf_bs_read_int_log_idx(bs, 1, \"cbr_flag\", i);\n\t}\n\tgf_bs_read_int_log(bs, 5, \"initial_cpb_removal_delay_length_minus1\");\n\thrd->cpb_removal_delay_length_minus1 = gf_bs_read_int_log(bs, 5, \"cpb_removal_delay_length_minus1\");\n\thrd->dpb_output_delay_length_minus1 = gf_bs_read_int_log(bs, 5, \"dpb_output_delay_length_minus1\");\n\thrd->time_offset_length = gf_bs_read_int_log(bs, 5, \"time_offset_length\");\n\treturn;\n}\n\n/*returns the nal_size without emulation prevention bytes*/\nu32 gf_media_nalu_emulation_bytes_add_count(u8 *buffer, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size) {\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\tother than the following sequences shall not occur at any byte-aligned position:\n\t\t\\96 0x00000300\n\t\t\\96 0x00000301\n\t\t\\96 0x00000302\n\t\t\\96 0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2 && (u8)buffer[i] < 0x04) {\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\tif (!buffer[i])\n\t\t\t\tnum_zero = 1;\n\t\t}\n\t\telse {\n\t\t\tif (!buffer[i])\n\t\t\t\tnum_zero++;\n\t\t\telse\n\t\t\t\tnum_zero = 0;\n\t\t}\n\t\ti++;\n\t}\n\treturn emulation_bytes_count;\n}\n\nu32 gf_media_nalu_add_emulation_bytes(const u8 *buffer_src, u8 *buffer_dst, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size) {\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\tother than the following sequences shall not occur at any byte-aligned position:\n\t\t0x00000300\n\t\t0x00000301\n\t\t0x00000302\n\t\t0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2 && (u8)buffer_src[i] < 0x04) {\n\t\t\t/*add emulation code*/\n\t\t\tnum_zero = 0;\n\t\t\tbuffer_dst[i + emulation_bytes_count] = 0x03;\n\t\t\temulation_bytes_count++;\n\t\t\tif (!buffer_src[i])\n\t\t\t\tnum_zero = 1;\n\t\t}\n\t\telse {\n\t\t\tif (!buffer_src[i])\n\t\t\t\tnum_zero++;\n\t\t\telse\n\t\t\t\tnum_zero = 0;\n\t\t}\n\t\tbuffer_dst[i + emulation_bytes_count] = buffer_src[i];\n\t\ti++;\n\t}\n\treturn nal_size + emulation_bytes_count;\n}\n\n/*returns the nal_size without emulation prevention bytes*/\nu32 gf_media_nalu_emulation_bytes_remove_count(const u8 *buffer, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\tif (!buffer || !nal_size) return 0;\n\n\twhile (i < nal_size)\n\t{\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\t  other than the following sequences shall not occur at any byte-aligned position:\n\t\t  \\96 0x00000300\n\t\t  \\96 0x00000301\n\t\t  \\96 0x00000302\n\t\t  \\96 0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2\n\t\t\t&& buffer[i] == 0x03\n\t\t\t&& i + 1 < nal_size /*next byte is readable*/\n\t\t\t&& (u8)buffer[i + 1] < 0x04)\n\t\t{\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\ti++;\n\t\t}\n\n\t\tif (!buffer[i])\n\t\t\tnum_zero++;\n\t\telse\n\t\t\tnum_zero = 0;\n\n\t\ti++;\n\t}\n\n\treturn emulation_bytes_count;\n}\n\n/*nal_size is updated to allow better error detection*/\nGF_EXPORT\nu32 gf_media_nalu_remove_emulation_bytes(const u8 *buffer_src, u8 *buffer_dst, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size)\n\t{\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\t  other than the following sequences shall not occur at any byte-aligned position:\n\t\t  0x00000300\n\t\t  0x00000301\n\t\t  0x00000302\n\t\t  0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2\n\t\t\t&& buffer_src[i] == 0x03\n\t\t\t&& i + 1 < nal_size /*next byte is readable*/\n\t\t\t&& (u8)buffer_src[i + 1] < 0x04)\n\t\t{\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\ti++;\n\t\t}\n\n\t\tbuffer_dst[i - emulation_bytes_count] = buffer_src[i];\n\n\t\tif (!buffer_src[i])\n\t\t\tnum_zero++;\n\t\telse\n\t\t\tnum_zero = 0;\n\n\t\ti++;\n\t}\n\n\treturn nal_size - emulation_bytes_count;\n}\n\nstatic s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif ((sps_id < 0) || (sps_id >= 32)) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tsps->poc_cycle_length = 255;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_avc_read_sps_bs(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos)\n{\n\treturn gf_avc_read_sps_bs_internal(bs, avc, subseq_sps, vui_flag_pos, 0);\n}\n\nGF_EXPORT\ns32 gf_avc_read_sps(const u8 *sps_data, u32 sps_size, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos)\n{\n\ts32 sps_id = -1;\n\tGF_BitStream *bs;\n\tchar *sps_data_without_emulation_bytes = NULL;\n\tu32 sps_data_without_emulation_bytes_size = 0;\n\n\tif (vui_flag_pos) {\n\t\t/*SPS still contains emulation bytes*/\n\t\tsps_data_without_emulation_bytes = gf_malloc(sps_size * sizeof(char));\n\t\tsps_data_without_emulation_bytes_size = gf_media_nalu_remove_emulation_bytes(sps_data, sps_data_without_emulation_bytes, sps_size);\n\t\tbs = gf_bs_new(sps_data_without_emulation_bytes, sps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\n\t\t*vui_flag_pos = 0;\n\t}\n\telse {\n\t\tbs = gf_bs_new(sps_data, sps_size, GF_BITSTREAM_READ);\n\t}\n\n\tif (!bs) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\n\tsps_id = gf_avc_read_sps_bs(bs, avc, subseq_sps, vui_flag_pos);\n\nexit:\n\tgf_bs_del(bs);\n\tif (sps_data_without_emulation_bytes) gf_free(sps_data_without_emulation_bytes);\n\treturn sps_id;\n}\n\nstatic s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)\n{\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 255)) {\n\t\treturn -1;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif ((pps->sps_id<0) || (pps->sps_id >= 32)) {\n\t\tpps->sps_id = 0;\n\t\treturn -1;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice referring to the pps*/\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\treturn -1;\n\t}\n\tavc->pps_active_idx = pps->id; /*set active sps*/\n\tavc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_mode_flag\");\n\tpps->pic_order_present = gf_bs_read_int_log(bs, 1, \"pic_order_present\");\n\tpps->slice_group_count = gf_bs_read_ue_log(bs, \"slice_group_count_minus1\") + 1;\n\tif (pps->slice_group_count > 1) {\n\t\tu32 iGroup;\n\t\tpps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, \"mb_slice_group_map_type\");\n\t\tif (pps->mb_slice_group_map_type == 0) {\n\t\t\tfor (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"run_length_minus1\", iGroup);\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 2) {\n\t\t\tfor (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"top_left\", iGroup);\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"bottom_right\", iGroup);\n\t\t\t}\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_group_change_direction_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"slice_group_change_rate_minus1\");\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 6) {\n\t\t\tu32 i;\n\t\t\tpps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, \"pic_size_in_map_units_minus1\");\n\t\t\tfor (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), \"slice_group_id\", i);\n\t\t\t}\n\t\t}\n\t}\n\tpps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active_minus1\");\n\tpps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active_minus1\");\n\n\t/*\n\tif ((pps->ref_count[0] > 32) || (pps->ref_count[1] > 32)) goto exit;\n\t*/\n\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tgf_bs_read_int_log(bs, 2, \"weighted_bipred_idc\");\n\tgf_bs_read_se_log(bs, \"init_qp_minus26\");\n\tgf_bs_read_se_log(bs, \"init_qs_minus26\");\n\tgf_bs_read_se_log(bs, \"chroma_qp_index_offset\");\n\tpps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\");\n\tgf_bs_read_int_log(bs, 1, \"constrained_intra_pred\");\n\tpps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, \"redundant_pic_cnt_present\");\n\n\treturn pps_id;\n}\n\nGF_EXPORT\ns32 gf_avc_read_pps_bs(GF_BitStream *bs, AVCState *avc)\n{\n\treturn gf_avc_read_pps_bs_internal(bs, avc, 0);\n}\n\nGF_EXPORT\ns32 gf_avc_read_pps(const u8 *pps_data, u32 pps_size, AVCState *avc)\n{\n\tGF_BitStream *bs;\n\ts32 pps_id;\n\n\t/*PPS still contains emulation bytes*/\n\tbs = gf_bs_new(pps_data, pps_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tpps_id = gf_avc_read_pps_bs(bs, avc);\n\tgf_bs_del(bs);\n\treturn pps_id;\n}\n\n#if 0 //unused\n\ns32 gf_avc_read_sps_ext(const char *spse_data, u32 spse_size)\n{\n\tGF_BitStream *bs;\n\ts32 sps_id;\n\n\tbs = gf_bs_new(spse_data, spse_size, GF_BITSTREAM_READ);\n\tsps_id = gf_avc_read_sps_ext_bs(bs);\n\n\tgf_bs_del(bs);\n\treturn sps_id;\n}\n#endif\n\nstatic s32 SVC_ReadNal_header_extension(GF_BitStream *bs, SVC_NALUHeader *NalHeader)\n{\n\tgf_bs_read_int_log(bs, 1, \"reserved_one_bit\");\n\tNalHeader->idr_pic_flag = gf_bs_read_int_log(bs, 1, \"idr_flag\");\n\tNalHeader->priority_id = gf_bs_read_int_log(bs, 6, \"priority_id\");\n\tgf_bs_read_int_log(bs, 1, \"no_inter_layer_pred_flag\");\n\tNalHeader->dependency_id = gf_bs_read_int_log(bs, 3, \"DependencyId\");\n\tNalHeader->quality_id = gf_bs_read_int_log(bs, 4, \"quality_id\");\n\tNalHeader->temporal_id = gf_bs_read_int_log(bs, 3, \"temporal_id\");\n\tgf_bs_read_int_log(bs, 1, \"use_ref_base_pic_flag\");\n\tgf_bs_read_int_log(bs, 1, \"discardable_flag\");\n\tgf_bs_read_int_log(bs, 1, \"output_flag\");\n\tgf_bs_read_int_log(bs, 2, \"reserved_three_2bits\");\n\treturn 1;\n}\n\nstatic void ref_pic_list_modification(GF_BitStream *bs, u32 slice_type) {\n\tif (slice_type % 5 != 2 && slice_type % 5 != 4) {\n\t\tif (gf_bs_read_int_log(bs, 1, \"ref_pic_list_modification_flag_l0\")) {\n\t\t\tu32 idx=0, modification_of_pic_nums_idc;\n\t\t\tdo {\n\t\t\t\tmodification_of_pic_nums_idc = gf_bs_read_ue_log_idx(bs, \"modification_of_pic_nums_idc\", idx);\n\t\t\t\tif (modification_of_pic_nums_idc == 0 || modification_of_pic_nums_idc == 1) {\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"abs_diff_pic_num_minus1\", idx);\n\t\t\t\t}\n\t\t\t\telse if (modification_of_pic_nums_idc == 2) {\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"long_term_pic_num\", idx);\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t} while ((modification_of_pic_nums_idc != 3) && gf_bs_available(bs));\n\t\t}\n\t}\n\tif (slice_type % 5 == 1) {\n\t\tif (gf_bs_read_int_log(bs, 1, \"ref_pic_list_modification_flag_l1\")) {\n\t\t\tu32 idx=0, modification_of_pic_nums_idc;\n\t\t\tdo {\n\t\t\t\tmodification_of_pic_nums_idc = gf_bs_read_ue_log_idx(bs, \"modification_of_pic_nums_idc\", idx);\n\t\t\t\tif (modification_of_pic_nums_idc == 0 || modification_of_pic_nums_idc == 1) {\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"abs_diff_pic_num_minus1\", idx);\n\t\t\t\t}\n\t\t\t\telse if (modification_of_pic_nums_idc == 2) {\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"long_term_pic_num\", idx);\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t} while ((modification_of_pic_nums_idc != 3) && gf_bs_available(bs));\n\t\t}\n\t}\n}\n\nstatic void pred_weight_table(GF_BitStream *bs, u32 slice_type, u32 ChromaArrayType, u32 num_ref_idx_l0_active_minus1, u32 num_ref_idx_l1_active_minus1) {\n\tu32 i, j;\n\tgf_bs_read_ue_log(bs, \"luma_log2_weight_denom\");\n\tif (ChromaArrayType != 0) {\n\t\tgf_bs_read_ue_log(bs, \"chroma_log2_weight_denom\");\n\t}\n\tfor (i = 0; i <= num_ref_idx_l0_active_minus1; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"luma_weight_l0_flag\", i)) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"luma_weight_l0\", i);\n\t\t\tgf_bs_read_se_log_idx(bs, \"luma_offset_l0\", i);\n\t\t}\n\t\tif (ChromaArrayType != 0) {\n\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"chroma_weight_l0_flag\", i))\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tgf_bs_read_se_log_idx2(bs, \"chroma_weight_l0\", i, j);\n\t\t\t\t\tgf_bs_read_se_log_idx2(bs, \"chroma_offset_l0\", i, j);\n\t\t\t\t}\n\t\t}\n\t}\n\tif (slice_type % 5 == 1) {\n\t\tfor (i = 0; i <= num_ref_idx_l1_active_minus1; i++) {\n\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"luma_weight_l1_flag\", i)) {\n\t\t\t\tgf_bs_read_se_log_idx(bs, \"luma_weight_l1\", i);\n\t\t\t\tgf_bs_read_se_log_idx(bs, \"luma_offset_l1\", i);\n\t\t\t}\n\t\t\tif (ChromaArrayType != 0) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"chroma_weight_l1_flag\", i)) {\n\t\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\t\tgf_bs_read_se_log_idx2(bs, \"chroma_weight_l1\", i, j);\n\t\t\t\t\t\tgf_bs_read_se_log_idx2(bs, \"chroma_offset_l1\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void dec_ref_pic_marking(GF_BitStream *bs, Bool IdrPicFlag) {\n\tif (IdrPicFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"no_output_of_prior_pics_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"long_term_reference_flag\");\n\t}\n\telse {\n\t\tif (gf_bs_read_int_log(bs, 1, \"adaptive_ref_pic_marking_mode_flag\")) {\n\t\t\tu32 idx=0, memory_management_control_operation;\n\t\t\tdo {\n\t\t\t\tmemory_management_control_operation = gf_bs_read_ue_log_idx(bs, \"memory_management_control_operation\", idx);\n\t\t\t\tif (memory_management_control_operation == 1 || memory_management_control_operation == 3)\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"difference_of_pic_nums_minus1\", idx);\n\t\t\t\tif (memory_management_control_operation == 2)\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"long_term_pic_num\", idx);\n\t\t\t\tif (memory_management_control_operation == 3 || memory_management_control_operation == 6)\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"long_term_frame_idx\", idx);\n\t\t\t\tif (memory_management_control_operation == 4)\n\t\t\t\t\tgf_bs_read_ue_log_idx(bs, \"max_long_term_frame_idx_plus1\", idx);\n\t\t\t\tidx++;\n\t\t\t} while (memory_management_control_operation != 0);\n\t\t}\n\t}\n}\n\nstatic s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255)) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;\n\tsi->bottom_field_flag = 0;\n\tif (!si->sps->frame_mbs_only_flag) {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag)\n\t\t\tsi->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\n\tif ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"poc_lsb\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\n\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tgf_bs_read_int_log(bs, 1, \"direct_spatial_mv_pred_flag\");\n\t}\n\n\tnum_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;\n\tnum_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;\n\n\tif (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tBool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\");\n\t\tif (num_ref_idx_active_override_flag) {\n\t\t\tnum_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active_minus1\");\n\t\t\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\t\t\tnum_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active_minus1\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (si->nal_unit_type == 20 || si->nal_unit_type == 21) {\n\t\t//ref_pic_list_mvc_modification(); /* specified in Annex H */\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\\n\"));\n\t\tassert(0);\n\t\treturn -1;\n\t}\n\telse {\n\t\tref_pic_list_modification(bs, si->slice_type);\n\t}\n\n\tif ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))\n\t\t|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {\n\t\tpred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);\n\t}\n\n\tif (si->nal_ref_idc != 0) {\n\t\tdec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));\n\t}\n\n\tif (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {\n\t\tgf_bs_read_ue_log(bs, \"cabac_init_idc\");\n\t}\n\n\t/*slice_qp_delta = */gf_bs_read_se(bs);\n\tif (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {\n\t\tif (si->slice_type % 5 == GF_AVC_TYPE_SP) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"sp_for_switch_flag\");\n\t\t}\n\t\tgf_bs_read_se_log(bs, \"slice_qs_delta\");\n\t}\n\n\tif (si->pps->deblocking_filter_control_present_flag) {\n\t\tif (gf_bs_read_ue_log(bs, \"disable_deblocking_filter_idc\") != 1) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_alpha_c0_offset_div2\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t}\n\t}\n\n\tif (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {\n\t\tgf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), \"slice_group_change_cycle\");\n\t}\n\treturn 0;\n}\n\n\nstatic s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255))\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;\n\tif (si->sps->frame_mbs_only_flag) {\n\t\t/*s->picture_structure= PICT_FRAME;*/\n\t}\n\telse {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"delta_poc_bottom\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\treturn 0;\n}\n\n\nstatic s32 avc_parse_recovery_point_sei(GF_BitStream *bs, AVCState *avc)\n{\n\tAVCSeiRecoveryPoint *rp = &avc->sei.recovery_point;\n\n\trp->frame_cnt = gf_bs_read_ue_log(bs, \"frame_cnt\");\n\trp->exact_match_flag = gf_bs_read_int_log(bs, 1, \"exact_match_flag\");\n\trp->broken_link_flag = gf_bs_read_int_log(bs, 1, \"broken_link_flag\");\n\trp->changing_slice_group_idc = gf_bs_read_int_log(bs, 2, \"changing_slice_group_idc\");\n\trp->valid = 1;\n\n\treturn 0;\n}\n\n/*for interpretation see ISO 14496-10 N.11084, table D-1*/\nstatic s32 avc_parse_pic_timing_sei(GF_BitStream *bs, AVCState *avc)\n{\n\tint sps_id = avc->sps_active_idx;\n\tconst char NumClockTS[] = { 1, 1, 1, 2, 2, 3, 3, 2, 3 };\n\tAVCSeiPicTiming *pt = &avc->sei.pic_timing;\n\n\tif (sps_id < 0) {\n\t\t/*sps_active_idx equals -1 when no sps has been detected. In this case SEI should not be decoded.*/\n\t\tassert(0);\n\t\treturn 1;\n\t}\n\tif (avc->sps[sps_id].vui.nal_hrd_parameters_present_flag || avc->sps[sps_id].vui.vcl_hrd_parameters_present_flag) { /*CpbDpbDelaysPresentFlag, see 14496-10(2003) E.11*/\n\t\tgf_bs_read_int_log(bs, 1 + avc->sps[sps_id].vui.hrd.cpb_removal_delay_length_minus1, \"cpb_removal_delay_minus1\");\n\t\tgf_bs_read_int_log(bs, 1 + avc->sps[sps_id].vui.hrd.dpb_output_delay_length_minus1, \"dpb_output_delay_minus1\");\n\t}\n\n\t/*ISO 14496-10 (2003), D.8.2: we need to get pic_struct in order to know if we display top field first or bottom field first*/\n\tif (avc->sps[sps_id].vui.pic_struct_present_flag) {\n\t\tint i;\n\t\tpt->pic_struct = gf_bs_read_int_log(bs, 4, \"pic_struct\");\n\t\tif (pt->pic_struct > 8) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] invalid pic_struct value %d\\n\", pt->pic_struct));\n\t\t\treturn 1;\n\t\t}\n\n\t\tfor (i = 0; i < NumClockTS[pt->pic_struct]; i++) {\n\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"clock_timestamp_flag\", i)) {\n\t\t\t\tBool full_timestamp_flag;\n\t\t\t\tgf_bs_read_int_log_idx(bs, 2, \"ct_type\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"nuit_field_based_flag\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 5, \"counting_type\", i);\n\t\t\t\tfull_timestamp_flag = gf_bs_read_int_log_idx(bs, 1, \"full_timestamp_flag\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"discontinuity_flag\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"cnt_dropped_flag\", i);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"n_frames\", i);\n\t\t\t\tif (full_timestamp_flag) {\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 6, \"seconds_value\", i);\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 6, \"minutes_value\", i);\n\t\t\t\t\tgf_bs_read_int_log_idx(bs, 5, \"hours_value\", i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seconds_flag\", i)) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 6, \"seconds_value\", i);\n\t\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"minutes_flag\", i)) {\n\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 6, \"minutes_value\", i);\n\t\t\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"hours_flag\", i)) {\n\t\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 5, \"hours_value\", i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (avc->sps[sps_id].vui.hrd.time_offset_length > 0)\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, avc->sps[sps_id].vui.hrd.time_offset_length, \"time_offset\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n#if !defined(GPAC_DISABLE_HEVC)\nstatic void avc_parse_itu_t_t35_sei(GF_BitStream* bs, AVCSeiItuTT35DolbyVision *dovi)\n{\n\tu8 itu_t_t35_country_code = gf_bs_read_u8(bs);\n\tu16 terminal_provider_code = gf_bs_read_u16(bs);\n\tu32 user_id = gf_bs_read_u32(bs);\n\tu8 data_type_code = gf_bs_read_u8(bs);\n\tif (itu_t_t35_country_code == 0xB5 && terminal_provider_code == 0x31 && user_id == 0x47413934 && (data_type_code == 0x8 || data_type_code == 0x9)) {\n\t\tdovi->rpu_flag = GF_TRUE;\n\t}\n}\n#endif\n\nstatic void avc_compute_poc(AVCSliceInfo *si)\n{\n\tenum {\n\t\tAVC_PIC_FRAME,\n\t\tAVC_PIC_FIELD_TOP,\n\t\tAVC_PIC_FIELD_BOTTOM,\n\t} pic_type;\n\ts32 field_poc[2] = { 0,0 };\n\ts32 max_frame_num;\n\n\tif (!si->sps) return;\n\n\tmax_frame_num = 1 << (si->sps->log2_max_frame_num);\n\n\t/* picture type */\n\tif (si->sps->frame_mbs_only_flag || !si->field_pic_flag) pic_type = AVC_PIC_FRAME;\n\telse if (si->bottom_field_flag) pic_type = AVC_PIC_FIELD_BOTTOM;\n\telse pic_type = AVC_PIC_FIELD_TOP;\n\n\t/* frame_num_offset */\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\tsi->poc_lsb_prev = 0;\n\t\tsi->poc_msb_prev = 0;\n\t\tsi->frame_num_offset = 0;\n\t}\n\telse {\n\t\tif (si->frame_num < si->frame_num_prev)\n\t\t\tsi->frame_num_offset = si->frame_num_offset_prev + max_frame_num;\n\t\telse\n\t\t\tsi->frame_num_offset = si->frame_num_offset_prev;\n\t}\n\n\t/*ISO 14496-10 N.11084 8.2.1.1*/\n\tif (si->sps->poc_type == 0)\n\t{\n\t\tconst u32 max_poc_lsb = 1 << (si->sps->log2_max_poc_lsb);\n\n\t\t/*ISO 14496-10 N.11084 eq (8-3)*/\n\t\tif ((si->poc_lsb < si->poc_lsb_prev) &&\n\t\t\t(si->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\t\telse if ((si->poc_lsb > si->poc_lsb_prev) &&\n\t\t\t(si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\t\telse\n\t\t\tsi->poc_msb = si->poc_msb_prev;\n\n\t\t/*ISO 14496-10 N.11084 eq (8-4)*/\n\t\tif (pic_type != AVC_PIC_FIELD_BOTTOM)\n\t\t\tfield_poc[0] = si->poc_msb + si->poc_lsb;\n\n\t\t/*ISO 14496-10 N.11084 eq (8-5)*/\n\t\tif (pic_type != AVC_PIC_FIELD_TOP) {\n\t\t\tif (!si->field_pic_flag)\n\t\t\t\tfield_poc[1] = field_poc[0] + si->delta_poc_bottom;\n\t\t\telse\n\t\t\t\tfield_poc[1] = si->poc_msb + si->poc_lsb;\n\t\t}\n\t}\n\t/*ISO 14496-10 N.11084 8.2.1.2*/\n\telse if (si->sps->poc_type == 1)\n\t{\n\t\tu32 i;\n\t\ts32 abs_frame_num, expected_delta_per_poc_cycle, expected_poc;\n\n\t\tif (si->sps->poc_cycle_length)\n\t\t\tabs_frame_num = si->frame_num_offset + si->frame_num;\n\t\telse\n\t\t\tabs_frame_num = 0;\n\n\t\tif (!si->nal_ref_idc && (abs_frame_num > 0)) abs_frame_num--;\n\n\t\texpected_delta_per_poc_cycle = 0;\n\t\tfor (i = 0; i < si->sps->poc_cycle_length; i++)\n\t\t\texpected_delta_per_poc_cycle += si->sps->offset_for_ref_frame[i];\n\n\t\tif (abs_frame_num > 0) {\n\t\t\tconst u32 poc_cycle_cnt = (abs_frame_num - 1) / si->sps->poc_cycle_length;\n\t\t\tconst u32 frame_num_in_poc_cycle = (abs_frame_num - 1) % si->sps->poc_cycle_length;\n\n\t\t\texpected_poc = poc_cycle_cnt * expected_delta_per_poc_cycle;\n\t\t\tfor (i = 0; i <= frame_num_in_poc_cycle; i++)\n\t\t\t\texpected_poc += si->sps->offset_for_ref_frame[i];\n\t\t}\n\t\telse {\n\t\t\texpected_poc = 0;\n\t\t}\n\n\t\tif (!si->nal_ref_idc) expected_poc += si->sps->offset_for_non_ref_pic;\n\n\t\tfield_poc[0] = expected_poc + si->delta_poc[0];\n\t\tfield_poc[1] = field_poc[0] + si->sps->offset_for_top_to_bottom_field;\n\t\tif (pic_type == AVC_PIC_FRAME) field_poc[1] += si->delta_poc[1];\n\t}\n\t/*ISO 14496-10 N.11084 8.2.1.3*/\n\telse if (si->sps->poc_type == 2)\n\t{\n\t\tint poc;\n\t\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\t\tpoc = 0;\n\t\t}\n\t\telse {\n\t\t\tconst int abs_frame_num = si->frame_num_offset + si->frame_num;\n\t\t\tpoc = 2 * abs_frame_num;\n\t\t\tif (!si->nal_ref_idc) poc -= 1;\n\t\t}\n\t\tfield_poc[0] = poc;\n\t\tfield_poc[1] = poc;\n\t}\n\n\t/*ISO 14496-10 N.11084 eq (8-1)*/\n\tif (pic_type == AVC_PIC_FRAME)\n\t\tsi->poc = MIN(field_poc[0], field_poc[1]);\n\telse if (pic_type == AVC_PIC_FIELD_TOP)\n\t\tsi->poc = field_poc[0];\n\telse\n\t\tsi->poc = field_poc[1];\n}\n\nGF_EXPORT\ns32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)\n{\n\tu8 idr_flag;\n\ts32 slice, ret;\n\tu32 nal_hdr;\n\tAVCSliceInfo n_state;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tnal_hdr = gf_bs_read_u8(bs);\n\n\tslice = 0;\n\tmemcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));\n\tavc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;\n\tn_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;\n\n\tidr_flag = 0;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\t// slice buffer - read the info and compare.\n\t\t/*ret = */svc_parse_slice(bs, avc, &n_state);\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t\tavc_compute_poc(&n_state);\n\n\t\tif (avc->s_info.poc != n_state.poc) {\n\t\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\t\treturn 1;\n\t\t}\n\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SVC_PREFIX_NALU:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_IDR_SLICE:\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\t\tslice = 1;\n\t\t/* slice buffer - read the info and compare.*/\n\t\tret = avc_parse_slice(bs, avc, idr_flag, &n_state);\n\t\tif (ret < 0) return ret;\n\t\tret = 0;\n\t\tif (\n\t\t\t((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))\n\t\t\t&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)\n\t\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\tif (avc->s_info.frame_num != n_state.frame_num) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (avc->s_info.field_pic_flag != n_state.field_pic_flag) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&\n\t\t\t(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tassert(avc->s_info.sps);\n\n\t\tif (avc->s_info.sps->poc_type == n_state.sps->poc_type) {\n\t\t\tif (!avc->s_info.sps->poc_type) {\n\t\t\t\tif (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (avc->s_info.sps->poc_type == 1) {\n\t\t\t\tif (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\t\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) { /*IdrPicFlag differs in value*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (avc->s_info.idr_pic_id != n_state.idr_pic_id) { /*both IDR and idr_pic_id differs*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tavc->last_ps_idx = (s32) gf_bs_read_ue(bs);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEI:\n\tcase GF_AVC_NALU_FILLER_DATA:\n\t\treturn 0;\n\n\tdefault:\n\t\tif (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;\n\t\t//To detect change of AU when multiple sps and pps in stream\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif (ret && avc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = avc->s_info.frame_num_offset;\n\t\tif ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))\n\t\t\tn_state.frame_num_prev = avc->s_info.frame_num;\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t}\n\tif (slice)\n\t\tavc_compute_poc(&n_state);\n\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\treturn ret;\n}\n\n\nu32 gf_media_avc_reformat_sei(u8 *buffer, u32 nal_size, Bool isobmf_rewrite, AVCState *avc)\n{\n\tu32 ptype, psize, hdr, var;\n\tu32 start;\n\tGF_BitStream *bs;\n\tGF_BitStream *bs_dest = NULL;\n\tu8 nhdr;\n\tBool sei_removed = GF_FALSE;\n\tchar store;\n\n\thdr = buffer[0];\n\tif ((hdr & 0x1F) != GF_AVC_NALU_SEI) return 0;\n\n\tif (isobmf_rewrite) bs_dest = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tbs = gf_bs_new(buffer, nal_size, GF_BITSTREAM_READ);\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tnhdr = gf_bs_read_int(bs, 8);\n\tif (bs_dest) gf_bs_write_int(bs_dest, nhdr, 8);\n\n\t/*parse SEI*/\n\twhile (gf_bs_available(bs)) {\n\t\tBool do_copy;\n\t\tptype = 0;\n\t\twhile (1) {\n\t\t\tu8 v = gf_bs_read_int(bs, 8);\n\t\t\tptype += v;\n\t\t\tif (v != 0xFF) break;\n\t\t}\n\n\t\tpsize = 0;\n\t\twhile (1) {\n\t\t\tu8 v = gf_bs_read_int(bs, 8);\n\t\t\tpsize += v;\n\t\t\tif (v != 0xFF) break;\n\t\t}\n\n\t\tstart = (u32)gf_bs_get_position(bs);\n\n\t\tdo_copy = 1;\n\n\t\tif (start + psize >= nal_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] SEI user message type %d size error (%d but %d remain), keeping full SEI untouched\\n\", ptype, psize, nal_size - start));\n\t\t\tif (bs_dest) gf_bs_del(bs_dest);\n\t\t\treturn nal_size;\n\t\t}\n\t\tswitch (ptype) {\n\t\t\t/*remove SEI messages forbidden in MP4*/\n\t\tcase 3: /*filler data*/\n\t\tcase 10: /*sub_seq info*/\n\t\tcase 11: /*sub_seq_layer char*/\n\t\tcase 12: /*sub_seq char*/\n\t\t\tdo_copy = 0;\n\t\t\tsei_removed = GF_TRUE;\n\t\t\tbreak;\n\t\tcase 5: /*user unregistered */\n\t\t\tstore = buffer[start + psize];\n\t\t\tbuffer[start + psize] = 0;\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[avc-h264] SEI user message %s\\n\", buffer + start + 16));\n\t\t\tbuffer[start + psize] = store;\n\t\t\tbreak;\n\n\t\tcase 6: /*recovery point*/\n\t\t\tavc_parse_recovery_point_sei(bs, avc);\n\t\t\tbreak;\n\n\t\tcase 1: /*pic_timing*/\n\t\t\tavc_parse_pic_timing_sei(bs, avc);\n\t\t\tbreak;\n\n\t\tcase 0: /*buffering period*/\n\t\tcase 2: /*pan scan rect*/\n\t\tcase 4: /*user registered ITU t35*/\n\t\tcase 7: /*def_rec_pic_marking_repetition*/\n\t\tcase 8: /*spare_pic*/\n\t\tcase 9: /*scene info*/\n\t\tcase 13: /*full frame freeze*/\n\t\tcase 14: /*full frame freeze release*/\n\t\tcase 15: /*full frame snapshot*/\n\t\tcase 16: /*progressive refinement segment start*/\n\t\tcase 17: /*progressive refinement segment end*/\n\t\tcase 18: /*motion constrained slice group*/\n\t\tdefault: /*add all unknown SEIs*/\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_copy && bs_dest) {\n\t\t\tvar = ptype;\n\t\t\twhile (var >= 255) {\n\t\t\t\tgf_bs_write_int(bs_dest, 0xFF, 8);\n\t\t\t\tvar -= 255;\n\t\t\t}\n\t\t\tgf_bs_write_int(bs_dest, var, 8);\n\n\t\t\tvar = psize;\n\t\t\twhile (var >= 255) {\n\t\t\t\tgf_bs_write_int(bs_dest, 0xFF, 8);\n\t\t\t\tvar -= 255;\n\t\t\t}\n\t\t\tgf_bs_write_int(bs_dest, var, 8);\n\t\t\tgf_bs_seek(bs, start);\n\n\t\t\t//bs_read_data does not skip EPB, read byte per byte\n\t\t\tvar = psize;\n\t\t\twhile (var) {\n\t\t\t\tgf_bs_write_u8(bs_dest, gf_bs_read_u8(bs));\n\t\t\t\tvar--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tgf_bs_seek(bs, start);\n\n\t\t\t//bs_skip_bytes does not skip EPB, skip byte per byte\n\t\t\twhile (psize) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tpsize--;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_available(bs) <= 2) {\n\t\t\tvar = gf_bs_read_int(bs, 8);\n\t\t\tif (var != 0x80) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] SEI user message has less than 2 bytes remaining but no end of sei found\\n\"));\n\t\t\t}\n\t\t\tif (bs_dest) gf_bs_write_int(bs_dest, 0x80, 8);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\t//we cannot compare final size and original size since original may have EPB and final does not yet have them\n\tif (bs_dest && sei_removed) {\n\t\tu8 *dst_no_epb = NULL;\n\t\tu32 dst_no_epb_size = 0;\n\t\tgf_bs_get_content(bs_dest, &dst_no_epb, &dst_no_epb_size);\n\t\tnal_size = gf_media_nalu_add_emulation_bytes(buffer, dst_no_epb, dst_no_epb_size);\n\t}\n\tif (bs_dest) gf_bs_del(bs_dest);\n\treturn nal_size;\n}\n\n\nstatic u8 avc_hevc_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i, count = GF_ARRAY_LENGTH(avc_hevc_sar);\n\tfor (i = 0; i < count; i++) {\n\t\tif ((avc_hevc_sar[i].w == w) && (avc_hevc_sar[i].h == h))\n\t\t\treturn i;\n\t}\n\treturn 0xFF;\n}\n\nstatic void avc_hevc_rewrite_vui(GF_VUIInfo *vui_info, GF_BitStream *orig, GF_BitStream *mod)\n{\n\t/* VUI present flag*/\n\tBool vui_present_flag = gf_bs_read_int(orig, 1);\n\n\t/*setup default values*/\n\tBool aspect_ratio_info_present_flag = 0;\n\ts32 aspect_ratio_idc = -1;\n\tu32 ar_n=0, ar_d=0;\n\tBool overscan_info_present_flag = 0;\n\tu32 overscan_info=0;\n\tu32 video_signal_type_present_flag=0;\n\tu32 video_format = 5;\n\tu32 video_full_range_flag = 0;\n\tu32 colour_description_present_flag = 0;\n\tu32 colour_primaries = 2;\n\tu32 transfer_characteristics = 2;\n\tu32 matrix_coefficients = 2;\n\n\t//if VUI is present, read all SAR and overscan values\n\tif (vui_present_flag) { /* VUI found in input bitstream */\n\t\taspect_ratio_info_present_flag = gf_bs_read_int(orig, 1);\n\t\tif (aspect_ratio_info_present_flag) {\n\t\t\taspect_ratio_idc = gf_bs_read_int(orig, 8); /*aspect_ratio_idc*/\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tar_n = gf_bs_read_int(orig, 16); /*sar_width*/\n\t\t\t\tar_d = gf_bs_read_int(orig, 16); /*sar_height*/\n\t\t\t}\n\t\t}\n\n\t\t/*overscan_info_present_flag */\n\t\toverscan_info_present_flag = gf_bs_read_int(orig, 1);\n\t\tif(overscan_info_present_flag) {\n\t\t\toverscan_info = gf_bs_read_int(orig, 1);\n\t\t}\n\n\t\t/* read all video signal related flags first */\n\t\tvideo_signal_type_present_flag = gf_bs_read_int(orig, 1);\n\t\tif(video_signal_type_present_flag) {\n\t\t\tvideo_format = gf_bs_read_int(orig, 3);\n\t\t\tvideo_full_range_flag = gf_bs_read_int(orig, 1);\n\t\t\tcolour_description_present_flag = gf_bs_read_int(orig, 1);\n\t\t\tif(colour_description_present_flag) {\n\t\t\t\tcolour_primaries = gf_bs_read_int(orig, 8);\n\t\t\t\ttransfer_characteristics = gf_bs_read_int(orig, 8);\n\t\t\t\tmatrix_coefficients = gf_bs_read_int(orig, 8);\n\t\t\t}\n\t\t}\n\t}\n\n\t//recompute values\n\t//no change\n\tif ((vui_info->ar_num<0) || (vui_info->ar_den<0)) {\n\t}\n\t//remove par\n\telse if ((vui_info->ar_num==0) || (vui_info->ar_den==0)) {\n\t\taspect_ratio_info_present_flag = 0;\n\t}\n\t//set par\n\telse {\n\t\taspect_ratio_info_present_flag = 1;\n\t\tar_n = vui_info->ar_num;\n\t\tar_d = vui_info->ar_den;\n\t\taspect_ratio_idc = avc_hevc_get_sar_idx((u32) ar_n, (u32) ar_d);\n\t}\n\n\tif (vui_info->remove_video_info) {\n\t\tvideo_signal_type_present_flag = 0;\n\t}\n\t/* correct the values of each flags */\n\telse if ((vui_info->fullrange==0) && (vui_info->video_format==5) && (vui_info->color_prim==2) && (vui_info->color_tfc==2) && (vui_info->color_matrix==2)) {\n\t\tvideo_signal_type_present_flag = 0; /* all default, nothing to write*/\n\t} else {\n\t\tvideo_signal_type_present_flag = 1;\n\t\tvideo_format = (vui_info->video_format < 0) ? video_format : vui_info->video_format;\n\t\tvideo_full_range_flag = (vui_info->fullrange < 0) ? video_full_range_flag : vui_info->fullrange;\n\t\tif ((vui_info->color_prim==2) && (vui_info->color_tfc==2) && (vui_info->color_matrix==2)) {\n\t\t\tcolour_description_present_flag = 0;\n\t\t} else {\n\t\t\tcolour_description_present_flag = 1;\n\t\t\tcolour_primaries = (vui_info->color_prim < 0) ? colour_primaries : vui_info->color_prim;\n\t\t\ttransfer_characteristics = (vui_info->color_tfc < 0) ? transfer_characteristics : vui_info->color_tfc;\n\t\t\tmatrix_coefficients = (vui_info->color_matrix < 0) ? matrix_coefficients : vui_info->color_matrix;\n\t\t}\n\t\tif ((colour_primaries==2) && (transfer_characteristics==2) && (matrix_coefficients==2)) {\n\t\t\tcolour_description_present_flag = 0;\n\t\t\tif ((video_format==5) && (video_full_range_flag==0))\n\t\t\t\tvideo_signal_type_present_flag = 0;\n\t\t}\n\t}\n\n\t//always rewrite VUI\n\tgf_bs_write_int(mod, 1, 1);\n\tgf_bs_write_int(mod, aspect_ratio_info_present_flag, 1);\n\tif (aspect_ratio_info_present_flag) {\n\t\tgf_bs_write_int(mod, aspect_ratio_idc, 8);\n\t\tif (aspect_ratio_idc == 255) {\n\t\t\tgf_bs_write_int(mod, ar_n, 16);\n\t\t\tgf_bs_write_int(mod, ar_d, 16);\n\t\t}\n\t\tif (vui_info->update) {\n\t\t\tvui_info->ar_num = ar_n;\n\t\t\tvui_info->ar_den = ar_d;\n\t\t}\n\t}\n\tgf_bs_write_int(mod, overscan_info_present_flag, 1);\n\tif (overscan_info_present_flag) {\n\t\tgf_bs_write_int(mod, overscan_info, 1);\n\t}\n\n\tgf_bs_write_int(mod, video_signal_type_present_flag, 1);\n\tif (video_signal_type_present_flag) {\n\t\tgf_bs_write_int(mod, video_format, 3);\n\t\tgf_bs_write_int(mod, video_full_range_flag, 1);\n\t\tgf_bs_write_int(mod, colour_description_present_flag, 1);\n\n\t\tif (colour_description_present_flag) {\n\t\t\tgf_bs_write_int(mod, colour_primaries, 8);\n\t\t\tgf_bs_write_int(mod, transfer_characteristics, 8);\n\t\t\tgf_bs_write_int(mod, matrix_coefficients, 8);\n\t\t}\n\n\t\tif (vui_info->update) {\n\t\t\tvui_info->video_format = video_format;\n\t\t\tvui_info->fullrange = video_full_range_flag;\n\t\t\tif (colour_description_present_flag) {\n\t\t\t\tvui_info->color_prim = colour_primaries;\n\t\t\t\tvui_info->color_tfc = transfer_characteristics;\n\t\t\t\tvui_info->color_matrix = matrix_coefficients;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*no VUI in input bitstream but we just inserted one, set all remaining vui flags to 0*/\n\tif (!vui_present_flag) {\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*chroma_location_info_present_flag */\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*timing_info_present_flag*/\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*nal_hrd_parameters_present*/\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*vcl_hrd_parameters_present*/\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*pic_struct_present*/\n\t\tgf_bs_write_int(mod, 0, 1);\t\t/*bitstream_restriction*/\n\t}\n\t/*otherwise we copy over th bits from the input bitrate*/\n}\n\nGF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)\n{\n\tGF_BitStream *orig, *mod;\n\tAVCState avc;\n\tu32 i, bit_offset, flag;\n\ts32 idx;\n\tGF_AVCConfigSlot *slc;\n\torig = NULL;\n\n\tmemset(&avc, 0, sizeof(AVCState));\n\tavc.sps_active_idx = -1;\n\n\ti=0;\n\twhile ((slc = (GF_AVCConfigSlot *)gf_list_enum(avcc->sequenceParameterSets, &i))) {\n\t\tu8 *no_emulation_buf = NULL;\n\t\tu32 no_emulation_buf_size = 0, emulation_bytes = 0;\n\t\tidx = gf_avc_read_sps(slc->data, slc->size, &avc, 0, &bit_offset);\n\t\tif (idx<0) {\n\t\t\tif ( orig )\n\t\t\t\tgf_bs_del(orig);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*SPS still contains emulation bytes*/\n\t\tno_emulation_buf = gf_malloc((slc->size - 1) * sizeof(char));\n\t\tno_emulation_buf_size = gf_media_nalu_remove_emulation_bytes(slc->data + 1, no_emulation_buf, slc->size - 1);\n\n\t\torig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);\n\t\tgf_bs_read_data(orig, no_emulation_buf, no_emulation_buf_size);\n\t\tgf_bs_seek(orig, 0);\n\t\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t/*copy over till vui flag*/\n\t\tassert(bit_offset >= 8);\n\t\twhile (bit_offset - 8/*bit_offset doesn't take care of the first byte (NALU type)*/) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t\tbit_offset--;\n\t\t}\n\n\t\tavc_hevc_rewrite_vui(vui_info, orig, mod);\n\n\t\t/*finally copy over remaining*/\n\t\twhile (gf_bs_bits_available(orig)) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t}\n\t\tgf_bs_del(orig);\n\t\torig = NULL;\n\t\tgf_free(no_emulation_buf);\n\n\t\t/*set anti-emulation*/\n\t\tgf_bs_get_content(mod, &no_emulation_buf, &flag);\n\t\temulation_bytes = gf_media_nalu_emulation_bytes_add_count(no_emulation_buf, flag);\n\t\tif (flag+emulation_bytes+1>slc->size)\n\t\t\tslc->data = (char*)gf_realloc(slc->data, flag+emulation_bytes+1);\n\t\tslc->size = gf_media_nalu_add_emulation_bytes(no_emulation_buf, slc->data + 1, flag) + 1;\n\n\t\tgf_bs_del(mod);\n\t\tgf_free(no_emulation_buf);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_media_avc_change_par(GF_AVCConfig *avcc, s32 ar_n, s32 ar_d)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = ar_n;\n\tvuii.ar_den = ar_d;\n\tvuii.fullrange = -1;\n\tvuii.video_format = -1;\n\tvuii.color_prim = -1;\n\tvuii.color_tfc = -1;\n\tvuii.color_matrix = -1;\n\treturn gf_avc_change_vui(avcc, &vuii);\n}\n\nGF_EXPORT\nGF_Err gf_media_avc_change_color(GF_AVCConfig *avcc, s32 fullrange, s32 vidformat, s32 colorprim, s32 transfer, s32 colmatrix)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = -1;\n\tvuii.ar_den = -1;\n\tvuii.fullrange = fullrange;\n\tvuii.video_format = vidformat;\n\tvuii.color_prim = colorprim;\n\tvuii.color_tfc = transfer;\n\tvuii.color_matrix = colmatrix;\n\treturn gf_avc_change_vui(avcc, &vuii);\n}\n\n\nGF_EXPORT\nGF_Err gf_avc_get_sps_info(u8 *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\tAVCState avc;\n\ts32 idx;\n\tmemset(&avc, 0, sizeof(AVCState));\n\tavc.sps_active_idx = -1;\n\n\tidx = gf_avc_read_sps(sps_data, sps_size, &avc, 0, NULL);\n\tif (idx < 0) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (sps_id) *sps_id = idx;\n\n\tif (width) *width = avc.sps[idx].width;\n\tif (height) *height = avc.sps[idx].height;\n\tif (par_n) *par_n = avc.sps[idx].vui.par_num ? avc.sps[idx].vui.par_num : (u32)-1;\n\tif (par_d) *par_d = avc.sps[idx].vui.par_den ? avc.sps[idx].vui.par_den : (u32)-1;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_avc_get_pps_info(u8 *pps_data, u32 pps_size, u32 *pps_id, u32 *sps_id)\n{\n\tGF_BitStream *bs;\n\tGF_Err e = GF_OK;\n\n\tbs = gf_bs_new(pps_data, pps_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto exit;\n\t}\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t/*nal hdr*/ gf_bs_read_int(bs, 8);\n\n\t*pps_id = gf_bs_read_ue(bs);\n\t*sps_id = gf_bs_read_ue(bs);\n\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_HEVC\n\n/**********\nHEVC parsing\n**********/\n\nBool gf_hevc_slice_is_intra(HEVCState *hevc)\n{\n\tswitch (hevc->s_info.nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nBool gf_hevc_slice_is_IDR(HEVCState *hevc)\n{\n\tif (hevc->sei.recovery_point.valid)\n\t{\n\t\thevc->sei.recovery_point.valid = 0;\n\t\treturn GF_TRUE;\n\t}\n\tswitch (hevc->s_info.nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nstatic Bool hevc_parse_short_term_ref_pic_set(GF_BitStream *bs, HEVC_SPS *sps, u32 idx_rps)\n{\n\tu32 i;\n\tBool inter_ref_pic_set_prediction_flag = 0;\n\tif (idx_rps != 0)\n\t\tinter_ref_pic_set_prediction_flag = gf_bs_read_int_log_idx(bs, 1, \"inter_ref_pic_set_prediction_flag\", idx_rps);\n\n\tif (inter_ref_pic_set_prediction_flag) {\n\t\tHEVC_ReferencePictureSets *ref_ps, *rps;\n\t\tu32 delta_idx_minus1 = 0;\n\t\tu32 ref_idx;\n\t\tu32 delta_rps_sign;\n\t\tu32 abs_delta_rps_minus1, nb_ref_pics;\n\t\ts32 deltaRPS;\n\t\tu32 k = 0, k0 = 0, k1 = 0;\n\t\tif (idx_rps == sps->num_short_term_ref_pic_sets)\n\t\t\tdelta_idx_minus1 = gf_bs_read_ue_log_idx(bs, \"delta_idx_minus1\", idx_rps);\n\n\t\tassert(delta_idx_minus1 <= idx_rps - 1);\n\t\tref_idx = idx_rps - 1 - delta_idx_minus1;\n\t\tdelta_rps_sign = gf_bs_read_int_log_idx(bs, 1, \"delta_rps_sign\", idx_rps);\n\t\tabs_delta_rps_minus1 = gf_bs_read_ue_log_idx(bs, \"abs_delta_rps_minus1\", idx_rps);\n\t\tdeltaRPS = (1 - (delta_rps_sign << 1)) * (abs_delta_rps_minus1 + 1);\n\n\t\trps = &sps->rps[idx_rps];\n\t\tref_ps = &sps->rps[ref_idx];\n\t\tnb_ref_pics = ref_ps->num_negative_pics + ref_ps->num_positive_pics;\n\t\tfor (i = 0; i <= nb_ref_pics; i++) {\n\t\t\ts32 ref_idc;\n\t\t\ts32 used_by_curr_pic_flag = gf_bs_read_int_log_idx2(bs, 1, \"used_by_curr_pic_flag\", idx_rps, i);\n\t\t\tref_idc = used_by_curr_pic_flag ? 1 : 0;\n\t\t\tif (!used_by_curr_pic_flag) {\n\t\t\t\tused_by_curr_pic_flag = gf_bs_read_int_log_idx2(bs, 1, \"used_by_curr_pic_flag\", idx_rps, i);\n\t\t\t\tref_idc = used_by_curr_pic_flag << 1;\n\t\t\t}\n\t\t\tif ((ref_idc == 1) || (ref_idc == 2)) {\n\t\t\t\ts32 deltaPOC = deltaRPS;\n\t\t\t\tif (i < nb_ref_pics)\n\t\t\t\t\tdeltaPOC += ref_ps->delta_poc[i];\n\n\t\t\t\trps->delta_poc[k] = deltaPOC;\n\n\t\t\t\tif (deltaPOC < 0)  k0++;\n\t\t\t\telse k1++;\n\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\trps->num_negative_pics = k0;\n\t\trps->num_positive_pics = k1;\n\t}\n\telse {\n\t\ts32 prev = 0, poc;\n\t\tsps->rps[idx_rps].num_negative_pics = gf_bs_read_ue_log_idx(bs, \"num_negative_pics\", idx_rps);\n\t\tsps->rps[idx_rps].num_positive_pics = gf_bs_read_ue_log_idx(bs, \"num_positive_pics\", idx_rps);\n\t\tif (sps->rps[idx_rps].num_negative_pics > 16)\n\t\t\treturn GF_FALSE;\n\t\tif (sps->rps[idx_rps].num_positive_pics > 16)\n\t\t\treturn GF_FALSE;\n\t\tfor (i = 0; i < sps->rps[idx_rps].num_negative_pics; i++) {\n\t\t\tu32 delta_poc_s0_minus1 = gf_bs_read_ue_log_idx2(bs, \"delta_poc_s0_minus1\", idx_rps, i);\n\t\t\tpoc = prev - delta_poc_s0_minus1 - 1;\n\t\t\tprev = poc;\n\t\t\tsps->rps[idx_rps].delta_poc[i] = poc;\n\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"delta_poc_s0_minus1\", idx_rps, i);\n\t\t}\n\t\tfor (i = 0; i < sps->rps[idx_rps].num_positive_pics; i++) {\n\t\t\tu32 delta_poc_s1_minus1 = gf_bs_read_ue_log_idx2(bs, \"delta_poc_s1_minus1\" , idx_rps, i);\n\t\t\tpoc = prev + delta_poc_s1_minus1 + 1;\n\t\t\tprev = poc;\n\t\t\tsps->rps[idx_rps].delta_poc[i] = poc;\n\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"used_by_curr_pic_s1_flag\", idx_rps, i);\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nvoid hevc_pred_weight_table(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si, HEVC_PPS *pps, HEVC_SPS *sps, u32 num_ref_idx_l0_active, u32 num_ref_idx_l1_active)\n{\n\tu32 i, num_ref_idx;\n\tBool first_pass = GF_TRUE;\n\tu8 luma_weights[20], chroma_weights[20];\n\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\n\tnum_ref_idx = num_ref_idx_l0_active;\n\n\tgf_bs_read_ue_log(bs, \"luma_log2_weight_denom\");\n\tif (ChromaArrayType != 0)\n\t\tgf_bs_read_se_log(bs, \"delta_chroma_log2_weight_denom\");\n\nparse_weights:\n\tfor (i = 0; i < num_ref_idx; i++) {\n\t\tluma_weights[i] = gf_bs_read_int_log_idx(bs, 1, \"luma_weights\", i);\n\t\t//infered to be 0 if not present\n\t\tchroma_weights[i] = 0;\n\t}\n\tif (ChromaArrayType != 0) {\n\t\tfor (i = 0; i < num_ref_idx; i++) {\n\t\t\tchroma_weights[i] = gf_bs_read_int_log_idx(bs, 1, \"chroma_weights\", i);\n\t\t}\n\t}\n\tfor (i = 0; i < num_ref_idx; i++) {\n\t\tif (luma_weights[i]) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"delta_luma_weight_l0\", i);\n\t\t\tgf_bs_read_se_log_idx(bs, \"luma_offset_l0\", i);\n\t\t}\n\t\tif (chroma_weights[i]) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"delta_chroma_weight_l0_0\", i);\n\t\t\tgf_bs_read_se_log_idx(bs, \"delta_chroma_offset_l0_0\", i);\n\n\t\t\tgf_bs_read_se_log_idx(bs, \"delta_chroma_weight_l0_1\", i);\n\t\t\tgf_bs_read_se_log_idx(bs, \"delta_chroma_offset_l0_1\", i);\n\t\t}\n\t}\n\n\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\tif (!first_pass) return;\n\t\tfirst_pass = GF_FALSE;\n\t\tnum_ref_idx = num_ref_idx_l1_active;\n\t\tgoto parse_weights;\n\t}\n}\n\nstatic\nBool ref_pic_lists_modification(GF_BitStream *bs, u32 slice_type, u32 num_ref_idx_l0_active, u32 num_ref_idx_l1_active)\n{\n\t//u32 i;\n\tBool ref_pic_list_modification_flag_l0 = gf_bs_read_int_log(bs, 1, \"ref_pic_list_modification_flag_l0\");\n\tif (ref_pic_list_modification_flag_l0) {\n\t\t/*for (i=0; i<num_ref_idx_l0_active; i++) {\n\t\t\tlist_entry_l0[i] = *//*gf_bs_read_int(bs, (u32)ceil(log(getNumPicTotalCurr())/log(2)));\n\t\t}*/\n\t\treturn GF_FALSE;\n\t}\n\tif (slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\tBool ref_pic_list_modification_flag_l1 = gf_bs_read_int_log(bs, 1, \"ref_pic_list_modification_flag_l1\");\n\t\tif (ref_pic_list_modification_flag_l1) {\n\t\t\t/*for (i=0; i<num_ref_idx_l1_active; i++) {\n\t\t\t\tlist_entry_l1[i] = *//*gf_bs_read_int(bs, (u32)ceil(log(getNumPicTotalCurr()) / log(2)));\n\t\t\t}*/\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\n\treturn GF_TRUE;\n}\n\nstatic\ns32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)\n{\n\tu32 i, j;\n\tu32 num_ref_idx_l0_active = 0, num_ref_idx_l1_active = 0;\n\tHEVC_PPS *pps;\n\tHEVC_SPS *sps;\n\ts32 pps_id;\n\tBool RapPicFlag = GF_FALSE;\n\tBool IDRPicFlag = GF_FALSE;\n\n\tsi->first_slice_segment_in_pic_flag = gf_bs_read_int_log(bs, 1, \"first_slice_segment_in_pic_flag\");\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tIDRPicFlag = GF_TRUE;\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\t}\n\n\tif (RapPicFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"no_output_of_prior_pics_flag\");\n\t}\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 64))\n\t\treturn -1;\n\n\tpps = &hevc->pps[pps_id];\n\tsps = &hevc->sps[pps->sps_id];\n\tsi->sps = sps;\n\tsi->pps = pps;\n\n\tif (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {\n\t\tsi->dependent_slice_segment_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segment_flag\");\n\t}\n\telse {\n\t\tsi->dependent_slice_segment_flag = GF_FALSE;\n\t}\n\n\tif (!si->first_slice_segment_in_pic_flag) {\n\t\tsi->slice_segment_address = gf_bs_read_int_log(bs, sps->bitsSliceSegmentAddress, \"slice_segment_address\");\n\t}\n\telse {\n\t\tsi->slice_segment_address = 0;\n\t}\n\n\tif (!si->dependent_slice_segment_flag) {\n\t\tBool deblocking_filter_override_flag = 0;\n\t\tBool slice_temporal_mvp_enabled_flag = 0;\n\t\tBool slice_sao_luma_flag = 0;\n\t\tBool slice_sao_chroma_flag = 0;\n\t\tBool slice_deblocking_filter_disabled_flag = 0;\n\n\t\t//\"slice_reserved_undetermined_flag[]\"\n\t\tgf_bs_read_int_log(bs, pps->num_extra_slice_header_bits, \"slice_reserved_undetermined_flag\");\n\n\t\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\n\t\tif (pps->output_flag_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"pic_output_flag\");\n\n\t\tif (sps->separate_colour_plane_flag == 1)\n\t\t\tgf_bs_read_int_log(bs, 2, \"colour_plane_id\");\n\n\t\tif (IDRPicFlag) {\n\t\t\tsi->poc_lsb = 0;\n\n\t\t\t//if not asked to parse full header, abort since we know the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t}\n\t\telse {\n\t\t\tsi->poc_lsb = gf_bs_read_int_log(bs, sps->log2_max_pic_order_cnt_lsb, \"poc_lsb\");\n\n\t\t\t//if not asked to parse full header, abort once we have the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"short_term_ref_pic_set_sps_flag\") == 0) {\n\t\t\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (sps->num_short_term_ref_pic_sets > 1) {\n\t\t\t\tu32 numbits = 0;\n\n\t\t\t\twhile ((u32)(1 << numbits) < sps->num_short_term_ref_pic_sets)\n\t\t\t\t\tnumbits++;\n\t\t\t\tif (numbits > 0)\n\t\t\t\t\tgf_bs_read_int_log(bs, numbits, \"short_term_ref_pic_set_idx\");\n\t\t\t\t/*else\n\t\t\t\t\tshort_term_ref_pic_set_idx = 0;*/\n\t\t\t}\n\t\t\tif (sps->long_term_ref_pics_present_flag) {\n\t\t\t\tu8 DeltaPocMsbCycleLt[32];\n\t\t\t\tu32 num_long_term_sps = 0;\n\t\t\t\tu32 num_long_term_pics = 0;\n\n\t\t\t\tmemset(DeltaPocMsbCycleLt, 0, sizeof(u8) * 32);\n\t\t\t\t\n\t\t\t\tif (sps->num_long_term_ref_pic_sps > 0) {\n\t\t\t\t\tnum_long_term_sps = gf_bs_read_ue_log(bs, \"num_long_term_sps\");\n\t\t\t\t}\n\t\t\t\tnum_long_term_pics = gf_bs_read_ue_log(bs, \"num_long_term_pics\");\n\n\t\t\t\tfor (i = 0; i < num_long_term_sps + num_long_term_pics; i++) {\n\t\t\t\t\tif (i < num_long_term_sps) {\n\t\t\t\t\t\tif (sps->num_long_term_ref_pic_sps > 1)\n\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps), \"lt_idx_sps\", i);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"PocLsbLt\", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"UsedByCurrPicLt\", i);\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"delta_poc_msb_present_flag\", i)) {\n\t\t\t\t\t\tif (i == 0 || i == num_long_term_sps)\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i) + DeltaPocMsbCycleLt[i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->temporal_mvp_enable_flag)\n\t\t\t\tslice_temporal_mvp_enabled_flag = gf_bs_read_int_log(bs, 1, \"slice_temporal_mvp_enabled_flag\");\n\t\t}\n\t\tif (sps->sample_adaptive_offset_enabled_flag) {\n\t\t\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\t\t\tslice_sao_luma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_luma_flag\");\n\t\t\tif (ChromaArrayType != 0)\n\t\t\t\tslice_sao_chroma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_chroma_flag\");\n\t\t}\n\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\t\t//u32 NumPocTotalCurr;\n\t\t\tnum_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n\t\t\tnum_ref_idx_l1_active = 0;\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tnum_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\")) {\n\t\t\t\tnum_ref_idx_l0_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active\");\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tnum_ref_idx_l1_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active\");\n\t\t\t}\n\n\t\t\tif (pps->lists_modification_present_flag /*TODO: && NumPicTotalCurr > 1*/) {\n\t\t\t\tif (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[hevc] ref_pic_lists_modification( ) not implemented\\n\"));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"mvd_l1_zero_flag\");\n\t\t\tif (pps->cabac_init_present_flag)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"cabac_init_flag\");\n\n\t\t\tif (slice_temporal_mvp_enabled_flag) {\n\t\t\t\t// When collocated_from_l0_flag is not present, it is inferred to be equal to 1.\n\t\t\t\tBool collocated_from_l0_flag = 1;\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tcollocated_from_l0_flag = gf_bs_read_int_log(bs, 1, \"collocated_from_l0_flag\");\n\n\t\t\t\tif ((collocated_from_l0_flag && (num_ref_idx_l0_active > 1))\n\t\t\t\t\t|| (!collocated_from_l0_flag && (num_ref_idx_l1_active > 1))\n\t\t\t\t) {\n\t\t\t\t\tgf_bs_read_ue_log(bs, \"collocated_ref_idx\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P)\n\t\t\t\t|| (pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t) {\n\t\t\t\thevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);\n\t\t\t}\n\t\t\tgf_bs_read_ue_log(bs, \"five_minus_max_num_merge_cand\");\n\t\t}\n\t\tsi->slice_qp_delta_start_bits = (s32) (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\t\tsi->slice_qp_delta = gf_bs_read_se_log(bs, \"slice_qp_delta\");\n\n\t\tif (pps->slice_chroma_qp_offsets_present_flag) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_cb_qp_offset\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_cr_qp_offset\");\n\t\t}\n\t\tif (pps->deblocking_filter_override_enabled_flag) {\n\t\t\tdeblocking_filter_override_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_flag\");\n\t\t}\n\n\t\tif (deblocking_filter_override_flag) {\n\t\t\tslice_deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, \"slice_deblocking_filter_disabled_flag\");\n\t\t\tif (!slice_deblocking_filter_disabled_flag) {\n\t\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t\t\tgf_bs_read_se_log(bs, \"slice_tc_offset_div2\");\n\t\t\t}\n\t\t}\n\t\tif (pps->loop_filter_across_slices_enabled_flag\n\t\t\t&& (slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag)\n\t\t) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_loop_filter_across_slices_enabled_flag\");\n\t\t}\n\t}\n\t//dependent slice segment\n\telse {\n\t\t//if not asked to parse full header, abort\n\t\tif (!hevc->full_slice_header_parse) return 0;\n\t}\n\n\tsi->entry_point_start_bits = ((u32)gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\n\tif (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {\n\t\tu32 num_entry_point_offsets = gf_bs_read_ue_log(bs, \"num_entry_point_offsets\");\n\t\tif (num_entry_point_offsets > 0) {\n\t\t\tu32 offset = gf_bs_read_ue_log(bs, \"offset\") + 1;\n\t\t\tu32 segments = offset >> 4;\n\t\t\ts32 remain = (offset & 15);\n\n\t\t\tfor (i = 0; i < num_entry_point_offsets; i++) {\n\t\t\t\t//u32 res = 0;\n\t\t\t\tfor (j = 0; j < segments; j++) {\n\t\t\t\t\t//res <<= 16;\n\t\t\t\t\t/*res +=*/ gf_bs_read_int(bs, 16);\n\t\t\t\t}\n\t\t\t\tif (remain) {\n\t\t\t\t\t//res <<= remain;\n\t\t\t\t\t/* res += */ gf_bs_read_int(bs, remain);\n\t\t\t\t}\n\t\t\t\t// entry_point_offset = val + 1; // +1; // +1 to get the size\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pps->slice_segment_header_extension_present_flag) {\n\t\tu32 size_ext = gf_bs_read_ue_log(bs, \"size_ext\");\n\t\twhile (size_ext) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tsize_ext--;\n\t\t}\n\t}\n\n\tsi->header_size_bits = (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs); // av_parser.c modified on 16 jan. 2019 \n\n\tif (gf_bs_read_int_log(bs, 1, \"byte_align\") == 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Error parsing slice header: byte_align not found at end of header !\\n\"));\n\t}\n\n\tgf_bs_align(bs);\n\tsi->payload_start_offset = (s32)gf_bs_get_position(bs);\n\treturn 0;\n}\n\nstatic void gf_hevc_vvc_parse_sei(char *buffer, u32 nal_size, HEVCState *hevc, VVCState *vvc)\n{\n\tu32 ptype, psize, hdr;\n\tu64 start;\n\tGF_BitStream *bs;\n\n\thdr = buffer[0];\n\tif (((hdr & 0x7e) >> 1) != GF_HEVC_NALU_SEI_PREFIX) return;\n\n\tbs = gf_bs_new(buffer, nal_size, GF_BITSTREAM_READ);\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tgf_bs_read_int(bs, 16);\n\n\t/*parse SEI*/\n\twhile (gf_bs_available(bs)) {\n\t\tu32 consumed;\n\t\tptype = 0;\n\t\twhile (gf_bs_peek_bits(bs, 8, 0)==0xFF) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tptype += 255;\n\t\t}\n\t\tptype += gf_bs_read_int(bs, 8);\n\t\tpsize = 0;\n\t\twhile (gf_bs_peek_bits(bs, 8, 0)==0xFF) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tpsize += 255;\n\t\t}\n\t\tpsize += gf_bs_read_int(bs, 8);\n\n\t\tstart = gf_bs_get_position(bs);\n\t\tif (start+psize >= nal_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[%s] SEI user message type %d size error (%d but %d remain), skipping SEI message\\n\", hevc ? \"HEVC\" : \"VVC\", ptype, psize, nal_size-start));\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ptype) {\n\t\tcase 4: /*user registered ITU-T T35*/\n\t\t\tif (hevc) {\n\t\t\t\tavc_parse_itu_t_t35_sei(bs, &hevc->sei.dovi);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tgf_bs_align(bs);\n\t\tconsumed = (u32) (gf_bs_get_position(bs) - start);\n\t\tpsize-=consumed;\n\t\tgf_bs_skip_bytes(bs, psize);\n\t\tif (gf_bs_available(bs) <= 2)\n\t\t\tbreak;\n\t}\n\tgf_bs_del(bs);\n}\n\nvoid gf_hevc_parse_sei(char *buffer, u32 nal_size, HEVCState *hevc)\n{\n\tgf_hevc_vvc_parse_sei(buffer, nal_size, hevc, NULL);\n}\n\nstatic void hevc_compute_poc(HEVCSliceInfo *si)\n{\n\tu32 max_poc_lsb = 1 << (si->sps->log2_max_pic_order_cnt_lsb);\n\n\t/*POC reset for IDR frames, NOT for CRA*/\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tsi->poc_lsb_prev = 0;\n\t\tsi->poc_msb_prev = 0;\n\t\tbreak;\n\t}\n\n\tif ((si->poc_lsb < si->poc_lsb_prev) && (si->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2))\n\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\telse if ((si->poc_lsb > si->poc_lsb_prev) && (si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\telse\n\t\tsi->poc_msb = si->poc_msb_prev;\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\tsi->poc_msb = 0;\n\t\tbreak;\n\t}\n\tsi->poc = si->poc_msb + si->poc_lsb;\n}\n\n\nstatic Bool hevc_parse_nal_header(GF_BitStream *bs, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tu32 val;\n\tval = gf_bs_read_int_log(bs, 1, \"forbidden_zero\");\n\tif (val) return GF_FALSE;\n\n\tval = gf_bs_read_int_log(bs, 6, \"nuh_type\");\n\tif (nal_unit_type) *nal_unit_type = val;\n\n\tval = gf_bs_read_int_log(bs, 6, \"layerID\");\n\tif (layer_id) *layer_id = val;\n\n\tval = gf_bs_read_int_log(bs, 3, \"temporalID\");\n\tif (!val)\n\t\treturn GF_FALSE;\n\tval -= 1;\n\tif (temporal_id) *temporal_id = val;\n\treturn GF_TRUE;\n}\n\n\nvoid hevc_profile_tier_level(GF_BitStream *bs, Bool ProfilePresentFlag, u8 MaxNumSubLayersMinus1, HEVC_ProfileTierLevel *ptl, u32 idx)\n{\n\tu32 i;\n\tif (ProfilePresentFlag) {\n\t\tptl->profile_space = gf_bs_read_int_log_idx(bs, 2, \"profile_space\", idx);\n\t\tptl->tier_flag = gf_bs_read_int_log_idx(bs, 1, \"tier_flag\", idx);\n\t\tptl->profile_idc = gf_bs_read_int_log_idx(bs, 5, \"profile_idc\", idx);\n\n\t\tptl->profile_compatibility_flag = gf_bs_read_int_log_idx(bs, 32, \"profile_compatibility_flag\", idx);\n\n\t\tptl->general_progressive_source_flag = gf_bs_read_int_log_idx(bs, 1, \"general_progressive_source_flag\", idx);\n\t\tptl->general_interlaced_source_flag = gf_bs_read_int_log_idx(bs, 1, \"general_interlaced_source_flag\", idx);\n\t\tptl->general_non_packed_constraint_flag = gf_bs_read_int_log_idx(bs, 1, \"general_non_packed_constraint_flag\", idx);\n\t\tptl->general_frame_only_constraint_flag = gf_bs_read_int_log_idx(bs, 1, \"general_frame_only_constraint_flag\", idx);\n\t\tptl->general_reserved_44bits = gf_bs_read_long_int(bs, 44);\n\t}\n\tptl->level_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\tfor (i = 0; i < MaxNumSubLayersMinus1; i++) {\n\t\tptl->sub_ptl[i].profile_present_flag = gf_bs_read_int_log_idx2(bs, 1, \"profile_present_flag\", idx, i);\n\t\tptl->sub_ptl[i].level_present_flag = gf_bs_read_int_log_idx2(bs, 1, \"level_present_flag\", idx, i);\n\t}\n\tif (MaxNumSubLayersMinus1 > 0) {\n\t\tfor (i = MaxNumSubLayersMinus1; i < 8; i++) {\n\t\t\t/*reserved_zero_2bits*/gf_bs_read_int(bs, 2);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MaxNumSubLayersMinus1; i++) {\n\t\tif (ptl->sub_ptl[i].profile_present_flag) {\n\t\t\tptl->sub_ptl[i].profile_space = gf_bs_read_int_log_idx2(bs, 2, \"sublayer_profile_space\", idx, i);\n\t\t\tptl->sub_ptl[i].tier_flag = gf_bs_read_int_log_idx2(bs, 1, \"sublayer_tier_flag\", idx, i);\n\t\t\tptl->sub_ptl[i].profile_idc = gf_bs_read_int_log_idx2(bs, 5, \"sublayer_profile_idc\", idx, i);\n\t\t\tptl->sub_ptl[i].profile_compatibility_flag = gf_bs_read_int_log_idx2(bs, 32, \"sublayer_profile_compatibility_flag\", idx, i);\n\t\t\t/*ptl->sub_ptl[i].progressive_source_flag =*/ gf_bs_read_int_log_idx2(bs, 1, \"sublayer_progressive_source_flag\", idx, i);\n\t\t\t/*ptl->sub_ptl[i].interlaced_source_flag =*/ gf_bs_read_int_log_idx2(bs, 1, \"sublayer_interlaced_source_flag\", idx, i);\n\t\t\t/*ptl->sub_ptl[i].non_packed_constraint_flag =*/ gf_bs_read_int_log_idx2(bs, 1, \"sublayer_non_packed_constraint_flag\", idx, i);\n\t\t\t/*ptl->sub_ptl[i].frame_only_constraint_flag =*/ gf_bs_read_int_log_idx2(bs, 1, \"sublayer_frame_only_constraint_flag\", idx, i);\n\t\t\t/*ptl->sub_ptl[i].reserved_44bits =*/ gf_bs_read_long_int(bs, 44);\n\t\t}\n\t\tif (ptl->sub_ptl[i].level_present_flag)\n\t\t\tptl->sub_ptl[i].level_idc = gf_bs_read_int_log_idx2(bs, 8, \"sublayer_level_idc\", idx, i);\n\t}\n}\n\nstatic u32 scalability_type_to_idx(HEVC_VPS *vps, u32 scalability_type)\n{\n\tu32 idx = 0, type;\n\tfor (type = 0; type < scalability_type; type++) {\n\t\tidx += (vps->scalability_mask[type] ? 1 : 0);\n\t}\n\treturn idx;\n}\n\n#define LHVC_VIEW_ORDER_INDEX  1\n#define LHVC_SCALABILITY_INDEX\t2\n\nstatic u32 lhvc_get_scalability_id(HEVC_VPS *vps, u32 layer_id_in_vps, u32 scalability_type)\n{\n\tu32 idx;\n\tif (!vps->scalability_mask[scalability_type]) return 0;\n\tidx = scalability_type_to_idx(vps, scalability_type);\n\treturn vps->dimension_id[layer_id_in_vps][idx];\n}\n\nstatic u32 lhvc_get_view_index(HEVC_VPS *vps, u32 id)\n{\n\treturn lhvc_get_scalability_id(vps, vps->layer_id_in_vps[id], LHVC_VIEW_ORDER_INDEX);\n}\n\nstatic u32 lhvc_get_num_views(HEVC_VPS *vps)\n{\n\tu32 numViews = 1, i;\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tu32 layer_id = vps->layer_id_in_nuh[i];\n\t\tif (i > 0 && (lhvc_get_view_index(vps, layer_id) != lhvc_get_scalability_id(vps, i - 1, LHVC_VIEW_ORDER_INDEX))) {\n\t\t\tnumViews++;\n\t\t}\n\t}\n\treturn numViews;\n}\n\nstatic void lhvc_parse_rep_format(HEVC_RepFormat *fmt, GF_BitStream *bs, u32 idx)\n{\n\tu8 chroma_bitdepth_present_flag;\n\tfmt->pic_width_luma_samples = gf_bs_read_int_log_idx(bs, 16, \"pic_width_luma_samples\", idx);\n\tfmt->pic_height_luma_samples = gf_bs_read_int_log_idx(bs, 16, \"pic_height_luma_samples\", idx);\n\tchroma_bitdepth_present_flag = gf_bs_read_int_log_idx(bs, 1, \"chroma_bitdepth_present_flag\", idx);\n\tif (chroma_bitdepth_present_flag) {\n\t\tfmt->chroma_format_idc = gf_bs_read_int_log_idx(bs, 2, \"chroma_format_idc\", idx);\n\n\t\tif (fmt->chroma_format_idc == 3)\n\t\t\tfmt->separate_colour_plane_flag = gf_bs_read_int_log_idx(bs, 1, \"separate_colour_plane_flag\", idx);\n\t\tfmt->bit_depth_luma = 8 + gf_bs_read_int_log_idx(bs, 4, \"bit_depth_luma_minus8\", idx);\n\t\tfmt->bit_depth_chroma = 8 + gf_bs_read_int_log_idx(bs, 4, \"bit_depth_chroma_minus8\", idx);\n\t}\n\tif (gf_bs_read_int_log_idx(bs, 1, \"conformance_window_vps_flag\", idx)) {\n\t\tgf_bs_read_ue_log_idx(bs, \"conf_win_vps_left_offset\", idx);\n\t\tgf_bs_read_ue_log_idx(bs, \"conf_win_vps_right_offset\", idx);\n\t\tgf_bs_read_ue_log_idx(bs, \"conf_win_vps_top_offset\", idx);\n\t\tgf_bs_read_ue_log_idx(bs, \"conf_win_vps_bottom_offset\", idx);\n\t}\n}\n\n\nstatic Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)\n{\n\tu8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;\n\tu32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;\n\tu8 dimension_id_len[16], dim_bit_offset[16];\n\tu8 /*avc_base_layer_flag, */NumLayerSets, /*default_one_target_output_layer_flag, */rep_format_idx_present_flag, ols_ids_to_ls_idx;\n\tu8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];\n\tu8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];\n\tu8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];\n\n\tu32 k, d, r, p, iNuhLId, jNuhLId;\n\tu8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];\n\tu8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 num_ref_layers[64];\n\t//\tu8 tree_partition_layer_id[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\t//\tu8 id_ref_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 id_direct_ref_layers[64][MAX_LHVC_LAYERS];\n\tu8 layer_id_in_list_flag[64];\n\tBool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\n\tvps->vps_extension_found = 1;\n\tif ((vps->max_layers > 1) && vps->base_layer_internal_flag)\n\t\thevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);\n\n\tsplitting_flag = gf_bs_read_int_log(bs, 1, \"splitting_flag\");\n\tnum_scalability_types = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tvps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, \"scalability_mask\", i);\n\t\tnum_scalability_types += vps->scalability_mask[i];\n\t}\n\tif (num_scalability_types >= 16) {\n\t\tnum_scalability_types = 16;\n\t}\n\tdimension_id_len[0] = 0;\n\tfor (i = 0; i < (num_scalability_types - splitting_flag); i++) {\n\t\tdimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, \"dimension_id_len_minus1\", i);\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < num_scalability_types; i++) {\n\t\t\tdim_bit_offset[i] = 0;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdim_bit_offset[i] += dimension_id_len[j];\n\t\t}\n\t\tdimension_id_len[num_scalability_types - 1] = 1 + (5 - dim_bit_offset[num_scalability_types - 1]);\n\t\tdim_bit_offset[num_scalability_types] = 6;\n\t}\n\n\tvps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, \"vps_nuh_layer_id_present_flag\");\n\tvps->layer_id_in_nuh[0] = 0;\n\tvps->layer_id_in_vps[0] = 0;\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tif (vps_nuh_layer_id_present_flag) {\n\t\t\tvps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, \"layer_id_in_nuh\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->layer_id_in_nuh[i] = i;\n\t\t}\n\t\tvps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;\n\n\t\tif (!splitting_flag) {\n\t\t\tfor (j = 0; j < num_scalability_types; j++) {\n\t\t\t\tvps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], \"dimension_id\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < vps->max_layers; i++)\n\t\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\t\tvps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);\n\t}\n\telse {\n\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\tvps->dimension_id[0][j] = 0;\n\t}\n\n\tview_id_len = gf_bs_read_int_log(bs, 4, \"view_id_len\");\n\tif (view_id_len > 0) {\n\t\tfor (i = 0; i < lhvc_get_num_views(vps); i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, view_id_len, \"view_id_val\", i);\n\t\t}\n\t}\n\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tvps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, \"direct_dependency_flag\", i);\n\t\t}\n\t}\n\n\t//we do the test on MAX_LHVC_LAYERS and break in the loop to avoid a wrong GCC 4.8 warning on array bounds\n\tfor (i = 0; i < MAX_LHVC_LAYERS; i++) {\n\t\tif (i >= vps->max_layers) break;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tdependency_flag[i][j] = vps->direct_dependency_flag[i][j];\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\tif (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])\n\t\t\t\t\tdependency_flag[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\td = r = p = 0;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tjNuhLId = vps->layer_id_in_nuh[j];\n\t\t\tif (vps->direct_dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_direct_ref_layers[iNuhLId][d] = jNuhLId;\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_ref_layers[iNuhLId][r] = jNuhLId;\n\t\t\t\tr++;\n\t\t\t}\n\n\t\t\tif (dependency_flag[j][i])\n\t\t\t\tid_pred_layers[iNuhLId][p++] = jNuhLId;\n\t\t}\n\t\tnum_direct_ref_layers[iNuhLId] = d;\n\t\t//\t\tnum_ref_layers[iNuhLId] = r;\n\t\tnum_pred_layers[iNuhLId] = p;\n\t}\n\n\tmemset(layer_id_in_list_flag, 0, 64 * sizeof(u8));\n\tk = 0; //num_indepentdent_layers\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\tif (!num_direct_ref_layers[iNuhLId]) {\n\t\t\tu32 h = 1;\n\t\t\t//tree_partition_layer_id[k][0] = iNuhLId;\n\t\t\tfor (j = 0; j < num_pred_layers[iNuhLId]; j++) {\n\t\t\t\tu32 predLId = id_pred_layers[iNuhLId][j];\n\t\t\t\tif (!layer_id_in_list_flag[predLId]) {\n\t\t\t\t\t//tree_partition_layer_id[k][h++] = predLId;\n\t\t\t\t\tlayer_id_in_list_flag[predLId] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_layers_in_tree_partition[k++] = h;\n\t\t}\n\t}\n\tnum_indepentdent_layers = k;\n\n\tnum_add_layer_set = 0;\n\tif (num_indepentdent_layers > 1)\n\t\tnum_add_layer_set = gf_bs_read_ue_log(bs, \"num_add_layer_set\");\n\n\tfor (i = 0; i < num_add_layer_set; i++)\n\t\tfor (j = 1; j < num_indepentdent_layers; j++) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))\n\t\t\t\tnb_bits++;\n\t\t\tgf_bs_read_int_log_idx2(bs, nb_bits, \"highest_layer_idx_plus1\", i, j);\n\t\t}\n\n\n\tif (gf_bs_read_int_log(bs, 1, \"vps_sub_layers_max_minus1_present_flag\")) {\n\t\tfor (i = 0; i < vps->max_layers; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, 3, \"sub_layers_vps_max_minus1\", i);\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"max_tid_ref_present_flag\")) {\n\t\tfor (i = 0; i < (vps->max_layers - 1); i++) {\n\t\t\tfor (j = i + 1; j < vps->max_layers; j++) {\n\t\t\t\tif (vps->direct_dependency_flag[j][i])\n\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"default_ref_layers_active_flag\");\n\n\tvps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, \"num_profile_tier_level\");\n\tif (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));\n\t\tvps->num_profile_tier_level = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {\n\t\tBool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_profile_present_flag\", i);\n\t\thevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);\n\t}\n\n\tNumLayerSets = vps->num_layer_sets + num_add_layer_set;\n\tnum_add_olss = 0;\n\n\tif (NumLayerSets > 1) {\n\t\tnum_add_olss = gf_bs_read_ue_log(bs, \"num_add_olss\");\n\t\tdefault_output_layer_idc = gf_bs_read_int_log(bs, 2, \"default_output_layer_idc\");\n\t\tdefault_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;\n\t}\n\tvps->num_output_layer_sets = num_add_olss + NumLayerSets;\n\n\tif (vps->num_output_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of output layer sets in VPS %d, max %d supported\\n\", vps->num_output_layer_sets, MAX_LHVC_LAYERS));\n\t\tvps->num_output_layer_sets = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tlayer_set_idx_for_ols_minus1[0] = 1;\n\tvps->output_layer_flag[0][0] = 1;\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tif ((NumLayerSets > 2) && (i >= NumLayerSets)) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (NumLayerSets - 1))\n\t\t\t\tnb_bits++;\n\t\t\tlayer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"layer_set_idx_for_ols_minus1\", i);\n\t\t}\n\t\telse\n\t\t\tlayer_set_idx_for_ols_minus1[i] = 0;\n\t\tols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;\n\n\t\tif ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\t\tvps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"output_layer_flag\", i, j);\n\t\t}\n\n\t\tif ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\t\tif ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tu32 curLayerID;\n\t\t\t\tvps->necessary_layers_flag[i][j] = GF_TRUE;\n\t\t\t\tcurLayerID = vps->LayerSetLayerIdList[i][j];\n\t\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\t\tu32 refLayerId = vps->LayerSetLayerIdList[i][k];\n\t\t\t\t\tif (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])\n\t\t\t\t\t\tvps->necessary_layers_flag[i][k] = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_necessary_layers[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (vps->necessary_layers_flag[i][j])\n\t\t\t\tvps->num_necessary_layers[i] += 1;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tif (vps->base_layer_internal_flag) {\n\t\t\t\tif (vps->max_layers > 1)\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 1;\n\t\t\t\telse\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnb_bits = 1;\n\t\twhile ((u32)(1 << nb_bits) < vps->num_profile_tier_level)\n\t\t\tnb_bits++;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\tif (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)\n\t\t\t\tvps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, \"profile_tier_level_idx\", i, j);\n\t\t\telse\n\t\t\t\tvps->profile_tier_level_idx[i][j] = 0;\n\n\n\t\tnb_output_layers_in_output_layer_set[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tnb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];\n\t\t\t}\n\t\t}\n\t\tif (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)\n\t\t\tvps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, \"alt_output_layer_flag\", i);\n\t}\n\n\tvps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, \"num_rep_formats_minus1\");\n\tif (vps->num_rep_formats > 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));\n\t\tvps->num_rep_formats = 0;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = 0; i < vps->num_rep_formats; i++) {\n\t\tlhvc_parse_rep_format(&vps->rep_formats[i], bs, i);\n\t}\n\tif (vps->num_rep_formats > 1)\n\t\trep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, \"rep_format_idx_present_flag\");\n\telse\n\t\trep_format_idx_present_flag = 0;\n\n\tvps->rep_format_idx[0] = 0;\n\tnb_bits = 1;\n\twhile ((u32)(1 << nb_bits) < vps->num_rep_formats)\n\t\tnb_bits++;\n\tfor (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {\n\t\tif (rep_format_idx_present_flag) {\n\t\t\tvps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"rep_format_idx\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;\n\t\t}\n\t}\n\t//TODO - we don't use the rest ...\n\n\treturn GF_TRUE;\n}\n\nstatic void sub_layer_hrd_parameters(GF_BitStream *bs, int subLayerId, u32 cpb_cnt, Bool sub_pic_hrd_params_present_flag, u32 idx1, u32 idx2)\n{\n\tu32 i;\n\tif (!gf_bs_available(bs)) return;\n\n\tfor (i = 0; i <= cpb_cnt; i++) {\n\t\tgf_bs_read_ue_log_idx3(bs, \"bit_rate_value_minus1\", idx1, idx2, i);\n\t\tgf_bs_read_ue_log_idx3(bs, \"cpb_size_value_minus1\", idx1, idx2, i);\n\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\tgf_bs_read_ue_log_idx3(bs, \"cpb_size_du_value_minus1\", idx1, idx2, i);\n\t\t\tgf_bs_read_ue_log_idx3(bs, \"bit_rate_du_value_minus1\", idx1, idx2, i);\n\t\t}\n\t\tgf_bs_read_int_log_idx3(bs, 1, \"cbr_flag\", idx1, idx2, i);\n\t}\n}\n\nstatic void hevc_parse_hrd_parameters(GF_BitStream *bs, Bool commonInfPresentFlag, int maxNumSubLayersMinus1, u32 idx)\n{\n\tint i;\n\tBool nal_hrd_parameters_present_flag = GF_FALSE;\n\tBool vcl_hrd_parameters_present_flag = GF_FALSE;\n\tBool sub_pic_hrd_params_present_flag = GF_FALSE;\n\n\tif (commonInfPresentFlag) {\n\t\tnal_hrd_parameters_present_flag = gf_bs_read_int_log_idx(bs, 1, \"nal_hrd_parameters_present_flag\", idx);\n\t\tvcl_hrd_parameters_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vcl_hrd_parameters_present_flag\", idx);\n\t\tif (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n\t\t\tsub_pic_hrd_params_present_flag = gf_bs_read_int_log_idx(bs, 1, \"sub_pic_hrd_params_present_flag\", idx);\n\t\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, 8, \"tick_divisor_minus2\", idx);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 5, \"du_cpb_removal_delay_increment_length_minus1\", idx);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"sub_pic_cpb_params_in_pic_timing_sei_flag\", idx);\n\t\t\t\tgf_bs_read_int_log_idx(bs, 5, \"dpb_output_delay_du_length_minus1\", idx);\n\t\t\t}\n\t\t\tgf_bs_read_int_log_idx(bs, 4, \"bit_rate_scale\", idx);\n\t\t\tgf_bs_read_int_log_idx(bs, 4, \"cpb_size_scale\", idx);\n\t\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, 4, \"cpb_size_du_scale\", idx);\n\t\t\t}\n\t\t\tgf_bs_read_int_log_idx(bs, 5, \"initial_cpb_removal_delay_length_minus1\", idx);\n\t\t\tgf_bs_read_int_log_idx(bs, 5, \"au_cpb_removal_delay_length_minus1\", idx);\n\t\t\tgf_bs_read_int_log_idx(bs, 5, \"dpb_output_delay_length_minus1\", idx);\n\t\t}\n\t}\n\tfor (i = 0; i <= maxNumSubLayersMinus1; i++) {\n\t\tBool fixed_pic_rate_general_flag_i = gf_bs_read_int_log_idx(bs, 1, \"fixed_pic_rate_general_flag\", idx);\n\t\tBool fixed_pic_rate_within_cvs_flag_i = GF_TRUE;\n\t\tBool low_delay_hrd_flag_i = GF_FALSE;\n\t\tu32 cpb_cnt_minus1_i = 0;\n\t\tif (!fixed_pic_rate_general_flag_i) {\n\t\t\tfixed_pic_rate_within_cvs_flag_i = gf_bs_read_int_log_idx(bs, 1, \"fixed_pic_rate_within_cvs_flag\", idx);\n\t\t}\n\t\tif (fixed_pic_rate_within_cvs_flag_i)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"elemental_duration_in_tc_minus1\", idx);\n\t\telse\n\t\t\tlow_delay_hrd_flag_i = gf_bs_read_int_log_idx(bs, 1, \"low_delay_hrd_flag\", idx);\n\t\tif (!low_delay_hrd_flag_i) {\n\t\t\tcpb_cnt_minus1_i = gf_bs_read_ue_log_idx(bs, \"cpb_cnt_minus1\", idx);\n\t\t}\n\t\tif (nal_hrd_parameters_present_flag) {\n\t\t\tsub_layer_hrd_parameters(bs, i, cpb_cnt_minus1_i, sub_pic_hrd_params_present_flag, idx, i);\n\t\t}\n\t\tif (vcl_hrd_parameters_present_flag) {\n\t\t\tsub_layer_hrd_parameters(bs, i, cpb_cnt_minus1_i, sub_pic_hrd_params_present_flag, idx, i);\n\t\t}\n\t}\n}\n\nstatic s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)\n{\n\tu8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;\n\tu32 i, j;\n\ts32 vps_id;\n\tHEVC_VPS *vps;\n\tu8 layer_id_included_flag[MAX_LHVC_LAYERS][64];\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\n\tif ((vps_id<0) || (vps_id >= 16)) return -1;\n\n\tvps = &hevc->vps[vps_id];\n\tvps->bit_pos_vps_extensions = -1;\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\n\tvps->base_layer_internal_flag = gf_bs_read_int_log(bs, 1, \"base_layer_internal_flag\");\n\tvps->base_layer_available_flag = gf_bs_read_int_log(bs, 1, \"base_layer_available_flag\");\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers_minus1\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\tvps->temporal_id_nesting = gf_bs_read_int_log(bs, 1, \"temporal_id_nesting\");\n\tgf_bs_read_int_log(bs, 16, \"vps_reserved_ffff_16bits\");\n\thevc_profile_tier_level(bs, 1, vps->max_sub_layers - 1, &vps->ptl, 0);\n\n\tvps_sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"vps_sub_layer_ordering_info_present_flag\");\n\tfor (i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_dec_pic_buffering_minus1\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_num_reorder_pics\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_latency_increase_plus1\", i);\n\t}\n\tvps->max_layer_id = gf_bs_read_int_log(bs, 6, \"max_layer_id\");\n\tif (vps->max_layer_id > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] VPS max layer ID %u but GPAC only supports %u\\n\", vps->max_layer_id, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->num_layer_sets = gf_bs_read_ue_log(bs, \"num_layer_sets_minus1\") + 1;\n\tif (vps->num_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of layer sets in VPS %d\\n\", vps->num_layer_sets));\n\t\treturn -1;\n\t}\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tfor (j = 0; j <= vps->max_layer_id; j++) {\n\t\t\tlayer_id_included_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"layer_id_included_flag\", i, j);\n\t\t}\n\t}\n\tvps->num_layers_in_id_list[0] = 1;\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tu32 n, m;\n\t\tn = 0;\n\t\tfor (m = 0; m <= vps->max_layer_id; m++) {\n\t\t\tif (layer_id_included_flag[i][m]) {\n\t\t\t\tvps->LayerSetLayerIdList[i][n++] = m;\n\t\t\t\tif (vps->LayerSetLayerIdListMax[i] < m)\n\t\t\t\t\tvps->LayerSetLayerIdListMax[i] = m;\n\t\t\t}\n\t\t}\n\t\tvps->num_layers_in_id_list[i] = n;\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"vps_timing_info_present_flag\")) {\n\t\tu32 vps_num_hrd_parameters;\n\t\tgf_bs_read_int_log(bs, 32, \"vps_num_units_in_tick\");\n\t\tgf_bs_read_int_log(bs, 32, \"vps_time_scale\");\n\t\tif (gf_bs_read_int_log(bs, 1, \"vps_poc_proportional_to_timing_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"vps_num_ticks_poc_diff_one_minus1\");\n\t\t}\n\t\tvps_num_hrd_parameters = gf_bs_read_ue_log(bs, \"vps_num_hrd_parameters\");\n\t\tfor (i = 0; i < vps_num_hrd_parameters; i++) {\n\t\t\tBool cprms_present_flag = GF_TRUE;\n\t\t\tgf_bs_read_ue_log_idx(bs, \"hrd_layer_set_idx\", i);\n\t\t\tif (i > 0)\n\t\t\t\tcprms_present_flag = gf_bs_read_int_log(bs, 1, \"cprms_present_flag\");\n\t\t\thevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1, i);\n\t\t}\n\t}\n\tif (stop_at_vps_ext) {\n\t\treturn vps_id;\n\t}\n\n\tvps_extension_flag = gf_bs_read_int_log(bs, 1, \"vps_extension_flag\");\n\tif (vps_extension_flag) {\n\t\tBool res;\n\t\tgf_bs_align(bs);\n\t\tres = hevc_parse_vps_extension(vps, bs);\n\t\tif (res != GF_TRUE) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Failed to parse VPS extensions\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tif (gf_bs_read_int_log(bs, 1, \"vps_extension2_flag\")) {\n#if 0\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t/*vps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\treturn vps_id;\n}\n\nGF_EXPORT\ns32 gf_hevc_read_vps_ex(u8 *data, u32 *size, HEVCState *hevc, Bool remove_extensions)\n{\n\tGF_BitStream *bs;\n\tchar *data_without_emulation_bytes = NULL;\n\tu32 data_without_emulation_bytes_size = 0;\n\ts32 vps_id = -1;\n\n\t/*still contains emulation bytes*/\n\tdata_without_emulation_bytes_size = remove_extensions ? gf_media_nalu_emulation_bytes_remove_count(data, (*size)) : 0;\n\tif (!data_without_emulation_bytes_size) {\n\t\tbs = gf_bs_new(data, (*size), GF_BITSTREAM_READ);\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\t//when removing VPS ext, we have to get the full buffer without emulation prevention bytes becuase we do a bit-by-bit copy of the vps\n\telse {\n\t\tdata_without_emulation_bytes = gf_malloc((*size) * sizeof(char));\n\t\tdata_without_emulation_bytes_size = gf_media_nalu_remove_emulation_bytes(data, data_without_emulation_bytes, (*size));\n\t\tbs = gf_bs_new(data_without_emulation_bytes, data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\t}\n\tif (!bs) goto exit;\n\n\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, NULL)) goto exit;\n\n\tvps_id = gf_hevc_read_vps_bs_internal(bs, hevc, remove_extensions);\n\tif (vps_id < 0) goto exit;\n\n\tif (remove_extensions) {\n\t\tu8 *new_vps;\n\t\tu32 new_vps_size, emulation_bytes;\n\t\tu32 bit_pos = gf_bs_get_bit_offset(bs);\n\t\tGF_BitStream *w_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_seek(bs, 0);\n\t\tgf_bs_write_u8(w_bs, gf_bs_read_u8(bs) );\n\t\tgf_bs_write_u8(w_bs, gf_bs_read_u8(bs) );\n\t\tgf_bs_write_u8(w_bs, gf_bs_read_u8(bs) );\n\t\tgf_bs_write_u8(w_bs, gf_bs_read_u8(bs) );\n\t\tgf_bs_write_u16(w_bs, gf_bs_read_u16(bs) );\n\t\tbit_pos -= 48;\n\t\twhile (bit_pos) {\n\t\t\tu32 v = gf_bs_read_int(bs, 1);\n\t\t\tgf_bs_write_int(w_bs, v, 1);\n\t\t\tbit_pos--;\n\t\t}\n\t\t/*vps extension flag*/\n\t\tgf_bs_write_int(w_bs, 0, 1);\n\t\tnew_vps = NULL;\n\t\tgf_bs_get_content(w_bs, &new_vps, &new_vps_size);\n\t\tgf_bs_del(w_bs);\n\n\t\temulation_bytes = gf_media_nalu_emulation_bytes_add_count(new_vps, new_vps_size);\n\t\tif (emulation_bytes + new_vps_size > *size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"Buffer too small to rewrite VPS - skipping rewrite\\n\"));\n\t\t}\n\t\telse {\n\t\t\t*size = gf_media_nalu_add_emulation_bytes(new_vps, data, new_vps_size);\n\t\t}\n\t\tif (new_vps)\n\t\t\tgf_free(new_vps);\n\t}\n\nexit:\n\tif (bs)\n\t\tgf_bs_del(bs);\n\tif (data_without_emulation_bytes) gf_free(data_without_emulation_bytes);\n\treturn vps_id;\n}\n\nGF_EXPORT\ns32 gf_hevc_read_vps(u8 *data, u32 size, HEVCState *hevc)\n{\n\treturn gf_hevc_read_vps_ex(data, &size, hevc, GF_FALSE);\n}\n\nGF_EXPORT\ns32 gf_hevc_read_vps_bs(GF_BitStream *bs, HEVCState *hevc)\n{\n\tif (!bs || !hevc) return -1;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, NULL)) return -1;\n\treturn gf_hevc_read_vps_bs_internal(bs, hevc, GF_FALSE);\n}\n\nstatic void hevc_scaling_list_data(GF_BitStream *bs)\n{\n\tu32 i, sizeId, matrixId;\n\tfor (sizeId = 0; sizeId < 4; sizeId++) {\n\t\tfor (matrixId = 0; matrixId < 6; matrixId += (sizeId == 3) ? 3 : 1) {\n\t\t\tu32 idx = sizeId*100 + 10*matrixId;\n\t\t\tu32 scaling_list_pred_mode_flag_sizeId_matrixId = gf_bs_read_int_log_idx(bs, 1, \"scaling_list_pred_mode_flag_sizeId_matrixId\", idx);\n\t\t\tif (!scaling_list_pred_mode_flag_sizeId_matrixId) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"scaling_list_pred_matrix_id_delta\", idx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//u32 nextCoef = 8;\n\t\t\t\tu32 coefNum = MIN(64, (1 << (4 + (sizeId << 1))));\n\t\t\t\tif (sizeId > 1) {\n\t\t\t\t\tgf_bs_read_se_log_idx(bs, \"scaling_list_dc_coef_minus8\", idx);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < coefNum; i++) {\n\t\t\t\t\tgf_bs_read_se_log_idx2(bs, \"scaling_list_delta_coef\", idx, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic const struct {\n\tu32 w, h;\n} hevc_sar[17] =\n{\n\t{ 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 },\n\t{ 16, 11 }, { 40, 33 }, { 24, 11 }, { 20, 11 },\n\t{ 32, 11 }, { 80, 33 }, { 18, 11 }, { 15, 11 },\n\t{ 64, 33 }, { 160,99 }, { 4,3}, { 3,2}, { 2,1}\n};\n\nstatic s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id = -1;\n\tu32 i, nb_CTUs, depth;\n\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"sps_ext_or_max_sub_layers_minus1\");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);\n\tif (!multiLayerExtSpsFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"temporal_id_nesting_flag\");\n\t\thevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);\n\t}\n\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif ((sps_id < 0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\n\tsps = &hevc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->ptl = ptl;\n\tvps = &hevc->vps[vps_id];\n\tsps->max_sub_layers_minus1 = 0;\n\tsps->sps_ext_or_max_sub_layers_minus1 = 0;\n\n\t/* default values */\n\tsps->colour_primaries = 2;\n\tsps->transfer_characteristic = 2;\n\tsps->matrix_coeffs = 2;\n\n\t//sps_rep_format_idx = 0;\n\tif (multiLayerExtSpsFlag) {\n\t\tsps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, \"update_rep_format_flag\");\n\t\tif (sps->update_rep_format_flag) {\n\t\t\tsps->rep_format_idx = gf_bs_read_int_log(bs, 8, \"rep_format_idx\");\n\t\t}\n\t\telse {\n\t\t\tsps->rep_format_idx = vps->rep_format_idx[layer_id];\n\t\t}\n\t\tsps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;\n\t\tsps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;\n\t\tsps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;\n\t\tsps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;\n\t\tsps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;\n\t\tsps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;\n\n\t\t//TODO this is crude ...\n\t\tsps->ptl = vps->ext_ptl[0];\n\t}\n\telse {\n\t\tsps->chroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tif (sps->chroma_format_idc == 3)\n\t\t\tsps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\t\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\t\tif ((sps->cw_flag = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\"))) {\n\t\t\tu32 SubWidthC, SubHeightC;\n\n\t\t\tif (sps->chroma_format_idc == 1) {\n\t\t\t\tSubWidthC = SubHeightC = 2;\n\t\t\t}\n\t\t\telse if (sps->chroma_format_idc == 2) {\n\t\t\t\tSubWidthC = 2;\n\t\t\t\tSubHeightC = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSubWidthC = SubHeightC = 1;\n\t\t\t}\n\n\t\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\n\t\t\tsps->width -= SubWidthC * (sps->cw_left + sps->cw_right);\n\t\t\tsps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);\n\t\t}\n\t\tsps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_luma_minus8\");\n\t\tsps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_chroma_minus8\");\n\t}\n\n\tsps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, \"log2_max_pic_order_cnt_lsb_minus4\");\n\n\tif (!multiLayerExtSpsFlag) {\n\t\tsps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"sub_layer_ordering_info_present_flag\");\n\t\tfor (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"max_dec_pic_buffering\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"max_latency_increase\", i);\n\t\t}\n\t}\n\n\tsps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, \"log2_min_luma_coding_block_size_minus3\");\n\tsps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_luma_coding_block_size\");\n\tsps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\tsps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\n\tsps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, \"log2_min_transform_block_size_minus2\");\n\tsps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, \"log2_max_transform_block_size\");\n\n\tdepth = 0;\n\tsps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_inter\");\n\tsps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_intra\");\n\twhile ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))\n\t{\n\t\tdepth++;\n\t}\n\tsps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;\n\n\tnb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);\n\tsps->bitsSliceSegmentAddress = 0;\n\twhile (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {\n\t\tsps->bitsSliceSegmentAddress++;\n\t}\n\n\tsps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_enable_flag\");\n\tif (sps->scaling_list_enable_flag) {\n\t\tsps->infer_scaling_list_flag = 0;\n\t\tsps->scaling_list_ref_layer_id = 0;\n\t\tif (multiLayerExtSpsFlag) {\n\t\t\tsps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, \"infer_scaling_list_flag\");\n\t\t}\n\t\tif (sps->infer_scaling_list_flag) {\n\t\t\tsps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, \"scaling_list_ref_layer_id\");\n\t\t}\n\t\telse {\n\t\t\tsps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_data_present_flag\");\n\t\t\tif (sps->scaling_list_data_present_flag) {\n\t\t\t\thevc_scaling_list_data(bs);\n\t\t\t}\n\t\t}\n\t}\n\tsps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, \"asymmetric_motion_partitions_enabled_flag\");\n\tsps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, \"sample_adaptive_offset_enabled_flag\");\n\tif ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, \"pcm_enabled_flag\")) ) {\n\t\tsps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_luma_minus1\");\n\t\tsps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_chroma_minus1\");\n\t\tsps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, \"log2_min_pcm_luma_coding_block_size_minus3\");\n\t\tsps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_pcm_luma_coding_block_size\");\n\t\tsps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, \"pcm_loop_filter_disable_flag\");\n\t}\n\tsps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, \"num_short_term_ref_pic_sets\");\n\tif (sps->num_short_term_ref_pic_sets > 64) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid number of short term reference picture sets %d\\n\", sps->num_short_term_ref_pic_sets));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {\n\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);\n\t\t/*cannot parse short_term_ref_pic_set, skip VUI parsing*/\n\t\tif (!ret) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid short_term_ref_pic_set\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, \"long_term_ref_pics_present_flag\");\n\tif (sps->long_term_ref_pics_present_flag) {\n\t\tsps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, \"num_long_term_ref_pic_sps\");\n\t\tfor (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"lt_ref_pic_poc_lsb_sps\", i);\n\t\t\tgf_bs_read_int_log_idx(bs, 1, \"used_by_curr_pic_lt_sps_flag\", i);\n\t\t}\n\t}\n\tsps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, \"temporal_mvp_enable_flag\");\n\tsps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, \"strong_intra_smoothing_enable_flag\");\n\n\tif (vui_flag_pos)\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\n\tif ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\")) ) {\n\t\tsps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->aspect_ratio_info_present_flag) {\n\t\t\tsps->sar_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (sps->sar_idc == 255) {\n\t\t\t\tsps->sar_width = gf_bs_read_int_log(bs, 16, \"aspect_ratio_width\");\n\t\t\t\tsps->sar_height = gf_bs_read_int_log(bs, 16, \"aspect_ratio_height\");\n\t\t\t}\n\t\t\telse if (sps->sar_idc < 17) {\n\t\t\t\tsps->sar_width = hevc_sar[sps->sar_idc].w;\n\t\t\t\tsps->sar_height = hevc_sar[sps->sar_idc].h;\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, \"overscan_info_present\")))\n\t\t\tsps->overscan_appropriate = gf_bs_read_int_log(bs, 1, \"overscan_appropriate\");\n\n\t\tsps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->video_signal_type_present_flag) {\n\t\t\tsps->video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tif ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\"))) {\n\t\t\t\tsps->colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->transfer_characteristic = gf_bs_read_int_log(bs, 8, \"transfer_characteristic\");\n\t\t\t\tsps->matrix_coeffs = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, \"chroma_loc_info_present_flag\"))) {\n\t\t\tsps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_top_field\");\n\t\t\tsps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_bottom_field\");\n\t\t}\n\n\t\tsps->neutra_chroma_indication_flag = gf_bs_read_int_log(bs, 1, \"neutra_chroma_indication_flag\");\n\t\tsps->field_seq_flag = gf_bs_read_int_log(bs, 1, \"field_seq_flag\");\n\t\tsps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, \"frame_field_info_present_flag\");\n\n\t\tif ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, \"default_display_window_flag\"))) {\n\t\t\tsps->left_offset = gf_bs_read_ue_log(bs, \"display_window_left_offset\");\n\t\t\tsps->right_offset = gf_bs_read_ue_log(bs, \"display_window_right_offset\");\n\t\t\tsps->top_offset = gf_bs_read_ue_log(bs, \"display_window_top_offset\");\n\t\t\tsps->bottom_offset = gf_bs_read_ue_log(bs, \"display_window_bottom_offset\");\n\t\t}\n\n\t\tsps->has_timing_info = gf_bs_read_int_log(bs, 1, \"has_timing_info\");\n\t\tif (sps->has_timing_info) {\n\t\t\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, \"poc_proportional_to_timing_flag\");\n\t\t\tif (sps->poc_proportional_to_timing_flag)\n\t\t\t\tsps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, \"num_ticks_poc_diff_one_minus1\");\n\t\t\tif ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"hrd_parameters_present_flag\"))) {\n\t\t\t\t//\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[HEVC] HRD param parsing not implemented\\n\"));\n\t\t\t\treturn sps_id;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"bitstream_restriction_flag\")) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"tiles_fixed_structure_flag\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"motion_vectors_over_pic_boundaries_flag\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"restricted_ref_pic_lists_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"min_spatial_segmentation_idc\");\n\t\t\tgf_bs_read_ue_log(bs, \"max_bytes_per_pic_denom\");\n\t\t\tgf_bs_read_ue_log(bs, \"max_bits_per_min_cu_denom\");\n\t\t\tgf_bs_read_ue_log(bs, \"log2_max_mv_length_horizontal\");\n\t\t\tgf_bs_read_ue_log(bs, \"log2_max_mv_length_vertical\");\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"sps_extension_flag\")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*sps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_hevc_read_sps_ex(char *data, u32 size, HEVCState *hevc, u32 *vui_flag_pos)\n{\n\tGF_BitStream *bs;\n\ts32 sps_id = -1;\n\tu8 layer_id;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tif (!bs) goto exit;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, &layer_id)) goto exit;\n\tsps_id = gf_hevc_read_sps_bs_internal(bs, hevc, layer_id, vui_flag_pos);\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_hevc_read_sps(u8 *data, u32 size, HEVCState *hevc)\n{\n\treturn gf_hevc_read_sps_ex(data, size, hevc, NULL);\n}\n\nGF_EXPORT\ns32 gf_hevc_read_sps_bs(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu8 layer_id;\n\tif (!bs || !hevc) return -1;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, &layer_id)) return -1;\n\treturn gf_hevc_read_sps_bs_internal(bs, hevc, layer_id, NULL);\n}\n\n\nstatic s32 gf_hevc_read_pps_bs_internal(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tHEVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &hevc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif (((s32)pps->sps_id<0) || (pps->sps_id >= 16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\thevc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->dependent_slice_segments_enabled_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segments_enabled_flag\");\n\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->num_extra_slice_header_bits = gf_bs_read_int_log(bs, 3, \"num_extra_slice_header_bits\");\n\tpps->sign_data_hiding_flag = gf_bs_read_int_log(bs, 1, \"sign_data_hiding_flag\");\n\tpps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, \"cabac_init_present_flag\");\n\tpps->num_ref_idx_l0_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active\");\n\tpps->num_ref_idx_l1_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active\");\n\tpps->pic_init_qp_minus26 = gf_bs_read_se_log(bs, \"pic_init_qp_minus26\");\n\tpps->constrained_intra_pred_flag = gf_bs_read_int_log(bs, 1, \"constrained_intra_pred_flag\");\n\tpps->transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"transform_skip_enabled_flag\");\n\tif ((pps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, \"cu_qp_delta_enabled_flag\")))\n\t\tpps->diff_cu_qp_delta_depth = gf_bs_read_ue_log(bs, \"diff_cu_qp_delta_depth\");\n\n\tpps->pic_cb_qp_offset = gf_bs_read_se_log(bs, \"pic_cb_qp_offset\");\n\tpps->pic_cr_qp_offset = gf_bs_read_se_log(bs, \"pic_cr_qp_offset\");\n\tpps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, \"slice_chroma_qp_offsets_present_flag\");\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tpps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, \"weighted_bipred_flag\");\n\tpps->transquant_bypass_enable_flag = gf_bs_read_int_log(bs, 1, \"transquant_bypass_enable_flag\");\n\tpps->tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"tiles_enabled_flag\");\n\tpps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tif (pps->tiles_enabled_flag) {\n\t\tpps->num_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_tile_columns_minus1\");\n\t\tpps->num_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_tile_rows_minus1\");\n\t\tpps->uniform_spacing_flag = gf_bs_read_int_log(bs, 1, \"uniform_spacing_flag\");\n\t\tif (!pps->uniform_spacing_flag) {\n\t\t\tfor (i = 0; i < pps->num_tile_columns - 1; i++) {\n\t\t\t\tpps->column_width[i] = 1 + gf_bs_read_ue_log_idx(bs, \"column_width_minus1\", i);\n\t\t\t}\n\t\t\tfor (i = 0; i < pps->num_tile_rows - 1; i++) {\n\t\t\t\tpps->row_height[i] = 1 + gf_bs_read_ue_log_idx(bs, \"row_height_minus1\", i);\n\t\t\t}\n\t\t}\n\t\tpps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_tiles_enabled_flag\");\n\t}\n\tpps->loop_filter_across_slices_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_slices_enabled_flag\");\n\tif ((pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\"))) {\n\t\tpps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_enabled_flag\");\n\t\tif (! (pps->pic_disable_deblocking_filter_flag = gf_bs_read_int_log(bs, 1, \"pic_disable_deblocking_filter_flag\"))) {\n\t\t\tpps->beta_offset_div2 = gf_bs_read_se_log(bs, \"beta_offset_div2\");\n\t\t\tpps->tc_offset_div2 = gf_bs_read_se_log(bs, \"tc_offset_div2\");\n\t\t}\n\t}\n\tif ((pps->pic_scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"pic_scaling_list_data_present_flag\"))) {\n\t\thevc_scaling_list_data(bs);\n\t}\n\tpps->lists_modification_present_flag = gf_bs_read_int_log(bs, 1, \"lists_modification_present_flag\");\n\tpps->log2_parallel_merge_level_minus2 = gf_bs_read_ue_log(bs, \"log2_parallel_merge_level_minus2\");\n\tpps->slice_segment_header_extension_present_flag = gf_bs_read_int_log(bs, 1, \"slice_segment_header_extension_present_flag\");\n\tif (gf_bs_read_int_log(bs, 1, \"pps_extension_flag\")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*pps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\treturn pps_id;\n}\n\n\nGF_EXPORT\ns32 gf_hevc_read_pps(u8 *data, u32 size, HEVCState *hevc)\n{\n\tGF_BitStream *bs;\n\ts32 pps_id = -1;\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tif (!bs) goto exit;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, NULL)) goto exit;\n\n\tpps_id = gf_hevc_read_pps_bs_internal(bs, hevc);\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\treturn pps_id;\n}\n\nGF_EXPORT\ns32 gf_hevc_read_pps_bs(GF_BitStream *bs, HEVCState *hevc)\n{\n\tif (!bs || !hevc) return -1;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tif (!hevc_parse_nal_header(bs, NULL, NULL, NULL)) return -1;\n\treturn gf_hevc_read_pps_bs_internal(bs, hevc);\n}\n\nGF_EXPORT\ns32 gf_hevc_parse_nalu_bs(GF_BitStream *bs, HEVCState *hevc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tBool is_slice = GF_FALSE;\n\ts32 ret = -1;\n\tHEVCSliceInfo n_state;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tmemcpy(&n_state, &hevc->s_info, sizeof(HEVCSliceInfo));\n\tif (!hevc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) return -1;\n\n\tn_state.nal_unit_type = *nal_unit_type;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\tcase GF_HEVC_NALU_END_OF_SEQ:\n\tcase GF_HEVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\t\t/*slice_segment_layer_rbsp*/\n\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\tcase GF_HEVC_NALU_SLICE_TRAIL_R:\n\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\tcase GF_HEVC_NALU_SLICE_RADL_R:\n\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\tcase GF_HEVC_NALU_SLICE_RASL_R:\n\t\tis_slice = GF_TRUE;\n\t\t/* slice - read the info and compare.*/\n\t\tret = hevc_parse_slice_segment(bs, hevc, &n_state);\n\t\tif (ret < 0) return ret;\n\n\t\thevc_compute_poc(&n_state);\n\n\t\tret = 0;\n\n\t\tif (hevc->s_info.poc != n_state.poc) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (n_state.first_slice_segment_in_pic_flag) {\n\t\t\tif (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1))) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\thevc->last_parsed_sps_id = gf_hevc_read_sps_bs_internal(bs, hevc, *layer_id, NULL);\n\t\tret = (hevc->last_parsed_sps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\thevc->last_parsed_pps_id = gf_hevc_read_pps_bs_internal(bs, hevc);\n\t\tret = (hevc->last_parsed_pps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tcase GF_HEVC_NALU_VID_PARAM:\n\t\thevc->last_parsed_vps_id = gf_hevc_read_vps_bs_internal(bs, hevc, GF_FALSE);\n\t\tret = (hevc->last_parsed_vps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif ((ret>0) && hevc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = hevc->s_info.frame_num_offset;\n\t\tn_state.frame_num_prev = hevc->s_info.frame_num;\n\n\t\tn_state.poc_lsb_prev = hevc->s_info.poc_lsb;\n\t\tn_state.poc_msb_prev = hevc->s_info.poc_msb;\n\t\tif (is_slice)\n\t\t\tn_state.prev_layer_id_plus1 = *layer_id + 1;\n\t}\n\tif (is_slice) hevc_compute_poc(&n_state);\n\tmemcpy(&hevc->s_info, &n_state, sizeof(HEVCSliceInfo));\n\n\treturn ret;\n}\n\nGF_EXPORT\ns32 gf_hevc_parse_nalu(u8 *data, u32 size, HEVCState *hevc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tGF_BitStream *bs = NULL;\n\ts32 ret = -1;\n\n\tif (!hevc) {\n\t\tif (nal_unit_type) (*nal_unit_type) = (data[0] & 0x7E) >> 1;\n\t\tif (layer_id) {\n\t\t\tu8 id = data[0] & 1;\n\t\t\tid <<= 5;\n\t\t\tid |= (data[1] >> 3) & 0x1F;\n\t\t\t(*layer_id) = id;\n\t\t}\n\t\tif (temporal_id) (*temporal_id) = (data[1] & 0x7);\n\t\treturn -1;\n\t}\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tif (!bs) return -1;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tret = gf_hevc_parse_nalu_bs(bs, hevc, nal_unit_type, temporal_id, layer_id);\n\n\tgf_bs_del(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nGF_Err gf_hevc_change_vui(GF_HEVCConfig *hvcc, GF_VUIInfo *vui_info)\n{\n\tGF_BitStream *orig, *mod;\n\tHEVCState hevc;\n\tu32 i, bit_offset, flag;\n\ts32 idx;\n\tGF_NALUFFParamArray *spss;\n\tGF_NALUFFParam *slc;\n\torig = NULL;\n\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\thevc.sps_active_idx = -1;\n\n\ti = 0;\n\tspss = NULL;\n\twhile ((spss = (GF_NALUFFParamArray *)gf_list_enum(hvcc->param_array, &i))) {\n\t\tif (spss->type == GF_HEVC_NALU_SEQ_PARAM)\n\t\t\tbreak;\n\t\tspss = NULL;\n\t}\n\tif (!spss) return GF_NON_COMPLIANT_BITSTREAM;\n\n\ti = 0;\n\twhile ((slc = (GF_NALUFFParam *)gf_list_enum(spss->nalus, &i))) {\n\t\tu8 *no_emulation_buf;\n\t\tu32 no_emulation_buf_size, emulation_bytes;\n\n\t\t/*SPS may still contains emulation bytes*/\n\t\tno_emulation_buf = gf_malloc((slc->size) * sizeof(char));\n\t\tno_emulation_buf_size = gf_media_nalu_remove_emulation_bytes(slc->data, no_emulation_buf, slc->size);\n\n\t\tidx = gf_hevc_read_sps_ex(no_emulation_buf, no_emulation_buf_size, &hevc, &bit_offset);\n\t\tif (idx < 0) {\n\t\t\tif (orig)\n\t\t\t\tgf_bs_del(orig);\n\t\t\tgf_free(no_emulation_buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\torig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);\n\t\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t/*copy over till vui flag*/\n\t\tassert(bit_offset >= 0);\n\t\twhile (bit_offset) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t\tbit_offset--;\n\t\t}\n\n\t\tavc_hevc_rewrite_vui(vui_info, orig, mod);\n\n\t\t/*finally copy over remaining*/\n\t\twhile (gf_bs_bits_available(orig)) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t}\n\t\tgf_bs_del(orig);\n\t\torig = NULL;\n\t\tgf_free(no_emulation_buf);\n\n\t\t/*set anti-emulation*/\n\t\tgf_bs_get_content(mod, &no_emulation_buf, &no_emulation_buf_size);\n\t\temulation_bytes = gf_media_nalu_emulation_bytes_add_count(no_emulation_buf, no_emulation_buf_size);\n\t\tif (no_emulation_buf_size + emulation_bytes > slc->size)\n\t\t\tslc->data = (char*)gf_realloc(slc->data, no_emulation_buf_size + emulation_bytes);\n\n\t\tslc->size = gf_media_nalu_add_emulation_bytes(no_emulation_buf, slc->data, no_emulation_buf_size);\n\n\t\tgf_bs_del(mod);\n\t\tgf_free(no_emulation_buf);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_hevc_change_par(GF_HEVCConfig *hvcc, s32 ar_n, s32 ar_d)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = ar_n;\n\tvuii.ar_den = ar_d;\n\tvuii.fullrange = -1;\n\tvuii.video_format = -1;\n\tvuii.color_prim = -1;\n\tvuii.color_tfc = -1;\n\tvuii.color_matrix = -1;\n\treturn gf_hevc_change_vui(hvcc, &vuii);\n}\n\nGF_EXPORT\nGF_Err gf_hevc_change_color(GF_HEVCConfig *hvcc, s32 fullrange, s32 vidformat, s32 colorprim, s32 transfer, s32 colmatrix)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = -1;\n\tvuii.ar_den = -1;\n\tvuii.fullrange = fullrange;\n\tvuii.video_format = vidformat;\n\tvuii.color_prim = colorprim;\n\tvuii.color_tfc = transfer;\n\tvuii.color_matrix = colmatrix;\n\treturn gf_hevc_change_vui(hvcc, &vuii);\n}\n\n\nGF_EXPORT\nGF_Err gf_hevc_get_sps_info_with_state(HEVCState *hevc, u8 *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\ts32 idx;\n\tidx = gf_hevc_read_sps(sps_data, sps_size, hevc);\n\tif (idx < 0) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (sps_id) *sps_id = idx;\n\n\tif (width) *width = hevc->sps[idx].width;\n\tif (height) *height = hevc->sps[idx].height;\n\tif (par_n) *par_n = hevc->sps[idx].aspect_ratio_info_present_flag ? hevc->sps[idx].sar_width : (u32)-1;\n\tif (par_d) *par_d = hevc->sps[idx].aspect_ratio_info_present_flag ? hevc->sps[idx].sar_height : (u32)-1;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_hevc_get_sps_info(u8 *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\tHEVCState hevc;\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\thevc.sps_active_idx = -1;\n\treturn gf_hevc_get_sps_info_with_state(&hevc, sps_data, sps_size, sps_id, width, height, par_n, par_d);\n}\n\n\n#endif //GPAC_DISABLE_HEVC\n\nstatic u32 AC3_FindSyncCode(u8 *buf, u32 buflen)\n{\n\tu32 end = buflen - 6;\n\tu32 offset = 0;\n\twhile (offset <= end) {\n\t\tif (buf[offset] == 0x0b && buf[offset + 1] == 0x77) {\n\t\t\treturn offset;\n\t\t}\n\t\toffset++;\n\t}\n\treturn buflen;\n}\n\n\nstatic Bool AC3_FindSyncCodeBS(GF_BitStream *bs)\n{\n\tu8 b1;\n\tu64 pos = gf_bs_get_position(bs);\n\tu64 end = gf_bs_get_size(bs);\n\n\tpos += 1;\n\tb1 = gf_bs_read_u8(bs);\n\twhile (pos + 1 <= end) {\n\t\tu8 b2 = gf_bs_read_u8(bs);\n\t\tif ((b1 == 0x0b) && (b2 == 0x77)) {\n\t\t\tgf_bs_seek(bs, pos - 1);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tpos++;\n\t\tb1 = b2;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic const u32 ac3_sizecod_to_bitrate[] = {\n\t32000, 40000, 48000, 56000, 64000, 80000, 96000,\n\t112000, 128000, 160000, 192000, 224000, 256000,\n\t320000, 384000, 448000, 512000, 576000, 640000\n};\n\nstatic const u32 ac3_sizecod2_to_framesize[] = {\n\t96, 120, 144, 168, 192, 240, 288, 336, 384, 480, 576, 672,\n\t768, 960, 1152, 1344, 1536, 1728, 1920\n};\n\nstatic const u32 ac3_sizecod1_to_framesize[] = {\n\t69, 87, 104, 121, 139, 174, 208, 243, 278, 348, 417, 487,\n\t557, 696, 835, 975, 1114, 1253, 1393\n};\nstatic const u32 ac3_sizecod0_to_framesize[] = {\n\t64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 448,\n\t512, 640, 768, 896, 1024, 1152, 1280\n};\n\nstatic const u32 ac3_mod_to_chans[] = {\n\t2, 1, 2, 3, 3, 4, 4, 5\n};\n\nGF_EXPORT\nu32 gf_ac3_get_channels(u32 acmod)\n{\n\tu32 nb_ch;\n\tnb_ch = ac3_mod_to_chans[acmod];\n\treturn nb_ch;\n}\n\nGF_EXPORT\nu32 gf_ac3_get_bitrate(u32 brcode)\n{\n\treturn ac3_sizecod_to_bitrate[brcode];\n}\n\nBool gf_ac3_parser(u8 *buf, u32 buflen, u32 *pos, GF_AC3Config *hdr, Bool full_parse)\n{\n\tGF_BitStream *bs;\n\tBool ret;\n\n\tif (buflen < 6) return GF_FALSE;\n\t(*pos) = AC3_FindSyncCode(buf, buflen);\n\tif (*pos >= buflen) return GF_FALSE;\n\n\tbs = gf_bs_new((const char*)(buf + *pos), buflen, GF_BITSTREAM_READ);\n\tret = gf_ac3_parser_bs(bs, hdr, full_parse);\n\tgf_bs_del(bs);\n\n\treturn ret;\n}\n\nGF_EXPORT\nBool gf_ac3_parser_bs(GF_BitStream *bs, GF_AC3Config *hdr, Bool full_parse)\n{\n\tu32 fscod, frmsizecod, bsid, ac3_mod, freq, framesize, bsmod, syncword;\n\tu64 pos;\n\tif (!hdr || (gf_bs_available(bs) < 6)) return GF_FALSE;\n\tif (!AC3_FindSyncCodeBS(bs)) return GF_FALSE;\n\n\tpos = gf_bs_get_position(bs);\n\n\tsyncword = gf_bs_read_u16(bs);\n\tif (syncword != 0x0B77) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AC3] Wrong sync word detected (0x%X - expecting 0x0B77).\\n\", syncword));\n\t\treturn GF_FALSE;\n\t}\n\tgf_bs_read_int_log(bs, 16, \"crc1\");\n\tfscod = gf_bs_read_int_log(bs, 2, \"fscod\");\n\tfrmsizecod = gf_bs_read_int_log(bs, 6, \"frmsizecod\");\n\tbsid = gf_bs_read_int_log(bs, 5, \"bsid\");\n\tbsmod = gf_bs_read_int_log(bs, 3, \"bsmod\");\n\tac3_mod = gf_bs_read_int_log(bs, 3, \"ac3_mod\");\n\tif (frmsizecod >= 2 * sizeof(ac3_sizecod_to_bitrate) / sizeof(u32))\n\t\treturn GF_FALSE;\n\n\thdr->bitrate = ac3_sizecod_to_bitrate[frmsizecod / 2];\n\tif (bsid > 8) hdr->bitrate = hdr->bitrate >> (bsid - 8);\n\n\tswitch (fscod) {\n\tcase 0:\n\t\tif (frmsizecod >=  2 * sizeof(ac3_sizecod0_to_framesize) / sizeof(u32))\n\t\t\treturn GF_FALSE;\n\t\tfreq = 48000;\n\t\tframesize = ac3_sizecod0_to_framesize[frmsizecod / 2] * 2;\n\t\tbreak;\n\tcase 1:\n\t\tif (frmsizecod >= 2 * sizeof(ac3_sizecod1_to_framesize) / sizeof(u32))\n\t\t\treturn GF_FALSE;\n\t\tfreq = 44100;\n\t\tframesize = (ac3_sizecod1_to_framesize[frmsizecod / 2] + (frmsizecod & 0x1)) * 2;\n\t\tbreak;\n\tcase 2:\n\t\tif (frmsizecod >= 2 * sizeof(ac3_sizecod2_to_framesize) / sizeof(u32))\n\t\t\treturn GF_FALSE;\n\t\tfreq = 32000;\n\t\tframesize = ac3_sizecod2_to_framesize[frmsizecod / 2] * 2;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\thdr->sample_rate = freq;\n\thdr->framesize = framesize;\n\n\tif (full_parse) {\n\t\thdr->streams[0].bsid = bsid;\n\t\thdr->streams[0].bsmod = bsmod;\n\t\thdr->streams[0].acmod = ac3_mod;\n\t\thdr->streams[0].lfon = 0;\n\t\thdr->streams[0].fscod = fscod;\n\t\thdr->brcode = frmsizecod / 2;\n\t}\n\tif (ac3_mod >= 2 * sizeof(ac3_mod_to_chans) / sizeof(u32))\n\t\treturn GF_FALSE;\n\n\thdr->channels = ac3_mod_to_chans[ac3_mod];\n\tif ((ac3_mod & 0x1) && (ac3_mod != 1)) gf_bs_read_int_log(bs, 2, \"cmixlev\");\n\tif (ac3_mod & 0x4) gf_bs_read_int_log(bs, 2, \"surmixlev\");\n\tif (ac3_mod == 0x2) gf_bs_read_int_log(bs, 2, \"dsurmod\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"lfeon\")) {\n\t\thdr->channels += 1;\n\t\thdr->streams[0].lfon = 1;\n\t}\n\n\tgf_bs_seek(bs, pos);\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_eac3_parser_bs(GF_BitStream *bs, GF_AC3Config *hdr, Bool full_parse)\n{\n\tu32 fscod, bsid, ac3_mod, freq, framesize, syncword, substreamid, lfon, channels, numblkscod, strmtyp, frmsiz;\n\tu64 pos;\n\tu16 chanmap;\n\tstatic u32 numblks[4] = {1, 2, 3, 6};\n\n\tif (!hdr || (gf_bs_available(bs) < 6))\n\t\treturn GF_FALSE;\n\tif (!AC3_FindSyncCodeBS(bs))\n\t\treturn GF_FALSE;\n\n\tpos = gf_bs_get_position(bs);\n\tframesize = 0;\n\tnumblkscod = 0;\n\tmemset(hdr, 0, sizeof(GF_AC3Config));\n\nblock:\n\tsyncword = gf_bs_read_u16(bs);\n\tif (syncword != 0x0B77) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[E-AC3] Wrong sync word detected (0x%X - expecting 0x0B77).\\n\", syncword));\n\t\treturn GF_FALSE;\n\t}\n\n\tstrmtyp = gf_bs_read_int_log(bs, 2, \"strmtyp\");\n\tsubstreamid = gf_bs_read_int_log(bs, 3, \"substreamid\");\n\t//next main (independent) AU, done with this frame\n\tif ((strmtyp!=0x1) && ((hdr->substreams >> substreamid) & 0x1)) {\n\t\thdr->framesize = framesize;\n\t\tgf_bs_seek(bs, pos);\n\t\treturn GF_TRUE;\n\t}\n\n\tfrmsiz = gf_bs_read_int_log(bs, 11, \"frmsiz\");\n\tframesize += 2 * (1 + frmsiz);\n\tfscod = gf_bs_read_int_log(bs, 2, \"fscod\");\n\tif (fscod == 0x3) {\n\t\tfscod = gf_bs_read_int_log(bs, 2, \"fscod2\");\n\t\tnumblkscod += 6;\n\t}\n\telse {\n\t\tnumblkscod += gf_bs_read_int_log(bs, 2, \"numblkscod\");\n\t}\n\tassert(numblkscod <= 9);\n\n\n\tif ((hdr->substreams >> substreamid) & 0x1) {\n\t\t//we still have sync frames following\n\t\tif (substreamid) {\n\t\t\tif (gf_bs_seek(bs, pos + framesize) != GF_OK) {\n\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t\tif ((gf_bs_available(bs) < 6) || !AC3_FindSyncCodeBS(bs)) {\n\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t\tgoto block;\n\t\t}\n\t}\n\n\thdr->substreams |= (1 << substreamid);\n\n\tswitch (fscod) {\n\tcase 0:\n\t\tfreq = 48000;\n\t\tbreak;\n\tcase 1:\n\t\tfreq = 44100;\n\t\tbreak;\n\tcase 2:\n\t\tfreq = 32000;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\n\tac3_mod = gf_bs_read_int_log(bs, 3, \"ac3_mod\");\n\tlfon = gf_bs_read_int_log(bs, 1, \"lfon\");\n\tbsid = gf_bs_read_int_log(bs, 5, \"bsid\");\n\tif (!substreamid && (bsid != 16/*E-AC3*/))\n\t\treturn GF_FALSE;\n\tgf_bs_read_int_log(bs, 5, \"dialnorm\");\n\tif (gf_bs_read_int_log(bs, 1, \"compre\")) {\n\t\tgf_bs_read_int_log(bs, 8, \"compr\");\n\t}\n\tif (ac3_mod==0) {\n\t\tgf_bs_read_int_log(bs, 5, \"dialnorm2\");\n\t\tif (gf_bs_read_int_log(bs, 1, \"compr2e\")) {\n\t\t\tgf_bs_read_int_log(bs, 8, \"compr2\");\n\t\t}\n\t}\n\tchanmap = 0;\n\tif (strmtyp==0x1) {\n\t\tif (gf_bs_read_int_log(bs, 1, \"chanmape\")) {\n\t\t\tchanmap = gf_bs_read_int_log(bs, 16, \"chanmap\");\n\t\t}\n\t}\n\n\tchannels = ac3_mod_to_chans[ac3_mod];\n\tif (lfon)\n\t\tchannels += 1;\n\n\thdr->bitrate = 0;\n\thdr->sample_rate = freq;\n\thdr->framesize = framesize;\n\tif (strmtyp != 1) {\n\t\thdr->channels = channels;\n\t\thdr->streams[substreamid].lfon = lfon;\n\t\tif (full_parse) {\n\t\t\thdr->streams[substreamid].bsid = bsid;\n\t\t\thdr->streams[substreamid].bsmod = 0;\n\t\t\thdr->streams[substreamid].acmod = ac3_mod;\n\t\t\thdr->streams[substreamid].fscod = fscod;\n\t\t\thdr->brcode = 0;\n\t\t}\n\t\thdr->nb_streams++;\n\t\t//not clear if this is only for the independent streams\n\t\thdr->brcode += ((frmsiz+1) * freq) / (numblks[numblkscod]*16) / 1000;\n\n\t\tif (lfon)\n\t\t\thdr->channels += 1;\n\n\t} else {\n\t\thdr->streams[substreamid].nb_dep_sub = substreamid;\n\t\thdr->streams[substreamid].chan_loc |= chanmap;\n\t}\n\n\tif (numblkscod < 6) { //we need 6 blocks to make a sample\n\t\tif (gf_bs_seek(bs, pos + framesize) != GF_OK) {\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\treturn GF_FALSE;\n\t\t}\n\n\t\tif ((gf_bs_available(bs) < 6) || !AC3_FindSyncCodeBS(bs))\n\t\t\treturn GF_FALSE;\n\t\tgoto block;\n\t}\n\n\tgf_bs_seek(bs, pos);\n\n\treturn GF_TRUE;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\nu32 gf_id3_read_size(GF_BitStream *bs)\n{\n\tu32 size = 0;\n\tgf_bs_read_int(bs, 1);\n\tsize |= gf_bs_read_int(bs, 7);\n\tsize<<=7;\n\tgf_bs_read_int(bs, 1);\n\tsize |= gf_bs_read_int(bs, 7);\n\tsize<<=7;\n\tgf_bs_read_int(bs, 1);\n\tsize |= gf_bs_read_int(bs, 7);\n\tsize<<=7;\n\tgf_bs_read_int(bs, 1);\n\tsize |= gf_bs_read_int(bs, 7);\n\treturn size;\n}\n\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined (GPAC_DISABLE_OGG)\n\n/*\n\tVorbis parser\n*/\n\nstatic u32 vorbis_book_maptype1_quantvals(u32 entries, u32 dim)\n{\n\tu32 vals = (u32)floor(pow(entries, 1.0 / dim));\n\twhile (1) {\n\t\tu32 acc = 1;\n\t\tu32 acc1 = 1;\n\t\tu32 i;\n\t\tfor (i = 0; i < dim; i++) {\n\t\t\tacc *= vals;\n\t\t\tacc1 *= vals + 1;\n\t\t}\n\t\tif (acc <= entries && acc1 > entries) return (vals);\n\t\telse {\n\t\t\tif (acc > entries) vals--;\n\t\t\telse vals++;\n\t\t}\n\t}\n}\n\nstatic u32 ilog(u32 v, Bool dec)\n{\n\tu32 ret = 0;\n\tif (dec && v) --v;\n\twhile (v) {\n\t\tret++;\n\t\tv >>= 1;\n\t}\n\treturn (ret);\n}\n\nstatic u32 icount(u32 v)\n{\n\tu32 ret = 0;\n\twhile (v) {\n\t\tret += v & 1;\n\t\tv >>= 1;\n\t}\n\treturn(ret);\n}\n\n\nGF_EXPORT\nBool gf_vorbis_parse_header(GF_VorbisParser *vp, u8 *data, u32 data_len)\n{\n\tu32 pack_type, i, j, k, times, nb_part, nb_books, nb_modes;\n\tu32 l;\n\tchar szNAME[8];\n\toggpack_buffer opb;\n\n\toggpack_readinit(&opb, (u8*)data, data_len);\n\tpack_type = oggpack_read(&opb, 8);\n\ti = 0;\n\twhile (i < 6) {\n\t\tszNAME[i] = oggpack_read(&opb, 8);\n\t\ti++;\n\t}\n\tszNAME[i] = 0;\n\tif (strcmp(szNAME, \"vorbis\")) {\n\t\treturn GF_FALSE;\n\t}\n\n\tswitch (pack_type) {\n\tcase 0x01:\n\t\tvp->version = oggpack_read(&opb, 32);\n\t\tif (vp->version != 0) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tvp->channels = oggpack_read(&opb, 8);\n\t\tvp->sample_rate = oggpack_read(&opb, 32);\n\t\tvp->max_r = oggpack_read(&opb, 32);\n\t\tvp->avg_r = oggpack_read(&opb, 32);\n\t\tvp->low_r = oggpack_read(&opb, 32);\n\n\t\tvp->min_block = 1<<oggpack_read(&opb, 4);\n\t\tvp->max_block = 1<<oggpack_read(&opb, 4);\n\t\tif (vp->sample_rate < 1 || vp->channels < 1 || vp->min_block < 8 || vp->max_block < vp->min_block\n\t\t    || oggpack_read(&opb, 1) != 1) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tvp->nb_init=1;\n\t\treturn GF_TRUE;\n\n\tcase 0x03:\n\t\t/*trash comments*/\n\t\tvp->nb_init++;\n\t\treturn GF_TRUE;\n\tcase 0x05:\n\t\t/*need at least bitstream header to make sure we're parsing the right thing*/\n\t\tif (!vp->nb_init) return GF_FALSE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\t/*OK parse codebook*/\n\tnb_books = oggpack_read(&opb, 8) + 1;\n\t/*skip vorbis static books*/\n\tfor (i = 0; i < nb_books; i++) {\n\t\tu32 map_type, qb, qq;\n\t\tu32 entries, dim;\n\t\toggpack_read(&opb, 24);\n\t\tdim = oggpack_read(&opb, 16);\n\t\tentries = oggpack_read(&opb, 24);\n\t\tif ((s32)entries < 0) entries = 0;\n\t\tif (oggpack_read(&opb, 1) == 0) {\n\t\t\tif (oggpack_read(&opb, 1)) {\n\t\t\t\tfor (j = 0; j < entries; j++) {\n\t\t\t\t\tif (oggpack_read(&opb, 1)) {\n\t\t\t\t\t\toggpack_read(&opb, 5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < entries; j++)\n\t\t\t\t\toggpack_read(&opb, 5);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\toggpack_read(&opb, 5);\n\t\t\tfor (j = 0; j < entries;) {\n\t\t\t\tu32 num = oggpack_read(&opb, ilog(entries - j, GF_FALSE));\n\t\t\t\tfor (k = 0; k < num && j < entries; k++, j++) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch ((map_type = oggpack_read(&opb, 4))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\toggpack_read(&opb, 32);\n\t\t\toggpack_read(&opb, 32);\n\t\t\tqq = oggpack_read(&opb, 4) + 1;\n\t\t\toggpack_read(&opb, 1);\n\t\t\tif (map_type == 1) qb = vorbis_book_maptype1_quantvals(entries, dim);\n\t\t\telse if (map_type == 2) qb = entries * dim;\n\t\t\telse qb = 0;\n\t\t\tfor (j = 0; j < qb; j++) oggpack_read(&opb, qq);\n\t\t\tbreak;\n\t\t}\n\t}\n\ttimes = oggpack_read(&opb, 6) + 1;\n\tfor (i = 0; i < times; i++) oggpack_read(&opb, 16);\n\ttimes = oggpack_read(&opb, 6) + 1;\n\tfor (i = 0; i < times; i++) {\n\t\tu32 type = oggpack_read(&opb, 16);\n\t\tif (type) {\n\t\t\tu32 *parts, *class_dims, count, rangebits;\n\t\t\tu32 max_class = 0;\n\t\t\tnb_part = oggpack_read(&opb, 5);\n\t\t\tparts = (u32*)gf_malloc(sizeof(u32) * nb_part);\n\t\t\tfor (j = 0; j < nb_part; j++) {\n\t\t\t\tparts[j] = oggpack_read(&opb, 4);\n\t\t\t\tif (max_class < parts[j]) max_class = parts[j];\n\t\t\t}\n\t\t\tclass_dims = (u32*)gf_malloc(sizeof(u32) * (max_class + 1));\n\t\t\tfor (j = 0; j < max_class + 1; j++) {\n\t\t\t\tu32 class_sub;\n\t\t\t\tclass_dims[j] = oggpack_read(&opb, 3) + 1;\n\t\t\t\tclass_sub = oggpack_read(&opb, 2);\n\t\t\t\tif (class_sub) oggpack_read(&opb, 8);\n\t\t\t\tfor (k = 0; k < (u32)(1 << class_sub); k++) oggpack_read(&opb, 8);\n\t\t\t}\n\t\t\toggpack_read(&opb, 2);\n\t\t\trangebits = oggpack_read(&opb, 4);\n\t\t\tcount = 0;\n\t\t\tfor (j = 0, k = 0; j < nb_part; j++) {\n\t\t\t\tcount += class_dims[parts[j]];\n\t\t\t\tfor (; k < count; k++) oggpack_read(&opb, rangebits);\n\t\t\t}\n\t\t\tgf_free(parts);\n\t\t\tgf_free(class_dims);\n\t\t}\n\t\telse {\n\t\t\toggpack_read(&opb, 8 + 16 + 16 + 6 + 8);\n\t\t\tnb_books = oggpack_read(&opb, 4) + 1;\n\t\t\tfor (j = 0; j < nb_books; j++)\n\t\t\t\toggpack_read(&opb, 8);\n\t\t}\n\t}\n\ttimes = oggpack_read(&opb, 6) + 1;\n\tfor (i = 0; i < times; i++) {\n\t\tu32 acc = 0;\n\t\toggpack_read(&opb, 16);/*type*/\n\t\toggpack_read(&opb, 24);\n\t\toggpack_read(&opb, 24);\n\t\toggpack_read(&opb, 24);\n\t\tnb_part = oggpack_read(&opb, 6) + 1;\n\t\toggpack_read(&opb, 8);\n\t\tfor (j = 0; j < nb_part; j++) {\n\t\t\tu32 cascade = oggpack_read(&opb, 3);\n\t\t\tif (oggpack_read(&opb, 1)) cascade |= (oggpack_read(&opb, 5) << 3);\n\t\t\tacc += icount(cascade);\n\t\t}\n\t\tfor (j = 0; j < acc; j++) oggpack_read(&opb, 8);\n\t}\n\ttimes = oggpack_read(&opb, 6) + 1;\n\tfor (i = 0; i < times; i++) {\n\t\tu32 sub_maps = 1;\n\t\toggpack_read(&opb, 16);\n\t\tif (oggpack_read(&opb, 1)) sub_maps = oggpack_read(&opb, 4) + 1;\n\t\tif (oggpack_read(&opb, 1)) {\n\t\t\tu32 nb_steps = oggpack_read(&opb, 8) + 1;\n\t\t\tfor (j = 0; j < nb_steps; j++) {\n\t\t\t\toggpack_read(&opb, ilog(vp->channels, GF_TRUE));\n\t\t\t\toggpack_read(&opb, ilog(vp->channels, GF_TRUE));\n\t\t\t}\n\t\t}\n\t\toggpack_read(&opb, 2);\n\t\tif (sub_maps>1) {\n\t\t\tfor(l=0; l<vp->channels; l++)\n\t\t\t\toggpack_read(&opb, 4);\n\t\t}\n\t\tfor (j = 0; j < sub_maps; j++) {\n\t\t\toggpack_read(&opb, 8);\n\t\t\toggpack_read(&opb, 8);\n\t\t\toggpack_read(&opb, 8);\n\t\t}\n\t}\n\tnb_modes = oggpack_read(&opb, 6) + 1;\n\tfor (i = 0; i < nb_modes; i++) {\n\t\tvp->mode_flag[i] = oggpack_read(&opb, 1);\n\t\toggpack_read(&opb, 16);\n\t\toggpack_read(&opb, 16);\n\t\toggpack_read(&opb, 8);\n\t}\n\n\tvp->modebits = 0;\n\tj = nb_modes;\n\twhile (j > 1) {\n\t\tvp->modebits++;\n\t\tj >>= 1;\n\t}\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nu32 gf_vorbis_check_frame(GF_VorbisParser *vp, u8 *data, u32 data_length)\n{\n\ts32 block_size;\n\toggpack_buffer opb;\n\tif (!vp) return 0;\n\toggpack_readinit(&opb, (unsigned char*)data, data_length);\n\t/*not audio*/\n\tif (oggpack_read(&opb, 1) != 0) return 0;\n\tblock_size = oggpack_read(&opb, vp->modebits);\n\tif (block_size == -1) return 0;\n\treturn ((vp->mode_flag[block_size]) ? vp->max_block : vp->min_block) / (2);\n}\n\n/*call with vorbis header packets - initializes the parser on success, leave it to NULL otherwise\nreturns 1 if success, 0 if error.*/\nBool gf_opus_parse_header(GF_OpusParser *opus, u8 *data, u32 data_len)\n{\n\tchar tag[9];\n\tGF_BitStream *bs = gf_bs_new(data, data_len, GF_BITSTREAM_READ);\n\tgf_bs_read_data(bs, tag, 8);\n\ttag[8]=0;\n\n\tif (memcmp(data, \"OpusHead\", sizeof(char)*8)) {\n\t\tgf_bs_del(bs);\n\t\treturn GF_FALSE;\n\t}\n\t/*Identification Header*/\n\topus->version = gf_bs_read_u8(bs); /*version*/\n\tif (opus->version != 1) {\n\t\tgf_bs_del(bs);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Opus] Unsupported version %d\\n\", opus->version));\n\t\treturn GF_FALSE;\n\t}\n\topus->OutputChannelCount = gf_bs_read_u8(bs);\n\topus->PreSkip = gf_bs_read_u16_le(bs);\n\topus->InputSampleRate = gf_bs_read_u32_le(bs);\n\topus->OutputGain = gf_bs_read_u16_le(bs);\n\topus->ChannelMappingFamily = gf_bs_read_u8(bs);\n\tif (opus->ChannelMappingFamily != 0) {\n\t\topus->StreamCount = gf_bs_read_u8(bs);\n\t\topus->CoupledCount = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) opus->ChannelMapping, opus->OutputChannelCount);\n\t}\n\tgf_bs_del(bs);\n\treturn GF_TRUE;\n}\n\n/*returns 0 if init error or not a vorbis frame, otherwise returns the number of audio samples\nin this frame*/\nu32 gf_opus_check_frame(GF_OpusParser *op, u8 *data, u32 data_length)\n{\n\tu32 block_size;\n\n\tif (!memcmp(data, \"OpusHead\", sizeof(char)*8))\n\t\treturn 0;\n\tif (!memcmp(data, \"OpusTags\", sizeof(char)*8))\n\t\treturn 0;\n\n\t/*consider the whole packet as Ogg packets and ISOBMFF samples for Opus are framed similarly*/\n\tstatic const int OpusFrameDurIn48k[] = { 480, 960, 1920, 2880, 480, 960, 1920, 2880, 480, 960, 1920, 2880,\n\t\t480, 960, 480, 960,\n\t\t120, 240, 480, 960, 120, 240, 480, 960, 120, 240, 480, 960, 120, 240, 480, 960,\n\t};\n\tint TOC_config = (data[0] & 0xf8) >> 3;\n\t//int s = (data[0] & 0x04) >> 2;\n\tblock_size = OpusFrameDurIn48k[TOC_config];\n\n\tint c = data[0] & 0x03;\n\tif (c == 1 || c == 2) {\n\t\tblock_size *= 2;\n\t} else if (c == 3) {\n\t\t/*unknown number of frames*/\n\t\tint num_frames = data[1] & 0x3f;\n\t\tblock_size *= num_frames;\n\t}\n\treturn block_size;\n}\n\n#endif /*!defined(GPAC_DISABLE_AV_PARSERS) && !defined (GPAC_DISABLE_OGG)*/\n\nu64 gf_mpegh_escaped_value(GF_BitStream *bs, u32 nBits1, u32 nBits2, u32 nBits3)\n{\n\tu64 value = gf_bs_read_int(bs, nBits1);\n\tif (value == (1<<nBits1)-1) {\n\t\tu32 vadd = gf_bs_read_int(bs, nBits2);\n\t\tvalue += vadd;\n\t\tif (vadd == (1<<nBits2)-1) {\n\t\t\tvadd = gf_bs_read_int(bs, nBits3);\n\t\t\tvalue += vadd;\n\t\t}\n\t}\n\treturn value;\n}\n\nGF_EXPORT\ns32 gf_mpegh_get_mhas_pl(u8 *ptr, u32 size, u64 *ch_layout)\n{\n\ts32 PL = -1;\n\tGF_BitStream *bs;\n\tu32 i;\n\ts32 sync_pos=-1;\n\n\tif (!ptr || !size) return 0;\n\t\n\tfor (i=0; i<size-3; i++) {\n\t\tif ((ptr[i]==0xC0) && (ptr[i+1]== 0x01) && (ptr[i+2]==0xA5)) {\n\t\t\tsync_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (sync_pos<0) return 0;\n\tif (ch_layout) *ch_layout = 0;\n\tbs = gf_bs_new(ptr, size, GF_BITSTREAM_READ);\n\tgf_bs_skip_bytes(bs, sync_pos);\n\n\twhile (gf_bs_available(bs)) {\n\t\tu32 type = (u32) gf_mpegh_escaped_value(bs, 3, 8, 8);\n\t\t/*u64 label = */gf_mpegh_escaped_value(bs, 2, 8, 32);\n\t\tu64 mh_size = gf_mpegh_escaped_value(bs, 11, 24, 24);\n\t\tif (mh_size > gf_bs_available(bs))\n\t\t\tbreak;\n\t\t//MHAS config\n\t\tif (type==1) {\n\t\t\tPL = gf_bs_read_int(bs, 8);\n\t\t\tif (ch_layout) {\n\t\t\t\tu32 idx = gf_bs_read_int(bs, 5);\n\t\t\t\tif (idx==0x1f)\n\t\t\t\t\tgf_bs_read_int(bs, 24);\n\t\t\t\t/*idx = */gf_bs_read_int(bs, 3);\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t\tgf_bs_read_int(bs, 1);\n\n\t\t\t\t//speaker config\n\t\t\t\tidx = gf_bs_read_int(bs, 2);\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\t*ch_layout = gf_audio_fmt_get_layout_from_cicp( gf_bs_read_int(bs, 6) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgf_bs_skip_bytes(bs, mh_size);\n\t}\n\tgf_bs_del(bs);\n\treturn PL;\n}\n\n\nGF_EXPORT\nvoid gf_media_vvc_parse_sei(char *buffer, u32 nal_size, VVCState *vvc)\n{\n\tgf_hevc_vvc_parse_sei(buffer, nal_size, NULL, vvc);\n}\n\nstatic Bool vvc_parse_nal_header(GF_BitStream *bs, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tu32 val;\n\tval = gf_bs_read_int_log(bs, 1, \"forbidden_zero\");\n\tif (val) return GF_FALSE;\n\tval = gf_bs_read_int_log(bs, 1, \"resevred0\");\n\tif (val) return GF_FALSE;\n\n\tval = gf_bs_read_int_log(bs, 6, \"layerID\");\n\tif (layer_id) *layer_id = val;\n\n\tval = gf_bs_read_int_log(bs, 5, \"nuh_type\");\n\tif (nal_unit_type) *nal_unit_type = val;\n\n\tval = gf_bs_read_int_log(bs, 3, \"temporalID\");\n\tif (!val) return GF_FALSE;\n\tval -= 1;\n\tif (temporal_id) *temporal_id = val;\n\treturn GF_TRUE;\n}\n\nstatic void vvc_profile_tier_level(GF_BitStream *bs, VVC_ProfileTierLevel *ptl, u32 idx)\n{\n\tu32 i;\n\tif (ptl->pt_present) {\n\t\tptl->general_profile_idc = gf_bs_read_int_log_idx(bs, 7, \"general_profile_idc\", idx);\n\t\tptl->general_tier_flag = gf_bs_read_int_log_idx(bs, 1, \"general_tier_flag\", idx);\n\t}\n\tptl->general_level_idc = gf_bs_read_int_log_idx(bs, 8, \"general_level_idc\", idx);\n\tptl->frame_only_constraint = gf_bs_read_int_log_idx(bs, 1, \"frame_only_constraint\", idx);\n\tptl->multilayer_enabled = gf_bs_read_int_log_idx(bs, 1, \"multilayer_enabled\", idx);\n\t//general constraints info - max size if 1 + 81 + 8 + 255\n\tif (ptl->pt_present) {\n\t\t//\t\tgeneral_constraints_info\n\t\tptl->gci_present = gf_bs_read_int_log_idx(bs, 1, \"gci_present\", idx);\n\t\tif (ptl->gci_present) {\n\t\t\tu8 res;\n\t\t\tptl->gci[0] = 0x80;\n\t\t\tptl->gci[0] |= gf_bs_read_int(bs, 7);\n\t\t\t//81-7 = 74 bits till reserved\n\t\t\tgf_bs_read_data(bs, ptl->gci+1, 9);\n\t\t\tptl->gci[10] = gf_bs_read_int(bs, 2)<<6;\n\t\t\t//skip extensions\n\t\t\tptl->gci[11] = 0;\n\t\t\tres = gf_bs_read_int(bs, 8);\n\t\t\tgf_bs_read_int(bs, res);\n\t\t}\n\t\tgf_bs_align(bs);\n\t}\n\tfor (i=ptl->ptl_max_tid; i>0; i--) {\n\t\tptl->sub_ptl[i-1].level_present_flag = gf_bs_read_int_log_idx2(bs, 1, \"level_present_flag\", idx, i);\n\t}\n\tgf_bs_align(bs);\n\tfor (i=ptl->ptl_max_tid; i>0; i--) {\n\t\tif (ptl->sub_ptl[i-1].level_present_flag)\n\t\t\tptl->sub_ptl[i-1].sublayer_level_idc = gf_bs_read_int_log_idx2(bs, 8, \"sublayer_level_idc\", idx, i);\n\t}\n\tif (ptl->pt_present) {\n\t\tptl->num_sub_profiles = gf_bs_read_int_log_idx(bs, 8, \"num_sub_profiles\", idx);\n\t\tfor (i=0; i<ptl->num_sub_profiles; i++) {\n\t\t\tptl->sub_profile_idc[i] = gf_bs_read_int_log_idx2(bs, 32, \"sub_profile_idc\", idx, i);\n\t\t}\n\t}\n}\n\nstatic s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)\n{\n\tu32 i, j;\n\ts32 vps_id;\n\tVVC_VPS *vps;\n\tBool vps_default_ptl_dpb_hrd_max_tid_flag=0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) return -1;\n\tif (!vps_id) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] VPS ID 0 is forbidden\\n\"));\n\t\treturn -1;\n\t}\n\tvps = &vvc->vps[vps_id];\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\n\tif ((vps->max_layers>1) && (vps->max_sub_layers>1))\n\t\tvps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, \"vps_default_ptl_dpb_hrd_max_tid_flag\");\n\n\tif (vps->max_layers>1)\n\t\tvps->all_layers_independent = gf_bs_read_int_log(bs, 1, \"all_layers_independent\");\n\n\tfor (i=0; i<vps->max_layers; i++) {\n\t\tu32 layer_id = gf_bs_read_int_log_idx(bs, 6, \"layer_id\", i);\n\t\tif (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;\n\t\tif (i && !vps->all_layers_independent) {\n\t\t\tBool layer_indep = gf_bs_read_int_log_idx(bs, 1, \"layer_independent\", i);\n\t\t\tif (!layer_indep) {\n\t\t\t\tBool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_max_tid_ref_present_flag\", i);\n\t\t\t\tfor (j=0; j<i; j++) {\n\t\t\t\t\tBool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, \"vps_direct_ref_layer_flag\", i, j);\n\t\t\t\t\tif (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"vps_max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvps->num_ptl = 1;\n\tif (vps->max_layers > 1) {\n\t\tif (vps->all_layers_independent) {\n\t\t\tvps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, \"each_layer_is_ols\");\n\t\t}\n\t\tif (!vps->each_layer_is_ols) {\n\t\t\tu32 vps_ols_mode_idc = 2;\n\t\t\tif (!vps->all_layers_independent) {\n\t\t\t\tvps_ols_mode_idc = gf_bs_read_int_log(bs, 2, \"vps_ols_mode_idc\");\n\t\t\t}\n\t\t\tif (vps_ols_mode_idc==2) {\n\t\t\t\tu8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, \"vps_num_output_layer_sets_minus2\");\n\t\t\t\tfor (i=0; i<vps_num_output_layer_sets; i++) {\n\t\t\t\t\tfor (j=0; j<vps->max_layers; j++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"vps_ols_output_layer_flag\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, \"num_ptl_minus1\");\n\t}\n\tvps->ptl[0].pt_present = 1;\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tif (i)\n\t\t\tvps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, \"pt_present\", i);\n\t\tif (!vps_default_ptl_dpb_hrd_max_tid_flag)\n\t\t\tvps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, \"ptl_max_tid\", i);\n\t\telse\n\t\t\tvps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;\n\t}\n\t//align\n\tgf_bs_align(bs);\n\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tvvc_profile_tier_level(bs, &vps->ptl[i], i);\n\t}\n\n\t//TODO, parse multilayer stuff\n\treturn vps_id;\n}\n\n\nstatic s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif ((sps_id<0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, \"max_sublayers_minus1\");\n\tsps->chroma_format_idc = gf_bs_read_int_log(bs, 2, \"chroma_format_idc\");\n\tsps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, \"log2_ctu_size_minus5\");\n\tCtbSizeY = 1<<sps->log2_ctu_size;\n\n\tsps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"sps_ptl_dpb_hrd_params_present_flag\");\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tVVC_ProfileTierLevel ptl, *p_ptl;\n\t\tif (sps->vps_id) {\n\t\t\tp_ptl = &ptl;\n\t\t} else {\n\t\t\tp_ptl = &vvc->vps[0].ptl[0];\n\t\t}\n\t\tmemset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));\n\t\tp_ptl->pt_present = 1;\n\t\tp_ptl->ptl_max_tid = sps->max_sublayers-1;\n\t\tvvc_profile_tier_level(bs, p_ptl, 0);\n\t}\n\tsps->gdr_enabled = gf_bs_read_int_log(bs, 1, \"gdr_enabled\");\n\tsps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, \"ref_pic_resampling\");\n\tif (sps->ref_pic_resampling)\n\t\tsps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, \"res_change_in_clvs\");\n\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\tsps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_present_flag\");\n\tif (sps->conf_window) {\n\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\t}\n\tsps->subpic_info_present = gf_bs_read_int_log(bs, 1, \"subpic_info_present\");\n\tif (sps->subpic_info_present) {\n\t\tsps->nb_subpics = 1 + gf_bs_read_ue_log(bs, \"nb_subpics_minus1\");\n\t\tif (sps->nb_subpics>1) {\n\t\t\tu32 tmpWidthVal, tmpHeightVal;\n\t\t\tsps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, \"independent_subpic_flags\");\n\t\t\tsps->subpic_same_size = gf_bs_read_int_log(bs, 1, \"subpic_same_size\");\n\n\t\t\ttmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpWidthVal = gf_get_bit_size(tmpWidthVal);\n\t\t\ttmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpHeightVal = gf_get_bit_size(tmpHeightVal);\n\n\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\tif( !sps->subpic_same_size || !i) {\n\t\t\t\t\tif (i && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_ctu_top_left_x\");\n\t\t\t\t\tif (i && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_ctu_top_left_y\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_width_minus1\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_height_minus1\");\n\t\t\t\t}\n\t\t\t\tif (!sps->independent_subpic_flags) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"subpic_treated_as_pic_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"loop_filter_across_subpic_enabled_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsps->subpicid_len = gf_bs_read_ue_log(bs, \"subpic_id_len_minus1\") + 1;\n\t\t\tsps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_explicitly_signalled_flag\");\n\t\t\tif (sps->subpicid_mapping_explicit) {\n\t\t\t\tsps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\t\t\t\tif (sps->subpicid_mapping_present) {\n\t\t\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\t\t\tgf_bs_read_ue_log(bs, \"subpic_id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsps->bitdepth = gf_bs_read_ue_log(bs, \"bitdepth_minus8\") + 8;\n\tgf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tgf_bs_read_int_log(bs, 1, \"entry_point_offsets_present_flag\");\n\tsps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, \"log2_max_poc_lsb_minus4\");\n\tif ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_flag\")))\n\t\tsps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, \"poc_msb_cycle_len_minus1\");\n\n\tu8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, \"sps_num_extra_ph_bytes\");\n\tfor (i=0; i<sps_num_extra_ph_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_ph_bit_present_flag\", 1))\n\t\t\tsps->ph_num_extra_bits++;\n\t}\n\tu8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, \"num_extra_sh_bytes\");\n\tfor (i=0; i<sps_num_extra_sh_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_sh_bit_present_flag\", i))\n\t\t\tsps->sh_num_extra_bits++;\n\t}\n\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tu8 sps_sublayer_dpb_params_flag = 0;\n\t\tif (sps->max_sublayers>1) {\n\t\t\tsps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, \"sps_sublayer_dpb_params_flag\");\n\t\t}\n\t\tfor (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_dec_pic_buffering_minus1\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_latency_increase_plus1\", i);\n\t\t}\n\t}\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tgf_bs_read_int_log(bs, 1, \"sps_partition_constraints_override_enabled_flag\");\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tu8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_luma\");\n\tif (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_luma\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_luma\");\n\t}\n\tu8 sps_qtbtt_dual_tree_intra_flag = 0;\n\tif (sps->chroma_format_idc) {\n\t\tsps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, \"sps_qtbtt_dual_tree_intra_flag\");\n\t}\n\tif (sps_qtbtt_dual_tree_intra_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_intra_slice_chroma\");\n\t\tu8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_chroma\");\n\t\tif( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_chroma\");\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_chroma\");\n\t\t}\n\t}\n\n\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_inter_slice\");\n\tu8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_inter_slice\");\n\tif (sps_max_mtt_hierarchy_depth_inter_slice != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_inter_slice\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_inter_slice\");\n\t}\n\t//u8 sps_max_luma_transform_size_64_flag = 0;\n\tif (CtbSizeY > 32) {\n\t\t/*sps_max_luma_transform_size_64_flag = */gf_bs_read_int_log(bs, 1, \"sps_max_luma_transform_size_64_flag\");\n\t}\n\tu8 sps_transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_transform_skip_enabled_flag\");\n\n\tif (sps_transform_skip_enabled_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_transform_skip_max_size_minus2\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_bdpcm_enabled_flag\");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"sps_mts_enabled_flag\")) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_intra_enabled_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_inter_enabled_flag\");\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_lfnst_enabled_flag\");\n\tif (sps->chroma_format_idc) {\n\t\tu8 sps_joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_joint_cbcr_enabled_flag\");\n\t\tu8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, \"sps_same_qp_table_for_chroma_flag\");\n\t\tu32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps_joint_cbcr_enabled_flag ? 3 : 2);\n\t\tfor (i=0; i<numQpTables; i++) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"sps_qp_table_start_minus26\", i);\n\t\t\tu32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, \"sps_num_points_in_qp_table_minus1\", i);\n\t\t\tfor (j=0; j<sps_num_points_in_qp_table; j++) {\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_in_val_minus1\", i, j);\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_diff_val\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_sao_enabled_flag\");\n\tsps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_alf_enabled_flag\");\n\tif (sps->alf_enabled_flag && sps->chroma_format_idc) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_ccalf_enabled_flag\");\n\t}\n\t/*! TODO parse the rest !*/\n\n\treturn sps_id;\n}\n\nstatic s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tVVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_int_log(bs, 6, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (((s32)pps->sps_id<0) || (pps->sps_id >= 16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {\n\t\tpps->cw_left = gf_bs_read_ue_log(bs, \"conf_win_left_offset\");\n\t\tpps->cw_right = gf_bs_read_ue_log(bs, \"conf_win_right_offset\");\n\t\tpps->cw_top = gf_bs_read_ue_log(bs, \"conf_win_top_offset\");\n\t\tpps->cw_bottom = gf_bs_read_ue_log(bs, \"conf_win_bottom_offset\");\n\t}\n\t//scaling window\n\tif (gf_bs_read_int_log(bs, 1, \"scaling_window_explicit_signaling_flag\")) {\n\t\tgf_bs_read_se_log(bs, \"scaling_win_left_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_right_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_top_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_bottom_offset\");\n\t}\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \"no_pic_partition_flag\");\n\tpps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\tif (pps->subpic_id_mapping_present_flag) {\n\t\tu32 pps_subpic_id_len, pps_num_subpics=0;\n\t\tif (!pps->no_pic_partition_flag) {\n\t\t\tpps_num_subpics = 1+gf_bs_read_ue_log(bs, \"pps_num_subpics_minus1\");\n\t\t}\n\t\tpps_subpic_id_len = 1 + gf_bs_read_ue(bs);\n\t\tfor (i=0; i<pps_num_subpics; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, pps_subpic_id_len, \"subpic_id\", i);\n\t\t}\n\t}\n\tif (!pps->no_pic_partition_flag) {\n\t\tgf_bs_read_int_log(bs, 2, \"pps_log2_ctu_size_minus5\");\n\t\tu32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_columns_minus1\");\n\t\tu32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_rows_minus1\");\n\t\tfor (i=0; i<num_exp_tile_columns; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_column_width_minus1\", i);\n\t\tfor (i=0; i<num_exp_tile_rows; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_row_height_minus1\", i);\n\n\t\t//todo parse the rest\n\t\treturn pps_id;\n\t}\n\n\n\t//todo parse the rest\n\n\treturn pps_id;\n}\n\nstatic\ns32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\tsi->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, \"irap_or_gdr_pic\");\n\tsi->non_ref_pic = gf_bs_read_int_log(bs, 1, \"non_ref_pic\");\n\tif (si->irap_or_gdr_pic)\n\t\tsi->gdr_pic = gf_bs_read_int_log(bs, 1, \"gdr_pic\");\n\tif ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"inter_slice_allowed_flag\")))\n\t\tsi->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"intra_slice_allowed_flag\");\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 64))\n\t\treturn -1;\n\tsi->pps = &vvc->pps[pps_id];\n\tsi->sps = &vvc->sps[si->pps->sps_id];\n\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\n\tsi->recovery_point_valid = 0;\n\tsi->gdr_recovery_count = 0;\n\tif (si->gdr_pic) {\n\t\tsi->recovery_point_valid = 1;\n\t\tsi->gdr_recovery_count = gf_bs_read_ue_log(bs, \"gdr_recovery_count\");\n\t}\n\tgf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, \"ph_extra_bits\");\n\n\tif (si->sps->poc_msb_cycle_flag) {\n\t\tif ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_present_flag\"))) {\n\t\t\tsi->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, \"poc_msb_cycle\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic s32 vvc_parse_slice(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n//\tu32 CurrSubpicIdx = 0;\n\n\tsi->picture_header_in_slice_header_flag = gf_bs_read_int_log(bs, 1, \"picture_header_in_slice_header_flag\");\n\tif (si->picture_header_in_slice_header_flag) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[VVC] Picture header in slice header incomplete support, cannot guess slice type\\n\"));\n\t\tsi->slice_type = GF_VVC_SLICE_TYPE_UNKNOWN;\n\t\treturn vvc_parse_picture_header(bs, vvc, si);\n\t}\n\tif (!si->sps) return -1;\n\tsi->slice_type = GF_VVC_SLICE_TYPE_I;\n\tif (gf_bs_read_int_log(bs, 1, \"sps_subpic_info_present_flag\")) {\n\t\tgf_bs_read_int_log(bs, si->sps->subpicid_len, \"subpic_id\");\n\t\t//todo update CurrSubpicIdx\n\t}\n\n\tif (si->pps->rect_slice_flag ) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[VVC] tiling parsing not supported - patch welcome\\n\"));\n\t\treturn 0;\n\t}\n\tgf_bs_read_int_log(bs, si->sps->sh_num_extra_bits, \"num_extra_bits\");\n\t/*\n\t\tif( !pps_rect_slice_flag  &&  NumTilesInPic \u2212 sh_slice_address > 1 )\n\t\tsh_num_tiles_in_slice_minus1\n\n\t */\n\n\tif (si->inter_slice_allowed_flag )\n\t\tsi->slice_type = gf_bs_read_int_log(bs, 2, \"slice_type\");\n\n\treturn 0;\n}\n\nstatic void vvc_compute_poc(VVCSliceInfo *si)\n{\n\tu32 max_poc_lsb = 1 << (si->sps->log2_max_poc_lsb);\n\n\tif (si->poc_msb_cycle_present_flag) {\n\t\tsi->poc_msb = si->poc_msb_cycle;\n\t} else {\n\t\tif ((si->poc_lsb < si->poc_lsb_prev) && (si->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\t\telse if ((si->poc_lsb > si->poc_lsb_prev) && (si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\t\telse\n\t\t\tsi->poc_msb = si->poc_msb_prev;\n\t}\n\n\tsi->poc = si->poc_msb + si->poc_lsb;\n}\n\n\nGF_EXPORT\ns32 gf_media_vvc_parse_nalu_bs(GF_BitStream *bs, VVCState *vvc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tBool is_slice = GF_FALSE;\n\ts32 ret = -1;\n\tBool poc_reset = GF_FALSE;\n\tVVCSliceInfo n_state;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tmemcpy(&n_state, &vvc->s_info, sizeof(VVCSliceInfo));\n\tif (!vvc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) return -1;\n\n\tn_state.nal_unit_type = *nal_unit_type;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_VVC_NALU_ACCESS_UNIT:\n\tcase GF_VVC_NALU_END_OF_SEQ:\n\tcase GF_VVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\t\tpoc_reset = GF_TRUE;\n\tcase GF_VVC_NALU_SLICE_TRAIL:\n\tcase GF_VVC_NALU_SLICE_STSA:\n\tcase GF_VVC_NALU_SLICE_RADL:\n\tcase GF_VVC_NALU_SLICE_RASL:\n\tcase GF_VVC_NALU_SLICE_CRA:\n\tcase GF_VVC_NALU_SLICE_GDR:\n\t\t/* slice - read the info and compare.*/\n\t\tret = vvc_parse_slice(bs, vvc, &n_state);\n\t\tif (ret < 0) return ret;\n\n\t\tret = 0;\n\t\tif (n_state.compute_poc_defer || n_state.picture_header_in_slice_header_flag) {\n\t\t\tis_slice = GF_TRUE;\n\t\t\tn_state.compute_poc_defer = 0;\n\t\t\tif (poc_reset) {\n\t\t\t\tn_state.poc_lsb_prev = 0;\n\t\t\t\tn_state.poc_msb_prev = 0;\n\t\t\t}\n\n\t\t\tvvc_compute_poc(&n_state);\n\t\t\tif (vvc->s_info.poc != n_state.poc) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1))) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_VVC_NALU_PIC_HEADER:\n\t\tif (vvc_parse_picture_header(bs, vvc, &n_state)<0) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tis_slice = GF_TRUE;\n\n\t\t/*POC reset for IDR frames, NOT for CRA*/\n\t\tif (n_state.irap_or_gdr_pic && !n_state.gdr_pic) {\n\t\t\tn_state.poc_lsb_prev = 0;\n\t\t\tn_state.poc_msb_prev = 0;\n\t\t\tvvc_compute_poc(&n_state);\n\t\t} else {\n\t\t\t//we cannot compute poc until we know the first picture unit type, since IDR will reset poc count\n\t\t\t//and irap_or_gdr_pic=0 does not prevent IDR from following\n\t\t\tn_state.compute_poc_defer = 1;\n\t\t}\n\n\t\tif (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1))) {\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\tvvc->last_parsed_sps_id = gf_media_vvc_read_sps_bs_internal(bs, vvc, *layer_id, NULL);\n\t\tret = (vvc->last_parsed_sps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tcase GF_VVC_NALU_PIC_PARAM:\n\t\tvvc->last_parsed_pps_id = gf_media_vvc_read_pps_bs_internal(bs, vvc);\n\t\tret = (vvc->last_parsed_pps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tcase GF_VVC_NALU_VID_PARAM:\n\t\tvvc->last_parsed_vps_id = gf_media_vvc_read_vps_bs_internal(bs, vvc, GF_FALSE);\n\t\tret = (vvc->last_parsed_vps_id>=0) ? 0 : -1;\n\t\tbreak;\n\tcase GF_VVC_NALU_DEC_PARAM:\n\t\tret = 0;\n\t\tbreak;\n\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t//we use the mix aps type + aps id (first 8 bits) as unique identifier\n\t\tvvc->last_parsed_aps_id = gf_bs_read_int_log(bs, 8, \"aps_id\");\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif ((ret>0) && vvc->s_info.sps) {\n//\t\tn_state.frame_num_offset_prev = vvc->s_info.frame_num_offset;\n//\t\tn_state.frame_num_prev = vvc->s_info.frame_num;\n\n\t\tn_state.poc_lsb_prev = vvc->s_info.poc_lsb;\n\t\tn_state.poc_msb_prev = vvc->s_info.poc_msb;\n\t\tif (is_slice)\n\t\t\tn_state.prev_layer_id_plus1 = *layer_id + 1;\n\t}\n\n\tmemcpy(&vvc->s_info, &n_state, sizeof(VVCSliceInfo));\n\n\treturn ret;\n}\n\nGF_EXPORT\ns32 gf_media_vvc_parse_nalu(u8 *data, u32 size, VVCState *vvc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tGF_BitStream *bs = NULL;\n\ts32 ret;\n\n\tif (!vvc) {\n\t\tif (nal_unit_type) (*nal_unit_type) = data[1] >> 3;\n\t\tif (layer_id) (*layer_id) = data[0] & 0x3f;\n\t\tif (temporal_id) (*temporal_id) = (data[1] & 0x7);\n\t\treturn -1;\n\t}\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tif (!bs) return -1;\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tret = gf_media_vvc_parse_nalu_bs(bs, vvc, nal_unit_type, temporal_id, layer_id);\n\tgf_bs_del(bs);\n\treturn ret;\n}\n\nBool gf_media_vvc_slice_is_ref(VVCState *vvc)\n{\n\tif (!vvc->s_info.irap_or_gdr_pic) {\n\t\treturn GF_FALSE;\n\t}\n\tif (vvc->s_info.gdr_pic) {\n\t\tif (vvc->s_info.recovery_point_valid) {\n\t\t\tvvc->s_info.recovery_point_valid = 0;\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n"], "filenames": ["src/media_tools/av_parsers.c"], "buggy_code_start_loc": [4693], "buggy_code_end_loc": [5789], "fixing_code_start_loc": [4693], "fixing_code_end_loc": [5792], "type": "CWE-120", "message": "A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "other": {"cve": {"id": "CVE-2021-40568", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-13T18:15:07.977", "lastModified": "2023-05-27T04:15:16.660", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges."}, {"lang": "es", "value": "es presentado una vulnerabilidad de desbordamiento de b\u00fafer en Gpac versiones hasta 1.0.1 por medio de un archivo MP4 malformado en la funci\u00f3n svc_parse_slice en el archivo av_parsers.c, que permite a atacantes causar una denegaci\u00f3n de servicio, incluso ejecuci\u00f3n de c\u00f3digo y escalada de privilegios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.1", "matchCriteriaId": "72EEF01B-F945-4AEF-B5C2-6F84A51311C9"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/f1ae01d745200a258cdf62622f71754c37cb6c30", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1900", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/f1ae01d745200a258cdf62622f71754c37cb6c30"}}