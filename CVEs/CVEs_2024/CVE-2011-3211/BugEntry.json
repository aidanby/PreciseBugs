{"buggy_code": ["import getopt\nfrom subprocess import Popen, PIPE\nimport Bcfg2.Server.Admin\n\nclass Viz(Bcfg2.Server.Admin.MetadataCore):\n    __shorthelp__ = \"Produce graphviz diagrams of metadata structures\"\n    __longhelp__ = (__shorthelp__ + \"\\n\\nbcfg2-admin viz [--includehosts] \"\n                                    \"[--includebundles] [--includekey] \"\n                                    \"[-o output.png] [--raw]\")\n    __usage__ = (\"bcfg2-admin viz [options]\\n\\n\"\n                 \"     %-25s%s\\n\"\n                 \"     %-25s%s\\n\"\n                 \"     %-25s%s\\n\"\n                 \"     %-25s%s\\n\" %\n                (\"-H, --includehosts\",\n                 \"include hosts in the viz output\",\n                 \"-b, --includebundles\",\n                 \"include bundles in the viz output\",\n                 \"-k, --includekey\",\n                 \"show a key for different digraph shapes\",\n                 \"-o, --outfile <file>\",\n                 \"write viz output to an output file\"))\n\n    colors = ['steelblue1', 'chartreuse', 'gold', 'magenta',\n              'indianred1', 'limegreen', 'orange1', 'lightblue2',\n              'green1', 'blue1', 'yellow1', 'darkturquoise', 'gray66']\n    plugin_blacklist = ['DBStats', 'Snapshots', 'Cfg', 'Pkgmgr', 'Packages',\n                        'Rules', 'Account', 'Decisions', 'Deps', 'Git', 'Svn',\n                        'Fossil', 'Bzr', 'Bundler', 'TGenshi', 'SGenshi', 'Base']\n\n    def __init__(self, cfile):\n\n        Bcfg2.Server.Admin.MetadataCore.__init__(self, cfile,\n                                                 self.__usage__,\n                                                 pblacklist=self.plugin_blacklist)\n\n    def __call__(self, args):\n        Bcfg2.Server.Admin.MetadataCore.__call__(self, args)\n        # First get options to the 'viz' subcommand\n        try:\n            opts, args = getopt.getopt(args, 'Hbko:',\n                                       ['includehosts', 'includebundles',\n                                        'includekey', 'outfile='])\n        except getopt.GetoptError, msg:\n            print msg\n\n        #FIXME: is this for --raw?\n        #rset = False\n        hset = False\n        bset = False\n        kset = False\n        outputfile = False\n        for opt, arg in opts:\n            if opt in (\"-H\", \"--includehosts\"):\n                hset = True\n            elif opt in (\"-b\", \"--includebundles\"):\n                bset = True\n            elif opt in (\"-k\", \"--includekey\"):\n                kset = True\n            elif opt in (\"-o\", \"--outfile\"):\n                outputfile = arg\n\n        data = self.Visualize(self.get_repo_path(), hset, bset,\n                              kset, outputfile)\n        print data\n        raise SystemExit, 0\n\n    def Visualize(self, repopath, hosts=False,\n                  bundles=False, key=False, output=False):\n        \"\"\"Build visualization of groups file.\"\"\"\n        if output:\n            format = output.split('.')[-1]\n        else:\n            format = 'png'\n\n        cmd = \"dot -T%s\" % (format)\n        if output:\n            cmd += \" -o %s\" % output\n        dotpipe = Popen(cmd, shell=True, stdin=PIPE,\n                        stdout=PIPE, close_fds=True)\n        try:\n            dotpipe.stdin.write(\"digraph groups {\\n\")\n        except:\n            print \"write to dot process failed. Is graphviz installed?\"\n            raise SystemExit(1)\n        dotpipe.stdin.write('\\trankdir=\"LR\";\\n')\n        dotpipe.stdin.write(self.metadata.viz(hosts, bundles,\n                                                key, self.colors))\n        if key:\n            dotpipe.stdin.write(\"\\tsubgraph cluster_key {\\n\")\n            dotpipe.stdin.write('''\\tstyle=\"filled\";\\n''')\n            dotpipe.stdin.write('''\\tcolor=\"lightblue\";\\n''')\n            dotpipe.stdin.write('''\\tBundle [ shape=\"septagon\" ];\\n''')\n            dotpipe.stdin.write('''\\tGroup [shape=\"ellipse\"];\\n''')\n            dotpipe.stdin.write('''\\tProfile [style=\"bold\", shape=\"ellipse\"];\\n''')\n            dotpipe.stdin.write('''\\tHblock [label=\"Host1|Host2|Host3\", shape=\"record\"];\\n''')\n            dotpipe.stdin.write('''\\tlabel=\"Key\";\\n''')\n            dotpipe.stdin.write(\"\\t}\\n\")\n        dotpipe.stdin.write(\"}\\n\")\n        dotpipe.stdin.close()\n        return dotpipe.stdout.read()\n", "\"\"\"This module implements a config file repository.\"\"\"\n__revision__ = '$Revision$'\n\nimport binascii\nimport logging\nimport lxml\nimport os\nimport re\nimport tempfile\n\nimport Bcfg2.Server.Plugin\n\nlogger = logging.getLogger('Bcfg2.Plugins.Cfg')\n\ndef process_delta(data, delta):\n    if not delta.specific.delta:\n        return data\n    if delta.specific.delta == 'cat':\n        datalines = data.split('\\n')\n        for line in delta.data.split('\\n'):\n            if not line:\n                continue\n            if line[0] == '+':\n                datalines.append(line[1:])\n            elif line[0] == '-':\n                if line[1:] in datalines:\n                    datalines.remove(line[1:])\n        return \"\\n\".join(datalines)\n    elif delta.specific.delta == 'diff':\n        basehandle, basename = tempfile.mkstemp()\n        basefile = open(basename, 'w')\n        basefile.write(data)\n        basefile.close()\n        os.close(basehandle)\n        dhandle, dname = tempfile.mkstemp()\n        dfile = open(dname, 'w')\n        dfile.write(delta.data)\n        dfile.close()\n        os.close(dhandle)\n        ret = os.system(\"patch -uf %s < %s > /dev/null 2>&1\" \\\n                        % (basefile.name, dfile.name))\n        output = open(basefile.name, 'r').read()\n        [os.unlink(fname) for fname in [basefile.name, dfile.name]]\n        if ret >> 8 != 0:\n            raise Bcfg2.Server.Plugin.PluginExecutionError, ('delta', delta)\n        return output\n\nclass CfgMatcher:\n    def __init__(self, fname):\n        name = re.escape(fname)\n        self.basefile_reg = re.compile('^(?P<basename>%s)(|\\\\.H_(?P<hostname>\\S+)|.G(?P<prio>\\d+)_(?P<group>\\S+))$' % name)\n        self.delta_reg = re.compile('^(?P<basename>%s)(|\\\\.H_(?P<hostname>\\S+)|\\\\.G(?P<prio>\\d+)_(?P<group>\\S+))\\\\.(?P<delta>(cat|diff))$' % name)\n        self.cat_count = fname.count(\".cat\")\n        self.diff_count = fname.count(\".diff\")\n\n    def match(self, fname):\n        if fname.count(\".cat\") > self.cat_count \\\n               or fname.count('.diff') > self.diff_count:\n            return self.delta_reg.match(fname)\n        return self.basefile_reg.match(fname)\n\nclass CfgEntrySet(Bcfg2.Server.Plugin.EntrySet):\n    def __init__(self, basename, path, entry_type, encoding):\n        Bcfg2.Server.Plugin.EntrySet.__init__(self, basename, path,\n                                              entry_type, encoding)\n        self.specific = CfgMatcher(path.split('/')[-1])\n\n    def sort_by_specific(self, one, other):\n        return cmp(one.specific, other.specific)\n\n    def get_pertinent_entries(self, metadata):\n        '''return a list of all entries pertinent to a client => [base, delta1, delta2]'''\n        matching = [ent for ent in self.entries.values() if \\\n                    ent.specific.matches(metadata)]\n        matching.sort(self.sort_by_specific)\n        non_delta = [matching.index(m) for m in matching if not m.specific.delta]\n        if not non_delta:\n            raise Bcfg2.Server.Plugin.PluginExecutionError\n        base = min(non_delta)\n        used = matching[:base+1]\n        used.reverse()\n        return used\n\n    def bind_entry(self, entry, metadata):\n        self.bind_info_to_entry(entry, metadata)\n        used = self.get_pertinent_entries(metadata)\n        basefile = used.pop(0)\n        data = basefile.data\n        if entry.tag == 'Path':\n            entry.set('type', 'file')\n        for delta in used:\n            data = data.strip()\n            data = process_delta(data, delta)\n        if used:\n            data += '\\n'\n        if entry.get('encoding') == 'base64':\n            entry.text = binascii.b2a_base64(data)\n        else:\n            entry.text = unicode(data, self.encoding)\n        if entry.text in ['', None]:\n            entry.set('empty', 'true')\n\n    def list_accept_choices(self, metadata):\n        '''return a list of candidate pull locations'''\n        used = self.get_pertinent_entries(metadata)\n        ret = []\n        if used:\n            ret.append(used[0].specific)\n        if not ret[0].hostname:\n            ret.append(Bcfg2.Server.Plugin.Specificity(hostname=metadata.hostname))\n        return ret\n\n    def build_filename(self, specific):\n        bfname = self.path + '/' + self.path.split('/')[-1]\n        if specific.all:\n            return bfname\n        elif specific.group:\n            return \"%s.G%d_%s\" % (bfname, specific.prio, specific.group)\n        elif specific.hostname:\n            return \"%s.H_%s\" % (bfname, specific.hostname)\n\n    def write_update(self, specific, new_entry, log):\n        if 'text' in new_entry:\n            name = self.build_filename(specific)\n            open(name, 'w').write(new_entry['text'])\n            if log:\n                logger.info(\"Wrote file %s\" % name)\n        badattr = [attr for attr in ['owner', 'group', 'perms'] if attr in new_entry]\n        if badattr:\n            metadata_updates = {}\n            metadata_updates.update(self.metadata)\n            for attr in badattr:\n                metadata_updates[attr] = new_entry.get(attr)\n            if self.infoxml:\n                infoxml = lxml.etree.Element('FileInfo')\n                infotag = lxml.etree.SubElement(infoxml, 'Info')\n                [infotag.attrib.__setitem__(attr, metadata_updates[attr]) \\\n                    for attr in metadata_updates]\n                ofile = open(self.path + \"/info.xml\",\"w\")\n                ofile.write(lxml.etree.tostring(infoxml, pretty_print=True))\n                ofile.close()\n                if log:\n                    logger.info(\"Wrote file %s\" % (self.path + \"/info.xml\"))\n            else:\n                infofile = open(self.path + '/:info', 'w')\n                for x in metadata_updates.iteritems():\n                    infofile.write(\"%s: %s\\n\" % x)\n                infofile.close()\n                if log:\n                    logger.info(\"Wrote file %s\" % infofile.name)\n\nclass Cfg(Bcfg2.Server.Plugin.GroupSpool,\n          Bcfg2.Server.Plugin.PullTarget):\n    \"\"\"This generator in the configuration file repository for Bcfg2.\"\"\"\n    name = 'Cfg'\n    __version__ = '$Id$'\n    __author__ = 'bcfg-dev@mcs.anl.gov'\n    es_cls = CfgEntrySet\n    es_child_cls = Bcfg2.Server.Plugin.SpecificData\n\n    def AcceptChoices(self, entry, metadata):\n        return self.entries[entry.get('name')].list_accept_choices(metadata)\n\n    def AcceptPullData(self, specific, new_entry, log):\n        return self.entries[new_entry.get('name')].write_update(specific, new_entry, log)\n", "import os\nfrom mercurial import ui, hg\nfrom subprocess import Popen, PIPE\nimport Bcfg2.Server.Plugin\n\n# for debugging output only\nimport logging\nlogger = logging.getLogger('Bcfg2.Plugins.Mercurial')\n\nclass Hg(Bcfg2.Server.Plugin.Plugin,\n             Bcfg2.Server.Plugin.Version):\n    \"\"\"Mercurial is a version plugin for dealing with Bcfg2 repository.\"\"\"\n    name = 'Mercurial'\n    __version__ = '$Id$'\n    __author__ = 'bcfg-dev@mcs.anl.gov'\n    experimental = True\n\n    def __init__(self, core, datastore):\n        Bcfg2.Server.Plugin.Plugin.__init__(self, core, datastore)\n        Bcfg2.Server.Plugin.Version.__init__(self)\n        self.core = core\n        self.datastore = datastore\n\n        # path to hg directory for Bcfg2 repo\n        hg_dir = \"%s/.hg\" % datastore\n\n        # Read changeset from bcfg2 repo\n        if os.path.isdir(hg_dir):\n            self.get_revision()\n        else:\n            logger.error(\"%s is not present.\" % hg_dir)\n            raise Bcfg2.Server.Plugin.PluginInitError\n\n        logger.debug(\"Initialized hg plugin with hg directory = %s\" % hg_dir)\n\n    def get_revision(self):\n        \"\"\"Read hg revision information for the Bcfg2 repository.\"\"\"\n        try:\n            repo_path = \"%s/\" % self.datastore\n            repo = hg.repository(ui.ui(), repo_path)\n            tip = repo.changelog.tip()\n            revision = repo.changelog.rev(tip)\n        except:\n            logger.error(\"Failed to read hg repository; disabling mercurial support\")\n            raise Bcfg2.Server.Plugin.PluginInitError\n        return revision\n\n", "'''This module manages ssh key files for bcfg2'''\n__revision__ = '$Revision$'\n\nimport binascii\nimport os\nimport socket\nimport shutil\nimport tempfile\nfrom subprocess import Popen, PIPE\nimport Bcfg2.Server.Plugin\n\n\nclass SSHbase(Bcfg2.Server.Plugin.Plugin,\n              Bcfg2.Server.Plugin.Generator,\n              Bcfg2.Server.Plugin.DirectoryBacked,\n              Bcfg2.Server.Plugin.PullTarget):\n    \"\"\"\n       The sshbase generator manages ssh host keys (both v1 and v2)\n       for hosts.  It also manages the ssh_known_hosts file. It can\n       integrate host keys from other management domains and similarly\n       export its keys. The repository contains files in the following\n       formats:\n\n       ssh_host_key.H_(hostname) -> the v1 host private key for\n         (hostname)\n       ssh_host_key.pub.H_(hostname) -> the v1 host public key\n         for (hostname)\n       ssh_host_(dr)sa_key.H_(hostname) -> the v2 ssh host\n         private key for (hostname)\n       ssh_host_(dr)sa_key.pub.H_(hostname) -> the v2 ssh host\n         public key for (hostname)\n       ssh_known_hosts -> the current known hosts file. this\n         is regenerated each time a new key is generated.\n\n    \"\"\"\n    name = 'SSHbase'\n    __version__ = '$Id$'\n    __author__ = 'bcfg-dev@mcs.anl.gov'\n\n    pubkeys = [\"ssh_host_dsa_key.pub.H_%s\",\n                \"ssh_host_rsa_key.pub.H_%s\", \"ssh_host_key.pub.H_%s\"]\n    hostkeys = [\"ssh_host_dsa_key.H_%s\",\n                \"ssh_host_rsa_key.H_%s\", \"ssh_host_key.H_%s\"]\n    keypatterns = ['ssh_host_dsa_key', 'ssh_host_rsa_key', 'ssh_host_key',\n                   'ssh_host_dsa_key.pub', 'ssh_host_rsa_key.pub',\n                   'ssh_host_key.pub']\n\n    def __init__(self, core, datastore):\n        Bcfg2.Server.Plugin.Plugin.__init__(self, core, datastore)\n        Bcfg2.Server.Plugin.Generator.__init__(self)\n        Bcfg2.Server.Plugin.PullTarget.__init__(self)\n        try:\n            Bcfg2.Server.Plugin.DirectoryBacked.__init__(self, self.data,\n                                                         self.core.fam)\n        except OSError, ioerr:\n            self.logger.error(\"Failed to load SSHbase repository from %s\" \\\n                              % (self.data))\n            self.logger.error(ioerr)\n            raise Bcfg2.Server.Plugin.PluginInitError\n        self.Entries = {'Path':\n                        {'/etc/ssh/ssh_known_hosts': self.build_skn,\n                         '/etc/ssh/ssh_host_dsa_key': self.build_hk,\n                         '/etc/ssh/ssh_host_rsa_key': self.build_hk,\n                         '/etc/ssh/ssh_host_dsa_key.pub': self.build_hk,\n                         '/etc/ssh/ssh_host_rsa_key.pub': self.build_hk,\n                         '/etc/ssh/ssh_host_key': self.build_hk,\n                         '/etc/ssh/ssh_host_key.pub': self.build_hk}}\n        self.ipcache = {}\n        self.namecache = {}\n        self.__skn = False\n\n    def get_skn(self):\n        \"\"\"Build memory cache of the ssh known hosts file.\"\"\"\n        if not self.__skn:\n            self.__skn = \"\\n\".join([value.data for key, value in \\\n                                    self.entries.iteritems() if \\\n                                    key.endswith('.static')])\n            names = dict()\n            # if no metadata is registered yet, defer\n            if len(self.core.metadata.query.all()) == 0:\n                self.__skn = False\n                return self.__skn\n            for cmeta in self.core.metadata.query.all():\n                names[cmeta.hostname] = set([cmeta.hostname])\n                names[cmeta.hostname].update(cmeta.aliases)\n                newnames = set()\n                newips = set()\n                for name in names[cmeta.hostname]:\n                    newnames.add(name.split('.')[0])\n                    try:\n                        newips.add(self.get_ipcache_entry(name)[0])\n                    except:\n                        continue\n                names[cmeta.hostname].update(newnames)\n                names[cmeta.hostname].update(cmeta.addresses)\n                names[cmeta.hostname].update(newips)\n                # TODO: Only perform reverse lookups on IPs if an option is set.\n                if True:\n                    for ip in newips:\n                        try:\n                            names[cmeta.hostname].update(self.get_namecache_entry(ip))\n                        except:\n                            continue\n                names[cmeta.hostname] = sorted(names[cmeta.hostname])\n            # now we have our name cache\n            pubkeys = [pubk for pubk in self.entries.keys() \\\n                       if pubk.find('.pub.H_') != -1]\n            pubkeys.sort()\n            badnames = set()\n            for pubkey in pubkeys:\n                hostname = pubkey.split('H_')[1]\n                if hostname not in names:\n                    if hostname not in badnames:\n                        badnames.add(hostname)\n                        self.logger.error(\"SSHbase: Unknown host %s; ignoring public keys\" % hostname)\n                    continue\n                self.__skn += \"%s %s\" % (','.join(names[hostname]),\n                                         self.entries[pubkey].data)\n        return self.__skn\n\n    def set_skn(self, value):\n        \"\"\"Set backing data for skn.\"\"\"\n        self.__skn = value\n    skn = property(get_skn, set_skn)\n\n    def HandleEvent(self, event=None):\n        \"\"\"Local event handler that does skn regen on pubkey change.\"\"\"\n        Bcfg2.Server.Plugin.DirectoryBacked.HandleEvent(self, event)\n        if event and '_key.pub.H_' in event.filename:\n            self.skn = False\n        if event and event.filename.endswith('.static'):\n            self.skn = False\n        if not self.__skn:\n            if (len(self.entries.keys())) >= (len(os.listdir(self.data))-1):\n                _ = self.skn\n\n    def HandlesEntry(self, entry, _):\n        \"\"\"Handle key entries dynamically.\"\"\"\n        return entry.tag == 'Path' and \\\n               ([fpat for fpat in self.keypatterns\n                 if entry.get('name').endswith(fpat)]\n                or entry.get('name').endswith('ssh_known_hosts'))\n\n    def HandleEntry(self, entry, metadata):\n        \"\"\"Bind data.\"\"\"\n        if entry.get('name').endswith('ssh_known_hosts'):\n            return self.build_skn(entry, metadata)\n        else:\n            return self.build_hk(entry, metadata)\n\n    def get_ipcache_entry(self, client):\n        \"\"\"Build a cache of dns results.\"\"\"\n        if client in self.ipcache:\n            if self.ipcache[client]:\n                return self.ipcache[client]\n            else:\n                raise socket.gaierror\n        else:\n            # need to add entry\n            try:\n                ipaddr = socket.gethostbyname(client)\n                self.ipcache[client] = (ipaddr, client)\n                return (ipaddr, client)\n            except socket.gaierror:\n                cmd = \"getent hosts %s\" % client\n                ipaddr = Popen(cmd, shell=True, \\\n                               stdout=PIPE).stdout.read().strip().split()\n                if ipaddr:\n                    self.ipcache[client] = (ipaddr, client)\n                    return (ipaddr, client)\n                self.ipcache[client] = False\n                self.logger.error(\"Failed to find IP address for %s\" % client)\n                raise socket.gaierror\n\n    def get_namecache_entry(self, cip):\n        \"\"\"Build a cache of name lookups from client IP addresses.\"\"\"\n        if cip in self.namecache:\n            # lookup cached name from IP\n            if self.namecache[cip]:\n                return self.namecache[cip]\n            else:\n                raise socket.gaierror\n        else:\n            # add an entry that has not been cached\n            try:\n                rvlookup = socket.gethostbyaddr(cip)\n                if rvlookup[0]:\n                    self.namecache[cip] = [rvlookup[0]]\n                else:\n                    self.namecache[cip] = []\n                self.namecache[cip].extend(rvlookup[1])\n                return self.namecache[cip]\n            except socket.gaierror:\n                self.namecache[cip] = False\n                self.logger.error(\"Failed to find any names associated with IP address %s\" % cip)\n                raise\n\n    def build_skn(self, entry, metadata):\n        \"\"\"This function builds builds a host specific known_hosts file.\"\"\"\n        client = metadata.hostname\n        entry.text = self.skn\n        hostkeys = [keytmpl % client for keytmpl in self.pubkeys \\\n                        if (keytmpl % client) in self.entries]\n        hostkeys.sort()\n        for hostkey in hostkeys:\n            entry.text += \"localhost,localhost.localdomain,127.0.0.1 %s\" % (\n                self.entries[hostkey].data)\n        permdata = {'owner':'root',\n                    'group':'root',\n                    'type':'file',\n                    'perms':'0644'}\n        [entry.attrib.__setitem__(key, permdata[key]) for key in permdata]\n\n    def build_hk(self, entry, metadata):\n        \"\"\"This binds host key data into entries.\"\"\"\n        client = metadata.hostname\n        filename = \"%s.H_%s\" % (entry.get('name').split('/')[-1], client)\n        if filename not in self.entries.keys():\n            self.GenerateHostKeys(client)\n        if not filename in self.entries:\n            self.logger.error(\"%s still not registered\" % filename)\n            raise Bcfg2.Server.Plugin.PluginExecutionError\n        keydata = self.entries[filename].data\n        permdata = {'owner':'root',\n                    'group':'root',\n                    'type':'file',\n                    'perms':'0600'}\n        if entry.get('name')[-4:] == '.pub':\n            permdata['perms'] = '0644'\n        [entry.attrib.__setitem__(key, permdata[key]) for key in permdata]\n        if \"ssh_host_key.H_\" == filename[:15]:\n            entry.attrib['encoding'] = 'base64'\n            entry.text = binascii.b2a_base64(keydata)\n        else:\n            entry.text = keydata\n\n    def GenerateHostKeys(self, client):\n        \"\"\"Generate new host keys for client.\"\"\"\n        keylist = [keytmpl % client for keytmpl in self.hostkeys]\n        for hostkey in keylist:\n            if 'ssh_host_rsa_key.H_' == hostkey[:19]:\n                keytype = 'rsa'\n            elif 'ssh_host_dsa_key.H_' == hostkey[:19]:\n                keytype = 'dsa'\n            else:\n                keytype = 'rsa1'\n\n            if hostkey not in self.entries.keys():\n                fileloc = \"%s/%s\" % (self.data, hostkey)\n                publoc = self.data + '/' + \".\".join([hostkey.split('.')[0],\n                                                     'pub',\n                                                     \"H_%s\" % client])\n                tempdir = tempfile.mkdtemp()\n                temploc = \"%s/%s\" % (tempdir, hostkey)\n                cmd = 'ssh-keygen -q -f %s -N \"\" -t %s -C root@%s < /dev/null'\n                os.system(cmd % (temploc, keytype, client))\n                shutil.copy(temploc, fileloc)\n                shutil.copy(\"%s.pub\" % temploc, publoc)\n                self.AddEntry(hostkey)\n                self.AddEntry(\".\".join([hostkey.split('.')[0]]+['pub', \"H_%s\" \\\n                                                                % client]))\n                try:\n                    os.unlink(temploc)\n                    os.unlink(\"%s.pub\" % temploc)\n                    os.rmdir(tempdir)\n                except OSError:\n                    self.logger.error(\"Failed to unlink temporary ssh keys\")\n\n    def AcceptChoices(self, _, metadata):\n        return [Bcfg2.Server.Plugin.Specificity(hostname=metadata.hostname)]\n\n    def AcceptPullData(self, specific, entry, log):\n        \"\"\"Per-plugin bcfg2-admin pull support.\"\"\"\n        # specific will always be host specific\n        filename = \"%s/%s.H_%s\" % (self.data, entry['name'].split('/')[-1],\n                                   specific.hostname)\n        open(filename, 'w').write(entry['text'])\n        if log:\n            print \"Wrote file %s\" % filename\n", "import os\nfrom subprocess import Popen, PIPE\nimport Bcfg2.Server.Plugin\n\n# for debugging output only\nimport logging\nlogger = logging.getLogger('Bcfg2.Plugins.Svn')\n\n\nclass Svn(Bcfg2.Server.Plugin.Plugin,\n          Bcfg2.Server.Plugin.Version):\n    \"\"\"Svn is a version plugin for dealing with Bcfg2 repos.\"\"\"\n    name = 'Svn'\n    __version__ = '$Id$'\n    __author__ = 'bcfg-dev@mcs.anl.gov'\n\n    def __init__(self, core, datastore):\n        Bcfg2.Server.Plugin.Plugin.__init__(self, core, datastore)\n        self.core = core\n        self.datastore = datastore\n\n        # path to svn directory for bcfg2 repo\n        svn_dir = \"%s/.svn\" % datastore\n\n        # Read revision from bcfg2 repo\n        if os.path.isdir(svn_dir):\n            self.get_revision()\n        else:\n            logger.error(\"%s is not a directory\" % svn_dir)\n            raise Bcfg2.Server.Plugin.PluginInitError\n\n        logger.debug(\"Initialized svn plugin with svn directory = %s\" % svn_dir)\n\n    def get_revision(self):\n        \"\"\"Read svn revision information for the Bcfg2 repository.\"\"\"\n        try:\n            data = Popen((\"env LC_ALL=C svn info %s\" %\n                         (self.datastore)), shell=True,\n                         stdout=PIPE).communicate()[0].split('\\n')\n            return [line.split(': ')[1] for line in data \\\n                    if line[:9] == 'Revision:'][-1]\n        except IndexError:\n            logger.error(\"Failed to read svn info; disabling svn support\")\n            logger.error('''Ran command \"svn info %s\"''' % (self.datastore))\n            logger.error(\"Got output: %s\" % data)\n            raise Bcfg2.Server.Plugin.PluginInitError\n"], "fixing_code": ["import getopt\nfrom subprocess import Popen, PIPE\nimport pipes\nimport Bcfg2.Server.Admin\n\nclass Viz(Bcfg2.Server.Admin.MetadataCore):\n    __shorthelp__ = \"Produce graphviz diagrams of metadata structures\"\n    __longhelp__ = (__shorthelp__ + \"\\n\\nbcfg2-admin viz [--includehosts] \"\n                                    \"[--includebundles] [--includekey] \"\n                                    \"[-o output.png] [--raw]\")\n    __usage__ = (\"bcfg2-admin viz [options]\\n\\n\"\n                 \"     %-25s%s\\n\"\n                 \"     %-25s%s\\n\"\n                 \"     %-25s%s\\n\"\n                 \"     %-25s%s\\n\" %\n                (\"-H, --includehosts\",\n                 \"include hosts in the viz output\",\n                 \"-b, --includebundles\",\n                 \"include bundles in the viz output\",\n                 \"-k, --includekey\",\n                 \"show a key for different digraph shapes\",\n                 \"-o, --outfile <file>\",\n                 \"write viz output to an output file\"))\n\n    colors = ['steelblue1', 'chartreuse', 'gold', 'magenta',\n              'indianred1', 'limegreen', 'orange1', 'lightblue2',\n              'green1', 'blue1', 'yellow1', 'darkturquoise', 'gray66']\n    plugin_blacklist = ['DBStats', 'Snapshots', 'Cfg', 'Pkgmgr', 'Packages',\n                        'Rules', 'Account', 'Decisions', 'Deps', 'Git', 'Svn',\n                        'Fossil', 'Bzr', 'Bundler', 'TGenshi', 'SGenshi', 'Base']\n\n    def __init__(self, cfile):\n\n        Bcfg2.Server.Admin.MetadataCore.__init__(self, cfile,\n                                                 self.__usage__,\n                                                 pblacklist=self.plugin_blacklist)\n\n    def __call__(self, args):\n        Bcfg2.Server.Admin.MetadataCore.__call__(self, args)\n        # First get options to the 'viz' subcommand\n        try:\n            opts, args = getopt.getopt(args, 'Hbko:',\n                                       ['includehosts', 'includebundles',\n                                        'includekey', 'outfile='])\n        except getopt.GetoptError, msg:\n            print msg\n\n        #FIXME: is this for --raw?\n        #rset = False\n        hset = False\n        bset = False\n        kset = False\n        outputfile = False\n        for opt, arg in opts:\n            if opt in (\"-H\", \"--includehosts\"):\n                hset = True\n            elif opt in (\"-b\", \"--includebundles\"):\n                bset = True\n            elif opt in (\"-k\", \"--includekey\"):\n                kset = True\n            elif opt in (\"-o\", \"--outfile\"):\n                outputfile = arg\n\n        data = self.Visualize(self.get_repo_path(), hset, bset,\n                              kset, outputfile)\n        if data:\n            print(data)\n        raise SystemExit, 0\n\n    def Visualize(self, repopath, hosts=False,\n                  bundles=False, key=False, output=False):\n        \"\"\"Build visualization of groups file.\"\"\"\n        if output:\n            format = output.split('.')[-1]\n        else:\n            format = 'png'\n\n        cmd = [\"dot\", \"-T\", format]\n        if output:\n            cmd.extend([\"-o\", output])\n        try:\n            dotpipe = Popen(cmd, stdin=PIPE, stdout=PIPE, close_fds=True)\n        except OSError:\n            # on some systems (RHEL 6), you cannot run dot with\n            # shell=True.  on others (Gentoo with Python 2.7), you\n            # must.  In yet others (RHEL 5), either way works.  I have\n            # no idea what the difference is, but it's kind of a PITA.\n            cmd = [\"dot\", \"-T\", pipes.quote(format)]\n            if output:\n                cmd.extend([\"-o\", pipes.quote(output)])\n            dotpipe = Popen(cmd, shell=True,\n                            stdin=PIPE, stdout=PIPE, close_fds=True)\n        try:\n            dotpipe.stdin.write(\"digraph groups {\\n\")\n        except:\n            print \"write to dot process failed. Is graphviz installed?\"\n            raise SystemExit(1)\n        dotpipe.stdin.write('\\trankdir=\"LR\";\\n')\n        dotpipe.stdin.write(self.metadata.viz(hosts, bundles,\n                                                key, self.colors))\n        if key:\n            dotpipe.stdin.write(\"\\tsubgraph cluster_key {\\n\")\n            dotpipe.stdin.write('''\\tstyle=\"filled\";\\n''')\n            dotpipe.stdin.write('''\\tcolor=\"lightblue\";\\n''')\n            dotpipe.stdin.write('''\\tBundle [ shape=\"septagon\" ];\\n''')\n            dotpipe.stdin.write('''\\tGroup [shape=\"ellipse\"];\\n''')\n            dotpipe.stdin.write('''\\tProfile [style=\"bold\", shape=\"ellipse\"];\\n''')\n            dotpipe.stdin.write('''\\tHblock [label=\"Host1|Host2|Host3\", shape=\"record\"];\\n''')\n            dotpipe.stdin.write('''\\tlabel=\"Key\";\\n''')\n            dotpipe.stdin.write(\"\\t}\\n\")\n        dotpipe.stdin.write(\"}\\n\")\n        dotpipe.stdin.close()\n        return dotpipe.stdout.read()\n", "\"\"\"This module implements a config file repository.\"\"\"\n__revision__ = '$Revision$'\n\nimport binascii\nimport logging\nimport lxml\nimport os\nimport re\nimport tempfile\nfrom subprocess import Popen, PIPE\n\nimport Bcfg2.Server.Plugin\n\nlogger = logging.getLogger('Bcfg2.Plugins.Cfg')\n\ndef process_delta(data, delta):\n    if not delta.specific.delta:\n        return data\n    if delta.specific.delta == 'cat':\n        datalines = data.split('\\n')\n        for line in delta.data.split('\\n'):\n            if not line:\n                continue\n            if line[0] == '+':\n                datalines.append(line[1:])\n            elif line[0] == '-':\n                if line[1:] in datalines:\n                    datalines.remove(line[1:])\n        return \"\\n\".join(datalines)\n    elif delta.specific.delta == 'diff':\n        basehandle, basename = tempfile.mkstemp()\n        basefile = open(basename, 'w')\n        basefile.write(data)\n        basefile.close()\n        os.close(basehandle)\n        \n        cmd = [\"patch\", \"-u\", \"-f\", basefile.name]\n        patch = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)\n        stderr = patch.communicate(input=delta.data)[1]\n        ret = patch.wait()\n        output = open(basefile.name, 'r').read()\n        os.unlink(basefile.name)\n        if ret >> 8 != 0:\n            logger.error(\"Error applying diff %s: %s\" % (delta.name, stderr))\n            raise Bcfg2.Server.Plugin.PluginExecutionError('delta', delta)\n        return output\n\nclass CfgMatcher:\n    def __init__(self, fname):\n        name = re.escape(fname)\n        self.basefile_reg = re.compile('^(?P<basename>%s)(|\\\\.H_(?P<hostname>\\S+)|.G(?P<prio>\\d+)_(?P<group>\\S+))$' % name)\n        self.delta_reg = re.compile('^(?P<basename>%s)(|\\\\.H_(?P<hostname>\\S+)|\\\\.G(?P<prio>\\d+)_(?P<group>\\S+))\\\\.(?P<delta>(cat|diff))$' % name)\n        self.cat_count = fname.count(\".cat\")\n        self.diff_count = fname.count(\".diff\")\n\n    def match(self, fname):\n        if fname.count(\".cat\") > self.cat_count \\\n               or fname.count('.diff') > self.diff_count:\n            return self.delta_reg.match(fname)\n        return self.basefile_reg.match(fname)\n\nclass CfgEntrySet(Bcfg2.Server.Plugin.EntrySet):\n    def __init__(self, basename, path, entry_type, encoding):\n        Bcfg2.Server.Plugin.EntrySet.__init__(self, basename, path,\n                                              entry_type, encoding)\n        self.specific = CfgMatcher(path.split('/')[-1])\n\n    def sort_by_specific(self, one, other):\n        return cmp(one.specific, other.specific)\n\n    def get_pertinent_entries(self, metadata):\n        '''return a list of all entries pertinent to a client => [base, delta1, delta2]'''\n        matching = [ent for ent in self.entries.values() if \\\n                    ent.specific.matches(metadata)]\n        matching.sort(self.sort_by_specific)\n        non_delta = [matching.index(m) for m in matching if not m.specific.delta]\n        if not non_delta:\n            raise Bcfg2.Server.Plugin.PluginExecutionError\n        base = min(non_delta)\n        used = matching[:base+1]\n        used.reverse()\n        return used\n\n    def bind_entry(self, entry, metadata):\n        self.bind_info_to_entry(entry, metadata)\n        used = self.get_pertinent_entries(metadata)\n        basefile = used.pop(0)\n        data = basefile.data\n        if entry.tag == 'Path':\n            entry.set('type', 'file')\n        for delta in used:\n            data = data.strip()\n            data = process_delta(data, delta)\n        if used:\n            data += '\\n'\n        if entry.get('encoding') == 'base64':\n            entry.text = binascii.b2a_base64(data)\n        else:\n            entry.text = unicode(data, self.encoding)\n        if entry.text in ['', None]:\n            entry.set('empty', 'true')\n\n    def list_accept_choices(self, metadata):\n        '''return a list of candidate pull locations'''\n        used = self.get_pertinent_entries(metadata)\n        ret = []\n        if used:\n            ret.append(used[0].specific)\n        if not ret[0].hostname:\n            ret.append(Bcfg2.Server.Plugin.Specificity(hostname=metadata.hostname))\n        return ret\n\n    def build_filename(self, specific):\n        bfname = self.path + '/' + self.path.split('/')[-1]\n        if specific.all:\n            return bfname\n        elif specific.group:\n            return \"%s.G%d_%s\" % (bfname, specific.prio, specific.group)\n        elif specific.hostname:\n            return \"%s.H_%s\" % (bfname, specific.hostname)\n\n    def write_update(self, specific, new_entry, log):\n        if 'text' in new_entry:\n            name = self.build_filename(specific)\n            open(name, 'w').write(new_entry['text'])\n            if log:\n                logger.info(\"Wrote file %s\" % name)\n        badattr = [attr for attr in ['owner', 'group', 'perms'] if attr in new_entry]\n        if badattr:\n            metadata_updates = {}\n            metadata_updates.update(self.metadata)\n            for attr in badattr:\n                metadata_updates[attr] = new_entry.get(attr)\n            if self.infoxml:\n                infoxml = lxml.etree.Element('FileInfo')\n                infotag = lxml.etree.SubElement(infoxml, 'Info')\n                [infotag.attrib.__setitem__(attr, metadata_updates[attr]) \\\n                    for attr in metadata_updates]\n                ofile = open(self.path + \"/info.xml\",\"w\")\n                ofile.write(lxml.etree.tostring(infoxml, pretty_print=True))\n                ofile.close()\n                if log:\n                    logger.info(\"Wrote file %s\" % (self.path + \"/info.xml\"))\n            else:\n                infofile = open(self.path + '/:info', 'w')\n                for x in metadata_updates.iteritems():\n                    infofile.write(\"%s: %s\\n\" % x)\n                infofile.close()\n                if log:\n                    logger.info(\"Wrote file %s\" % infofile.name)\n\nclass Cfg(Bcfg2.Server.Plugin.GroupSpool,\n          Bcfg2.Server.Plugin.PullTarget):\n    \"\"\"This generator in the configuration file repository for Bcfg2.\"\"\"\n    name = 'Cfg'\n    __version__ = '$Id$'\n    __author__ = 'bcfg-dev@mcs.anl.gov'\n    es_cls = CfgEntrySet\n    es_child_cls = Bcfg2.Server.Plugin.SpecificData\n\n    def AcceptChoices(self, entry, metadata):\n        return self.entries[entry.get('name')].list_accept_choices(metadata)\n\n    def AcceptPullData(self, specific, new_entry, log):\n        return self.entries[new_entry.get('name')].write_update(specific, new_entry, log)\n", "import os\nfrom mercurial import ui, hg\nimport Bcfg2.Server.Plugin\n\n# for debugging output only\nimport logging\nlogger = logging.getLogger('Bcfg2.Plugins.Mercurial')\n\nclass Hg(Bcfg2.Server.Plugin.Plugin,\n             Bcfg2.Server.Plugin.Version):\n    \"\"\"Mercurial is a version plugin for dealing with Bcfg2 repository.\"\"\"\n    name = 'Mercurial'\n    __version__ = '$Id$'\n    __author__ = 'bcfg-dev@mcs.anl.gov'\n    experimental = True\n\n    def __init__(self, core, datastore):\n        Bcfg2.Server.Plugin.Plugin.__init__(self, core, datastore)\n        Bcfg2.Server.Plugin.Version.__init__(self)\n        self.core = core\n        self.datastore = datastore\n\n        # path to hg directory for Bcfg2 repo\n        hg_dir = \"%s/.hg\" % datastore\n\n        # Read changeset from bcfg2 repo\n        if os.path.isdir(hg_dir):\n            self.get_revision()\n        else:\n            logger.error(\"%s is not present.\" % hg_dir)\n            raise Bcfg2.Server.Plugin.PluginInitError\n\n        logger.debug(\"Initialized hg plugin with hg directory = %s\" % hg_dir)\n\n    def get_revision(self):\n        \"\"\"Read hg revision information for the Bcfg2 repository.\"\"\"\n        try:\n            repo_path = \"%s/\" % self.datastore\n            repo = hg.repository(ui.ui(), repo_path)\n            tip = repo.changelog.tip()\n            revision = repo.changelog.rev(tip)\n        except:\n            logger.error(\"Failed to read hg repository; disabling mercurial support\")\n            raise Bcfg2.Server.Plugin.PluginInitError\n        return revision\n\n", "'''This module manages ssh key files for bcfg2'''\n__revision__ = '$Revision$'\n\nimport binascii\nimport os\nimport sys\nimport socket\nimport shutil\nimport tempfile\nfrom subprocess import Popen, PIPE\nimport Bcfg2.Server.Plugin\n\n\nclass SSHbase(Bcfg2.Server.Plugin.Plugin,\n              Bcfg2.Server.Plugin.Generator,\n              Bcfg2.Server.Plugin.DirectoryBacked,\n              Bcfg2.Server.Plugin.PullTarget):\n    \"\"\"\n       The sshbase generator manages ssh host keys (both v1 and v2)\n       for hosts.  It also manages the ssh_known_hosts file. It can\n       integrate host keys from other management domains and similarly\n       export its keys. The repository contains files in the following\n       formats:\n\n       ssh_host_key.H_(hostname) -> the v1 host private key for\n         (hostname)\n       ssh_host_key.pub.H_(hostname) -> the v1 host public key\n         for (hostname)\n       ssh_host_(dr)sa_key.H_(hostname) -> the v2 ssh host\n         private key for (hostname)\n       ssh_host_(dr)sa_key.pub.H_(hostname) -> the v2 ssh host\n         public key for (hostname)\n       ssh_known_hosts -> the current known hosts file. this\n         is regenerated each time a new key is generated.\n\n    \"\"\"\n    name = 'SSHbase'\n    __version__ = '$Id$'\n    __author__ = 'bcfg-dev@mcs.anl.gov'\n\n    pubkeys = [\"ssh_host_dsa_key.pub.H_%s\",\n                \"ssh_host_rsa_key.pub.H_%s\", \"ssh_host_key.pub.H_%s\"]\n    hostkeys = [\"ssh_host_dsa_key.H_%s\",\n                \"ssh_host_rsa_key.H_%s\", \"ssh_host_key.H_%s\"]\n    keypatterns = ['ssh_host_dsa_key', 'ssh_host_rsa_key', 'ssh_host_key',\n                   'ssh_host_dsa_key.pub', 'ssh_host_rsa_key.pub',\n                   'ssh_host_key.pub']\n\n    def __init__(self, core, datastore):\n        Bcfg2.Server.Plugin.Plugin.__init__(self, core, datastore)\n        Bcfg2.Server.Plugin.Generator.__init__(self)\n        Bcfg2.Server.Plugin.PullTarget.__init__(self)\n        try:\n            Bcfg2.Server.Plugin.DirectoryBacked.__init__(self, self.data,\n                                                         self.core.fam)\n        except OSError, ioerr:\n            self.logger.error(\"Failed to load SSHbase repository from %s\" \\\n                              % (self.data))\n            self.logger.error(ioerr)\n            raise Bcfg2.Server.Plugin.PluginInitError\n        self.Entries = {'Path':\n                        {'/etc/ssh/ssh_known_hosts': self.build_skn,\n                         '/etc/ssh/ssh_host_dsa_key': self.build_hk,\n                         '/etc/ssh/ssh_host_rsa_key': self.build_hk,\n                         '/etc/ssh/ssh_host_dsa_key.pub': self.build_hk,\n                         '/etc/ssh/ssh_host_rsa_key.pub': self.build_hk,\n                         '/etc/ssh/ssh_host_key': self.build_hk,\n                         '/etc/ssh/ssh_host_key.pub': self.build_hk}}\n        self.ipcache = {}\n        self.namecache = {}\n        self.__skn = False\n\n    def get_skn(self):\n        \"\"\"Build memory cache of the ssh known hosts file.\"\"\"\n        if not self.__skn:\n            self.__skn = \"\\n\".join([value.data for key, value in \\\n                                    self.entries.iteritems() if \\\n                                    key.endswith('.static')])\n            names = dict()\n            # if no metadata is registered yet, defer\n            if len(self.core.metadata.query.all()) == 0:\n                self.__skn = False\n                return self.__skn\n            for cmeta in self.core.metadata.query.all():\n                names[cmeta.hostname] = set([cmeta.hostname])\n                names[cmeta.hostname].update(cmeta.aliases)\n                newnames = set()\n                newips = set()\n                for name in names[cmeta.hostname]:\n                    newnames.add(name.split('.')[0])\n                    try:\n                        newips.add(self.get_ipcache_entry(name)[0])\n                    except:\n                        continue\n                names[cmeta.hostname].update(newnames)\n                names[cmeta.hostname].update(cmeta.addresses)\n                names[cmeta.hostname].update(newips)\n                # TODO: Only perform reverse lookups on IPs if an option is set.\n                if True:\n                    for ip in newips:\n                        try:\n                            names[cmeta.hostname].update(self.get_namecache_entry(ip))\n                        except:\n                            continue\n                names[cmeta.hostname] = sorted(names[cmeta.hostname])\n            # now we have our name cache\n            pubkeys = [pubk for pubk in self.entries.keys() \\\n                       if pubk.find('.pub.H_') != -1]\n            pubkeys.sort()\n            badnames = set()\n            for pubkey in pubkeys:\n                hostname = pubkey.split('H_')[1]\n                if hostname not in names:\n                    if hostname not in badnames:\n                        badnames.add(hostname)\n                        self.logger.error(\"SSHbase: Unknown host %s; ignoring public keys\" % hostname)\n                    continue\n                self.__skn += \"%s %s\" % (','.join(names[hostname]),\n                                         self.entries[pubkey].data)\n        return self.__skn\n\n    def set_skn(self, value):\n        \"\"\"Set backing data for skn.\"\"\"\n        self.__skn = value\n    skn = property(get_skn, set_skn)\n\n    def HandleEvent(self, event=None):\n        \"\"\"Local event handler that does skn regen on pubkey change.\"\"\"\n        Bcfg2.Server.Plugin.DirectoryBacked.HandleEvent(self, event)\n        if event and '_key.pub.H_' in event.filename:\n            self.skn = False\n        if event and event.filename.endswith('.static'):\n            self.skn = False\n        if not self.__skn:\n            if (len(self.entries.keys())) >= (len(os.listdir(self.data))-1):\n                _ = self.skn\n\n    def HandlesEntry(self, entry, _):\n        \"\"\"Handle key entries dynamically.\"\"\"\n        return entry.tag == 'Path' and \\\n               ([fpat for fpat in self.keypatterns\n                 if entry.get('name').endswith(fpat)]\n                or entry.get('name').endswith('ssh_known_hosts'))\n\n    def HandleEntry(self, entry, metadata):\n        \"\"\"Bind data.\"\"\"\n        if entry.get('name').endswith('ssh_known_hosts'):\n            return self.build_skn(entry, metadata)\n        else:\n            return self.build_hk(entry, metadata)\n\n    def get_ipcache_entry(self, client):\n        \"\"\"Build a cache of dns results.\"\"\"\n        if client in self.ipcache:\n            if self.ipcache[client]:\n                return self.ipcache[client]\n            else:\n                raise socket.gaierror\n        else:\n            # need to add entry\n            try:\n                ipaddr = socket.gethostbyname(client)\n                self.ipcache[client] = (ipaddr, client)\n                return (ipaddr, client)\n            except socket.gaierror:\n                ipaddr = Popen([\"getent\", \"hosts\", client],\n                               stdout=PIPE).stdout.read().strip().split()\n                if ipaddr:\n                    self.ipcache[client] = (ipaddr, client)\n                    return (ipaddr, client)\n                self.ipcache[client] = False\n                self.logger.error(\"Failed to find IP address for %s\" % client)\n                raise socket.gaierror\n\n    def get_namecache_entry(self, cip):\n        \"\"\"Build a cache of name lookups from client IP addresses.\"\"\"\n        if cip in self.namecache:\n            # lookup cached name from IP\n            if self.namecache[cip]:\n                return self.namecache[cip]\n            else:\n                raise socket.gaierror\n        else:\n            # add an entry that has not been cached\n            try:\n                rvlookup = socket.gethostbyaddr(cip)\n                if rvlookup[0]:\n                    self.namecache[cip] = [rvlookup[0]]\n                else:\n                    self.namecache[cip] = []\n                self.namecache[cip].extend(rvlookup[1])\n                return self.namecache[cip]\n            except socket.gaierror:\n                self.namecache[cip] = False\n                self.logger.error(\"Failed to find any names associated with IP address %s\" % cip)\n                raise\n\n    def build_skn(self, entry, metadata):\n        \"\"\"This function builds builds a host specific known_hosts file.\"\"\"\n        client = metadata.hostname\n        entry.text = self.skn\n        hostkeys = [keytmpl % client for keytmpl in self.pubkeys \\\n                        if (keytmpl % client) in self.entries]\n        hostkeys.sort()\n        for hostkey in hostkeys:\n            entry.text += \"localhost,localhost.localdomain,127.0.0.1 %s\" % (\n                self.entries[hostkey].data)\n        permdata = {'owner':'root',\n                    'group':'root',\n                    'type':'file',\n                    'perms':'0644'}\n        [entry.attrib.__setitem__(key, permdata[key]) for key in permdata]\n\n    def build_hk(self, entry, metadata):\n        \"\"\"This binds host key data into entries.\"\"\"\n        client = metadata.hostname\n        filename = \"%s.H_%s\" % (entry.get('name').split('/')[-1], client)\n        if filename not in self.entries.keys():\n            self.GenerateHostKeys(client)\n        if not filename in self.entries:\n            self.logger.error(\"%s still not registered\" % filename)\n            raise Bcfg2.Server.Plugin.PluginExecutionError\n        keydata = self.entries[filename].data\n        permdata = {'owner':'root',\n                    'group':'root',\n                    'type':'file',\n                    'perms':'0600'}\n        if entry.get('name')[-4:] == '.pub':\n            permdata['perms'] = '0644'\n        [entry.attrib.__setitem__(key, permdata[key]) for key in permdata]\n        if \"ssh_host_key.H_\" == filename[:15]:\n            entry.attrib['encoding'] = 'base64'\n            entry.text = binascii.b2a_base64(keydata)\n        else:\n            entry.text = keydata\n\n    def GenerateHostKeys(self, client):\n        \"\"\"Generate new host keys for client.\"\"\"\n        keylist = [keytmpl % client for keytmpl in self.hostkeys]\n        for hostkey in keylist:\n            if 'ssh_host_rsa_key.H_' == hostkey[:19]:\n                keytype = 'rsa'\n            elif 'ssh_host_dsa_key.H_' == hostkey[:19]:\n                keytype = 'dsa'\n            else:\n                keytype = 'rsa1'\n\n            if hostkey not in self.entries.keys():\n                fileloc = \"%s/%s\" % (self.data, hostkey)\n                publoc = self.data + '/' + \".\".join([hostkey.split('.')[0],\n                                                     'pub',\n                                                     \"H_%s\" % client])\n                tempdir = tempfile.mkdtemp()\n                temploc = \"%s/%s\" % (tempdir, hostkey)\n                cmd = [\"ssh-keygen\", \"-q\", \"-f\", temploc, \"-N\", \"\",\n                       \"-t\", keytype, \"-C\", \"root@%s\" % client]\n                proc = Popen(cmd, stdout=PIPE, stdin=PIPE)\n                proc.communicate()\n                proc.wait()\n\n                try:\n                    shutil.copy(temploc, fileloc)\n                    shutil.copy(\"%s.pub\" % temploc, publoc)\n                except IOError:\n                    err = sys.exc_info()[1]\n                    self.logger.error(\"Temporary SSH keys not found: %s\" % err)\n                try:\n                    os.unlink(temploc)\n                    os.unlink(\"%s.pub\" % temploc)\n                    os.rmdir(tempdir)\n                except OSError:\n                    err = sys.exc_info()[1]\n                    self.logger.error(\"Failed to unlink temporary ssh keys: %s\"\n                                      % err)\n\n    def AcceptChoices(self, _, metadata):\n        return [Bcfg2.Server.Plugin.Specificity(hostname=metadata.hostname)]\n\n    def AcceptPullData(self, specific, entry, log):\n        \"\"\"Per-plugin bcfg2-admin pull support.\"\"\"\n        # specific will always be host specific\n        filename = \"%s/%s.H_%s\" % (self.data, entry['name'].split('/')[-1],\n                                   specific.hostname)\n        open(filename, 'w').write(entry['text'])\n        if log:\n            print \"Wrote file %s\" % filename\n", "import os\nimport pipes\nfrom subprocess import Popen, PIPE\nimport Bcfg2.Server.Plugin\n\n# for debugging output only\nimport logging\nlogger = logging.getLogger('Bcfg2.Plugins.Svn')\n\n\nclass Svn(Bcfg2.Server.Plugin.Plugin,\n          Bcfg2.Server.Plugin.Version):\n    \"\"\"Svn is a version plugin for dealing with Bcfg2 repos.\"\"\"\n    name = 'Svn'\n    __version__ = '$Id$'\n    __author__ = 'bcfg-dev@mcs.anl.gov'\n\n    def __init__(self, core, datastore):\n        Bcfg2.Server.Plugin.Plugin.__init__(self, core, datastore)\n        self.core = core\n        self.datastore = datastore\n\n        # path to svn directory for bcfg2 repo\n        svn_dir = \"%s/.svn\" % datastore\n\n        # Read revision from bcfg2 repo\n        if os.path.isdir(svn_dir):\n            self.get_revision()\n        else:\n            logger.error(\"%s is not a directory\" % svn_dir)\n            raise Bcfg2.Server.Plugin.PluginInitError\n\n        logger.debug(\"Initialized svn plugin with svn directory = %s\" % svn_dir)\n\n    def get_revision(self):\n        \"\"\"Read svn revision information for the Bcfg2 repository.\"\"\"\n        try:\n            data = Popen((\"env LC_ALL=C svn info %s\" %\n                         pipes.quote(self.datastore)), shell=True,\n                         stdout=PIPE).communicate()[0].split('\\n')\n            return [line.split(': ')[1] for line in data \\\n                    if line[:9] == 'Revision:'][-1]\n        except IndexError:\n            logger.error(\"Failed to read svn info; disabling svn support\")\n            logger.error('''Ran command \"svn info %s\"''' % (self.datastore))\n            logger.error(\"Got output: %s\" % data)\n            raise Bcfg2.Server.Plugin.PluginInitError\n"], "filenames": ["src/lib/Server/Admin/Viz.py", "src/lib/Server/Plugins/Cfg.py", "src/lib/Server/Plugins/Hg.py", "src/lib/Server/Plugins/SSHbase.py", "src/lib/Server/Plugins/Svn.py"], "buggy_code_start_loc": [2, 9, 3, 5, 1], "buggy_code_end_loc": [81, 46, 4, 268, 39], "fixing_code_start_loc": [3, 10, 2, 6, 2], "fixing_code_end_loc": [93, 46, 2, 275, 40], "type": "CWE-20", "message": "The server in Bcfg2 1.1.2 and earlier, and 1.2 prerelease, allows remote attackers to execute arbitrary commands via shell metacharacters in data received from a client.", "other": {"cve": {"id": "CVE-2011-3211", "sourceIdentifier": "secalert@redhat.com", "published": "2011-09-16T12:35:13.573", "lastModified": "2011-09-23T03:34:34.677", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The server in Bcfg2 1.1.2 and earlier, and 1.2 prerelease, allows remote attackers to execute arbitrary commands via shell metacharacters in data received from a client."}, {"lang": "es", "value": "El servidor en Bcfg2 1.1.2 y versiones anteriores, y 1.2 prerelease, permite a atacantes remotos ejecutar comandos arbitrarios a trav\u00e9s de meta-caracteres de shell en datos recibidos del cliente."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1.2", "matchCriteriaId": "77A928D8-07DE-4B90-AA9E-92DCEC76CFFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "887E6F86-C2E3-4C99-A221-4DA23AFEB670"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.4:*:*:*:*:*:*:*", "matchCriteriaId": "7A6AD1D6-A82B-4755-A6F3-3F2880BCC58C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "B2A17178-D13C-4C7A-AA8D-57FD0504DBC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "EDEC3F72-1EF4-4019-A4D5-22435A53C969"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "8F9DDADC-7ED2-40B7-A7BF-59C6EA76682B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "3ED2D839-B25E-4CA4-B482-A7930515776F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "EE8C9539-9F13-4A2B-AEF2-790A30E6B4F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "6DA64795-89BF-454F-AF68-11748F37BBD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "E2918A6E-E9AD-4C75-B348-ED6F4F69264C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "21315AD3-773A-470E-A201-D5184A84DC87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "E136795E-7FE9-4EEC-9D5C-81F3CCBEFB3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "384A9EA5-63D3-4B66-A53B-B31F6716F265"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "5A1DEE63-F95C-409C-9063-A89CF9AB6023"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "62523B2D-4412-45AF-B0EC-E6E00F711F74"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "32729C3F-2D4C-4EA3-B44A-9E04020D4D67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "A25D6157-5431-4A6C-80C9-C3DEDFBB3C30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "EECD2B05-2497-4B40-939B-46539F9F91B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "292F346B-DC6F-4FBF-B2B9-860122B1CC98"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "735F5DD0-0E9F-4A75-8528-71B23C08EE3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "7CFFE471-CF69-40C6-ACEB-5D7EFDB3A882"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "5953E395-69E9-49CA-BC04-15E083E27230"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "C02A1EA0-1AB6-4D3F-9295-CEE9FA48D6FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "0247382E-5E59-4D86-8AD3-790E46FF4A1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "AAC82467-8528-458A-9AA8-9ADB42554F02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.8.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "E1D64218-1FCC-4587-8839-B72C6681FBC1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "0F387C3A-D7B2-4308-9CAE-9F425DDF3C34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.8.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "9523B97E-89F6-42AA-BF35-2F2D14111C5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.8.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "C13577D8-DF81-4583-AE44-BDC28FC7FF90"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "035CB0CB-5BD9-49D5-AAFA-6FA6DE6A304B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.1d:*:*:*:*:*:*:*", "matchCriteriaId": "E94EDC70-1E55-4EE0-9D4F-D651860A747E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "2286469A-B930-494E-A149-C93C002DE829"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "EFFA6DF0-48D2-4A74-B4A6-96461BCD2032"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "FDAFDE21-457F-4940-B5DA-C82BDE33E276"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "6DD0755D-F58B-4145-A415-423872DE2666"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "75752F84-08E8-4CD9-84FA-6270D5D32B16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "473AC1DE-E521-4281-8F9D-ED1402518644"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "09447F81-211B-49E0-907E-4ECAD0F83883"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "F3DA85BD-68AD-408E-8376-520896DF3E85"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "A06908AC-9F4A-4FA5-BC70-73B9D65B6B3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:0.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A67B14D0-0824-417F-AB98-09FB0DB9DBF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:1.0:pre1:*:*:*:*:*:*", "matchCriteriaId": "93070B16-C4EC-43C0-B7AC-780B0726E603"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:1.0:pre2:*:*:*:*:*:*", "matchCriteriaId": "2C2B2EBC-C594-422A-AFBF-E533449F06B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:1.0:pre4:*:*:*:*:*:*", "matchCriteriaId": "0D35FC9A-9B30-478A-81F7-282AE84FA331"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "41654280-40DE-4D8D-BB30-E4EB30B6C1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "548B1801-0D47-4C9C-A408-3186189D1FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "9F7508FC-2FA3-484A-98E7-F4B5436F1944"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "500BD528-099E-447D-BD5F-0D7AEA8540FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bcfg2:bcfg2:1.2:prerelease:*:*:*:*:*:*", "matchCriteriaId": "04CB1E12-2E59-42CE-AABE-CDC470A20B6E"}]}]}], "references": [{"url": "http://article.gmane.org/gmane.comp.sysutils.bcfg2.devel/4318", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=640028", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-September/066070.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-September/066071.html", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/09/01/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2011/09/06/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.debian.org/security/2011/dsa-2302", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/49414", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=736279", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/solj/bcfg2/commit/46795ae451ca6ede55a0edeb726978aef4684b53", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/solj/bcfg2/commit/f4a35efec1b6a1e54d61cf1b8bfc83dd1d89eef7", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/solj/bcfg2/commit/46795ae451ca6ede55a0edeb726978aef4684b53"}}