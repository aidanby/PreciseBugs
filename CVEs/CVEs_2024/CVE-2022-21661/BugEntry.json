{"buggy_code": ["<?php\n/**\n * Taxonomy API: WP_Tax_Query class\n *\n * @package WordPress\n * @subpackage Taxonomy\n * @since 4.4.0\n */\n\n/**\n * Core class used to implement taxonomy queries for the Taxonomy API.\n *\n * Used for generating SQL clauses that filter a primary query according to object\n * taxonomy terms.\n *\n * WP_Tax_Query is a helper that allows primary query classes, such as WP_Query, to filter\n * their results by object metadata, by generating `JOIN` and `WHERE` subclauses to be\n * attached to the primary SQL query string.\n *\n * @since 3.1.0\n */\nclass WP_Tax_Query {\n\n\t/**\n\t * Array of taxonomy queries.\n\t *\n\t * See WP_Tax_Query::__construct() for information on tax query arguments.\n\t *\n\t * @since 3.1.0\n\t * @var array\n\t */\n\tpublic $queries = array();\n\n\t/**\n\t * The relation between the queries. Can be one of 'AND' or 'OR'.\n\t *\n\t * @since 3.1.0\n\t * @var string\n\t */\n\tpublic $relation;\n\n\t/**\n\t * Standard response when the query should not return any rows.\n\t *\n\t * @since 3.2.0\n\t * @var string\n\t */\n\tprivate static $no_results = array(\n\t\t'join'  => array( '' ),\n\t\t'where' => array( '0 = 1' ),\n\t);\n\n\t/**\n\t * A flat list of table aliases used in the JOIN clauses.\n\t *\n\t * @since 4.1.0\n\t * @var array\n\t */\n\tprotected $table_aliases = array();\n\n\t/**\n\t * Terms and taxonomies fetched by this query.\n\t *\n\t * We store this data in a flat array because they are referenced in a\n\t * number of places by WP_Query.\n\t *\n\t * @since 4.1.0\n\t * @var array\n\t */\n\tpublic $queried_terms = array();\n\n\t/**\n\t * Database table that where the metadata's objects are stored (eg $wpdb->users).\n\t *\n\t * @since 4.1.0\n\t * @var string\n\t */\n\tpublic $primary_table;\n\n\t/**\n\t * Column in 'primary_table' that represents the ID of the object.\n\t *\n\t * @since 4.1.0\n\t * @var string\n\t */\n\tpublic $primary_id_column;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 3.1.0\n\t * @since 4.1.0 Added support for `$operator` 'NOT EXISTS' and 'EXISTS' values.\n\t *\n\t * @param array $tax_query {\n\t *     Array of taxonomy query clauses.\n\t *\n\t *     @type string $relation Optional. The MySQL keyword used to join\n\t *                            the clauses of the query. Accepts 'AND', or 'OR'. Default 'AND'.\n\t *     @type array  ...$0 {\n\t *         An array of first-order clause parameters, or another fully-formed tax query.\n\t *\n\t *         @type string           $taxonomy         Taxonomy being queried. Optional when field=term_taxonomy_id.\n\t *         @type string|int|array $terms            Term or terms to filter by.\n\t *         @type string           $field            Field to match $terms against. Accepts 'term_id', 'slug',\n\t *                                                 'name', or 'term_taxonomy_id'. Default: 'term_id'.\n\t *         @type string           $operator         MySQL operator to be used with $terms in the WHERE clause.\n\t *                                                  Accepts 'AND', 'IN', 'NOT IN', 'EXISTS', 'NOT EXISTS'.\n\t *                                                  Default: 'IN'.\n\t *         @type bool             $include_children Optional. Whether to include child terms.\n\t *                                                  Requires a $taxonomy. Default: true.\n\t *     }\n\t * }\n\t */\n\tpublic function __construct( $tax_query ) {\n\t\tif ( isset( $tax_query['relation'] ) ) {\n\t\t\t$this->relation = $this->sanitize_relation( $tax_query['relation'] );\n\t\t} else {\n\t\t\t$this->relation = 'AND';\n\t\t}\n\n\t\t$this->queries = $this->sanitize_query( $tax_query );\n\t}\n\n\t/**\n\t * Ensure the 'tax_query' argument passed to the class constructor is well-formed.\n\t *\n\t * Ensures that each query-level clause has a 'relation' key, and that\n\t * each first-order clause contains all the necessary keys from `$defaults`.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @param array $queries Array of queries clauses.\n\t * @return array Sanitized array of query clauses.\n\t */\n\tpublic function sanitize_query( $queries ) {\n\t\t$cleaned_query = array();\n\n\t\t$defaults = array(\n\t\t\t'taxonomy'         => '',\n\t\t\t'terms'            => array(),\n\t\t\t'field'            => 'term_id',\n\t\t\t'operator'         => 'IN',\n\t\t\t'include_children' => true,\n\t\t);\n\n\t\tforeach ( $queries as $key => $query ) {\n\t\t\tif ( 'relation' === $key ) {\n\t\t\t\t$cleaned_query['relation'] = $this->sanitize_relation( $query );\n\n\t\t\t\t// First-order clause.\n\t\t\t} elseif ( self::is_first_order_clause( $query ) ) {\n\n\t\t\t\t$cleaned_clause          = array_merge( $defaults, $query );\n\t\t\t\t$cleaned_clause['terms'] = (array) $cleaned_clause['terms'];\n\t\t\t\t$cleaned_query[]         = $cleaned_clause;\n\n\t\t\t\t/*\n\t\t\t\t * Keep a copy of the clause in the flate\n\t\t\t\t * $queried_terms array, for use in WP_Query.\n\t\t\t\t */\n\t\t\t\tif ( ! empty( $cleaned_clause['taxonomy'] ) && 'NOT IN' !== $cleaned_clause['operator'] ) {\n\t\t\t\t\t$taxonomy = $cleaned_clause['taxonomy'];\n\t\t\t\t\tif ( ! isset( $this->queried_terms[ $taxonomy ] ) ) {\n\t\t\t\t\t\t$this->queried_terms[ $taxonomy ] = array();\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Backward compatibility: Only store the first\n\t\t\t\t\t * 'terms' and 'field' found for a given taxonomy.\n\t\t\t\t\t */\n\t\t\t\t\tif ( ! empty( $cleaned_clause['terms'] ) && ! isset( $this->queried_terms[ $taxonomy ]['terms'] ) ) {\n\t\t\t\t\t\t$this->queried_terms[ $taxonomy ]['terms'] = $cleaned_clause['terms'];\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! empty( $cleaned_clause['field'] ) && ! isset( $this->queried_terms[ $taxonomy ]['field'] ) ) {\n\t\t\t\t\t\t$this->queried_terms[ $taxonomy ]['field'] = $cleaned_clause['field'];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, it's a nested query, so we recurse.\n\t\t\t} elseif ( is_array( $query ) ) {\n\t\t\t\t$cleaned_subquery = $this->sanitize_query( $query );\n\n\t\t\t\tif ( ! empty( $cleaned_subquery ) ) {\n\t\t\t\t\t// All queries with children must have a relation.\n\t\t\t\t\tif ( ! isset( $cleaned_subquery['relation'] ) ) {\n\t\t\t\t\t\t$cleaned_subquery['relation'] = 'AND';\n\t\t\t\t\t}\n\n\t\t\t\t\t$cleaned_query[] = $cleaned_subquery;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $cleaned_query;\n\t}\n\n\t/**\n\t * Sanitize a 'relation' operator.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @param string $relation Raw relation key from the query argument.\n\t * @return string Sanitized relation ('AND' or 'OR').\n\t */\n\tpublic function sanitize_relation( $relation ) {\n\t\tif ( 'OR' === strtoupper( $relation ) ) {\n\t\t\treturn 'OR';\n\t\t} else {\n\t\t\treturn 'AND';\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether a clause is first-order.\n\t *\n\t * A \"first-order\" clause is one that contains any of the first-order\n\t * clause keys ('terms', 'taxonomy', 'include_children', 'field',\n\t * 'operator'). An empty clause also counts as a first-order clause,\n\t * for backward compatibility. Any clause that doesn't meet this is\n\t * determined, by process of elimination, to be a higher-order query.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @param array $query Tax query arguments.\n\t * @return bool Whether the query clause is a first-order clause.\n\t */\n\tprotected static function is_first_order_clause( $query ) {\n\t\treturn is_array( $query ) && ( empty( $query ) || array_key_exists( 'terms', $query ) || array_key_exists( 'taxonomy', $query ) || array_key_exists( 'include_children', $query ) || array_key_exists( 'field', $query ) || array_key_exists( 'operator', $query ) );\n\t}\n\n\t/**\n\t * Generates SQL clauses to be appended to a main query.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param string $primary_table     Database table where the object being filtered is stored (eg wp_users).\n\t * @param string $primary_id_column ID column for the filtered object in $primary_table.\n\t * @return array {\n\t *     Array containing JOIN and WHERE SQL clauses to append to the main query.\n\t *\n\t *     @type string $join  SQL fragment to append to the main JOIN clause.\n\t *     @type string $where SQL fragment to append to the main WHERE clause.\n\t * }\n\t */\n\tpublic function get_sql( $primary_table, $primary_id_column ) {\n\t\t$this->primary_table     = $primary_table;\n\t\t$this->primary_id_column = $primary_id_column;\n\n\t\treturn $this->get_sql_clauses();\n\t}\n\n\t/**\n\t * Generate SQL clauses to be appended to a main query.\n\t *\n\t * Called by the public WP_Tax_Query::get_sql(), this method\n\t * is abstracted out to maintain parity with the other Query classes.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @return array {\n\t *     Array containing JOIN and WHERE SQL clauses to append to the main query.\n\t *\n\t *     @type string $join  SQL fragment to append to the main JOIN clause.\n\t *     @type string $where SQL fragment to append to the main WHERE clause.\n\t * }\n\t */\n\tprotected function get_sql_clauses() {\n\t\t/*\n\t\t * $queries are passed by reference to get_sql_for_query() for recursion.\n\t\t * To keep $this->queries unaltered, pass a copy.\n\t\t */\n\t\t$queries = $this->queries;\n\t\t$sql     = $this->get_sql_for_query( $queries );\n\n\t\tif ( ! empty( $sql['where'] ) ) {\n\t\t\t$sql['where'] = ' AND ' . $sql['where'];\n\t\t}\n\n\t\treturn $sql;\n\t}\n\n\t/**\n\t * Generate SQL clauses for a single query array.\n\t *\n\t * If nested subqueries are found, this method recurses the tree to\n\t * produce the properly nested SQL.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @param array $query Query to parse (passed by reference).\n\t * @param int   $depth Optional. Number of tree levels deep we currently are.\n\t *                     Used to calculate indentation. Default 0.\n\t * @return array {\n\t *     Array containing JOIN and WHERE SQL clauses to append to a single query array.\n\t *\n\t *     @type string $join  SQL fragment to append to the main JOIN clause.\n\t *     @type string $where SQL fragment to append to the main WHERE clause.\n\t * }\n\t */\n\tprotected function get_sql_for_query( &$query, $depth = 0 ) {\n\t\t$sql_chunks = array(\n\t\t\t'join'  => array(),\n\t\t\t'where' => array(),\n\t\t);\n\n\t\t$sql = array(\n\t\t\t'join'  => '',\n\t\t\t'where' => '',\n\t\t);\n\n\t\t$indent = '';\n\t\tfor ( $i = 0; $i < $depth; $i++ ) {\n\t\t\t$indent .= '  ';\n\t\t}\n\n\t\tforeach ( $query as $key => &$clause ) {\n\t\t\tif ( 'relation' === $key ) {\n\t\t\t\t$relation = $query['relation'];\n\t\t\t} elseif ( is_array( $clause ) ) {\n\n\t\t\t\t// This is a first-order clause.\n\t\t\t\tif ( $this->is_first_order_clause( $clause ) ) {\n\t\t\t\t\t$clause_sql = $this->get_sql_for_clause( $clause, $query );\n\n\t\t\t\t\t$where_count = count( $clause_sql['where'] );\n\t\t\t\t\tif ( ! $where_count ) {\n\t\t\t\t\t\t$sql_chunks['where'][] = '';\n\t\t\t\t\t} elseif ( 1 === $where_count ) {\n\t\t\t\t\t\t$sql_chunks['where'][] = $clause_sql['where'][0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$sql_chunks['where'][] = '( ' . implode( ' AND ', $clause_sql['where'] ) . ' )';\n\t\t\t\t\t}\n\n\t\t\t\t\t$sql_chunks['join'] = array_merge( $sql_chunks['join'], $clause_sql['join'] );\n\t\t\t\t\t// This is a subquery, so we recurse.\n\t\t\t\t} else {\n\t\t\t\t\t$clause_sql = $this->get_sql_for_query( $clause, $depth + 1 );\n\n\t\t\t\t\t$sql_chunks['where'][] = $clause_sql['where'];\n\t\t\t\t\t$sql_chunks['join'][]  = $clause_sql['join'];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filter to remove empties.\n\t\t$sql_chunks['join']  = array_filter( $sql_chunks['join'] );\n\t\t$sql_chunks['where'] = array_filter( $sql_chunks['where'] );\n\n\t\tif ( empty( $relation ) ) {\n\t\t\t$relation = 'AND';\n\t\t}\n\n\t\t// Filter duplicate JOIN clauses and combine into a single string.\n\t\tif ( ! empty( $sql_chunks['join'] ) ) {\n\t\t\t$sql['join'] = implode( ' ', array_unique( $sql_chunks['join'] ) );\n\t\t}\n\n\t\t// Generate a single WHERE clause with proper brackets and indentation.\n\t\tif ( ! empty( $sql_chunks['where'] ) ) {\n\t\t\t$sql['where'] = '( ' . \"\\n  \" . $indent . implode( ' ' . \"\\n  \" . $indent . $relation . ' ' . \"\\n  \" . $indent, $sql_chunks['where'] ) . \"\\n\" . $indent . ')';\n\t\t}\n\n\t\treturn $sql;\n\t}\n\n\t/**\n\t * Generate SQL JOIN and WHERE clauses for a \"first-order\" query clause.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @global wpdb $wpdb The WordPress database abstraction object.\n\t *\n\t * @param array $clause       Query clause (passed by reference).\n\t * @param array $parent_query Parent query array.\n\t * @return array {\n\t *     Array containing JOIN and WHERE SQL clauses to append to a first-order query.\n\t *\n\t *     @type string $join  SQL fragment to append to the main JOIN clause.\n\t *     @type string $where SQL fragment to append to the main WHERE clause.\n\t * }\n\t */\n\tpublic function get_sql_for_clause( &$clause, $parent_query ) {\n\t\tglobal $wpdb;\n\n\t\t$sql = array(\n\t\t\t'where' => array(),\n\t\t\t'join'  => array(),\n\t\t);\n\n\t\t$join  = '';\n\t\t$where = '';\n\n\t\t$this->clean_query( $clause );\n\n\t\tif ( is_wp_error( $clause ) ) {\n\t\t\treturn self::$no_results;\n\t\t}\n\n\t\t$terms    = $clause['terms'];\n\t\t$operator = strtoupper( $clause['operator'] );\n\n\t\tif ( 'IN' === $operator ) {\n\n\t\t\tif ( empty( $terms ) ) {\n\t\t\t\treturn self::$no_results;\n\t\t\t}\n\n\t\t\t$terms = implode( ',', $terms );\n\n\t\t\t/*\n\t\t\t * Before creating another table join, see if this clause has a\n\t\t\t * sibling with an existing join that can be shared.\n\t\t\t */\n\t\t\t$alias = $this->find_compatible_table_alias( $clause, $parent_query );\n\t\t\tif ( false === $alias ) {\n\t\t\t\t$i     = count( $this->table_aliases );\n\t\t\t\t$alias = $i ? 'tt' . $i : $wpdb->term_relationships;\n\n\t\t\t\t// Store the alias as part of a flat array to build future iterators.\n\t\t\t\t$this->table_aliases[] = $alias;\n\n\t\t\t\t// Store the alias with this clause, so later siblings can use it.\n\t\t\t\t$clause['alias'] = $alias;\n\n\t\t\t\t$join .= \" LEFT JOIN $wpdb->term_relationships\";\n\t\t\t\t$join .= $i ? \" AS $alias\" : '';\n\t\t\t\t$join .= \" ON ($this->primary_table.$this->primary_id_column = $alias.object_id)\";\n\t\t\t}\n\n\t\t\t$where = \"$alias.term_taxonomy_id $operator ($terms)\";\n\n\t\t} elseif ( 'NOT IN' === $operator ) {\n\n\t\t\tif ( empty( $terms ) ) {\n\t\t\t\treturn $sql;\n\t\t\t}\n\n\t\t\t$terms = implode( ',', $terms );\n\n\t\t\t$where = \"$this->primary_table.$this->primary_id_column NOT IN (\n\t\t\t\tSELECT object_id\n\t\t\t\tFROM $wpdb->term_relationships\n\t\t\t\tWHERE term_taxonomy_id IN ($terms)\n\t\t\t)\";\n\n\t\t} elseif ( 'AND' === $operator ) {\n\n\t\t\tif ( empty( $terms ) ) {\n\t\t\t\treturn $sql;\n\t\t\t}\n\n\t\t\t$num_terms = count( $terms );\n\n\t\t\t$terms = implode( ',', $terms );\n\n\t\t\t$where = \"(\n\t\t\t\tSELECT COUNT(1)\n\t\t\t\tFROM $wpdb->term_relationships\n\t\t\t\tWHERE term_taxonomy_id IN ($terms)\n\t\t\t\tAND object_id = $this->primary_table.$this->primary_id_column\n\t\t\t) = $num_terms\";\n\n\t\t} elseif ( 'NOT EXISTS' === $operator || 'EXISTS' === $operator ) {\n\n\t\t\t$where = $wpdb->prepare(\n\t\t\t\t\"$operator (\n\t\t\t\tSELECT 1\n\t\t\t\tFROM $wpdb->term_relationships\n\t\t\t\tINNER JOIN $wpdb->term_taxonomy\n\t\t\t\tON $wpdb->term_taxonomy.term_taxonomy_id = $wpdb->term_relationships.term_taxonomy_id\n\t\t\t\tWHERE $wpdb->term_taxonomy.taxonomy = %s\n\t\t\t\tAND $wpdb->term_relationships.object_id = $this->primary_table.$this->primary_id_column\n\t\t\t)\",\n\t\t\t\t$clause['taxonomy']\n\t\t\t);\n\n\t\t}\n\n\t\t$sql['join'][]  = $join;\n\t\t$sql['where'][] = $where;\n\t\treturn $sql;\n\t}\n\n\t/**\n\t * Identify an existing table alias that is compatible with the current query clause.\n\t *\n\t * We avoid unnecessary table joins by allowing each clause to look for\n\t * an existing table alias that is compatible with the query that it\n\t * needs to perform.\n\t *\n\t * An existing alias is compatible if (a) it is a sibling of `$clause`\n\t * (ie, it's under the scope of the same relation), and (b) the combination\n\t * of operator and relation between the clauses allows for a shared table\n\t * join. In the case of WP_Tax_Query, this only applies to 'IN'\n\t * clauses that are connected by the relation 'OR'.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @param array $clause       Query clause.\n\t * @param array $parent_query Parent query of $clause.\n\t * @return string|false Table alias if found, otherwise false.\n\t */\n\tprotected function find_compatible_table_alias( $clause, $parent_query ) {\n\t\t$alias = false;\n\n\t\t// Sanity check. Only IN queries use the JOIN syntax.\n\t\tif ( ! isset( $clause['operator'] ) || 'IN' !== $clause['operator'] ) {\n\t\t\treturn $alias;\n\t\t}\n\n\t\t// Since we're only checking IN queries, we're only concerned with OR relations.\n\t\tif ( ! isset( $parent_query['relation'] ) || 'OR' !== $parent_query['relation'] ) {\n\t\t\treturn $alias;\n\t\t}\n\n\t\t$compatible_operators = array( 'IN' );\n\n\t\tforeach ( $parent_query as $sibling ) {\n\t\t\tif ( ! is_array( $sibling ) || ! $this->is_first_order_clause( $sibling ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( empty( $sibling['alias'] ) || empty( $sibling['operator'] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The sibling must both have compatible operator to share its alias.\n\t\t\tif ( in_array( strtoupper( $sibling['operator'] ), $compatible_operators, true ) ) {\n\t\t\t\t$alias = $sibling['alias'];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn $alias;\n\t}\n\n\t/**\n\t * Validates a single query.\n\t *\n\t * @since 3.2.0\n\t *\n\t * @param array $query The single query. Passed by reference.\n\t */\n\tprivate function clean_query( &$query ) {\n\t\tif ( empty( $query['taxonomy'] ) ) {\n\t\t\tif ( 'term_taxonomy_id' !== $query['field'] ) {\n\t\t\t\t$query = new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// So long as there are shared terms, 'include_children' requires that a taxonomy is set.\n\t\t\t$query['include_children'] = false;\n\t\t} elseif ( ! taxonomy_exists( $query['taxonomy'] ) ) {\n\t\t\t$query = new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );\n\t\t\treturn;\n\t\t}\n\n\t\t$query['terms'] = array_unique( (array) $query['terms'] );\n\n\t\tif ( is_taxonomy_hierarchical( $query['taxonomy'] ) && $query['include_children'] ) {\n\t\t\t$this->transform_query( $query, 'term_id' );\n\n\t\t\tif ( is_wp_error( $query ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$children = array();\n\t\t\tforeach ( $query['terms'] as $term ) {\n\t\t\t\t$children   = array_merge( $children, get_term_children( $term, $query['taxonomy'] ) );\n\t\t\t\t$children[] = $term;\n\t\t\t}\n\t\t\t$query['terms'] = $children;\n\t\t}\n\n\t\t$this->transform_query( $query, 'term_taxonomy_id' );\n\t}\n\n\t/**\n\t * Transforms a single query, from one field to another.\n\t *\n\t * Operates on the `$query` object by reference. In the case of error,\n\t * `$query` is converted to a WP_Error object.\n\t *\n\t * @since 3.2.0\n\t *\n\t * @global wpdb $wpdb The WordPress database abstraction object.\n\t *\n\t * @param array  $query           The single query. Passed by reference.\n\t * @param string $resulting_field The resulting field. Accepts 'slug', 'name', 'term_taxonomy_id',\n\t *                                or 'term_id'. Default 'term_id'.\n\t */\n\tpublic function transform_query( &$query, $resulting_field ) {\n\t\tif ( empty( $query['terms'] ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( $query['field'] == $resulting_field ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$resulting_field = sanitize_key( $resulting_field );\n\n\t\t// Empty 'terms' always results in a null transformation.\n\t\t$terms = array_filter( $query['terms'] );\n\t\tif ( empty( $terms ) ) {\n\t\t\t$query['terms'] = array();\n\t\t\t$query['field'] = $resulting_field;\n\t\t\treturn;\n\t\t}\n\n\t\t$args = array(\n\t\t\t'get'                    => 'all',\n\t\t\t'number'                 => 0,\n\t\t\t'taxonomy'               => $query['taxonomy'],\n\t\t\t'update_term_meta_cache' => false,\n\t\t\t'orderby'                => 'none',\n\t\t);\n\n\t\t// Term query parameter name depends on the 'field' being searched on.\n\t\tswitch ( $query['field'] ) {\n\t\t\tcase 'slug':\n\t\t\t\t$args['slug'] = $terms;\n\t\t\t\tbreak;\n\t\t\tcase 'name':\n\t\t\t\t$args['name'] = $terms;\n\t\t\t\tbreak;\n\t\t\tcase 'term_taxonomy_id':\n\t\t\t\t$args['term_taxonomy_id'] = $terms;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$args['include'] = wp_parse_id_list( $terms );\n\t\t\t\tbreak;\n\t\t}\n\n\t\t$term_query = new WP_Term_Query();\n\t\t$term_list  = $term_query->query( $args );\n\n\t\tif ( is_wp_error( $term_list ) ) {\n\t\t\t$query = $term_list;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( 'AND' === $query['operator'] && count( $term_list ) < count( $query['terms'] ) ) {\n\t\t\t$query = new WP_Error( 'inexistent_terms', __( 'Inexistent terms.' ) );\n\t\t\treturn;\n\t\t}\n\n\t\t$query['terms'] = wp_list_pluck( $term_list, $resulting_field );\n\t\t$query['field'] = $resulting_field;\n\t}\n}\n"], "fixing_code": ["<?php\n/**\n * Taxonomy API: WP_Tax_Query class\n *\n * @package WordPress\n * @subpackage Taxonomy\n * @since 4.4.0\n */\n\n/**\n * Core class used to implement taxonomy queries for the Taxonomy API.\n *\n * Used for generating SQL clauses that filter a primary query according to object\n * taxonomy terms.\n *\n * WP_Tax_Query is a helper that allows primary query classes, such as WP_Query, to filter\n * their results by object metadata, by generating `JOIN` and `WHERE` subclauses to be\n * attached to the primary SQL query string.\n *\n * @since 3.1.0\n */\nclass WP_Tax_Query {\n\n\t/**\n\t * Array of taxonomy queries.\n\t *\n\t * See WP_Tax_Query::__construct() for information on tax query arguments.\n\t *\n\t * @since 3.1.0\n\t * @var array\n\t */\n\tpublic $queries = array();\n\n\t/**\n\t * The relation between the queries. Can be one of 'AND' or 'OR'.\n\t *\n\t * @since 3.1.0\n\t * @var string\n\t */\n\tpublic $relation;\n\n\t/**\n\t * Standard response when the query should not return any rows.\n\t *\n\t * @since 3.2.0\n\t * @var string\n\t */\n\tprivate static $no_results = array(\n\t\t'join'  => array( '' ),\n\t\t'where' => array( '0 = 1' ),\n\t);\n\n\t/**\n\t * A flat list of table aliases used in the JOIN clauses.\n\t *\n\t * @since 4.1.0\n\t * @var array\n\t */\n\tprotected $table_aliases = array();\n\n\t/**\n\t * Terms and taxonomies fetched by this query.\n\t *\n\t * We store this data in a flat array because they are referenced in a\n\t * number of places by WP_Query.\n\t *\n\t * @since 4.1.0\n\t * @var array\n\t */\n\tpublic $queried_terms = array();\n\n\t/**\n\t * Database table that where the metadata's objects are stored (eg $wpdb->users).\n\t *\n\t * @since 4.1.0\n\t * @var string\n\t */\n\tpublic $primary_table;\n\n\t/**\n\t * Column in 'primary_table' that represents the ID of the object.\n\t *\n\t * @since 4.1.0\n\t * @var string\n\t */\n\tpublic $primary_id_column;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @since 3.1.0\n\t * @since 4.1.0 Added support for `$operator` 'NOT EXISTS' and 'EXISTS' values.\n\t *\n\t * @param array $tax_query {\n\t *     Array of taxonomy query clauses.\n\t *\n\t *     @type string $relation Optional. The MySQL keyword used to join\n\t *                            the clauses of the query. Accepts 'AND', or 'OR'. Default 'AND'.\n\t *     @type array  ...$0 {\n\t *         An array of first-order clause parameters, or another fully-formed tax query.\n\t *\n\t *         @type string           $taxonomy         Taxonomy being queried. Optional when field=term_taxonomy_id.\n\t *         @type string|int|array $terms            Term or terms to filter by.\n\t *         @type string           $field            Field to match $terms against. Accepts 'term_id', 'slug',\n\t *                                                 'name', or 'term_taxonomy_id'. Default: 'term_id'.\n\t *         @type string           $operator         MySQL operator to be used with $terms in the WHERE clause.\n\t *                                                  Accepts 'AND', 'IN', 'NOT IN', 'EXISTS', 'NOT EXISTS'.\n\t *                                                  Default: 'IN'.\n\t *         @type bool             $include_children Optional. Whether to include child terms.\n\t *                                                  Requires a $taxonomy. Default: true.\n\t *     }\n\t * }\n\t */\n\tpublic function __construct( $tax_query ) {\n\t\tif ( isset( $tax_query['relation'] ) ) {\n\t\t\t$this->relation = $this->sanitize_relation( $tax_query['relation'] );\n\t\t} else {\n\t\t\t$this->relation = 'AND';\n\t\t}\n\n\t\t$this->queries = $this->sanitize_query( $tax_query );\n\t}\n\n\t/**\n\t * Ensure the 'tax_query' argument passed to the class constructor is well-formed.\n\t *\n\t * Ensures that each query-level clause has a 'relation' key, and that\n\t * each first-order clause contains all the necessary keys from `$defaults`.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @param array $queries Array of queries clauses.\n\t * @return array Sanitized array of query clauses.\n\t */\n\tpublic function sanitize_query( $queries ) {\n\t\t$cleaned_query = array();\n\n\t\t$defaults = array(\n\t\t\t'taxonomy'         => '',\n\t\t\t'terms'            => array(),\n\t\t\t'field'            => 'term_id',\n\t\t\t'operator'         => 'IN',\n\t\t\t'include_children' => true,\n\t\t);\n\n\t\tforeach ( $queries as $key => $query ) {\n\t\t\tif ( 'relation' === $key ) {\n\t\t\t\t$cleaned_query['relation'] = $this->sanitize_relation( $query );\n\n\t\t\t\t// First-order clause.\n\t\t\t} elseif ( self::is_first_order_clause( $query ) ) {\n\n\t\t\t\t$cleaned_clause          = array_merge( $defaults, $query );\n\t\t\t\t$cleaned_clause['terms'] = (array) $cleaned_clause['terms'];\n\t\t\t\t$cleaned_query[]         = $cleaned_clause;\n\n\t\t\t\t/*\n\t\t\t\t * Keep a copy of the clause in the flate\n\t\t\t\t * $queried_terms array, for use in WP_Query.\n\t\t\t\t */\n\t\t\t\tif ( ! empty( $cleaned_clause['taxonomy'] ) && 'NOT IN' !== $cleaned_clause['operator'] ) {\n\t\t\t\t\t$taxonomy = $cleaned_clause['taxonomy'];\n\t\t\t\t\tif ( ! isset( $this->queried_terms[ $taxonomy ] ) ) {\n\t\t\t\t\t\t$this->queried_terms[ $taxonomy ] = array();\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Backward compatibility: Only store the first\n\t\t\t\t\t * 'terms' and 'field' found for a given taxonomy.\n\t\t\t\t\t */\n\t\t\t\t\tif ( ! empty( $cleaned_clause['terms'] ) && ! isset( $this->queried_terms[ $taxonomy ]['terms'] ) ) {\n\t\t\t\t\t\t$this->queried_terms[ $taxonomy ]['terms'] = $cleaned_clause['terms'];\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! empty( $cleaned_clause['field'] ) && ! isset( $this->queried_terms[ $taxonomy ]['field'] ) ) {\n\t\t\t\t\t\t$this->queried_terms[ $taxonomy ]['field'] = $cleaned_clause['field'];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, it's a nested query, so we recurse.\n\t\t\t} elseif ( is_array( $query ) ) {\n\t\t\t\t$cleaned_subquery = $this->sanitize_query( $query );\n\n\t\t\t\tif ( ! empty( $cleaned_subquery ) ) {\n\t\t\t\t\t// All queries with children must have a relation.\n\t\t\t\t\tif ( ! isset( $cleaned_subquery['relation'] ) ) {\n\t\t\t\t\t\t$cleaned_subquery['relation'] = 'AND';\n\t\t\t\t\t}\n\n\t\t\t\t\t$cleaned_query[] = $cleaned_subquery;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $cleaned_query;\n\t}\n\n\t/**\n\t * Sanitize a 'relation' operator.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @param string $relation Raw relation key from the query argument.\n\t * @return string Sanitized relation ('AND' or 'OR').\n\t */\n\tpublic function sanitize_relation( $relation ) {\n\t\tif ( 'OR' === strtoupper( $relation ) ) {\n\t\t\treturn 'OR';\n\t\t} else {\n\t\t\treturn 'AND';\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether a clause is first-order.\n\t *\n\t * A \"first-order\" clause is one that contains any of the first-order\n\t * clause keys ('terms', 'taxonomy', 'include_children', 'field',\n\t * 'operator'). An empty clause also counts as a first-order clause,\n\t * for backward compatibility. Any clause that doesn't meet this is\n\t * determined, by process of elimination, to be a higher-order query.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @param array $query Tax query arguments.\n\t * @return bool Whether the query clause is a first-order clause.\n\t */\n\tprotected static function is_first_order_clause( $query ) {\n\t\treturn is_array( $query ) && ( empty( $query ) || array_key_exists( 'terms', $query ) || array_key_exists( 'taxonomy', $query ) || array_key_exists( 'include_children', $query ) || array_key_exists( 'field', $query ) || array_key_exists( 'operator', $query ) );\n\t}\n\n\t/**\n\t * Generates SQL clauses to be appended to a main query.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param string $primary_table     Database table where the object being filtered is stored (eg wp_users).\n\t * @param string $primary_id_column ID column for the filtered object in $primary_table.\n\t * @return array {\n\t *     Array containing JOIN and WHERE SQL clauses to append to the main query.\n\t *\n\t *     @type string $join  SQL fragment to append to the main JOIN clause.\n\t *     @type string $where SQL fragment to append to the main WHERE clause.\n\t * }\n\t */\n\tpublic function get_sql( $primary_table, $primary_id_column ) {\n\t\t$this->primary_table     = $primary_table;\n\t\t$this->primary_id_column = $primary_id_column;\n\n\t\treturn $this->get_sql_clauses();\n\t}\n\n\t/**\n\t * Generate SQL clauses to be appended to a main query.\n\t *\n\t * Called by the public WP_Tax_Query::get_sql(), this method\n\t * is abstracted out to maintain parity with the other Query classes.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @return array {\n\t *     Array containing JOIN and WHERE SQL clauses to append to the main query.\n\t *\n\t *     @type string $join  SQL fragment to append to the main JOIN clause.\n\t *     @type string $where SQL fragment to append to the main WHERE clause.\n\t * }\n\t */\n\tprotected function get_sql_clauses() {\n\t\t/*\n\t\t * $queries are passed by reference to get_sql_for_query() for recursion.\n\t\t * To keep $this->queries unaltered, pass a copy.\n\t\t */\n\t\t$queries = $this->queries;\n\t\t$sql     = $this->get_sql_for_query( $queries );\n\n\t\tif ( ! empty( $sql['where'] ) ) {\n\t\t\t$sql['where'] = ' AND ' . $sql['where'];\n\t\t}\n\n\t\treturn $sql;\n\t}\n\n\t/**\n\t * Generate SQL clauses for a single query array.\n\t *\n\t * If nested subqueries are found, this method recurses the tree to\n\t * produce the properly nested SQL.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @param array $query Query to parse (passed by reference).\n\t * @param int   $depth Optional. Number of tree levels deep we currently are.\n\t *                     Used to calculate indentation. Default 0.\n\t * @return array {\n\t *     Array containing JOIN and WHERE SQL clauses to append to a single query array.\n\t *\n\t *     @type string $join  SQL fragment to append to the main JOIN clause.\n\t *     @type string $where SQL fragment to append to the main WHERE clause.\n\t * }\n\t */\n\tprotected function get_sql_for_query( &$query, $depth = 0 ) {\n\t\t$sql_chunks = array(\n\t\t\t'join'  => array(),\n\t\t\t'where' => array(),\n\t\t);\n\n\t\t$sql = array(\n\t\t\t'join'  => '',\n\t\t\t'where' => '',\n\t\t);\n\n\t\t$indent = '';\n\t\tfor ( $i = 0; $i < $depth; $i++ ) {\n\t\t\t$indent .= '  ';\n\t\t}\n\n\t\tforeach ( $query as $key => &$clause ) {\n\t\t\tif ( 'relation' === $key ) {\n\t\t\t\t$relation = $query['relation'];\n\t\t\t} elseif ( is_array( $clause ) ) {\n\n\t\t\t\t// This is a first-order clause.\n\t\t\t\tif ( $this->is_first_order_clause( $clause ) ) {\n\t\t\t\t\t$clause_sql = $this->get_sql_for_clause( $clause, $query );\n\n\t\t\t\t\t$where_count = count( $clause_sql['where'] );\n\t\t\t\t\tif ( ! $where_count ) {\n\t\t\t\t\t\t$sql_chunks['where'][] = '';\n\t\t\t\t\t} elseif ( 1 === $where_count ) {\n\t\t\t\t\t\t$sql_chunks['where'][] = $clause_sql['where'][0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$sql_chunks['where'][] = '( ' . implode( ' AND ', $clause_sql['where'] ) . ' )';\n\t\t\t\t\t}\n\n\t\t\t\t\t$sql_chunks['join'] = array_merge( $sql_chunks['join'], $clause_sql['join'] );\n\t\t\t\t\t// This is a subquery, so we recurse.\n\t\t\t\t} else {\n\t\t\t\t\t$clause_sql = $this->get_sql_for_query( $clause, $depth + 1 );\n\n\t\t\t\t\t$sql_chunks['where'][] = $clause_sql['where'];\n\t\t\t\t\t$sql_chunks['join'][]  = $clause_sql['join'];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filter to remove empties.\n\t\t$sql_chunks['join']  = array_filter( $sql_chunks['join'] );\n\t\t$sql_chunks['where'] = array_filter( $sql_chunks['where'] );\n\n\t\tif ( empty( $relation ) ) {\n\t\t\t$relation = 'AND';\n\t\t}\n\n\t\t// Filter duplicate JOIN clauses and combine into a single string.\n\t\tif ( ! empty( $sql_chunks['join'] ) ) {\n\t\t\t$sql['join'] = implode( ' ', array_unique( $sql_chunks['join'] ) );\n\t\t}\n\n\t\t// Generate a single WHERE clause with proper brackets and indentation.\n\t\tif ( ! empty( $sql_chunks['where'] ) ) {\n\t\t\t$sql['where'] = '( ' . \"\\n  \" . $indent . implode( ' ' . \"\\n  \" . $indent . $relation . ' ' . \"\\n  \" . $indent, $sql_chunks['where'] ) . \"\\n\" . $indent . ')';\n\t\t}\n\n\t\treturn $sql;\n\t}\n\n\t/**\n\t * Generate SQL JOIN and WHERE clauses for a \"first-order\" query clause.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @global wpdb $wpdb The WordPress database abstraction object.\n\t *\n\t * @param array $clause       Query clause (passed by reference).\n\t * @param array $parent_query Parent query array.\n\t * @return array {\n\t *     Array containing JOIN and WHERE SQL clauses to append to a first-order query.\n\t *\n\t *     @type string $join  SQL fragment to append to the main JOIN clause.\n\t *     @type string $where SQL fragment to append to the main WHERE clause.\n\t * }\n\t */\n\tpublic function get_sql_for_clause( &$clause, $parent_query ) {\n\t\tglobal $wpdb;\n\n\t\t$sql = array(\n\t\t\t'where' => array(),\n\t\t\t'join'  => array(),\n\t\t);\n\n\t\t$join  = '';\n\t\t$where = '';\n\n\t\t$this->clean_query( $clause );\n\n\t\tif ( is_wp_error( $clause ) ) {\n\t\t\treturn self::$no_results;\n\t\t}\n\n\t\t$terms    = $clause['terms'];\n\t\t$operator = strtoupper( $clause['operator'] );\n\n\t\tif ( 'IN' === $operator ) {\n\n\t\t\tif ( empty( $terms ) ) {\n\t\t\t\treturn self::$no_results;\n\t\t\t}\n\n\t\t\t$terms = implode( ',', $terms );\n\n\t\t\t/*\n\t\t\t * Before creating another table join, see if this clause has a\n\t\t\t * sibling with an existing join that can be shared.\n\t\t\t */\n\t\t\t$alias = $this->find_compatible_table_alias( $clause, $parent_query );\n\t\t\tif ( false === $alias ) {\n\t\t\t\t$i     = count( $this->table_aliases );\n\t\t\t\t$alias = $i ? 'tt' . $i : $wpdb->term_relationships;\n\n\t\t\t\t// Store the alias as part of a flat array to build future iterators.\n\t\t\t\t$this->table_aliases[] = $alias;\n\n\t\t\t\t// Store the alias with this clause, so later siblings can use it.\n\t\t\t\t$clause['alias'] = $alias;\n\n\t\t\t\t$join .= \" LEFT JOIN $wpdb->term_relationships\";\n\t\t\t\t$join .= $i ? \" AS $alias\" : '';\n\t\t\t\t$join .= \" ON ($this->primary_table.$this->primary_id_column = $alias.object_id)\";\n\t\t\t}\n\n\t\t\t$where = \"$alias.term_taxonomy_id $operator ($terms)\";\n\n\t\t} elseif ( 'NOT IN' === $operator ) {\n\n\t\t\tif ( empty( $terms ) ) {\n\t\t\t\treturn $sql;\n\t\t\t}\n\n\t\t\t$terms = implode( ',', $terms );\n\n\t\t\t$where = \"$this->primary_table.$this->primary_id_column NOT IN (\n\t\t\t\tSELECT object_id\n\t\t\t\tFROM $wpdb->term_relationships\n\t\t\t\tWHERE term_taxonomy_id IN ($terms)\n\t\t\t)\";\n\n\t\t} elseif ( 'AND' === $operator ) {\n\n\t\t\tif ( empty( $terms ) ) {\n\t\t\t\treturn $sql;\n\t\t\t}\n\n\t\t\t$num_terms = count( $terms );\n\n\t\t\t$terms = implode( ',', $terms );\n\n\t\t\t$where = \"(\n\t\t\t\tSELECT COUNT(1)\n\t\t\t\tFROM $wpdb->term_relationships\n\t\t\t\tWHERE term_taxonomy_id IN ($terms)\n\t\t\t\tAND object_id = $this->primary_table.$this->primary_id_column\n\t\t\t) = $num_terms\";\n\n\t\t} elseif ( 'NOT EXISTS' === $operator || 'EXISTS' === $operator ) {\n\n\t\t\t$where = $wpdb->prepare(\n\t\t\t\t\"$operator (\n\t\t\t\tSELECT 1\n\t\t\t\tFROM $wpdb->term_relationships\n\t\t\t\tINNER JOIN $wpdb->term_taxonomy\n\t\t\t\tON $wpdb->term_taxonomy.term_taxonomy_id = $wpdb->term_relationships.term_taxonomy_id\n\t\t\t\tWHERE $wpdb->term_taxonomy.taxonomy = %s\n\t\t\t\tAND $wpdb->term_relationships.object_id = $this->primary_table.$this->primary_id_column\n\t\t\t)\",\n\t\t\t\t$clause['taxonomy']\n\t\t\t);\n\n\t\t}\n\n\t\t$sql['join'][]  = $join;\n\t\t$sql['where'][] = $where;\n\t\treturn $sql;\n\t}\n\n\t/**\n\t * Identify an existing table alias that is compatible with the current query clause.\n\t *\n\t * We avoid unnecessary table joins by allowing each clause to look for\n\t * an existing table alias that is compatible with the query that it\n\t * needs to perform.\n\t *\n\t * An existing alias is compatible if (a) it is a sibling of `$clause`\n\t * (ie, it's under the scope of the same relation), and (b) the combination\n\t * of operator and relation between the clauses allows for a shared table\n\t * join. In the case of WP_Tax_Query, this only applies to 'IN'\n\t * clauses that are connected by the relation 'OR'.\n\t *\n\t * @since 4.1.0\n\t *\n\t * @param array $clause       Query clause.\n\t * @param array $parent_query Parent query of $clause.\n\t * @return string|false Table alias if found, otherwise false.\n\t */\n\tprotected function find_compatible_table_alias( $clause, $parent_query ) {\n\t\t$alias = false;\n\n\t\t// Sanity check. Only IN queries use the JOIN syntax.\n\t\tif ( ! isset( $clause['operator'] ) || 'IN' !== $clause['operator'] ) {\n\t\t\treturn $alias;\n\t\t}\n\n\t\t// Since we're only checking IN queries, we're only concerned with OR relations.\n\t\tif ( ! isset( $parent_query['relation'] ) || 'OR' !== $parent_query['relation'] ) {\n\t\t\treturn $alias;\n\t\t}\n\n\t\t$compatible_operators = array( 'IN' );\n\n\t\tforeach ( $parent_query as $sibling ) {\n\t\t\tif ( ! is_array( $sibling ) || ! $this->is_first_order_clause( $sibling ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( empty( $sibling['alias'] ) || empty( $sibling['operator'] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The sibling must both have compatible operator to share its alias.\n\t\t\tif ( in_array( strtoupper( $sibling['operator'] ), $compatible_operators, true ) ) {\n\t\t\t\t$alias = $sibling['alias'];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn $alias;\n\t}\n\n\t/**\n\t * Validates a single query.\n\t *\n\t * @since 3.2.0\n\t *\n\t * @param array $query The single query. Passed by reference.\n\t */\n\tprivate function clean_query( &$query ) {\n\t\tif ( empty( $query['taxonomy'] ) ) {\n\t\t\tif ( 'term_taxonomy_id' !== $query['field'] ) {\n\t\t\t\t$query = new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// So long as there are shared terms, 'include_children' requires that a taxonomy is set.\n\t\t\t$query['include_children'] = false;\n\t\t} elseif ( ! taxonomy_exists( $query['taxonomy'] ) ) {\n\t\t\t$query = new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( 'slug' === $query['field'] || 'name' === $query['field'] ) {\n\t\t\t$query['terms'] = array_unique( (array) $query['terms'] );\n\t\t} else {\n\t\t\t$query['terms'] = wp_parse_id_list( $query['terms'] );\n\t\t}\n\n\t\tif ( is_taxonomy_hierarchical( $query['taxonomy'] ) && $query['include_children'] ) {\n\t\t\t$this->transform_query( $query, 'term_id' );\n\n\t\t\tif ( is_wp_error( $query ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$children = array();\n\t\t\tforeach ( $query['terms'] as $term ) {\n\t\t\t\t$children   = array_merge( $children, get_term_children( $term, $query['taxonomy'] ) );\n\t\t\t\t$children[] = $term;\n\t\t\t}\n\t\t\t$query['terms'] = $children;\n\t\t}\n\n\t\t$this->transform_query( $query, 'term_taxonomy_id' );\n\t}\n\n\t/**\n\t * Transforms a single query, from one field to another.\n\t *\n\t * Operates on the `$query` object by reference. In the case of error,\n\t * `$query` is converted to a WP_Error object.\n\t *\n\t * @since 3.2.0\n\t *\n\t * @global wpdb $wpdb The WordPress database abstraction object.\n\t *\n\t * @param array  $query           The single query. Passed by reference.\n\t * @param string $resulting_field The resulting field. Accepts 'slug', 'name', 'term_taxonomy_id',\n\t *                                or 'term_id'. Default 'term_id'.\n\t */\n\tpublic function transform_query( &$query, $resulting_field ) {\n\t\tif ( empty( $query['terms'] ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( $query['field'] == $resulting_field ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$resulting_field = sanitize_key( $resulting_field );\n\n\t\t// Empty 'terms' always results in a null transformation.\n\t\t$terms = array_filter( $query['terms'] );\n\t\tif ( empty( $terms ) ) {\n\t\t\t$query['terms'] = array();\n\t\t\t$query['field'] = $resulting_field;\n\t\t\treturn;\n\t\t}\n\n\t\t$args = array(\n\t\t\t'get'                    => 'all',\n\t\t\t'number'                 => 0,\n\t\t\t'taxonomy'               => $query['taxonomy'],\n\t\t\t'update_term_meta_cache' => false,\n\t\t\t'orderby'                => 'none',\n\t\t);\n\n\t\t// Term query parameter name depends on the 'field' being searched on.\n\t\tswitch ( $query['field'] ) {\n\t\t\tcase 'slug':\n\t\t\t\t$args['slug'] = $terms;\n\t\t\t\tbreak;\n\t\t\tcase 'name':\n\t\t\t\t$args['name'] = $terms;\n\t\t\t\tbreak;\n\t\t\tcase 'term_taxonomy_id':\n\t\t\t\t$args['term_taxonomy_id'] = $terms;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$args['include'] = wp_parse_id_list( $terms );\n\t\t\t\tbreak;\n\t\t}\n\n\t\t$term_query = new WP_Term_Query();\n\t\t$term_list  = $term_query->query( $args );\n\n\t\tif ( is_wp_error( $term_list ) ) {\n\t\t\t$query = $term_list;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( 'AND' === $query['operator'] && count( $term_list ) < count( $query['terms'] ) ) {\n\t\t\t$query = new WP_Error( 'inexistent_terms', __( 'Inexistent terms.' ) );\n\t\t\treturn;\n\t\t}\n\n\t\t$query['terms'] = wp_list_pluck( $term_list, $resulting_field );\n\t\t$query['field'] = $resulting_field;\n\t}\n}\n"], "filenames": ["src/wp-includes/class-wp-tax-query.php"], "buggy_code_start_loc": [559], "buggy_code_end_loc": [560], "fixing_code_start_loc": [559], "fixing_code_end_loc": [564], "type": "CWE-89", "message": "WordPress is a free and open-source content management system written in PHP and paired with a MariaDB database. Due to improper sanitization in WP_Query, there can be cases where SQL injection is possible through plugins or themes that use it in a certain way. This has been patched in WordPress version 5.8.3. Older affected versions are also fixed via security release, that go back till 3.7.37. We strongly recommend that you keep auto-updates enabled. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2022-21661", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-06T23:15:07.933", "lastModified": "2022-04-12T18:47:13.057", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "WordPress is a free and open-source content management system written in PHP and paired with a MariaDB database. Due to improper sanitization in WP_Query, there can be cases where SQL injection is possible through plugins or themes that use it in a certain way. This has been patched in WordPress version 5.8.3. Older affected versions are also fixed via security release, that go back till 3.7.37. We strongly recommend that you keep auto-updates enabled. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "WordPress es un sistema de administraci\u00f3n de contenidos gratuito y de c\u00f3digo abierto escrito en PHP y emparejado con una base de datos MariaDB. Debido a un saneo inapropiado en WP_Query, puede haber casos en los que la inyecci\u00f3n SQL es posible mediante plugins o temas que lo usan de una manera determinada. Esto ha sido parcheado en WordPress versi\u00f3n 5.8.3. Las versiones m\u00e1s antiguas afectadas tambi\u00e9n han sido corregidas por medio de un security release, que remonta hasta la versi\u00f3n 3.7.37. Le recomendamos encarecidamente que mantenga habilitadas las actualizaciones autom\u00e1ticas. No se presentan medidas de mitigaci\u00f3n conocidas para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.8.3", "matchCriteriaId": "AE024D27-D244-464B-A640-FCE0FC7458D8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/165540/WordPress-Core-5.8.2-SQL-Injection.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/WordPress/wordpress-develop/commit/17efac8c8ec64555eff5cf51a3eff81e06317214", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/WordPress/wordpress-develop/security/advisories/GHSA-6676-cqfm-gw84", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/01/msg00019.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CV4UNEC63UU5GEU47IIR4RMTZAHNEOJG/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DM6XPH3JN6V4NF4WBOJTOXZIVE6VKKE3/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://wordpress.org/news/2022/01/wordpress-5-8-3-security-release/", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5039", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/50663", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.zerodayinitiative.com/advisories/ZDI-22-020/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/WordPress/wordpress-develop/commit/17efac8c8ec64555eff5cf51a3eff81e06317214"}}