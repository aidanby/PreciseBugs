{"buggy_code": ["/*\n * ncrx - extended netconsole receiver library\n *\n * Copyright (C) 2016, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the license found in the LICENSE file in\n * the root directory of this source tree.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/udp.h>\n\n#include \"ncrx.h\"\n\n/* oos history is tracked with a uint32_t */\n#define NCRX_OOS_MAX\t\t32\n\nstruct ncrx_msg_list {\n\tstruct ncrx_list\thead;\n\tint\t\t\tnr;\t\t/* number of msgs on the list */\n};\n\nstruct ncrx_slot {\n\tstruct ncrx_msg\t\t*msg;\n\tuint64_t\t\ttimestamp;\t/* last rx on this slot */\n\tuint64_t\t\tretx_timestamp;\t/* last retransmission */\n\tstruct ncrx_list\thole_node;\t/* anchored @ ncrx->hole_list */\n};\n\nstruct ncrx {\n\tstruct ncrx_param\tp;\n\n\tuint64_t\t\tnow_mono;\t/* latest time in msecs */\n\n\tint\t\t\thead;\t\t/* next slot to use */\n\tint\t\t\ttail;\t\t/* last slot in use */\n\tuint64_t\t\thead_seq;\t/* next expected seq, unset=0 */\n\tstruct ncrx_slot\t*slots;\t\t/* msg slots */\n\tstruct ncrx_list\thole_list;\t/* missing or !complete slots */\n\n\tuint32_t\t\toos_history;\t/* bit history of oos msgs */\n\tstruct ncrx_msg_list\toos_list;\t/* buffered oos msgs */\n\n\tstruct ncrx_msg_list\tretired_list;\t/* msgs to be fetched by user */\n\n\tuint64_t\t\tacked_seq;\t/* last seq acked, unset=max */\n\tuint64_t\t\tacked_at;\t/* and when */\n\n\t/* response buffer for ncrx_response() */\n\tchar\t\t\tresp_buf[NCRX_PKT_MAX + 1];\n\tint\t\t\tresp_len;\n};\n\nstatic const struct ncrx_param ncrx_dfl_param = {\n\t.nr_slots\t\t= NCRX_DFL_NR_SLOTS,\n\n\t.ack_intv\t\t= NCRX_DFL_ACK_INTV,\n\t.retx_intv\t\t= NCRX_DFL_RETX_INTV,\n\t.retx_stride\t\t= NCRX_DFL_RETX_STRIDE,\n\t.msg_timeout\t\t= NCRX_DFL_MSG_TIMEOUT,\n\n\t.oos_thr\t\t= NCRX_DFL_OOS_THR,\n\t.oos_intv\t\t= NCRX_DFL_OOS_INTV,\n\t.oos_timeout\t\t= NCRX_DFL_OOS_TIMEOUT,\n};\n\n/* utilities mostly stolen from kernel */\n#define min(x, y) ({\t\t\t\t\t\t\t\\\n\ttypeof(x) _min1 = (x);\t\t\t\t\t\t\\\n\ttypeof(y) _min2 = (y);\t\t\t\t\t\t\\\n\t(void) (&_min1 == &_min2);\t\t\t\t\t\\\n\t_min1 < _min2 ? _min1 : _min2; })\n\n#define max(x, y) ({\t\t\t\t\t\t\t\\\n\ttypeof(x) _max1 = (x);\t\t\t\t\t\t\\\n\ttypeof(y) _max2 = (y);\t\t\t\t\t\t\\\n\t(void) (&_max1 == &_max2);\t\t\t\t\t\\\n\t_max1 > _max2 ? _max1 : _max2; })\n\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n\n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tconst typeof( ((type *)0)->member ) *__mptr = (ptr);\t\t\\\n\t(type *)( (char *)__mptr - offsetof(type,member) );})\n\n/* ncrx_msg from its ->node */\n#define node_to_msg(ptr)\tcontainer_of(ptr, struct ncrx_msg, node)\n\n/* iterate msg_list */\n#define msg_list_for_each(pos, n, list)\t\t\t\t\t\\\n\tfor (pos = node_to_msg((list)->head.next),\t\t\t\\\n\t\t     n = node_to_msg(pos->node.next);\t\t\t\\\n\t     &pos->node != &(list)->head;\t\t\t\t\\\n\t     pos = n, n = node_to_msg(pos->node.next))\n\n/* ncrx_slot from its ->hole_node */\n#define hole_to_slot(ptr)\t\t\t\t\t\t\\\n\tcontainer_of(ptr, struct ncrx_slot, hole_node)\n\n/* iterate hole_list */\n#define hole_list_for_each(pos, n, list)\t\t\t\t\\\n\tfor (pos = hole_to_slot((list)->next),\t\t\t\t\\\n\t\t     n = hole_to_slot(pos->hole_node.next);\t\t\\\n\t     &pos->hole_node != (list);\t\t\t\t\t\\\n\t     pos = n, n = hole_to_slot(pos->hole_node.next))\n\nstatic unsigned int hweight32(uint32_t w)\n{\n\tw -= (w >> 1) & 0x55555555;\n\tw =  (w & 0x33333333) + ((w >> 2) & 0x33333333);\n\tw =  (w + (w >> 4)) & 0x0f0f0f0f;\n\treturn (w * 0x01010101) >> 24;\n}\n\nstatic void init_list(struct ncrx_list *head)\n{\n\thead->next = head;\n\thead->prev = head;\n}\n\nstatic int list_empty(struct ncrx_list *head)\n{\n\treturn head->next == head;\n}\n\nstatic void list_del(struct ncrx_list *head)\n{\n\tstruct ncrx_list *prev = head->prev;\n\tstruct ncrx_list *next = head->next;\n\n\tprev->next = next;\n\tnext->prev = prev;\n\tinit_list(head);\n}\n\nstatic void list_append(struct ncrx_list *node, struct ncrx_list *list)\n{\n\tstruct ncrx_list *prev = list->prev;\n\n\tassert(node->next == node && node->prev == node);\n\n\tnode->next = list;\n\tnode->prev = prev;\n\tprev->next = node;\n\tlist->prev = node;\n}\n\nstatic void msg_list_del(struct ncrx_msg *msg, struct ncrx_msg_list *list)\n{\n\tlist_del(&msg->node);\n\tlist->nr--;\n\n\tif (!list->nr)\n\t\tassert(list->head.next == &list->head &&\n\t\t       list->head.prev == &list->head);\n}\n\nstatic void msg_list_append(struct ncrx_msg *msg, struct ncrx_msg_list *list)\n{\n\tlist_append(&msg->node, &list->head);\n\tlist->nr++;\n}\n\nstatic struct ncrx_msg *msg_list_peek(struct ncrx_msg_list *list)\n{\n\tif (list_empty(&list->head))\n\t\treturn NULL;\n\treturn node_to_msg(list->head.next);\n}\n\nstatic struct ncrx_msg *msg_list_pop(struct ncrx_msg_list *list)\n{\n\tstruct ncrx_msg *msg;\n\n\tmsg = msg_list_peek(list);\n\tif (msg)\n\t\tmsg_list_del(msg, list);\n\treturn msg;\n}\n\n/*\n * Parse @payload into @msg.  The data is not copied into @msg's buffer.\n * @msg->text and ->dict are updated to point into @payload instead.\n */\nstatic int parse_packet(const char *payload, struct ncrx_msg *msg)\n{\n\tchar buf[1024];\n\tchar *p, *tok;\n\tint idx;\n\n\tmemset(msg, 0, sizeof(*msg));\n\n\tp = strchr(payload, ';');\n\tif (!p || p - payload >= (signed)sizeof(buf))\n\t\tgoto einval;\n\tmemcpy(buf, payload, p - payload);\n\tbuf[p - payload] = '\\0';\n\n\tmsg->text = p + 1;\n\tmsg->text_len = strlen(msg->text);\n\tif (msg->text_len > NCRX_LINE_MAX)\n\t\tmsg->text_len = NCRX_LINE_MAX;\n\n\t/* <level>,<sequnum>,<timestamp>,<contflag>[,KEY=VAL]* */\n\tidx = 0;\n\tp = buf;\n\twhile ((tok = strsep(&p, \",\"))) {\n\t\tchar *endp, *key, *val;\n\t\tunsigned long long v;\n\n\t\tswitch (idx++) {\n\t\tcase 0:\n\t\t\tv = strtoul(tok, &endp, 0);\n\t\t\tif (*endp != '\\0' || v > UINT8_MAX)\n\t\t\t\tgoto einval;\n\t\t\tmsg->facility = v >> 3;\n\t\t\tmsg->level = v & ((1 << 3) - 1);\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\tv = strtoull(tok, &endp, 0);\n\t\t\tif (*endp != '\\0')\n\t\t\t\tgoto einval;\n\t\t\tmsg->seq = v;\n\t\t\tcontinue;\n\t\tcase 2:\n\t\t\tv = strtoull(tok, &endp, 0);\n\t\t\tif (*endp != '\\0')\n\t\t\t\tgoto einval;\n\t\t\tmsg->ts_usec = v;\n\t\t\tcontinue;\n\t\tcase 3:\n\t\t\tif (tok[0] == 'c')\n\t\t\t\tmsg->cont_start = 1;\n\t\t\telse if (tok[0] == '+')\n\t\t\t\tmsg->cont = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tval = tok;\n\t\tkey = strsep(&val, \"=\");\n\t\tif (!val)\n\t\t\tcontinue;\n\t\tif (!strcmp(key, \"ncfrag\")) {\n\t\t\tunsigned nf_off, nf_len;\n\n\t\t\tif (sscanf(val, \"%u/%u\", &nf_off, &nf_len) != 2)\n\t\t\t\tgoto einval;\n\t\t\tif (!msg->text_len ||\n\t\t\t    nf_len >= NCRX_LINE_MAX ||\n\t\t\t    nf_off + msg->text_len > nf_len)\n\t\t\t\tgoto einval;\n\n\t\t\tmsg->ncfrag_off = nf_off;\n\t\t\tmsg->ncfrag_len = msg->text_len;\n\t\t\tmsg->ncfrag_left = nf_len - msg->ncfrag_len;\n\t\t\tmsg->text_len = nf_len;\n\t\t} else if (!strcmp(key, \"ncemg\")) {\n\t\t\tv = strtoul(val, &endp, 0);\n\t\t\tif (*endp != '\\0')\n\t\t\t\tgoto einval;\n\t\t\tmsg->emg = v;\n\t\t}\n\t}\n\treturn 0;\neinval:\n\terrno = EINVAL;\n\treturn -1;\n}\n\n/* how far @idx is behind @ncrx->head */\nstatic int slot_dist(int idx, struct ncrx *ncrx)\n{\n\tint dist = ncrx->head - idx;\n\treturn dist >= 0 ? dist : dist + ncrx->p.nr_slots;\n}\n\n/* number of occupied slots */\nstatic int nr_queued(struct ncrx *ncrx)\n{\n\treturn slot_dist(ncrx->tail, ncrx);\n}\n\n/* seq of the last queued message */\nstatic uint64_t tail_seq(struct ncrx *ncrx)\n{\n\treturn ncrx->head_seq - nr_queued(ncrx);\n}\n\n/* slot index of a message with sequence number @ncrx->head_seq + @delta */\nstatic int seq_delta_idx(struct ncrx *ncrx, int delta)\n{\n\tint idx = ncrx->head + delta;\n\n\tif (idx < 0)\n\t\treturn idx + ncrx->p.nr_slots;\n\telse if (idx >= ncrx->p.nr_slots)\n\t\treturn idx - ncrx->p.nr_slots;\n\telse\n\t\treturn idx;\n}\n\n/* is @slot completely empty? */\nstatic int slot_is_free(struct ncrx_slot *slot)\n{\n\treturn !slot->msg && list_empty(&slot->hole_node);\n}\n\n/* @slot may have just been completed, if so, remove it from hole_list */\nstatic void slot_maybe_complete(struct ncrx_slot *slot)\n{\n\tstruct ncrx_msg *msg = slot->msg;\n\n\tif (!msg || msg->ncfrag_left || list_empty(&slot->hole_node))\n\t\treturn;\n\n\tlist_del(&slot->hole_node);\n}\n\n/* retire the last queued slot whether complete or not */\nstatic void retire_tail(struct ncrx *ncrx)\n{\n\tint ntail = (ncrx->tail + 1) % ncrx->p.nr_slots;\n\tstruct ncrx_slot *slot = &ncrx->slots[ncrx->tail];\n\tstruct ncrx_slot *nslot = &ncrx->slots[ntail];\n\n\tif (slot->msg) {\n\t\tmsg_list_append(slot->msg, &ncrx->retired_list);\n\t\tslot->msg = NULL;\n\t}\n\n\tlist_del(&slot->hole_node);\t/* free slot is never a hole */\n\tncrx->tail = ntail;\n\t/*\n\t * Activities of past msgs are considered activities for newer ones\n\t * too.  This prevents oos interval verdicts from flipping as\n\t * sequence progresses.\n\t */\n\tnslot->timestamp = max(slot->timestamp, nslot->timestamp);\n}\n\n/* make room for message with seq ncrx->head_seq + @delta */\nstatic void make_room(struct ncrx *ncrx, int delta)\n{\n\tint i;\n\n\t/* head_seq is for the next msg, need to advance for 0 @delta too */\n\tfor (i = 0; i <= delta; i++) {\n\t\tstruct ncrx_slot *slot;\n\t\tint max_busy = ncrx->p.nr_slots - ncrx->p.retx_stride;\n\n\t\t/* a new slot is considered hole until it gets completed */\n\t\tslot = &ncrx->slots[ncrx->head];\n\t\tassert(slot_is_free(slot));\n\t\tlist_append(&slot->hole_node, &ncrx->hole_list);\n\t\tslot->timestamp = ncrx->now_mono;\n\t\tslot->retx_timestamp = 0;\n\n\t\t/*\n\t\t * Wind the ring buffer and push out if overflowed.  Always\n\t\t * keep at least one stride empty so that retransmissions\n\t\t * of expired slots don't count as oos.\n\t\t */\n\t\tncrx->head_seq++;\n\t\tncrx->head = (ncrx->head + 1) % ncrx->p.nr_slots;\n\t\tif (slot_dist(ncrx->tail, ncrx) > max_busy)\n\t\t\tretire_tail(ncrx);\n\t}\n}\n\n/*\n * Get slot for @tmsg.  On success, returns pointer to the slot which may\n * be free or occupied with partial or complete message.  Returns NULL with\n * errno set to ERANGE if oos, NULL / ENOENT if already retired.\n */\nstatic struct ncrx_slot *get_seq_slot(struct ncrx_msg *tmsg, struct ncrx *ncrx)\n{\n\tstruct ncrx_slot *slot;\n\tint64_t delta;\n\tint idx;\n\n\t/* new seq stream */\n\tif (!ncrx->head_seq) {\n\t\tncrx->head_seq = tmsg->seq;\n\t\tncrx->acked_seq = UINT64_MAX;\n\t\ttmsg->seq_reset = 1;\n\t}\n\n\tdelta = tmsg->seq - ncrx->head_seq;\n\n\t/*\n\t * Consider oos if outside reorder window or if the slot is\n\t * complete and the last activity on it was more than oos_intv ago.\n\t * Emergency messages are never considered oos as they don't follow\n\t * the usual transmission pattern and may repeat indefinitely.\n\t */\n\tif (-delta > ncrx->p.nr_slots || delta > ncrx->p.nr_slots) {\n\t\terrno = ERANGE;\n\t\treturn NULL;\n\t}\n\n\tidx = seq_delta_idx(ncrx, delta);\n\tslot = &ncrx->slots[idx];\n\n\tif (-delta > nr_queued(ncrx)) {\n\t\tint is_free = slot_is_free(slot);\n\n\t\tif (!tmsg->emg &&\n\t\t    (!is_free ||\n\t\t     slot->timestamp + ncrx->p.oos_intv < ncrx->now_mono)) {\n\t\t\terrno = ERANGE;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (is_free)\n\t\t\tslot->timestamp = ncrx->now_mono;\n\t\terrno = ENOENT;\n\t\treturn NULL;\n\t}\n\n\tmake_room(ncrx, delta);\n\tslot->timestamp = ncrx->now_mono;\n\n\treturn slot;\n}\n\n/* make @src's copy, if @src is a fragment, allocate full size as it may grow */\nstatic struct ncrx_msg *copy_msg(struct ncrx_msg *src)\n{\n\tstruct ncrx_msg *dst;\n\n\tassert(!src->dict && !src->dict_len);\n\n\tdst = malloc(sizeof(*dst) + src->text_len + 1);\n\tif (!dst)\n\t\treturn NULL;\n\n\t*dst = *src;\n\tinit_list(&dst->node);\n\n\tdst->text = dst->buf;\n\tif (src->ncfrag_len) {\n\t\tmemset(dst->text, 0, src->text_len + 1);\n\t\tmemcpy(dst->text + src->ncfrag_off, src->text, src->ncfrag_len);\n\t\tdst->ncfrag_off = 0;\n\t\tdst->ncfrag_len = 0;\n\t} else {\n\t\tmemcpy(dst->text, src->text, src->text_len);\n\t\tdst->text[dst->text_len] = '\\0';\n\t}\n\treturn dst;\n}\n\n/*\n * @tmsg is a newly parsed msg which is out-of-sequence.  Queue it on\n * @ncrx->oos_list until the message times out, gets pushed out by other\n * oos messages or the sequence stream gets reset.\n */\nstatic int queue_oos_msg(struct ncrx_msg *tmsg, struct ncrx *ncrx)\n{\n\tstruct ncrx_slot *slot;\n\tstruct ncrx_msg *msg, *nmsg, *first;\n\n\tmsg = copy_msg(tmsg);\n\tif (!msg)\n\t\treturn -1;\n\n\tmsg_list_append(msg, &ncrx->oos_list);\n\n\t/*\n\t * Shifted left automatically on each new msg.  Set oos and see if\n\t * there have been too many oos among the last 32 messages.\n\t */\n\tncrx->oos_history |= 1;\n\tif ((signed)hweight32(ncrx->oos_history) < ncrx->p.oos_thr) {\n\t\t/* nope, handle oos overflow and handle */\n\t\tif (ncrx->oos_list.nr > NCRX_OOS_MAX) {\n\t\t\tmsg = msg_list_pop(&ncrx->oos_list);\n\t\t\tif (msg) {\n\t\t\t\tmsg->oos = 1;\n\t\t\t\tmsg_list_append(msg, &ncrx->retired_list);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The current sequence stream seems no good.  Let's reset by\n\t * retiring all pending, picking the oos msg with the lowest seq,\n\t * queueing it to reset the seq and then queueing all other oos\n\t * msgs.  If a msg is still oos after reset, just retire it.\n\t */\n\twhile (ncrx->tail != ncrx->head)\n\t\tretire_tail(ncrx);\n\n\tncrx->head_seq = 0;\n\tncrx->acked_seq = UINT64_MAX;\n\n\tfirst = node_to_msg(ncrx->oos_list.head.next);\n\tmsg_list_for_each(msg, nmsg, &ncrx->oos_list)\n\t\tfirst = msg->seq < first->seq ? msg : first;\n\n\tmsg_list_del(first, &ncrx->oos_list);\n\tslot = get_seq_slot(first, ncrx);\n\tslot->msg = first;\n\tslot_maybe_complete(slot);\n\n\twhile ((msg = msg_list_pop(&ncrx->oos_list))) {\n\t\tslot = get_seq_slot(msg, ncrx);\n\t\tif (slot) {\n\t\t\tslot->msg = msg;\n\t\t\tslot_maybe_complete(slot);\n\t\t} else {\n\t\t\tmsg->oos = 1;\n\t\t\tmsg_list_append(msg, &ncrx->retired_list);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* @payload has just been received, parse and queue it */\nstatic int ncrx_queue_payload(const char *payload, struct ncrx *ncrx,\n\t\tuint64_t now_real)\n{\n\tstruct ncrx_msg tmsg;\n\tstruct ncrx_slot *slot;\n\tint new_msg = 0;\n\n\tif (parse_packet(payload, &tmsg))\n\t\treturn -1;\n\n\ttmsg.rx_at_mono = ncrx->now_mono;\n\ttmsg.rx_at_real = now_real;\n\tncrx->oos_history <<= 1;\n\n\t/* ack immediately if logging source is doing emergency transmissions */\n\tif (tmsg.emg) {\n\t\tncrx->acked_seq = UINT64_MAX;\n\t\tncrx->acked_at = 0;\n\t}\n\n\t/* get the matching slot and allocate a new message if empty */\n\tslot = get_seq_slot(&tmsg, ncrx);\n\tif (slot && !slot->msg) {\n\t\tslot->msg = copy_msg(&tmsg);\n\t\tnew_msg = 1;\n\t}\n\tif (!slot || !slot->msg) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tif (errno == ERANGE)\n\t\t\treturn queue_oos_msg(&tmsg, ncrx);\n\t\treturn -1;\n\t}\n\n\tif (!new_msg && slot->msg->ncfrag_left) {\n\t\tstruct ncrx_msg *msg = slot->msg;\n\t\tint off = tmsg.ncfrag_off;\n\t\tint i;\n\n\t\tfor (i = 0; i < tmsg.ncfrag_len; i++) {\n\t\t\tif (msg->text[off + i])\n\t\t\t\tcontinue;\n\t\t\tmsg->text[off + i] = tmsg.text[i];\n\t\t\tmsg->ncfrag_left--;\n\t\t}\n\t}\n\n\tslot_maybe_complete(slot);\n\n\treturn 0;\n}\n\n/*\n * Build ncrx_response() output.  Ack for the last retired msg is always\n * added.  If @slot is non-NULL, re-transmission for it is also added.\n */\nstatic void ncrx_build_resp(struct ncrx_slot *slot, struct ncrx *ncrx)\n{\n\t/* no msg received? */\n\tif (!ncrx->head_seq)\n\t\treturn;\n\n\t/* \"ncrx<ack-seq>\" */\n\tif (!ncrx->resp_len) {\n\t\tncrx->acked_seq = tail_seq(ncrx) - 1;\n\t\tncrx->acked_at = ncrx->now_mono;\n\n\t\tncrx->resp_len = snprintf(ncrx->resp_buf, NCRX_PKT_MAX,\n\t\t\t\t\t  \"ncrx%\"PRIu64, ncrx->acked_seq);\n\t}\n\n\t/* \" <missing-seq>...\" truncated to NCRX_PKT_MAX */\n\tif (slot) {\n\t\tint idx = slot - ncrx->slots;\n\t\tint len;\n\n\t\tlen = snprintf(ncrx->resp_buf + ncrx->resp_len,\n\t\t\t       NCRX_PKT_MAX - ncrx->resp_len, \" %\"PRIu64,\n\t\t\t       ncrx->head_seq - slot_dist(idx, ncrx));\n\t\tif (ncrx->resp_len + len <= NCRX_PKT_MAX) {\n\t\t\tncrx->resp_len += len;\n\t\t\tncrx->resp_buf[ncrx->resp_len] = '\\0';\n\t\t}\n\t}\n}\n\nint ncrx_process(const char *payload, uint64_t now_mono, uint64_t now_real,\n\t\tstruct ncrx *ncrx)\n{\n\tstruct ncrx_slot *slot, *tmp_slot;\n\tstruct ncrx_msg *msg;\n\tuint64_t old_head_seq = ncrx->head_seq;\n\tint dist_retx, ret = 0;\n\n\tif (now_mono < ncrx->now_mono)\n\t\tfprintf(stderr, \"ncrx: time regressed %\"PRIu64\"->%\"PRIu64\"\\n\",\n\t\t\tncrx->now_mono, now_mono);\n\n\tncrx->now_mono = now_mono;\n\tncrx->resp_len = 0;\n\n\t/*\n\t * If fully acked, keep last ack timestamp current so that new\n\t * messages arriving doesn't trigger ack timeout immediately.\n\t */\n\tif (ncrx->acked_seq == tail_seq(ncrx) - 1)\n\t\tncrx->acked_at = now_mono;\n\n\t/* parse and queue @payload */\n\tif (payload)\n\t\tret = ncrx_queue_payload(payload, ncrx, now_real);\n\n\t/* retire complete & timed-out msgs from tail */\n\twhile (ncrx->tail != ncrx->head) {\n\t\tslot = &ncrx->slots[ncrx->tail];\n\n\t\tif ((!slot->msg || !list_empty(&slot->hole_node)) &&\n\t\t    slot->timestamp + ncrx->p.msg_timeout > now_mono)\n\t\t\tbreak;\n\t\tretire_tail(ncrx);\n\t}\n\n\t/* retire timed-out oos msgs */\n\twhile ((msg = msg_list_peek(&ncrx->oos_list))) {\n\t\tif (msg->rx_at_mono + ncrx->p.oos_timeout > now_mono)\n\t\t\tbreak;\n\t\tmsg->oos = 1;\n\t\tmsg_list_del(msg, &ncrx->oos_list);\n\t\tmsg_list_append(msg, &ncrx->retired_list);\n\t}\n\n\t/* if enabled, ack pending and timeout expired? */\n\tif (ncrx->p.ack_intv && ncrx->acked_seq != tail_seq(ncrx) - 1 &&\n\t    ncrx->acked_at + ncrx->p.ack_intv < now_mono)\n\t\tncrx_build_resp(NULL, ncrx);\n\n\t/* head passed one or more re-transmission boundaries? */\n\tdist_retx = old_head_seq / ncrx->p.retx_stride !=\n\t\tncrx->head_seq / ncrx->p.retx_stride;\n\n\thole_list_for_each(slot, tmp_slot, &ncrx->hole_list) {\n\t\tint retx = 0;\n\n\t\t/*\n\t\t * If so, request re-tx of holes further away than stride.\n\t\t * This ensures that a missing seq is requested at least\n\t\t * certain number of times regardless of incoming rate.\n\t\t */\n\t\tif (dist_retx &&\n\t\t    slot_dist(slot - ncrx->slots, ncrx) > ncrx->p.retx_stride)\n\t\t\tretx = 1;\n\n\t\t/* request re-tx every retx_intv */\n\t\tif (now_mono - max(slot->timestamp, slot->retx_timestamp) >=\n\t\t    (unsigned)ncrx->p.retx_intv) {\n\t\t\tslot->retx_timestamp = now_mono;\n\t\t\tretx = 1;\n\t\t}\n\n\t\tif (retx)\n\t\t\tncrx_build_resp(slot, ncrx);\n\t}\n\n\treturn ret;\n}\n\nconst char *ncrx_response(struct ncrx *ncrx, int *lenp)\n{\n\tif (lenp)\n\t\t*lenp = ncrx->resp_len;\n\tif (ncrx->resp_len)\n\t\treturn ncrx->resp_buf;\n\treturn NULL;\n}\n\n/* parse out the dictionary in a complete message, if it exists */\nstatic void terminate_msg_and_dict(struct ncrx_msg *msg)\n{\n\tmsg->dict = strchr(msg->text, '\\n');\n\tif (msg->dict) {\n\t\tint len = msg->text_len;\n\t\tmsg->text_len = msg->dict - msg->text;\n\t\tmsg->text[msg->text_len] = '\\0';\n\t\tmsg->dict_len = len - msg->text_len - 1;\n\t\tmsg->dict++;\n\t}\n}\n\nstruct ncrx_msg *ncrx_next_msg(struct ncrx *ncrx)\n{\n\tstruct ncrx_msg *msg = msg_list_pop(&ncrx->retired_list);\n\n\tif (msg)\n\t\tterminate_msg_and_dict(msg);\n\n\treturn msg;\n}\n\nuint64_t ncrx_invoke_process_at(struct ncrx *ncrx)\n{\n\tuint64_t when = UINT64_MAX;\n\tstruct ncrx_msg *msg;\n\n\t/* ack enabled and pending? */\n\tif (ncrx->p.ack_intv && ncrx->head_seq &&\n\t\t\tncrx->acked_seq != tail_seq(ncrx) - 1)\n\t\twhen = min(when, ncrx->acked_at + ncrx->p.ack_intv);\n\n\t/*\n\t * Holes to request for retransmission?  msg_timeout is the same\n\t * condition but way longer.  Checking on retx_intv is enough.\n\t */\n\tif (!list_empty(&ncrx->hole_list))\n\t\twhen = min(when, ncrx->now_mono + ncrx->p.retx_intv);\n\n\t/* oos timeout */\n\tif ((msg = msg_list_peek(&ncrx->oos_list)))\n\t\twhen = min(when, msg->rx_at_mono + ncrx->p.oos_timeout);\n\n\t/* min 10ms intv to avoid busy loop in case something goes bonkers */\n\treturn max(when, ncrx->now_mono + 10);\n}\n\nstruct ncrx *ncrx_create(const struct ncrx_param *param)\n{\n\tconst struct ncrx_param *dfl = &ncrx_dfl_param;\n\tstruct ncrx_param *p;\n\tstruct ncrx *ncrx;\n\tint i;\n\n\tncrx = calloc(1, sizeof(*ncrx));\n\tif (!ncrx)\n\t\treturn NULL;\n\n\tp = &ncrx->p;\n\tif (param) {\n\t\tp->nr_slots\t= param->nr_slots\t?: dfl->nr_slots;\n\n\t\tp->ack_intv\t= param->ack_intv\t?: dfl->ack_intv;\n\t\tp->retx_intv\t= param->retx_intv\t?: dfl->retx_intv;\n\t\tp->retx_stride\t= param->retx_stride\t?: dfl->retx_stride;\n\t\tp->msg_timeout\t= param->msg_timeout\t?: dfl->msg_timeout;\n\n\t\tp->oos_thr\t= param->oos_thr\t?: dfl->oos_thr;\n\t\tp->oos_intv\t= param->oos_intv\t?: dfl->oos_intv;\n\t\tp->oos_timeout\t= param->oos_timeout\t?: dfl->oos_timeout;\n\t} else {\n\t\t*p = *dfl;\n\t}\n\n\tncrx->acked_seq = UINT64_MAX;\n\tinit_list(&ncrx->hole_list);\n\tinit_list(&ncrx->oos_list.head);\n\tinit_list(&ncrx->retired_list.head);\n\n\tncrx->slots = calloc(ncrx->p.nr_slots, sizeof(ncrx->slots[0]));\n\tif (!ncrx->slots)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ncrx->p.nr_slots; i++)\n\t\tinit_list(&ncrx->slots[i].hole_node);\n\n\treturn ncrx;\n}\n\nvoid ncrx_destroy(struct ncrx *ncrx)\n{\n\tstruct ncrx_msg *msg;\n\tint i;\n\n\tfor (i = 0; i < ncrx->p.nr_slots; i++)\n\t\tfree(ncrx->slots[i].msg);\n\n\twhile ((msg = msg_list_pop(&ncrx->oos_list)))\n\t\tfree(msg);\n\n\twhile ((msg = msg_list_pop(&ncrx->retired_list)))\n\t\tfree(msg);\n\n\tfree(ncrx->slots);\n\tfree(ncrx);\n}\n"], "fixing_code": ["/*\n * ncrx - extended netconsole receiver library\n *\n * Copyright (C) 2016, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the license found in the LICENSE file in\n * the root directory of this source tree.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/udp.h>\n\n#include \"ncrx.h\"\n\n/* oos history is tracked with a uint32_t */\n#define NCRX_OOS_MAX\t\t32\n\nstruct ncrx_msg_list {\n\tstruct ncrx_list\thead;\n\tint\t\t\tnr;\t\t/* number of msgs on the list */\n};\n\nstruct ncrx_slot {\n\tstruct ncrx_msg\t\t*msg;\n\tuint64_t\t\ttimestamp;\t/* last rx on this slot */\n\tuint64_t\t\tretx_timestamp;\t/* last retransmission */\n\tstruct ncrx_list\thole_node;\t/* anchored @ ncrx->hole_list */\n};\n\nstruct ncrx {\n\tstruct ncrx_param\tp;\n\n\tuint64_t\t\tnow_mono;\t/* latest time in msecs */\n\n\tint\t\t\thead;\t\t/* next slot to use */\n\tint\t\t\ttail;\t\t/* last slot in use */\n\tuint64_t\t\thead_seq;\t/* next expected seq, unset=0 */\n\tstruct ncrx_slot\t*slots;\t\t/* msg slots */\n\tstruct ncrx_list\thole_list;\t/* missing or !complete slots */\n\n\tuint32_t\t\toos_history;\t/* bit history of oos msgs */\n\tstruct ncrx_msg_list\toos_list;\t/* buffered oos msgs */\n\n\tstruct ncrx_msg_list\tretired_list;\t/* msgs to be fetched by user */\n\n\tuint64_t\t\tacked_seq;\t/* last seq acked, unset=max */\n\tuint64_t\t\tacked_at;\t/* and when */\n\n\t/* response buffer for ncrx_response() */\n\tchar\t\t\tresp_buf[NCRX_PKT_MAX + 1];\n\tint\t\t\tresp_len;\n};\n\nstatic const struct ncrx_param ncrx_dfl_param = {\n\t.nr_slots\t\t= NCRX_DFL_NR_SLOTS,\n\n\t.ack_intv\t\t= NCRX_DFL_ACK_INTV,\n\t.retx_intv\t\t= NCRX_DFL_RETX_INTV,\n\t.retx_stride\t\t= NCRX_DFL_RETX_STRIDE,\n\t.msg_timeout\t\t= NCRX_DFL_MSG_TIMEOUT,\n\n\t.oos_thr\t\t= NCRX_DFL_OOS_THR,\n\t.oos_intv\t\t= NCRX_DFL_OOS_INTV,\n\t.oos_timeout\t\t= NCRX_DFL_OOS_TIMEOUT,\n};\n\n/* utilities mostly stolen from kernel */\n#define min(x, y) ({\t\t\t\t\t\t\t\\\n\ttypeof(x) _min1 = (x);\t\t\t\t\t\t\\\n\ttypeof(y) _min2 = (y);\t\t\t\t\t\t\\\n\t(void) (&_min1 == &_min2);\t\t\t\t\t\\\n\t_min1 < _min2 ? _min1 : _min2; })\n\n#define max(x, y) ({\t\t\t\t\t\t\t\\\n\ttypeof(x) _max1 = (x);\t\t\t\t\t\t\\\n\ttypeof(y) _max2 = (y);\t\t\t\t\t\t\\\n\t(void) (&_max1 == &_max2);\t\t\t\t\t\\\n\t_max1 > _max2 ? _max1 : _max2; })\n\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n\n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tconst typeof( ((type *)0)->member ) *__mptr = (ptr);\t\t\\\n\t(type *)( (char *)__mptr - offsetof(type,member) );})\n\n/* ncrx_msg from its ->node */\n#define node_to_msg(ptr)\tcontainer_of(ptr, struct ncrx_msg, node)\n\n/* iterate msg_list */\n#define msg_list_for_each(pos, n, list)\t\t\t\t\t\\\n\tfor (pos = node_to_msg((list)->head.next),\t\t\t\\\n\t\t     n = node_to_msg(pos->node.next);\t\t\t\\\n\t     &pos->node != &(list)->head;\t\t\t\t\\\n\t     pos = n, n = node_to_msg(pos->node.next))\n\n/* ncrx_slot from its ->hole_node */\n#define hole_to_slot(ptr)\t\t\t\t\t\t\\\n\tcontainer_of(ptr, struct ncrx_slot, hole_node)\n\n/* iterate hole_list */\n#define hole_list_for_each(pos, n, list)\t\t\t\t\\\n\tfor (pos = hole_to_slot((list)->next),\t\t\t\t\\\n\t\t     n = hole_to_slot(pos->hole_node.next);\t\t\\\n\t     &pos->hole_node != (list);\t\t\t\t\t\\\n\t     pos = n, n = hole_to_slot(pos->hole_node.next))\n\nstatic unsigned int hweight32(uint32_t w)\n{\n\tw -= (w >> 1) & 0x55555555;\n\tw =  (w & 0x33333333) + ((w >> 2) & 0x33333333);\n\tw =  (w + (w >> 4)) & 0x0f0f0f0f;\n\treturn (w * 0x01010101) >> 24;\n}\n\nstatic void init_list(struct ncrx_list *head)\n{\n\thead->next = head;\n\thead->prev = head;\n}\n\nstatic int list_empty(struct ncrx_list *head)\n{\n\treturn head->next == head;\n}\n\nstatic void list_del(struct ncrx_list *head)\n{\n\tstruct ncrx_list *prev = head->prev;\n\tstruct ncrx_list *next = head->next;\n\n\tprev->next = next;\n\tnext->prev = prev;\n\tinit_list(head);\n}\n\nstatic void list_append(struct ncrx_list *node, struct ncrx_list *list)\n{\n\tstruct ncrx_list *prev = list->prev;\n\n\tassert(node->next == node && node->prev == node);\n\n\tnode->next = list;\n\tnode->prev = prev;\n\tprev->next = node;\n\tlist->prev = node;\n}\n\nstatic void msg_list_del(struct ncrx_msg *msg, struct ncrx_msg_list *list)\n{\n\tlist_del(&msg->node);\n\tlist->nr--;\n\n\tif (!list->nr)\n\t\tassert(list->head.next == &list->head &&\n\t\t       list->head.prev == &list->head);\n}\n\nstatic void msg_list_append(struct ncrx_msg *msg, struct ncrx_msg_list *list)\n{\n\tlist_append(&msg->node, &list->head);\n\tlist->nr++;\n}\n\nstatic struct ncrx_msg *msg_list_peek(struct ncrx_msg_list *list)\n{\n\tif (list_empty(&list->head))\n\t\treturn NULL;\n\treturn node_to_msg(list->head.next);\n}\n\nstatic struct ncrx_msg *msg_list_pop(struct ncrx_msg_list *list)\n{\n\tstruct ncrx_msg *msg;\n\n\tmsg = msg_list_peek(list);\n\tif (msg)\n\t\tmsg_list_del(msg, list);\n\treturn msg;\n}\n\n/*\n * Parse @payload into @msg.  The data is not copied into @msg's buffer.\n * @msg->text and ->dict are updated to point into @payload instead.\n */\nstatic int parse_packet(const char *payload, struct ncrx_msg *msg)\n{\n\tchar buf[1024];\n\tchar *p, *tok;\n\tint idx;\n\n\tmemset(msg, 0, sizeof(*msg));\n\n\tp = strchr(payload, ';');\n\tif (!p || p - payload >= (signed)sizeof(buf))\n\t\tgoto einval;\n\tmemcpy(buf, payload, p - payload);\n\tbuf[p - payload] = '\\0';\n\n\tmsg->text = p + 1;\n\tmsg->text_len = strlen(msg->text);\n\tif (msg->text_len > NCRX_LINE_MAX)\n\t\tmsg->text_len = NCRX_LINE_MAX;\n\n\t/* <level>,<sequnum>,<timestamp>,<contflag>[,KEY=VAL]* */\n\tidx = 0;\n\tp = buf;\n\twhile ((tok = strsep(&p, \",\"))) {\n\t\tchar *endp, *key, *val;\n\t\tunsigned long long v;\n\n\t\tswitch (idx++) {\n\t\tcase 0:\n\t\t\tv = strtoul(tok, &endp, 0);\n\t\t\tif (*endp != '\\0' || v > UINT8_MAX)\n\t\t\t\tgoto einval;\n\t\t\tmsg->facility = v >> 3;\n\t\t\tmsg->level = v & ((1 << 3) - 1);\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\tv = strtoull(tok, &endp, 0);\n\t\t\tif (*endp != '\\0')\n\t\t\t\tgoto einval;\n\t\t\tmsg->seq = v;\n\t\t\tcontinue;\n\t\tcase 2:\n\t\t\tv = strtoull(tok, &endp, 0);\n\t\t\tif (*endp != '\\0')\n\t\t\t\tgoto einval;\n\t\t\tmsg->ts_usec = v;\n\t\t\tcontinue;\n\t\tcase 3:\n\t\t\tif (tok[0] == 'c')\n\t\t\t\tmsg->cont_start = 1;\n\t\t\telse if (tok[0] == '+')\n\t\t\t\tmsg->cont = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tval = tok;\n\t\tkey = strsep(&val, \"=\");\n\t\tif (!val)\n\t\t\tcontinue;\n\t\tif (!strcmp(key, \"ncfrag\")) {\n\t\t\tunsigned nf_off, nf_len;\n\n\t\t\tif (sscanf(val, \"%u/%u\", &nf_off, &nf_len) != 2)\n\t\t\t\tgoto einval;\n\t\t\tif (!msg->text_len ||\n\t\t\t    nf_len >= NCRX_LINE_MAX ||\n\t\t\t    nf_off >= nf_len ||\n\t\t\t    nf_off + msg->text_len > nf_len)\n\t\t\t\tgoto einval;\n\n\t\t\tmsg->ncfrag_off = nf_off;\n\t\t\tmsg->ncfrag_len = msg->text_len;\n\t\t\tmsg->ncfrag_left = nf_len - msg->ncfrag_len;\n\t\t\tmsg->text_len = nf_len;\n\t\t} else if (!strcmp(key, \"ncemg\")) {\n\t\t\tv = strtoul(val, &endp, 0);\n\t\t\tif (*endp != '\\0')\n\t\t\t\tgoto einval;\n\t\t\tmsg->emg = v;\n\t\t}\n\t}\n\treturn 0;\neinval:\n\terrno = EINVAL;\n\treturn -1;\n}\n\n/* how far @idx is behind @ncrx->head */\nstatic int slot_dist(int idx, struct ncrx *ncrx)\n{\n\tint dist = ncrx->head - idx;\n\treturn dist >= 0 ? dist : dist + ncrx->p.nr_slots;\n}\n\n/* number of occupied slots */\nstatic int nr_queued(struct ncrx *ncrx)\n{\n\treturn slot_dist(ncrx->tail, ncrx);\n}\n\n/* seq of the last queued message */\nstatic uint64_t tail_seq(struct ncrx *ncrx)\n{\n\treturn ncrx->head_seq - nr_queued(ncrx);\n}\n\n/* slot index of a message with sequence number @ncrx->head_seq + @delta */\nstatic int seq_delta_idx(struct ncrx *ncrx, int delta)\n{\n\tint idx = ncrx->head + delta;\n\n\tif (idx < 0)\n\t\treturn idx + ncrx->p.nr_slots;\n\telse if (idx >= ncrx->p.nr_slots)\n\t\treturn idx - ncrx->p.nr_slots;\n\telse\n\t\treturn idx;\n}\n\n/* is @slot completely empty? */\nstatic int slot_is_free(struct ncrx_slot *slot)\n{\n\treturn !slot->msg && list_empty(&slot->hole_node);\n}\n\n/* @slot may have just been completed, if so, remove it from hole_list */\nstatic void slot_maybe_complete(struct ncrx_slot *slot)\n{\n\tstruct ncrx_msg *msg = slot->msg;\n\n\tif (!msg || msg->ncfrag_left || list_empty(&slot->hole_node))\n\t\treturn;\n\n\tlist_del(&slot->hole_node);\n}\n\n/* retire the last queued slot whether complete or not */\nstatic void retire_tail(struct ncrx *ncrx)\n{\n\tint ntail = (ncrx->tail + 1) % ncrx->p.nr_slots;\n\tstruct ncrx_slot *slot = &ncrx->slots[ncrx->tail];\n\tstruct ncrx_slot *nslot = &ncrx->slots[ntail];\n\n\tif (slot->msg) {\n\t\tmsg_list_append(slot->msg, &ncrx->retired_list);\n\t\tslot->msg = NULL;\n\t}\n\n\tlist_del(&slot->hole_node);\t/* free slot is never a hole */\n\tncrx->tail = ntail;\n\t/*\n\t * Activities of past msgs are considered activities for newer ones\n\t * too.  This prevents oos interval verdicts from flipping as\n\t * sequence progresses.\n\t */\n\tnslot->timestamp = max(slot->timestamp, nslot->timestamp);\n}\n\n/* make room for message with seq ncrx->head_seq + @delta */\nstatic void make_room(struct ncrx *ncrx, int delta)\n{\n\tint i;\n\n\t/* head_seq is for the next msg, need to advance for 0 @delta too */\n\tfor (i = 0; i <= delta; i++) {\n\t\tstruct ncrx_slot *slot;\n\t\tint max_busy = ncrx->p.nr_slots - ncrx->p.retx_stride;\n\n\t\t/* a new slot is considered hole until it gets completed */\n\t\tslot = &ncrx->slots[ncrx->head];\n\t\tassert(slot_is_free(slot));\n\t\tlist_append(&slot->hole_node, &ncrx->hole_list);\n\t\tslot->timestamp = ncrx->now_mono;\n\t\tslot->retx_timestamp = 0;\n\n\t\t/*\n\t\t * Wind the ring buffer and push out if overflowed.  Always\n\t\t * keep at least one stride empty so that retransmissions\n\t\t * of expired slots don't count as oos.\n\t\t */\n\t\tncrx->head_seq++;\n\t\tncrx->head = (ncrx->head + 1) % ncrx->p.nr_slots;\n\t\tif (slot_dist(ncrx->tail, ncrx) > max_busy)\n\t\t\tretire_tail(ncrx);\n\t}\n}\n\n/*\n * Get slot for @tmsg.  On success, returns pointer to the slot which may\n * be free or occupied with partial or complete message.  Returns NULL with\n * errno set to ERANGE if oos, NULL / ENOENT if already retired.\n */\nstatic struct ncrx_slot *get_seq_slot(struct ncrx_msg *tmsg, struct ncrx *ncrx)\n{\n\tstruct ncrx_slot *slot;\n\tint64_t delta;\n\tint idx;\n\n\t/* new seq stream */\n\tif (!ncrx->head_seq) {\n\t\tncrx->head_seq = tmsg->seq;\n\t\tncrx->acked_seq = UINT64_MAX;\n\t\ttmsg->seq_reset = 1;\n\t}\n\n\tdelta = tmsg->seq - ncrx->head_seq;\n\n\t/*\n\t * Consider oos if outside reorder window or if the slot is\n\t * complete and the last activity on it was more than oos_intv ago.\n\t * Emergency messages are never considered oos as they don't follow\n\t * the usual transmission pattern and may repeat indefinitely.\n\t */\n\tif (-delta > ncrx->p.nr_slots || delta > ncrx->p.nr_slots) {\n\t\terrno = ERANGE;\n\t\treturn NULL;\n\t}\n\n\tidx = seq_delta_idx(ncrx, delta);\n\tslot = &ncrx->slots[idx];\n\n\tif (-delta > nr_queued(ncrx)) {\n\t\tint is_free = slot_is_free(slot);\n\n\t\tif (!tmsg->emg &&\n\t\t    (!is_free ||\n\t\t     slot->timestamp + ncrx->p.oos_intv < ncrx->now_mono)) {\n\t\t\terrno = ERANGE;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (is_free)\n\t\t\tslot->timestamp = ncrx->now_mono;\n\t\terrno = ENOENT;\n\t\treturn NULL;\n\t}\n\n\tmake_room(ncrx, delta);\n\tslot->timestamp = ncrx->now_mono;\n\n\treturn slot;\n}\n\n/* make @src's copy, if @src is a fragment, allocate full size as it may grow */\nstatic struct ncrx_msg *copy_msg(struct ncrx_msg *src)\n{\n\tstruct ncrx_msg *dst;\n\n\tassert(!src->dict && !src->dict_len);\n\n\tdst = malloc(sizeof(*dst) + src->text_len + 1);\n\tif (!dst)\n\t\treturn NULL;\n\n\t*dst = *src;\n\tinit_list(&dst->node);\n\n\tdst->text = dst->buf;\n\tif (src->ncfrag_len) {\n\t\tmemset(dst->text, 0, src->text_len + 1);\n\t\tmemcpy(dst->text + src->ncfrag_off, src->text, src->ncfrag_len);\n\t\tdst->ncfrag_off = 0;\n\t\tdst->ncfrag_len = 0;\n\t} else {\n\t\tmemcpy(dst->text, src->text, src->text_len);\n\t\tdst->text[dst->text_len] = '\\0';\n\t}\n\treturn dst;\n}\n\n/*\n * @tmsg is a newly parsed msg which is out-of-sequence.  Queue it on\n * @ncrx->oos_list until the message times out, gets pushed out by other\n * oos messages or the sequence stream gets reset.\n */\nstatic int queue_oos_msg(struct ncrx_msg *tmsg, struct ncrx *ncrx)\n{\n\tstruct ncrx_slot *slot;\n\tstruct ncrx_msg *msg, *nmsg, *first;\n\n\tmsg = copy_msg(tmsg);\n\tif (!msg)\n\t\treturn -1;\n\n\tmsg_list_append(msg, &ncrx->oos_list);\n\n\t/*\n\t * Shifted left automatically on each new msg.  Set oos and see if\n\t * there have been too many oos among the last 32 messages.\n\t */\n\tncrx->oos_history |= 1;\n\tif ((signed)hweight32(ncrx->oos_history) < ncrx->p.oos_thr) {\n\t\t/* nope, handle oos overflow and handle */\n\t\tif (ncrx->oos_list.nr > NCRX_OOS_MAX) {\n\t\t\tmsg = msg_list_pop(&ncrx->oos_list);\n\t\t\tif (msg) {\n\t\t\t\tmsg->oos = 1;\n\t\t\t\tmsg_list_append(msg, &ncrx->retired_list);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The current sequence stream seems no good.  Let's reset by\n\t * retiring all pending, picking the oos msg with the lowest seq,\n\t * queueing it to reset the seq and then queueing all other oos\n\t * msgs.  If a msg is still oos after reset, just retire it.\n\t */\n\twhile (ncrx->tail != ncrx->head)\n\t\tretire_tail(ncrx);\n\n\tncrx->head_seq = 0;\n\tncrx->acked_seq = UINT64_MAX;\n\n\tfirst = node_to_msg(ncrx->oos_list.head.next);\n\tmsg_list_for_each(msg, nmsg, &ncrx->oos_list)\n\t\tfirst = msg->seq < first->seq ? msg : first;\n\n\tmsg_list_del(first, &ncrx->oos_list);\n\tslot = get_seq_slot(first, ncrx);\n\tslot->msg = first;\n\tslot_maybe_complete(slot);\n\n\twhile ((msg = msg_list_pop(&ncrx->oos_list))) {\n\t\tslot = get_seq_slot(msg, ncrx);\n\t\tif (slot) {\n\t\t\tslot->msg = msg;\n\t\t\tslot_maybe_complete(slot);\n\t\t} else {\n\t\t\tmsg->oos = 1;\n\t\t\tmsg_list_append(msg, &ncrx->retired_list);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* @payload has just been received, parse and queue it */\nstatic int ncrx_queue_payload(const char *payload, struct ncrx *ncrx,\n\t\tuint64_t now_real)\n{\n\tstruct ncrx_msg tmsg;\n\tstruct ncrx_slot *slot;\n\tint new_msg = 0;\n\n\tif (parse_packet(payload, &tmsg))\n\t\treturn -1;\n\n\ttmsg.rx_at_mono = ncrx->now_mono;\n\ttmsg.rx_at_real = now_real;\n\tncrx->oos_history <<= 1;\n\n\t/* ack immediately if logging source is doing emergency transmissions */\n\tif (tmsg.emg) {\n\t\tncrx->acked_seq = UINT64_MAX;\n\t\tncrx->acked_at = 0;\n\t}\n\n\t/* get the matching slot and allocate a new message if empty */\n\tslot = get_seq_slot(&tmsg, ncrx);\n\tif (slot && !slot->msg) {\n\t\tslot->msg = copy_msg(&tmsg);\n\t\tnew_msg = 1;\n\t}\n\tif (!slot || !slot->msg) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tif (errno == ERANGE)\n\t\t\treturn queue_oos_msg(&tmsg, ncrx);\n\t\treturn -1;\n\t}\n\n\tif (!new_msg && slot->msg->ncfrag_left) {\n\t\tstruct ncrx_msg *msg = slot->msg;\n\t\tint off = tmsg.ncfrag_off;\n\t\tint i;\n\n\t\tfor (i = 0; i < tmsg.ncfrag_len; i++) {\n\t\t\tif (msg->text[off + i])\n\t\t\t\tcontinue;\n\t\t\tmsg->text[off + i] = tmsg.text[i];\n\t\t\tmsg->ncfrag_left--;\n\t\t}\n\t}\n\n\tslot_maybe_complete(slot);\n\n\treturn 0;\n}\n\n/*\n * Build ncrx_response() output.  Ack for the last retired msg is always\n * added.  If @slot is non-NULL, re-transmission for it is also added.\n */\nstatic void ncrx_build_resp(struct ncrx_slot *slot, struct ncrx *ncrx)\n{\n\t/* no msg received? */\n\tif (!ncrx->head_seq)\n\t\treturn;\n\n\t/* \"ncrx<ack-seq>\" */\n\tif (!ncrx->resp_len) {\n\t\tncrx->acked_seq = tail_seq(ncrx) - 1;\n\t\tncrx->acked_at = ncrx->now_mono;\n\n\t\tncrx->resp_len = snprintf(ncrx->resp_buf, NCRX_PKT_MAX,\n\t\t\t\t\t  \"ncrx%\"PRIu64, ncrx->acked_seq);\n\t}\n\n\t/* \" <missing-seq>...\" truncated to NCRX_PKT_MAX */\n\tif (slot) {\n\t\tint idx = slot - ncrx->slots;\n\t\tint len;\n\n\t\tlen = snprintf(ncrx->resp_buf + ncrx->resp_len,\n\t\t\t       NCRX_PKT_MAX - ncrx->resp_len, \" %\"PRIu64,\n\t\t\t       ncrx->head_seq - slot_dist(idx, ncrx));\n\t\tif (ncrx->resp_len + len <= NCRX_PKT_MAX) {\n\t\t\tncrx->resp_len += len;\n\t\t\tncrx->resp_buf[ncrx->resp_len] = '\\0';\n\t\t}\n\t}\n}\n\nint ncrx_process(const char *payload, uint64_t now_mono, uint64_t now_real,\n\t\tstruct ncrx *ncrx)\n{\n\tstruct ncrx_slot *slot, *tmp_slot;\n\tstruct ncrx_msg *msg;\n\tuint64_t old_head_seq = ncrx->head_seq;\n\tint dist_retx, ret = 0;\n\n\tif (now_mono < ncrx->now_mono)\n\t\tfprintf(stderr, \"ncrx: time regressed %\"PRIu64\"->%\"PRIu64\"\\n\",\n\t\t\tncrx->now_mono, now_mono);\n\n\tncrx->now_mono = now_mono;\n\tncrx->resp_len = 0;\n\n\t/*\n\t * If fully acked, keep last ack timestamp current so that new\n\t * messages arriving doesn't trigger ack timeout immediately.\n\t */\n\tif (ncrx->acked_seq == tail_seq(ncrx) - 1)\n\t\tncrx->acked_at = now_mono;\n\n\t/* parse and queue @payload */\n\tif (payload)\n\t\tret = ncrx_queue_payload(payload, ncrx, now_real);\n\n\t/* retire complete & timed-out msgs from tail */\n\twhile (ncrx->tail != ncrx->head) {\n\t\tslot = &ncrx->slots[ncrx->tail];\n\n\t\tif ((!slot->msg || !list_empty(&slot->hole_node)) &&\n\t\t    slot->timestamp + ncrx->p.msg_timeout > now_mono)\n\t\t\tbreak;\n\t\tretire_tail(ncrx);\n\t}\n\n\t/* retire timed-out oos msgs */\n\twhile ((msg = msg_list_peek(&ncrx->oos_list))) {\n\t\tif (msg->rx_at_mono + ncrx->p.oos_timeout > now_mono)\n\t\t\tbreak;\n\t\tmsg->oos = 1;\n\t\tmsg_list_del(msg, &ncrx->oos_list);\n\t\tmsg_list_append(msg, &ncrx->retired_list);\n\t}\n\n\t/* if enabled, ack pending and timeout expired? */\n\tif (ncrx->p.ack_intv && ncrx->acked_seq != tail_seq(ncrx) - 1 &&\n\t    ncrx->acked_at + ncrx->p.ack_intv < now_mono)\n\t\tncrx_build_resp(NULL, ncrx);\n\n\t/* head passed one or more re-transmission boundaries? */\n\tdist_retx = old_head_seq / ncrx->p.retx_stride !=\n\t\tncrx->head_seq / ncrx->p.retx_stride;\n\n\thole_list_for_each(slot, tmp_slot, &ncrx->hole_list) {\n\t\tint retx = 0;\n\n\t\t/*\n\t\t * If so, request re-tx of holes further away than stride.\n\t\t * This ensures that a missing seq is requested at least\n\t\t * certain number of times regardless of incoming rate.\n\t\t */\n\t\tif (dist_retx &&\n\t\t    slot_dist(slot - ncrx->slots, ncrx) > ncrx->p.retx_stride)\n\t\t\tretx = 1;\n\n\t\t/* request re-tx every retx_intv */\n\t\tif (now_mono - max(slot->timestamp, slot->retx_timestamp) >=\n\t\t    (unsigned)ncrx->p.retx_intv) {\n\t\t\tslot->retx_timestamp = now_mono;\n\t\t\tretx = 1;\n\t\t}\n\n\t\tif (retx)\n\t\t\tncrx_build_resp(slot, ncrx);\n\t}\n\n\treturn ret;\n}\n\nconst char *ncrx_response(struct ncrx *ncrx, int *lenp)\n{\n\tif (lenp)\n\t\t*lenp = ncrx->resp_len;\n\tif (ncrx->resp_len)\n\t\treturn ncrx->resp_buf;\n\treturn NULL;\n}\n\n/* parse out the dictionary in a complete message, if it exists */\nstatic void terminate_msg_and_dict(struct ncrx_msg *msg)\n{\n\tmsg->dict = strchr(msg->text, '\\n');\n\tif (msg->dict) {\n\t\tint len = msg->text_len;\n\t\tmsg->text_len = msg->dict - msg->text;\n\t\tmsg->text[msg->text_len] = '\\0';\n\t\tmsg->dict_len = len - msg->text_len - 1;\n\t\tmsg->dict++;\n\t}\n}\n\nstruct ncrx_msg *ncrx_next_msg(struct ncrx *ncrx)\n{\n\tstruct ncrx_msg *msg = msg_list_pop(&ncrx->retired_list);\n\n\tif (msg)\n\t\tterminate_msg_and_dict(msg);\n\n\treturn msg;\n}\n\nuint64_t ncrx_invoke_process_at(struct ncrx *ncrx)\n{\n\tuint64_t when = UINT64_MAX;\n\tstruct ncrx_msg *msg;\n\n\t/* ack enabled and pending? */\n\tif (ncrx->p.ack_intv && ncrx->head_seq &&\n\t\t\tncrx->acked_seq != tail_seq(ncrx) - 1)\n\t\twhen = min(when, ncrx->acked_at + ncrx->p.ack_intv);\n\n\t/*\n\t * Holes to request for retransmission?  msg_timeout is the same\n\t * condition but way longer.  Checking on retx_intv is enough.\n\t */\n\tif (!list_empty(&ncrx->hole_list))\n\t\twhen = min(when, ncrx->now_mono + ncrx->p.retx_intv);\n\n\t/* oos timeout */\n\tif ((msg = msg_list_peek(&ncrx->oos_list)))\n\t\twhen = min(when, msg->rx_at_mono + ncrx->p.oos_timeout);\n\n\t/* min 10ms intv to avoid busy loop in case something goes bonkers */\n\treturn max(when, ncrx->now_mono + 10);\n}\n\nstruct ncrx *ncrx_create(const struct ncrx_param *param)\n{\n\tconst struct ncrx_param *dfl = &ncrx_dfl_param;\n\tstruct ncrx_param *p;\n\tstruct ncrx *ncrx;\n\tint i;\n\n\tncrx = calloc(1, sizeof(*ncrx));\n\tif (!ncrx)\n\t\treturn NULL;\n\n\tp = &ncrx->p;\n\tif (param) {\n\t\tp->nr_slots\t= param->nr_slots\t?: dfl->nr_slots;\n\n\t\tp->ack_intv\t= param->ack_intv\t?: dfl->ack_intv;\n\t\tp->retx_intv\t= param->retx_intv\t?: dfl->retx_intv;\n\t\tp->retx_stride\t= param->retx_stride\t?: dfl->retx_stride;\n\t\tp->msg_timeout\t= param->msg_timeout\t?: dfl->msg_timeout;\n\n\t\tp->oos_thr\t= param->oos_thr\t?: dfl->oos_thr;\n\t\tp->oos_intv\t= param->oos_intv\t?: dfl->oos_intv;\n\t\tp->oos_timeout\t= param->oos_timeout\t?: dfl->oos_timeout;\n\t} else {\n\t\t*p = *dfl;\n\t}\n\n\tncrx->acked_seq = UINT64_MAX;\n\tinit_list(&ncrx->hole_list);\n\tinit_list(&ncrx->oos_list.head);\n\tinit_list(&ncrx->retired_list.head);\n\n\tncrx->slots = calloc(ncrx->p.nr_slots, sizeof(ncrx->slots[0]));\n\tif (!ncrx->slots)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ncrx->p.nr_slots; i++)\n\t\tinit_list(&ncrx->slots[i].hole_node);\n\n\treturn ncrx;\n}\n\nvoid ncrx_destroy(struct ncrx *ncrx)\n{\n\tstruct ncrx_msg *msg;\n\tint i;\n\n\tfor (i = 0; i < ncrx->p.nr_slots; i++)\n\t\tfree(ncrx->slots[i].msg);\n\n\twhile ((msg = msg_list_pop(&ncrx->oos_list)))\n\t\tfree(msg);\n\n\twhile ((msg = msg_list_pop(&ncrx->retired_list)))\n\t\tfree(msg);\n\n\tfree(ncrx->slots);\n\tfree(ncrx);\n}\n"], "filenames": ["ncrx/libncrx.c"], "buggy_code_start_loc": [259], "buggy_code_end_loc": [259], "fixing_code_start_loc": [260], "fixing_code_end_loc": [261], "type": "CWE-787", "message": "netconsd prior to v0.2 was vulnerable to an integer overflow in its parse_packet function. A malicious individual could leverage this overflow to create heap memory corruption with attacker controlled data.", "other": {"cve": {"id": "CVE-2023-28753", "sourceIdentifier": "cve-assign@fb.com", "published": "2023-05-18T22:15:09.860", "lastModified": "2023-05-26T18:25:43.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "netconsd prior to v0.2 was vulnerable to an integer overflow in its parse_packet function. A malicious individual could leverage this overflow to create heap memory corruption with attacker controlled data."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:netconsd:0.1:*:*:*:*:*:*:*", "matchCriteriaId": "C7C31BF2-FE76-4643-8339-142389136E80"}]}]}], "references": [{"url": "https://github.com/facebook/netconsd/commit/9fc54edf54f7caea1189c2b979337ed37af2c60e", "source": "cve-assign@fb.com", "tags": ["Patch"]}, {"url": "https://www.facebook.com/security/advisories/cve-2023-28753", "source": "cve-assign@fb.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/netconsd/commit/9fc54edf54f7caea1189c2b979337ed37af2c60e"}}