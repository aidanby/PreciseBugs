{"buggy_code": ["# Release Notes\n\n\n## WIP\n\n- Add create|update|delete endpoints content item to REST API\n- Add GraphQL mutation saveContentItem to create|update content items\n- Add GraphQL mutation deleteContentItem to delete content items\n- Add app side panel (admin layout)\n\n## 2.1.2 (2022-08-04)\n\n- \ud83d\udea8 Fix typo field-contentItemtLink -> Need to re-assign field type contentItemLink \ud83d\udea8\n- General cleanup + fix typos\n- Add content tree items reorder permission\n- Refactor app layout header\n- Show more detailed error message if saving user settings fail\n- Hide publish state configuration ui if missing permission to mange publish state\n- Fix selected item link of tree model\n- Fix missing assets folders permission checks\n\n## 2.1.1 (2022-08-02)\n\n- Fix tree model route in app search results\n- Fix loosing nested level on saving tree item\n\n## 2.1.0 (2022-08-01)\n\n- Add initial global app search implementation (alt|option + f)\n- Minor fixes on closing html tag + uninitialized variable #11 @remluben\n- Update lib/vendor\n- Update vendor assets sortablejs v1.15, uppy v2.13.1, tinyMCE v6.1.2\n- Add model type tree - organize content items as tree\n\n## 2.0.2 (2022-07-20)\n\n- Fix select boxes in dark theme (chrome on windows) #8\n- Change login (noun) to log in (verb)\n- Fix required field check on nested repeatable items\n- Enable picking item by clicking on empty placeholder area (Asset + Content Link field)\n- Open api playground with preselected api key\n- Enable clear field function also in nested fields\n- Make fields-manger + fields-renderer component available by default\n- Set content model icon\n\n## 2.0.1 (2022-07-17)\n\n- Refactor admin ui localization\n- Object.freeze App._vars + App._paths\n- Make logged in user information available on the client side (App.user)\n- Update .htaccess file to deny public access to php files except router entry index.php\n- Add visual hover state to content item tables\n\n## 2.0.0 (2022-07-13)\n\n- Initial release \ud83c\udf7e\ud83e\udd73", "<?php\n/*\n * Lime.\n *\n * Copyright (c) 2014 Artur Heinze\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nnamespace Lime;\n\nuse ArrayObject;\n\ninclude(__DIR__.'/Request.php');\ninclude(__DIR__.'/Response.php');\n\n\nclass App implements \\ArrayAccess {\n\n    protected static $apps = [];\n\n    protected array $registry = [];\n    protected array $routes   = [];\n    protected array $paths    = [];\n    protected array $events   = [];\n    protected array $blocks   = [];\n\n    /** @var Response|null  */\n    public ?Response $response = null;\n\n    /** @var Request|null  */\n    public ?Request $request = null;\n\n    public ArrayObject $helpers;\n    public mixed $layout = false;\n\n    /**\n    * Constructor\n    * @param Array $settings initial registry settings\n    */\n    public function __construct (array $settings = []) {\n\n        $self = $this;\n        $base_url = implode('/', \\array_slice(explode('/', $_SERVER['SCRIPT_NAME']), 0, -1));\n\n        $this->registry = \\array_merge([\n            'debug'        => true,\n            'app.name'     => 'LimeApp',\n            'session.name' => 'limeappsession',\n            'autoload'     => new ArrayObject([]),\n            'sec-key'      => 'xxxxx-SiteSecKeyPleaseChangeMe-xxxxx',\n            'route'        => $_SERVER['PATH_INFO'] ?? '/',\n            'charset'      => 'UTF-8',\n            'helpers'      => [],\n            'base_url'     => $base_url,\n            'base_route'   => $base_url,\n            'base_host'    => $_SERVER['SERVER_NAME'] ?? \\php_uname('n'),\n            'base_port'    => $_SERVER['SERVER_PORT'] ?? 80,\n            'docs_root'    => null,\n            'site_url'     => null\n        ], $settings);\n\n        // app modules container\n        $this->registry['modules'] = new ArrayObject([]);\n\n        // try to guess site url\n        if (!isset($this['site_url']) && \\PHP_SAPI !== 'cli') {\n\n            $url = ((!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') ? 'https':'http').'://';\n\n            if (!\\in_array($this->registry['base_port'], ['80', '443'])) {\n                $url .= $this->registry['base_host'].':'.$this->registry['base_port'];\n            } else {\n                $url .= $this->registry['base_host'];\n            }\n\n            $this->registry['site_url'] = \\rtrim($url, '/');\n\n        } elseif (\\is_string($this->registry['site_url'])) {\n            $this->registry['site_url'] = \\rtrim($this->registry['site_url'], '/');\n        }\n\n        if (!isset($this['docs_root'])) {\n            $this->registry['docs_root'] = \\str_replace(DIRECTORY_SEPARATOR, '/', isset($_SERVER['DOCUMENT_ROOT']) ? \\realpath($_SERVER['DOCUMENT_ROOT']) : \\dirname($_SERVER['SCRIPT_FILENAME']));\n        }\n\n        // make sure base + route url doesn't end with a slash;\n        $this->registry['base_url']   = \\rtrim($this->registry['base_url'], '/');\n        $this->registry['base_route'] = \\rtrim($this->registry['base_route'], '/');\n\n        self::$apps[$this['app.name']] = $this;\n\n        // default helpers\n        $this->helpers = new ArrayObject(\\array_merge([\n            'cache' => 'Lime\\\\Helper\\\\Cache',\n            'fs' => 'Lime\\\\Helper\\\\Filesystem',\n            'session' => 'Lime\\\\Helper\\\\Session',\n            'utils' => 'Lime\\\\Helper\\\\Utils'\n        ], $this->registry['helpers']));\n\n        // register simple autoloader\n        spl_autoload_register(function ($class) use($self){\n\n            foreach ($self->retrieve('autoload', []) as $dir) {\n\n                $class_file = $dir.'/'.\\str_replace('\\\\', '/', $class).'.php';\n\n                if (\\file_exists($class_file)){\n                    include_once($class_file);\n                    return;\n                }\n            }\n        });\n    }\n\n    /**\n     * Object behavior on clone\n     *\n     * @return void\n     */\n    public function __clone() {\n\n        // update app instance on appaware objects\n\n        $this->helpers = clone $this->helpers;\n\n        foreach ($this->helpers as $name => $helper) {\n            if (is_string($helper)) continue;\n            $helper = clone $helper;\n            $helper->app = $this;\n            $this->helpers[$name] = $helper;\n        }\n\n        $this->registry['modules'] = clone $this->registry['modules'];\n\n        foreach ($this->registry['modules'] as $name => $module) {\n            $module = clone $module;\n            $module->bindApp($this);\n            $this->registry['modules'][$name] = $module;\n        }\n\n        foreach ($this->events as $name => &$list) {\n            foreach ($list as &$meta) {\n                if (\\is_object($meta['fn']) && $meta['fn'] instanceof \\Closure) {\n                    $meta['fn'] = $meta['fn']->bindTo($this, $this);\n                }\n            }\n        }\n    }\n\n    /**\n    * Get App instance\n    * @param  String $name Lime app name\n    * @return Object       Lime app object\n    */\n    public static function instance(string $name, bool $clone = false): self {\n        return $clone ? clone self::$apps[$name] : self::$apps[$name];\n    }\n\n    /**\n    * Returns a closure that stores the result of the given closure\n    * @param  String  $name\n    * @param  \\Closure $callable\n    * @return Object\n    */\n    public function service(string $name, mixed $callable): object {\n\n        $this->registry[$name] = function($c) use($callable) {\n            static $object;\n\n            if (null === $object) {\n                $object = $callable($c);\n            }\n\n            return $object;\n        };\n\n        return $this;\n    }\n\n    /**\n    * stop application (exit)\n    */\n    public function stop(mixed $data = null, ?int $status = null): void {\n\n        if (!isset($this->response)) {\n\n            if (\\is_array($data) || \\is_object($data)) {\n                $data = \\json_encode($data);\n            }\n\n            if ($data) {\n                echo $data;\n            }\n\n            $this->trigger('after', [true]);\n\n            exit;\n        }\n\n        if ($status) {\n            $this->response->status = $status;\n        }\n\n        if ($data) {\n            $this->response->body = $data;\n        }\n\n        if (\\is_numeric($data) && isset(Response::$statusCodes[$data])) {\n\n            $this->response->status = $data;\n\n            if ($this->response->mime == 'json') {\n                $this->response->body = \\json_encode(['error' => Response::$statusCodes[$data]]);\n            } else {\n                $this->response->body = Response::$statusCodes[$data];\n            }\n        }\n\n        $this->request->stopped = true;\n    }\n\n    /**\n    * Returns link based on the base url of the app\n    * @param  String $path e.g. /js/myscript.js\n    * @return String       Link\n    */\n    public function baseUrl(string $path): string {\n\n        $url = '';\n\n        if (\\strpos($path, ':')===false) {\n\n            /*\n            if ($this->registry['base_port'] != '80') {\n                $url .= $this->registry['site_url'];\n            }\n            */\n\n            $url .= $this->registry['base_url'].'/'.\\ltrim($path, '/');\n\n        } else {\n            $url = $this->pathToUrl($path);\n        }\n\n        return $url;\n    }\n\n    public function base(string $path): void {\n\n        $args = \\func_get_args();\n\n        echo (\\count($args)==1) ? $this->baseUrl($args[0]) : $this->baseUrl(\\call_user_func_array('sprintf', $args));\n    }\n\n    /**\n    * Returns link based on the route url of the app\n    * @param  String $path e.g. /pages/home\n    * @return String       Link\n    */\n    public function routeUrl(string $path): string {\n\n        $url = '';\n\n        /*\n        if ($this->registry['base_port'] != '80') {\n            $url .= $this->registry['site_url'];\n        }\n        */\n\n        $url .= $this->registry['base_route'];\n\n        return $url.'/'.\\ltrim($path, '/');\n    }\n\n    public function route(): void {\n\n        $args = \\func_get_args();\n\n        echo (\\count($args)==1) ? $this->routeUrl($args[0]) : $this->routeUrl(\\call_user_func_array('sprintf', $args));\n\n    }\n\n    /**\n    * Redirect to path.\n    * @param  String $path Path redirect to.\n    * @return void\n    */\n    public function reroute(string $path): void {\n\n        if (\\strpos($path,'://') === false) {\n            if (\\substr($path,0,1)!='/'){\n                $path = '/'.$path;\n            }\n            $path = $this->routeUrl($path);\n        }\n\n        $this->response->status = 307;\n        $this->response->headers['Location'] = $path;\n\n        $this->stop();\n    }\n\n    /**\n    * Put a value in the Lime registry\n    * @param String $key  Key name\n    * @param Mixed $value  Value\n    */\n    public function set(string $key,mixed $value): self {\n\n        $keys = \\explode('/',$key);\n\n        if (\\count($keys)>5) return false;\n\n        switch (\\count($keys)){\n\n          case 1:\n            $this->registry[$keys[0]] = $value;\n            break;\n\n          case 2:\n            $this->registry[$keys[0]][$keys[1]] = $value;\n            break;\n\n          case 3:\n            $this->registry[$keys[0]][$keys[1]][$keys[2]] = $value;\n            break;\n\n          case 4:\n            $this->registry[$keys[0]][$keys[1]][$keys[2]][$keys[3]] = $value;\n            break;\n\n          case 5:\n            $this->registry[$keys[0]][$keys[1]][$keys[2]][$keys[3]][$keys[4]] = $value;\n            break;\n        }\n\n        return $this;\n    }\n\n    /**\n    * Get a value from the Lime registry\n    * @param  String $key\n    * @param  Mixed $default\n    * @return Mixed\n    */\n    public function retrieve(string $key, mixed $default = null): mixed {\n        return fetch_from_array($this->registry, $key, $default);\n    }\n\n\n    /**\n    * Path helper method\n    * @return Mixed\n    */\n    public function path(): mixed {\n\n        $args = \\func_get_args();\n\n        switch (\\count($args)){\n\n            case 1:\n\n                $file  = $args[0];\n\n                if ($this->isAbsolutePath($file) && \\file_exists($file)) {\n                    return $file;\n                }\n\n                $parts = \\explode(':', $file, 2);\n\n                if (count($parts)==2){\n                    if (!isset($this->paths[$parts[0]])) return null;\n\n                    foreach ($this->paths[$parts[0]] as &$path) {\n                        if (\\file_exists($path.$parts[1])){\n                            return $path.$parts[1];\n                        }\n                    }\n                }\n\n                return null;\n\n            case 2:\n\n                if (!isset($this->paths[$args[0]])) {\n                    $this->paths[$args[0]] = [];\n                }\n                \\array_unshift($this->paths[$args[0]], \\rtrim(\\str_replace(DIRECTORY_SEPARATOR, '/', $args[1]), '/').'/');\n\n                return $this;\n        }\n\n        return null;\n    }\n\n    /**\n     * @param $namespace\n     * @return array\n     */\n    public function paths(?string $namespace = null): array {\n\n        if (!$namespace) {\n            return $this->paths;\n        }\n\n        return $this->paths[$namespace] ?? [];\n    }\n\n    /**\n     * @param $path\n     * @return bool|string\n     */\n    public function pathToUrl(string $path, bool $full = false): mixed {\n\n        $url = false;\n\n        if ($file = $this->path($path)) {\n\n            $file = \\str_replace(DIRECTORY_SEPARATOR, '/', $file);\n            $root = \\str_replace(DIRECTORY_SEPARATOR, '/', $this['docs_root']);\n\n            $url = '/'.\\ltrim(\\str_replace($root, '', $file), '/');\n            $url = \\implode('/', \\array_map('rawurlencode', explode('/', $url)));\n\n            if ($full) {\n                $site_url = str_replace(parse_url($this->registry['site_url'] ?? '', \\PHP_URL_PATH) ?? '', '', $this->registry['site_url'] ?? '');\n                $url = \\rtrim($site_url, '/').$url;\n            }\n        }\n\n        return $url;\n    }\n\n    /**\n    * Cache helper method\n    * @return Mixed\n    */\n    public function cache(): mixed{\n\n        $args = \\func_get_args();\n\n        switch(\\count($args)){\n            case 1:\n                return $this->helper('cache')->read($args[0]);\n            case 2:\n                return $this->helper('cache')->write($args[0], $args[1]);\n        }\n\n        return null;\n    }\n\n    /**\n    * Bind an event to closure\n    * @param  String  $event\n    * @param  \\Closure $callback\n    * @param  Integer $priority\n    * @return App\n    */\n    public function on(string|array $event, mixed $callback, int $priority = 0): self {\n\n        if (\\is_array($event)) {\n\n            foreach ($event as &$evt) {\n                $this->on($evt, $callback, $priority);\n            }\n            return $this;\n        }\n\n        if (!isset($this->events[$event])) $this->events[$event] = [];\n\n        // make $this available in closures\n        if (\\is_object($callback) && $callback instanceof \\Closure) {\n            $callback = $callback->bindTo($this, $this);\n        }\n\n        $this->events[$event][] = ['fn' => $callback, 'prio' => $priority];\n\n        return $this;\n    }\n\n    /**\n    * Trigger event.\n    * @param  String $event\n    * @param  Array  $params\n    * @return Boolean\n    */\n    public function trigger(string $event, array $params=[]): self {\n\n        if (!isset($this->events[$event])){\n            return $this;\n        }\n\n        if (!\\count($this->events[$event])){\n            return $this;\n        }\n\n        $queue = new \\SplPriorityQueue();\n\n        foreach ($this->events[$event] as $index => $action){\n            $queue->insert($index, $action['prio']);\n        }\n\n        $queue->top();\n\n        while ($queue->valid()){\n            $index = $queue->current();\n            if (\\is_callable($this->events[$event][$index]['fn'])){\n                if (\\call_user_func_array($this->events[$event][$index]['fn'], $params) === false) {\n                    break; // stop Propagation\n                }\n            }\n            $queue->next();\n        }\n\n        return $this;\n    }\n\n    /**\n    * Render view.\n    * @param  String $____template Path to view\n    * @param  Array  $_____slots   Passed variables\n    * @return String               Rendered view\n    */\n    public function render(string $____template, array $_____slots = []): string {\n\n        $this->trigger('app.render.view', [&$____template, &$_____slots]);\n\n        if (\\is_string($____template) && $____template) {\n            $this->trigger(\"app.render.view/{$____template}\", [&$____template, &$_____slots]);\n        }\n\n        $____layout = $this->layout;\n\n        if (\\strpos($____template, ' with ') !== false ) {\n            list($____template, $____layout) = \\explode(' with ', $____template, 2);\n        }\n\n        if (\\strpos($____template, ':') !== false && $____file = $this->path($____template)) {\n            $____template = $____file;\n        }\n\n        $extend = function($from) use(&$____layout) {\n            $____layout = $from;\n        };\n\n        \\extract((array)$_____slots);\n\n        \\ob_start();\n        include $____template;\n        $output = \\ob_get_clean();\n\n        if ($____layout) {\n\n            if (\\strpos($____layout, ':') !== false && $____file = $this->path($____layout)) {\n                $____layout = $____file;\n            }\n\n            $content_for_layout = $output;\n\n            \\ob_start();\n            include $____layout;\n            $output = \\ob_get_clean();\n\n        }\n\n        return $output;\n    }\n\n    /**\n    * Start block\n    * @param  String $name\n    * @return Null\n    */\n    public function start(string $name): void {\n\n        if (!isset($this->blocks[$name])){\n            $this->blocks[$name] = [];\n        }\n\n        \\ob_start();\n    }\n\n    /**\n    * End block\n    * @param  String $name\n    * @return Null\n    */\n    public function end(string $name): void {\n\n        $out = \\ob_get_clean();\n\n        if (isset($this->blocks[$name])){\n            $this->blocks[$name][] = $out;\n        }\n    }\n\n    /**\n    * Get block content\n    * @param  String $name\n    * @param  array  $options\n    * @return String\n    */\n    public function block(string $name, array $options=[]): ?string {\n\n        if (!isset($this->blocks[$name])) return null;\n\n        $options = \\array_merge([\n            'print' => true\n        ], $options);\n\n        $block = \\implode(\"\\n\", $this->blocks[$name]);\n\n        if ($options['print']){\n            echo $block;\n        }\n\n        return $block;\n    }\n\n    /**\n    * Escape string.\n    * @param  String $string\n    * @param  String $charset\n    * @return String\n    */\n    public function escape(?string $string, ?string $charset = null): string {\n\n        if (\\is_null($charset)){\n            $charset = $this['charset'];\n        }\n\n        return \\htmlspecialchars($string ?? '', \\ENT_QUOTES, $charset);\n    }\n\n    /**\n    * Get style inc. markup\n    * @param  Mixed $href\n    * @return String\n    */\n    public function style(mixed $href, ?string $version = null): string {\n\n        $output = '';\n\n        $type = 'text/css';\n        $rel  = 'stylesheet';\n        $src = $href;\n\n        if (\\is_array($href)) {\n            extract($href, \\EXTR_OVERWRITE);\n        }\n\n        $ispath = \\strpos($src, ':') !== false && !\\preg_match('#^(|http\\:|https\\:)//#', $src);\n        $output = '<link href=\"'.($ispath ? $this->pathToUrl($src):$src).($version ? \"?ver={$version}\":\"\").'\" type=\"'.$type.'\" rel=\"'.$rel.'\">';\n\n        return $output;\n    }\n\n    /**\n    * Get script inc. markup\n    * @param  Mixed $src\n    * @return String\n    */\n    public function script(mixed $src, ?string $version = null): string {\n\n        $output = '';\n\n        $type = 'text/javascript';\n        $load = '';\n\n        if (\\is_array($src)) {\n            extract($src, \\EXTR_OVERWRITE);\n        }\n\n        $ispath = \\strpos($src, ':') !== false && !\\preg_match('#^(/|http\\:|https\\:)//#', $src);\n        $output = '<script src=\"'.($ispath ? $this->pathToUrl($src):$src).($version ? \"?ver={$version}\":\"\").'\" type=\"'.$type.'\" '.$load.'></script>';\n\n        return $output;\n    }\n\n    /**\n    * Get assets inc. markup\n    * @param  Array|String $src\n    * @param  Mixed $version\n    * @return String\n    */\n    public function assets(mixed $src, ?string $version = null): string {\n\n        $list = [];\n\n        foreach ((array)$src as $asset) {\n\n            $src = $asset;\n\n            if (\\is_array($asset)) {\n                extract($asset, \\EXTR_OVERWRITE);\n            }\n\n            if (@\\substr($src, -3) == '.js') {\n                $list[] = $this->script($asset, $version);\n            }\n\n            if (@\\substr($src, -4) == '.css') {\n                $list[] = $this->style($asset, $version);\n            }\n        }\n\n        return \\implode(\"\\n\", $list);\n    }\n\n    /**\n    * Bind GET request to route\n    * @param  String  $path\n    * @param  \\Closure  $callback\n    * @param  Boolean $condition\n    * @return void\n    */\n    public function get(string $path, mixed $callback, bool $condition = true): void {\n        if ($this->request && $this->request->is('get')) {\n            $this->bind($path, $callback, $condition);\n        }\n    }\n\n    /**\n    * Bind POST request to route\n    * @param  String  $path\n    * @param  \\Closure  $callback\n    * @param  Boolean $condition\n    * @return void\n    */\n    public function post(string $path, mixed $callback, bool $condition = true): void {\n        if ($this->request && $this->request->is('post')) {\n            $this->bind($path, $callback, $condition);\n        }\n    }\n\n    /**\n    * Bind Class to routes\n    * @param  String $class\n    * @return void\n    */\n    public function bindClass(string $class, ?string $alias = null): void {\n\n        $self  = $this;\n        $clean = ltrim($alias ? $alias : \\trim(\\strtolower(\\str_replace(\"\\\\\", \"/\", $class)), \"\\\\\"), '/');\n\n        $this->bind(\"/{$clean}/*\", function() use($self, $class, $clean) {\n\n            $parts  = \\explode('/', \\trim(\\preg_replace(\"#$clean#\", \"\", $self->request->route,1),'/'));\n            $action = isset($parts[0]) ? $parts[0]:\"index\";\n            $params = \\count($parts)>1 ? \\array_slice($parts, 1):[];\n\n            return $self->invoke($class, $action, $params);\n        });\n\n        $this->bind(\"/{$clean}\", function() use($self, $class) {\n            return $self->invoke($class, 'index', []);\n        });\n    }\n\n    /**\n    * Bind namespace to routes\n    * @param  String $namespace\n    * @return void\n    */\n    public function bindNamespace(string $namespace, ?string $alias = null): void {\n\n        $self  = $this;\n        $clean = $alias ? $alias : \\trim(\\strtolower(\\str_replace(\"\\\\\", \"/\", $namespace)), \"\\\\\");\n\n        $this->bind('/'.$clean.'/*', function() use($self, $namespace, $clean) {\n\n            $parts      = \\explode('/', trim(preg_replace(\"#$clean#\",\"\",$self[\"route\"],1),'/'));\n            $class      = $namespace.'\\\\'.$parts[0];\n            $action     = isset($parts[1]) ? $parts[1]:\"index\";\n            $params     = \\count($parts)>2 ? \\array_slice($parts, 2):[];\n\n            return $self->invoke($class,$action, $params);\n        });\n\n        $this->bind('/'.\\strtolower($namespace), function() use($self, $namespace) {\n\n            $class = $namespace.\"\\\\\".\\array_pop(\\explode('\\\\', $namespace));\n\n            return $self->invoke($class, 'index', []);\n        });\n    }\n\n    /**\n    * Bind request to route\n    * @param  String  $path\n    * @param  \\Closure  $callback\n    * @param  Boolean $condition\n    * @return void\n    */\n    public function bind(string $path, mixed $callback, bool $condition = true): void {\n\n        if (!$condition) return;\n\n        if (!isset($this->routes[$path])) {\n            $this->routes[$path] = [];\n        }\n\n        // make $this available in closures\n        if (\\is_object($callback) && $callback instanceof \\Closure) {\n            $callback = $callback->bindTo($this, $this);\n        }\n\n        // autou-register for /route/* also /route\n        if (\\substr($path, -2) == '/*' && !isset($this->routes[\\substr($path, 0, -2)])) {\n            $this->bind(\\substr($path, 0, -2), $callback, $condition);\n        }\n\n        $this->routes[$path] = $callback;\n    }\n\n    /**\n    * Run Application request\n    * @param  String $route Route to parse\n    * @return void\n    */\n    public function run(?string $route = null, ?Request $request = null, bool $flush = true): Response {\n\n        $self = $this;\n\n        $this->request = $request ?? $this->getRequestfromGlobals();\n\n        \\register_shutdown_function(function() use($self) {\n\n            if (\\session_status() === \\PHP_SESSION_ACTIVE) {\n                \\session_write_close();\n            }\n            $self->trigger('shutdown');\n        });\n\n        if ($route) {\n            $this->request->route = $route;\n        }\n\n        $this->response = new Response();\n        $this->trigger('before');\n\n        if (!$this->request->stopped) {\n\n            $contents = $this->dispatch($route);\n\n            if (!$this->request->stopped) {\n                $this->response->body = $contents;\n            }\n        }\n\n        if ($this->response->status == 200 && $this->response->body === false) {\n            $this->response->status = 404;\n        }\n\n        $this->trigger('after');\n\n        if ($flush) {\n\n            if ($this->response->status === 307 && isset($this->response->headers['Location'])) {\n                header(\"Location: {$this->response->headers['Location']}\");\n                exit;\n            }\n\n            $this->response->flush();\n        }\n\n        return $this->response;\n    }\n\n    /**\n    * Dispatch route\n    * @param  String $path\n    * @return Mixed\n    */\n    public function dispatch(string $path): mixed {\n\n            $found  = false;\n            $params = [];\n\n            if (isset($this->routes[$path])) {\n\n                $found = $this->render_route($path, $params);\n\n            } else {\n\n                foreach ($this->routes as $route => $callback) {\n\n                    $params = [];\n\n                    /* e.g. #\\.html$#  */\n                    if (\\substr($route,0,1)=='#' && \\substr($route,-1)=='#'){\n\n                        if (\\preg_match($route, $path, $matches)){\n                            $params[':captures'] = \\array_slice($matches, 1);\n                            $found = $this->render_route($route, $params);\n                            break;\n                        }\n                    }\n\n                    /* e.g. /admin/*  */\n                    if (\\strpos($route, '*') !== false){\n\n                        $pattern = '#^'.\\str_replace('\\*', '(.*)', \\preg_quote($route, '#')).'#';\n\n                        if (\\preg_match($pattern, $path, $matches)){\n\n                            $params[':splat'] = \\array_slice($matches, 1);\n                            $found = $this->render_route($route, $params);\n                            break;\n                        }\n                    }\n\n                    /* e.g. /admin/:id  */\n                    if (strpos($route, ':') !== false){\n\n                        $parts_p = \\explode('/', $path);\n                        $parts_r = \\explode('/', $route);\n\n                        if (\\count($parts_p) == \\count($parts_r)){\n\n                            $matched = true;\n\n                            foreach ($parts_r as $index => $part){\n                                if (':' === \\substr($part,0,1)) {\n                                    $params[\\substr($part,1)] = $parts_p[$index];\n                                    continue;\n                                }\n\n                                if ($parts_p[$index] != $parts_r[$index]) {\n                                    $matched = false;\n                                    break;\n                                }\n                            }\n\n                            if ($matched){\n                                $found = $this->render_route($route, $params);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return $found;\n    }\n\n    /**\n    * Render dispatched route\n    * @param  [type] $route\n    * @param  array  $params\n    * @return String\n    */\n    protected function render_route(string $route, array $params = []): mixed {\n\n        $output = false;\n\n        if (isset($this->routes[$route])) {\n\n            $ret = null;\n\n            if (\\is_callable($this->routes[$route])){\n                $ret = \\call_user_func($this->routes[$route], $params);\n            }\n\n            if (!is_null($ret)){\n                return $ret;\n            }\n        }\n\n        return $output;\n    }\n\n\n    /**\n    * Invoke Class as controller\n    * @param  String $class\n    * @param  String $action\n    * @param  Array  $params\n    * @return Mixed\n    */\n    public function invoke(string $class, string $action='index', array$params=[]): mixed {\n\n        $context = compact('action', 'params');\n        $controller = new $class($this, $context);\n\n        return \\method_exists($controller, $action) && \\is_callable([$controller, $action])\n                ? \\call_user_func_array([$controller,$action], $params)\n                : false;\n    }\n\n    /**\n    * Get request variables\n    * @param  String $index\n    * @param  Mixed $default\n    * @param  Array $source\n    * @return Mixed\n    */\n    public function param(?string $index = null, mixed $default = null, mixed $source = null): mixed {\n        return isset($this->request) ? $this->request->param($index, $default, $source) : $default;\n    }\n\n    /**\n    * Request helper function\n    * @param  String $type\n    * @return Boolean\n    */\n    public function req_is(string $type): bool {\n        return isset($this->request) ? $this->request->is($type) : false;\n    }\n\n    /**\n    * Get client ip.\n    * @return String\n    */\n    public function getClientIp(): string{\n        return isset($this->request) ? $this->request->getClientIp() : '';\n    }\n\n    /**\n    * Get client language\n    * @return String\n    */\n    public function getClientLang(string $default=\"en\"): string {\n        return isset($this->request) ? $this->request->getClientLang($default) : $default;\n    }\n\n    /**\n    * Get site url\n    * @return String\n    */\n    public function getSiteUrl(bool $withpath = false): string {\n        return isset($this->request) ? $this->request->getSiteUrl($withpath) : '';\n    }\n\n    /**\n    * Create Hash\n    * @return String\n    */\n    public function hash(string $text, mixed $algo = PASSWORD_BCRYPT): string {\n        return \\password_hash($text, $algo);\n    }\n\n    /**\n     * RC4 encryption\n     * @param  String  $data\n     * @param  String  $pwd\n     * @param  boolean $base64encoded\n     * @return String\n     */\n    public function encode(string $data, string $pwd, bool $base64encoded = false): string {\n\n        $key = [''];\n        $box = [''];\n        $cipher = '';\n\n        $pwd_length = \\strlen($pwd);\n        $data_length = \\strlen($data);\n\n        for ($i = 0; $i < 256; $i++) {\n            $key[$i] = \\ord($pwd[$i % $pwd_length]);\n            $box[$i] = $i;\n        }\n        for ($j = $i = 0; $i < 256; $i++) {\n            $j = ($j + $box[$i] + $key[$i]) % 256;\n            $tmp = $box[$i];\n            $box[$i] = $box[$j];\n            $box[$j] = $tmp;\n        }\n        for ($a = $j = $i = 0; $i < $data_length; $i++) {\n            $a = ($a + 1) % 256;\n            $j = ($j + $box[$a]) % 256;\n            $tmp = $box[$a];\n            $box[$a] = $box[$j];\n            $box[$j] = $tmp;\n            $k = $box[(($box[$a] + $box[$j]) % 256)];\n            $cipher .= \\chr(\\ord($data[$i]) ^ $k);\n        }\n        return $base64encoded ? \\base64_encode($cipher):$cipher;\n    }\n\n    /**\n     * Decode RC4 encrypted text\n     * @param  String $data\n     * @param  String $pwd\n     * @return String\n     */\n    public function decode(string $data, string $pwd): string {\n        return $this->encode($data, $pwd);\n    }\n\n    public function helper(string $helper): Helper {\n        if (isset($this->helpers[$helper]) && !\\is_object($this->helpers[$helper])) {\n            $this->helpers[$helper] = new $this->helpers[$helper]($this);\n        }\n\n        return $this->helpers[$helper];\n    }\n\n    public function isAbsolutePath(string $path): bool {\n        return '/' == $path[0] || '\\\\' == $path[0] || (3 < \\strlen($path) && \\ctype_alpha($path[0]) && $path[1] == ':' && ('\\\\' == $path[2] || '/' == $path[2]));\n    }\n\n    public function module(string $name): mixed {\n        return $this->registry['modules'][$name] ?? null;\n    }\n\n    public function registerModule(string $name, string $dir): Module {\n\n        $name = \\strtolower($name);\n\n        if (!isset($this->registry['modules'][$name])) {\n\n            $module = new Module($this);\n\n            $module->_dir = $dir;\n            $module->_bootfile = \"{$dir}/bootstrap.php\";\n\n            $this->path($name, $dir);\n            $this->registry['modules'][$name] = $module;\n            $this->bootModule($module);\n        }\n\n        return $this->registry['modules'][$name];\n    }\n\n    public function loadModule($path, $prefix = null) {\n\n        if (is_array($path)) {\n            foreach ($path as $p) $this->loadModule($p);\n            return true;\n        }\n\n        $disabled = $this->registry['modules.disabled'] ?? null;\n        $basename = basename($path);\n        $pfx = \\is_bool($prefix) && $prefix ? \\strtolower(basename($path)) : $prefix;\n        $name = $prefix ? \"{$pfx}-{$basename}\" : $basename;\n\n        if ($disabled && \\in_array($name, $disabled)) return false;\n\n        $this->registerModule($name, $path);\n\n        return true;\n    }\n\n    public function loadModules(mixed $dirs, bool $autoload = true, mixed $prefix = null): array {\n\n        $modules  = [];\n        $dirs     = (array)$dirs;\n\n        foreach ($dirs as &$dir) {\n\n            if (\\file_exists($dir)) {\n\n                // load modules\n                foreach (new \\DirectoryIterator($dir) as $module) {\n\n                    if ($module->isFile() || $module->isDot()) continue;\n\n                    if ($this->loadModule($module->getRealPath(), $prefix)) {\n                        $modules[] = \\strtolower($module->getBasename());\n                    }\n                }\n\n                if ($autoload) $this['autoload']->append($dir);\n            }\n        }\n\n        return $modules;\n    }\n\n    protected function bootModule(Module $module): void {\n\n        if (is_file($module->_bootfile)) {\n            $app = $this;\n            require($module->_bootfile);\n        }\n    }\n\n    // accces to services\n    public function __get($name): mixed {\n        return $this[$name];\n    }\n\n    // Array Access implementation\n\n    public function offsetSet(mixed $key, mixed $value): void {\n        $this->registry[$key] = $value;\n    }\n\n    public function offsetGet($key): mixed {\n\n        $value = $this->retrieve($key, null);\n\n        if (!is_null($value)) {\n            return ($value instanceof \\Closure) ? $value($this) : $value;\n        }\n\n        return $value;\n    }\n\n    public function offsetExists($key): bool {\n        return isset($this->registry[$key]);\n    }\n\n    public function offsetUnset(mixed $key): void {\n        unset($this->registry[$key]);\n    }\n\n    // Invoke call\n    public function __invoke($helper) {\n\n        return $this->helper($helper);\n    }\n\n    protected function getRequestfromGlobals(): Request {\n\n        return Request::fromGlobalRequest([\n            'site_url'   => $this->registry['site_url'],\n            'base_url'   => $this->registry['base_url'],\n            'base_route' => $this->registry['base_route']\n        ]);\n    }\n\n} // End App\n\n// Helpers\n\nclass AppAware {\n\n    public App $app;\n    public mixed $context;\n\n    public function __construct(App $app, mixed $context = null) {\n        $this->app = $app;\n        $this->context = $context;\n\n        $this->initialize();\n    }\n\n    protected function initialize() {}\n\n    public function __call($name, $arguments) {\n\n        if (\\is_callable([$this->app, $name])) {\n            return \\call_user_func_array([$this->app, $name], $arguments);\n        }\n        return $this;\n    }\n\n    public function __invoke($helper) {\n\n        return $this->app->helper($helper);\n    }\n\n    // acccess to services\n    public function __get($name) {\n        return $this->app[$name];\n    }\n\n}\n\nclass Module extends AppAware {\n\n    protected $apis = [];\n\n    public ?string $_dir = null;\n    public ?string $_bootfile = null;\n\n    public function extend(array $api) {\n\n        foreach ($api as $name => $value) {\n\n            if ($value instanceof \\Closure) {\n                $value = $value->bindTo($this, $this);\n                $this->apis[$name] = $value;\n            } else {\n                $this->{$name} = $value;\n            }\n        }\n    }\n\n    public function bindApp(App $app) {\n\n        $this->app = $app;\n\n        foreach ($this->apis as $name => $value) {\n\n            if ($value instanceof \\Closure) {\n                $value = $value->bindTo($this, $this);\n            }\n\n            $this->apis[$name] = $value;\n        }\n    }\n\n    public function __set($name , $value) {\n        $this->extend([$name => $value]);\n    }\n    public function __get($name) {\n        return isset($this->apis[$name]) ? $this->apis[$name] : null;\n    }\n    public function __isset($name) {\n        return isset($this->apis[$name]);\n    }\n    public function __unset($name) {\n        unset($this->apis[$name]);\n    }\n    public function __call($name, $arguments) {\n\n        if (isset($this->apis[$name]) && \\is_callable($this->apis[$name])) {\n            return \\call_user_func_array($this->apis[$name], $arguments);\n        }\n\n        if (isset($this->apis['__call']) && \\is_callable($this->apis['__call'])) {\n            return \\call_user_func_array($this->apis['__call'], [$name, $arguments]);\n        }\n\n        return null;\n    }\n}\n\n\nclass Helper extends AppAware { }\n\n\ninclude(__DIR__.'/Helper/Session.php');\ninclude(__DIR__.'/Helper/Cache.php');\n\n// helper functions\n\nfunction fetch_from_array(array &$array, ?string $index = null, mixed $default = null) {\n\n    if (is_null($index)) {\n\n        return $array;\n\n    } elseif (isset($array[$index])) {\n\n        return $array[$index];\n\n    } elseif (\\strpos($index, '/')) {\n\n        $keys = \\explode('/', $index);\n\n        switch (\\count($keys)){\n\n            case 1:\n                if (isset($array[$keys[0]])){\n                    return $array[$keys[0]];\n                }\n                break;\n\n            case 2:\n                if (isset($array[$keys[0]][$keys[1]])){\n                    return $array[$keys[0]][$keys[1]];\n                }\n                break;\n\n            case 3:\n                if (isset($array[$keys[0]][$keys[1]][$keys[2]])){\n                    return $array[$keys[0]][$keys[1]][$keys[2]];\n                }\n                break;\n\n            case 4:\n                if (isset($array[$keys[0]][$keys[1]][$keys[2]][$keys[3]])){\n                    return $array[$keys[0]][$keys[1]][$keys[2]][$keys[3]];\n                }\n                break;\n        }\n    }\n\n    return \\is_callable($default) ? \\call_user_func($default) : $default;\n}\n"], "fixing_code": ["# Release Notes\n\n\n## WIP\n\n- Add create|update|delete endpoints content item to REST API\n- Add GraphQL mutation saveContentItem to create|update content items\n- Add GraphQL mutation deleteContentItem to delete content items\n- Add app side panel (admin layout)\n- Stop execution of code after redirecting\n\n## 2.1.2 (2022-08-04)\n\n- \ud83d\udea8 Fix typo field-contentItemtLink -> Need to re-assign field type contentItemLink \ud83d\udea8\n- General cleanup + fix typos\n- Add content tree items reorder permission\n- Refactor app layout header\n- Show more detailed error message if saving user settings fail\n- Hide publish state configuration ui if missing permission to mange publish state\n- Fix selected item link of tree model\n- Fix missing assets folders permission checks\n\n## 2.1.1 (2022-08-02)\n\n- Fix tree model route in app search results\n- Fix loosing nested level on saving tree item\n\n## 2.1.0 (2022-08-01)\n\n- Add initial global app search implementation (alt|option + f)\n- Minor fixes on closing html tag + uninitialized variable #11 @remluben\n- Update lib/vendor\n- Update vendor assets sortablejs v1.15, uppy v2.13.1, tinyMCE v6.1.2\n- Add model type tree - organize content items as tree\n\n## 2.0.2 (2022-07-20)\n\n- Fix select boxes in dark theme (chrome on windows) #8\n- Change login (noun) to log in (verb)\n- Fix required field check on nested repeatable items\n- Enable picking item by clicking on empty placeholder area (Asset + Content Link field)\n- Open api playground with preselected api key\n- Enable clear field function also in nested fields\n- Make fields-manger + fields-renderer component available by default\n- Set content model icon\n\n## 2.0.1 (2022-07-17)\n\n- Refactor admin ui localization\n- Object.freeze App._vars + App._paths\n- Make logged in user information available on the client side (App.user)\n- Update .htaccess file to deny public access to php files except router entry index.php\n- Add visual hover state to content item tables\n\n## 2.0.0 (2022-07-13)\n\n- Initial release \ud83c\udf7e\ud83e\udd73", "<?php\n/*\n * Lime.\n *\n * Copyright (c) 2014 Artur Heinze\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nnamespace Lime;\n\nuse ArrayObject;\n\ninclude(__DIR__.'/Request.php');\ninclude(__DIR__.'/Response.php');\n\n\nclass App implements \\ArrayAccess {\n\n    protected static $apps = [];\n\n    protected array $registry = [];\n    protected array $routes   = [];\n    protected array $paths    = [];\n    protected array $events   = [];\n    protected array $blocks   = [];\n\n    /** @var Response|null  */\n    public ?Response $response = null;\n\n    /** @var Request|null  */\n    public ?Request $request = null;\n\n    public ArrayObject $helpers;\n    public mixed $layout = false;\n\n    /**\n    * Constructor\n    * @param Array $settings initial registry settings\n    */\n    public function __construct (array $settings = []) {\n\n        $self = $this;\n        $base_url = implode('/', \\array_slice(explode('/', $_SERVER['SCRIPT_NAME']), 0, -1));\n\n        $this->registry = \\array_merge([\n            'debug'        => true,\n            'app.name'     => 'LimeApp',\n            'session.name' => 'limeappsession',\n            'autoload'     => new ArrayObject([]),\n            'sec-key'      => 'xxxxx-SiteSecKeyPleaseChangeMe-xxxxx',\n            'route'        => $_SERVER['PATH_INFO'] ?? '/',\n            'charset'      => 'UTF-8',\n            'helpers'      => [],\n            'base_url'     => $base_url,\n            'base_route'   => $base_url,\n            'base_host'    => $_SERVER['SERVER_NAME'] ?? \\php_uname('n'),\n            'base_port'    => $_SERVER['SERVER_PORT'] ?? 80,\n            'docs_root'    => null,\n            'site_url'     => null\n        ], $settings);\n\n        // app modules container\n        $this->registry['modules'] = new ArrayObject([]);\n\n        // try to guess site url\n        if (!isset($this['site_url']) && \\PHP_SAPI !== 'cli') {\n\n            $url = ((!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') ? 'https':'http').'://';\n\n            if (!\\in_array($this->registry['base_port'], ['80', '443'])) {\n                $url .= $this->registry['base_host'].':'.$this->registry['base_port'];\n            } else {\n                $url .= $this->registry['base_host'];\n            }\n\n            $this->registry['site_url'] = \\rtrim($url, '/');\n\n        } elseif (\\is_string($this->registry['site_url'])) {\n            $this->registry['site_url'] = \\rtrim($this->registry['site_url'], '/');\n        }\n\n        if (!isset($this['docs_root'])) {\n            $this->registry['docs_root'] = \\str_replace(DIRECTORY_SEPARATOR, '/', isset($_SERVER['DOCUMENT_ROOT']) ? \\realpath($_SERVER['DOCUMENT_ROOT']) : \\dirname($_SERVER['SCRIPT_FILENAME']));\n        }\n\n        // make sure base + route url doesn't end with a slash;\n        $this->registry['base_url']   = \\rtrim($this->registry['base_url'], '/');\n        $this->registry['base_route'] = \\rtrim($this->registry['base_route'], '/');\n\n        self::$apps[$this['app.name']] = $this;\n\n        // default helpers\n        $this->helpers = new ArrayObject(\\array_merge([\n            'cache' => 'Lime\\\\Helper\\\\Cache',\n            'fs' => 'Lime\\\\Helper\\\\Filesystem',\n            'session' => 'Lime\\\\Helper\\\\Session',\n            'utils' => 'Lime\\\\Helper\\\\Utils'\n        ], $this->registry['helpers']));\n\n        // register simple autoloader\n        spl_autoload_register(function ($class) use($self){\n\n            foreach ($self->retrieve('autoload', []) as $dir) {\n\n                $class_file = $dir.'/'.\\str_replace('\\\\', '/', $class).'.php';\n\n                if (\\file_exists($class_file)){\n                    include_once($class_file);\n                    return;\n                }\n            }\n        });\n    }\n\n    /**\n     * Object behavior on clone\n     *\n     * @return void\n     */\n    public function __clone() {\n\n        // update app instance on appaware objects\n\n        $this->helpers = clone $this->helpers;\n\n        foreach ($this->helpers as $name => $helper) {\n            if (is_string($helper)) continue;\n            $helper = clone $helper;\n            $helper->app = $this;\n            $this->helpers[$name] = $helper;\n        }\n\n        $this->registry['modules'] = clone $this->registry['modules'];\n\n        foreach ($this->registry['modules'] as $name => $module) {\n            $module = clone $module;\n            $module->bindApp($this);\n            $this->registry['modules'][$name] = $module;\n        }\n\n        foreach ($this->events as $name => &$list) {\n            foreach ($list as &$meta) {\n                if (\\is_object($meta['fn']) && $meta['fn'] instanceof \\Closure) {\n                    $meta['fn'] = $meta['fn']->bindTo($this, $this);\n                }\n            }\n        }\n    }\n\n    /**\n    * Get App instance\n    * @param  String $name Lime app name\n    * @return Object       Lime app object\n    */\n    public static function instance(string $name, bool $clone = false): self {\n        return $clone ? clone self::$apps[$name] : self::$apps[$name];\n    }\n\n    /**\n    * Returns a closure that stores the result of the given closure\n    * @param  String  $name\n    * @param  \\Closure $callable\n    * @return Object\n    */\n    public function service(string $name, mixed $callable): object {\n\n        $this->registry[$name] = function($c) use($callable) {\n            static $object;\n\n            if (null === $object) {\n                $object = $callable($c);\n            }\n\n            return $object;\n        };\n\n        return $this;\n    }\n\n    /**\n    * stop application (exit)\n    */\n    public function stop(mixed $data = null, ?int $status = null): void {\n\n        if (!isset($this->response)) {\n\n            if (\\is_array($data) || \\is_object($data)) {\n                $data = \\json_encode($data);\n            }\n\n            if ($data) {\n                echo $data;\n            }\n\n            $this->trigger('after', [true]);\n\n            exit;\n        }\n\n        if ($status) {\n            $this->response->status = $status;\n        }\n\n        if ($data) {\n            $this->response->body = $data;\n        }\n\n        if (\\is_numeric($data) && isset(Response::$statusCodes[$data])) {\n\n            $this->response->status = $data;\n\n            if ($this->response->mime == 'json') {\n                $this->response->body = \\json_encode(['error' => Response::$statusCodes[$data]]);\n            } else {\n                $this->response->body = Response::$statusCodes[$data];\n            }\n        }\n\n        $this->request->stopped = true;\n\n        $this->trigger('app:request:stop');\n        $this->trigger('after', [true]);\n\n        exit;\n    }\n\n    /**\n    * Returns link based on the base url of the app\n    * @param  String $path e.g. /js/myscript.js\n    * @return String       Link\n    */\n    public function baseUrl(string $path): string {\n\n        $url = '';\n\n        if (\\strpos($path, ':')===false) {\n\n            /*\n            if ($this->registry['base_port'] != '80') {\n                $url .= $this->registry['site_url'];\n            }\n            */\n\n            $url .= $this->registry['base_url'].'/'.\\ltrim($path, '/');\n\n        } else {\n            $url = $this->pathToUrl($path);\n        }\n\n        return $url;\n    }\n\n    public function base(string $path): void {\n\n        $args = \\func_get_args();\n\n        echo (\\count($args)==1) ? $this->baseUrl($args[0]) : $this->baseUrl(\\call_user_func_array('sprintf', $args));\n    }\n\n    /**\n    * Returns link based on the route url of the app\n    * @param  String $path e.g. /pages/home\n    * @return String       Link\n    */\n    public function routeUrl(string $path): string {\n\n        $url = '';\n\n        /*\n        if ($this->registry['base_port'] != '80') {\n            $url .= $this->registry['site_url'];\n        }\n        */\n\n        $url .= $this->registry['base_route'];\n\n        return $url.'/'.\\ltrim($path, '/');\n    }\n\n    public function route(): void {\n\n        $args = \\func_get_args();\n\n        echo (\\count($args)==1) ? $this->routeUrl($args[0]) : $this->routeUrl(\\call_user_func_array('sprintf', $args));\n\n    }\n\n    /**\n    * Redirect to path.\n    * @param  String $path Path redirect to.\n    * @return void\n    */\n    public function reroute(string $path): void {\n\n        if (\\strpos($path,'://') === false) {\n            if (\\substr($path,0,1)!='/'){\n                $path = '/'.$path;\n            }\n            $path = $this->routeUrl($path);\n        }\n\n        $this->response->status = 307;\n        $this->response->headers['Location'] = $path;\n\n        $this->stop();\n    }\n\n    /**\n    * Put a value in the Lime registry\n    * @param String $key  Key name\n    * @param Mixed $value  Value\n    */\n    public function set(string $key,mixed $value): self {\n\n        $keys = \\explode('/',$key);\n\n        if (\\count($keys)>5) return false;\n\n        switch (\\count($keys)){\n\n          case 1:\n            $this->registry[$keys[0]] = $value;\n            break;\n\n          case 2:\n            $this->registry[$keys[0]][$keys[1]] = $value;\n            break;\n\n          case 3:\n            $this->registry[$keys[0]][$keys[1]][$keys[2]] = $value;\n            break;\n\n          case 4:\n            $this->registry[$keys[0]][$keys[1]][$keys[2]][$keys[3]] = $value;\n            break;\n\n          case 5:\n            $this->registry[$keys[0]][$keys[1]][$keys[2]][$keys[3]][$keys[4]] = $value;\n            break;\n        }\n\n        return $this;\n    }\n\n    /**\n    * Get a value from the Lime registry\n    * @param  String $key\n    * @param  Mixed $default\n    * @return Mixed\n    */\n    public function retrieve(string $key, mixed $default = null): mixed {\n        return fetch_from_array($this->registry, $key, $default);\n    }\n\n\n    /**\n    * Path helper method\n    * @return Mixed\n    */\n    public function path(): mixed {\n\n        $args = \\func_get_args();\n\n        switch (\\count($args)){\n\n            case 1:\n\n                $file  = $args[0];\n\n                if ($this->isAbsolutePath($file) && \\file_exists($file)) {\n                    return $file;\n                }\n\n                $parts = \\explode(':', $file, 2);\n\n                if (count($parts)==2){\n                    if (!isset($this->paths[$parts[0]])) return null;\n\n                    foreach ($this->paths[$parts[0]] as &$path) {\n                        if (\\file_exists($path.$parts[1])){\n                            return $path.$parts[1];\n                        }\n                    }\n                }\n\n                return null;\n\n            case 2:\n\n                if (!isset($this->paths[$args[0]])) {\n                    $this->paths[$args[0]] = [];\n                }\n                \\array_unshift($this->paths[$args[0]], \\rtrim(\\str_replace(DIRECTORY_SEPARATOR, '/', $args[1]), '/').'/');\n\n                return $this;\n        }\n\n        return null;\n    }\n\n    /**\n     * @param $namespace\n     * @return array\n     */\n    public function paths(?string $namespace = null): array {\n\n        if (!$namespace) {\n            return $this->paths;\n        }\n\n        return $this->paths[$namespace] ?? [];\n    }\n\n    /**\n     * @param $path\n     * @return bool|string\n     */\n    public function pathToUrl(string $path, bool $full = false): mixed {\n\n        $url = false;\n\n        if ($file = $this->path($path)) {\n\n            $file = \\str_replace(DIRECTORY_SEPARATOR, '/', $file);\n            $root = \\str_replace(DIRECTORY_SEPARATOR, '/', $this['docs_root']);\n\n            $url = '/'.\\ltrim(\\str_replace($root, '', $file), '/');\n            $url = \\implode('/', \\array_map('rawurlencode', explode('/', $url)));\n\n            if ($full) {\n                $site_url = str_replace(parse_url($this->registry['site_url'] ?? '', \\PHP_URL_PATH) ?? '', '', $this->registry['site_url'] ?? '');\n                $url = \\rtrim($site_url, '/').$url;\n            }\n        }\n\n        return $url;\n    }\n\n    /**\n    * Cache helper method\n    * @return Mixed\n    */\n    public function cache(): mixed{\n\n        $args = \\func_get_args();\n\n        switch(\\count($args)){\n            case 1:\n                return $this->helper('cache')->read($args[0]);\n            case 2:\n                return $this->helper('cache')->write($args[0], $args[1]);\n        }\n\n        return null;\n    }\n\n    /**\n    * Bind an event to closure\n    * @param  String  $event\n    * @param  \\Closure $callback\n    * @param  Integer $priority\n    * @return App\n    */\n    public function on(string|array $event, mixed $callback, int $priority = 0): self {\n\n        if (\\is_array($event)) {\n\n            foreach ($event as &$evt) {\n                $this->on($evt, $callback, $priority);\n            }\n            return $this;\n        }\n\n        if (!isset($this->events[$event])) $this->events[$event] = [];\n\n        // make $this available in closures\n        if (\\is_object($callback) && $callback instanceof \\Closure) {\n            $callback = $callback->bindTo($this, $this);\n        }\n\n        $this->events[$event][] = ['fn' => $callback, 'prio' => $priority];\n\n        return $this;\n    }\n\n    /**\n    * Trigger event.\n    * @param  String $event\n    * @param  Array  $params\n    * @return Boolean\n    */\n    public function trigger(string $event, array $params=[]): self {\n\n        if (!isset($this->events[$event])){\n            return $this;\n        }\n\n        if (!\\count($this->events[$event])){\n            return $this;\n        }\n\n        $queue = new \\SplPriorityQueue();\n\n        foreach ($this->events[$event] as $index => $action){\n            $queue->insert($index, $action['prio']);\n        }\n\n        $queue->top();\n\n        while ($queue->valid()){\n            $index = $queue->current();\n            if (\\is_callable($this->events[$event][$index]['fn'])){\n                if (\\call_user_func_array($this->events[$event][$index]['fn'], $params) === false) {\n                    break; // stop Propagation\n                }\n            }\n            $queue->next();\n        }\n\n        return $this;\n    }\n\n    /**\n    * Render view.\n    * @param  String $____template Path to view\n    * @param  Array  $_____slots   Passed variables\n    * @return String               Rendered view\n    */\n    public function render(string $____template, array $_____slots = []): string {\n\n        $this->trigger('app.render.view', [&$____template, &$_____slots]);\n\n        if (\\is_string($____template) && $____template) {\n            $this->trigger(\"app.render.view/{$____template}\", [&$____template, &$_____slots]);\n        }\n\n        $____layout = $this->layout;\n\n        if (\\strpos($____template, ' with ') !== false ) {\n            list($____template, $____layout) = \\explode(' with ', $____template, 2);\n        }\n\n        if (\\strpos($____template, ':') !== false && $____file = $this->path($____template)) {\n            $____template = $____file;\n        }\n\n        $extend = function($from) use(&$____layout) {\n            $____layout = $from;\n        };\n\n        \\extract((array)$_____slots);\n\n        \\ob_start();\n        include $____template;\n        $output = \\ob_get_clean();\n\n        if ($____layout) {\n\n            if (\\strpos($____layout, ':') !== false && $____file = $this->path($____layout)) {\n                $____layout = $____file;\n            }\n\n            $content_for_layout = $output;\n\n            \\ob_start();\n            include $____layout;\n            $output = \\ob_get_clean();\n\n        }\n\n        return $output;\n    }\n\n    /**\n    * Start block\n    * @param  String $name\n    * @return Null\n    */\n    public function start(string $name): void {\n\n        if (!isset($this->blocks[$name])){\n            $this->blocks[$name] = [];\n        }\n\n        \\ob_start();\n    }\n\n    /**\n    * End block\n    * @param  String $name\n    * @return Null\n    */\n    public function end(string $name): void {\n\n        $out = \\ob_get_clean();\n\n        if (isset($this->blocks[$name])){\n            $this->blocks[$name][] = $out;\n        }\n    }\n\n    /**\n    * Get block content\n    * @param  String $name\n    * @param  array  $options\n    * @return String\n    */\n    public function block(string $name, array $options=[]): ?string {\n\n        if (!isset($this->blocks[$name])) return null;\n\n        $options = \\array_merge([\n            'print' => true\n        ], $options);\n\n        $block = \\implode(\"\\n\", $this->blocks[$name]);\n\n        if ($options['print']){\n            echo $block;\n        }\n\n        return $block;\n    }\n\n    /**\n    * Escape string.\n    * @param  String $string\n    * @param  String $charset\n    * @return String\n    */\n    public function escape(?string $string, ?string $charset = null): string {\n\n        if (\\is_null($charset)){\n            $charset = $this['charset'];\n        }\n\n        return \\htmlspecialchars($string ?? '', \\ENT_QUOTES, $charset);\n    }\n\n    /**\n    * Get style inc. markup\n    * @param  Mixed $href\n    * @return String\n    */\n    public function style(mixed $href, ?string $version = null): string {\n\n        $output = '';\n\n        $type = 'text/css';\n        $rel  = 'stylesheet';\n        $src = $href;\n\n        if (\\is_array($href)) {\n            extract($href, \\EXTR_OVERWRITE);\n        }\n\n        $ispath = \\strpos($src, ':') !== false && !\\preg_match('#^(|http\\:|https\\:)//#', $src);\n        $output = '<link href=\"'.($ispath ? $this->pathToUrl($src):$src).($version ? \"?ver={$version}\":\"\").'\" type=\"'.$type.'\" rel=\"'.$rel.'\">';\n\n        return $output;\n    }\n\n    /**\n    * Get script inc. markup\n    * @param  Mixed $src\n    * @return String\n    */\n    public function script(mixed $src, ?string $version = null): string {\n\n        $output = '';\n\n        $type = 'text/javascript';\n        $load = '';\n\n        if (\\is_array($src)) {\n            extract($src, \\EXTR_OVERWRITE);\n        }\n\n        $ispath = \\strpos($src, ':') !== false && !\\preg_match('#^(/|http\\:|https\\:)//#', $src);\n        $output = '<script src=\"'.($ispath ? $this->pathToUrl($src):$src).($version ? \"?ver={$version}\":\"\").'\" type=\"'.$type.'\" '.$load.'></script>';\n\n        return $output;\n    }\n\n    /**\n    * Get assets inc. markup\n    * @param  Array|String $src\n    * @param  Mixed $version\n    * @return String\n    */\n    public function assets(mixed $src, ?string $version = null): string {\n\n        $list = [];\n\n        foreach ((array)$src as $asset) {\n\n            $src = $asset;\n\n            if (\\is_array($asset)) {\n                extract($asset, \\EXTR_OVERWRITE);\n            }\n\n            if (@\\substr($src, -3) == '.js') {\n                $list[] = $this->script($asset, $version);\n            }\n\n            if (@\\substr($src, -4) == '.css') {\n                $list[] = $this->style($asset, $version);\n            }\n        }\n\n        return \\implode(\"\\n\", $list);\n    }\n\n    /**\n    * Bind GET request to route\n    * @param  String  $path\n    * @param  \\Closure  $callback\n    * @param  Boolean $condition\n    * @return void\n    */\n    public function get(string $path, mixed $callback, bool $condition = true): void {\n        if ($this->request && $this->request->is('get')) {\n            $this->bind($path, $callback, $condition);\n        }\n    }\n\n    /**\n    * Bind POST request to route\n    * @param  String  $path\n    * @param  \\Closure  $callback\n    * @param  Boolean $condition\n    * @return void\n    */\n    public function post(string $path, mixed $callback, bool $condition = true): void {\n        if ($this->request && $this->request->is('post')) {\n            $this->bind($path, $callback, $condition);\n        }\n    }\n\n    /**\n    * Bind Class to routes\n    * @param  String $class\n    * @return void\n    */\n    public function bindClass(string $class, ?string $alias = null): void {\n\n        $self  = $this;\n        $clean = ltrim($alias ? $alias : \\trim(\\strtolower(\\str_replace(\"\\\\\", \"/\", $class)), \"\\\\\"), '/');\n\n        $this->bind(\"/{$clean}/*\", function() use($self, $class, $clean) {\n\n            $parts  = \\explode('/', \\trim(\\preg_replace(\"#$clean#\", \"\", $self->request->route,1),'/'));\n            $action = isset($parts[0]) ? $parts[0]:\"index\";\n            $params = \\count($parts)>1 ? \\array_slice($parts, 1):[];\n\n            return $self->invoke($class, $action, $params);\n        });\n\n        $this->bind(\"/{$clean}\", function() use($self, $class) {\n            return $self->invoke($class, 'index', []);\n        });\n    }\n\n    /**\n    * Bind namespace to routes\n    * @param  String $namespace\n    * @return void\n    */\n    public function bindNamespace(string $namespace, ?string $alias = null): void {\n\n        $self  = $this;\n        $clean = $alias ? $alias : \\trim(\\strtolower(\\str_replace(\"\\\\\", \"/\", $namespace)), \"\\\\\");\n\n        $this->bind('/'.$clean.'/*', function() use($self, $namespace, $clean) {\n\n            $parts      = \\explode('/', trim(preg_replace(\"#$clean#\",\"\",$self[\"route\"],1),'/'));\n            $class      = $namespace.'\\\\'.$parts[0];\n            $action     = isset($parts[1]) ? $parts[1]:\"index\";\n            $params     = \\count($parts)>2 ? \\array_slice($parts, 2):[];\n\n            return $self->invoke($class,$action, $params);\n        });\n\n        $this->bind('/'.\\strtolower($namespace), function() use($self, $namespace) {\n\n            $class = $namespace.\"\\\\\".\\array_pop(\\explode('\\\\', $namespace));\n\n            return $self->invoke($class, 'index', []);\n        });\n    }\n\n    /**\n    * Bind request to route\n    * @param  String  $path\n    * @param  \\Closure  $callback\n    * @param  Boolean $condition\n    * @return void\n    */\n    public function bind(string $path, mixed $callback, bool $condition = true): void {\n\n        if (!$condition) return;\n\n        if (!isset($this->routes[$path])) {\n            $this->routes[$path] = [];\n        }\n\n        // make $this available in closures\n        if (\\is_object($callback) && $callback instanceof \\Closure) {\n            $callback = $callback->bindTo($this, $this);\n        }\n\n        // autou-register for /route/* also /route\n        if (\\substr($path, -2) == '/*' && !isset($this->routes[\\substr($path, 0, -2)])) {\n            $this->bind(\\substr($path, 0, -2), $callback, $condition);\n        }\n\n        $this->routes[$path] = $callback;\n    }\n\n    /**\n    * Run Application request\n    * @param  String $route Route to parse\n    * @return void\n    */\n    public function run(?string $route = null, ?Request $request = null, bool $flush = true): Response {\n\n        $self = $this;\n\n        $this->request = $request ?? $this->getRequestfromGlobals();\n\n        \\register_shutdown_function(function() use($self) {\n\n            if (\\session_status() === \\PHP_SESSION_ACTIVE) {\n                \\session_write_close();\n            }\n            $self->trigger('shutdown');\n        });\n\n        if ($route) {\n            $this->request->route = $route;\n        }\n\n        $this->response = new Response();\n        $this->trigger('before');\n\n        if ($flush) {\n\n            $this->on('app:request:stop', function() {\n\n                if ($this->response->status === 307 && isset($this->response->headers['Location'])) {\n                    \\header(\"Location: {$this->response->headers['Location']}\");\n                    exit;\n                }\n\n                $this->response->flush();\n            });\n        }\n\n        if (!$this->request->stopped) {\n\n            $contents = $this->dispatch($route);\n\n            if (!$this->request->stopped) {\n                $this->response->body = $contents;\n            }\n        }\n\n        if ($this->response->status == 200 && $this->response->body === false) {\n            $this->response->status = 404;\n        }\n\n        $this->trigger('after');\n\n        if ($flush) {\n\n            if ($this->response->status === 307 && isset($this->response->headers['Location'])) {\n                header(\"Location: {$this->response->headers['Location']}\");\n                exit;\n            }\n\n            $this->response->flush();\n        }\n\n        return $this->response;\n    }\n\n    /**\n    * Dispatch route\n    * @param  String $path\n    * @return Mixed\n    */\n    public function dispatch(string $path): mixed {\n\n            $found  = false;\n            $params = [];\n\n            if (isset($this->routes[$path])) {\n\n                $found = $this->render_route($path, $params);\n\n            } else {\n\n                foreach ($this->routes as $route => $callback) {\n\n                    $params = [];\n\n                    /* e.g. #\\.html$#  */\n                    if (\\substr($route,0,1)=='#' && \\substr($route,-1)=='#'){\n\n                        if (\\preg_match($route, $path, $matches)){\n                            $params[':captures'] = \\array_slice($matches, 1);\n                            $found = $this->render_route($route, $params);\n                            break;\n                        }\n                    }\n\n                    /* e.g. /admin/*  */\n                    if (\\strpos($route, '*') !== false){\n\n                        $pattern = '#^'.\\str_replace('\\*', '(.*)', \\preg_quote($route, '#')).'#';\n\n                        if (\\preg_match($pattern, $path, $matches)){\n\n                            $params[':splat'] = \\array_slice($matches, 1);\n                            $found = $this->render_route($route, $params);\n                            break;\n                        }\n                    }\n\n                    /* e.g. /admin/:id  */\n                    if (strpos($route, ':') !== false){\n\n                        $parts_p = \\explode('/', $path);\n                        $parts_r = \\explode('/', $route);\n\n                        if (\\count($parts_p) == \\count($parts_r)){\n\n                            $matched = true;\n\n                            foreach ($parts_r as $index => $part){\n                                if (':' === \\substr($part,0,1)) {\n                                    $params[\\substr($part,1)] = $parts_p[$index];\n                                    continue;\n                                }\n\n                                if ($parts_p[$index] != $parts_r[$index]) {\n                                    $matched = false;\n                                    break;\n                                }\n                            }\n\n                            if ($matched){\n                                $found = $this->render_route($route, $params);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return $found;\n    }\n\n    /**\n    * Render dispatched route\n    * @param  [type] $route\n    * @param  array  $params\n    * @return String\n    */\n    protected function render_route(string $route, array $params = []): mixed {\n\n        $output = false;\n\n        if (isset($this->routes[$route])) {\n\n            $ret = null;\n\n            if (\\is_callable($this->routes[$route])){\n                $ret = \\call_user_func($this->routes[$route], $params);\n            }\n\n            if (!is_null($ret)){\n                return $ret;\n            }\n        }\n\n        return $output;\n    }\n\n\n    /**\n    * Invoke Class as controller\n    * @param  String $class\n    * @param  String $action\n    * @param  Array  $params\n    * @return Mixed\n    */\n    public function invoke(string $class, string $action='index', array$params=[]): mixed {\n\n        $context = compact('action', 'params');\n        $controller = new $class($this, $context);\n\n        return \\method_exists($controller, $action) && \\is_callable([$controller, $action])\n                ? \\call_user_func_array([$controller,$action], $params)\n                : false;\n    }\n\n    /**\n    * Get request variables\n    * @param  String $index\n    * @param  Mixed $default\n    * @param  Array $source\n    * @return Mixed\n    */\n    public function param(?string $index = null, mixed $default = null, mixed $source = null): mixed {\n        return isset($this->request) ? $this->request->param($index, $default, $source) : $default;\n    }\n\n    /**\n    * Request helper function\n    * @param  String $type\n    * @return Boolean\n    */\n    public function req_is(string $type): bool {\n        return isset($this->request) ? $this->request->is($type) : false;\n    }\n\n    /**\n    * Get client ip.\n    * @return String\n    */\n    public function getClientIp(): string{\n        return isset($this->request) ? $this->request->getClientIp() : '';\n    }\n\n    /**\n    * Get client language\n    * @return String\n    */\n    public function getClientLang(string $default=\"en\"): string {\n        return isset($this->request) ? $this->request->getClientLang($default) : $default;\n    }\n\n    /**\n    * Get site url\n    * @return String\n    */\n    public function getSiteUrl(bool $withpath = false): string {\n        return isset($this->request) ? $this->request->getSiteUrl($withpath) : '';\n    }\n\n    /**\n    * Create Hash\n    * @return String\n    */\n    public function hash(string $text, mixed $algo = PASSWORD_BCRYPT): string {\n        return \\password_hash($text, $algo);\n    }\n\n    /**\n     * RC4 encryption\n     * @param  String  $data\n     * @param  String  $pwd\n     * @param  boolean $base64encoded\n     * @return String\n     */\n    public function encode(string $data, string $pwd, bool $base64encoded = false): string {\n\n        $key = [''];\n        $box = [''];\n        $cipher = '';\n\n        $pwd_length = \\strlen($pwd);\n        $data_length = \\strlen($data);\n\n        for ($i = 0; $i < 256; $i++) {\n            $key[$i] = \\ord($pwd[$i % $pwd_length]);\n            $box[$i] = $i;\n        }\n        for ($j = $i = 0; $i < 256; $i++) {\n            $j = ($j + $box[$i] + $key[$i]) % 256;\n            $tmp = $box[$i];\n            $box[$i] = $box[$j];\n            $box[$j] = $tmp;\n        }\n        for ($a = $j = $i = 0; $i < $data_length; $i++) {\n            $a = ($a + 1) % 256;\n            $j = ($j + $box[$a]) % 256;\n            $tmp = $box[$a];\n            $box[$a] = $box[$j];\n            $box[$j] = $tmp;\n            $k = $box[(($box[$a] + $box[$j]) % 256)];\n            $cipher .= \\chr(\\ord($data[$i]) ^ $k);\n        }\n        return $base64encoded ? \\base64_encode($cipher):$cipher;\n    }\n\n    /**\n     * Decode RC4 encrypted text\n     * @param  String $data\n     * @param  String $pwd\n     * @return String\n     */\n    public function decode(string $data, string $pwd): string {\n        return $this->encode($data, $pwd);\n    }\n\n    public function helper(string $helper): Helper {\n        if (isset($this->helpers[$helper]) && !\\is_object($this->helpers[$helper])) {\n            $this->helpers[$helper] = new $this->helpers[$helper]($this);\n        }\n\n        return $this->helpers[$helper];\n    }\n\n    public function isAbsolutePath(string $path): bool {\n        return '/' == $path[0] || '\\\\' == $path[0] || (3 < \\strlen($path) && \\ctype_alpha($path[0]) && $path[1] == ':' && ('\\\\' == $path[2] || '/' == $path[2]));\n    }\n\n    public function module(string $name): mixed {\n        return $this->registry['modules'][$name] ?? null;\n    }\n\n    public function registerModule(string $name, string $dir): Module {\n\n        $name = \\strtolower($name);\n\n        if (!isset($this->registry['modules'][$name])) {\n\n            $module = new Module($this);\n\n            $module->_dir = $dir;\n            $module->_bootfile = \"{$dir}/bootstrap.php\";\n\n            $this->path($name, $dir);\n            $this->registry['modules'][$name] = $module;\n            $this->bootModule($module);\n        }\n\n        return $this->registry['modules'][$name];\n    }\n\n    public function loadModule($path, $prefix = null) {\n\n        if (is_array($path)) {\n            foreach ($path as $p) $this->loadModule($p);\n            return true;\n        }\n\n        $disabled = $this->registry['modules.disabled'] ?? null;\n        $basename = basename($path);\n        $pfx = \\is_bool($prefix) && $prefix ? \\strtolower(basename($path)) : $prefix;\n        $name = $prefix ? \"{$pfx}-{$basename}\" : $basename;\n\n        if ($disabled && \\in_array($name, $disabled)) return false;\n\n        $this->registerModule($name, $path);\n\n        return true;\n    }\n\n    public function loadModules(mixed $dirs, bool $autoload = true, mixed $prefix = null): array {\n\n        $modules  = [];\n        $dirs     = (array)$dirs;\n\n        foreach ($dirs as &$dir) {\n\n            if (\\file_exists($dir)) {\n\n                // load modules\n                foreach (new \\DirectoryIterator($dir) as $module) {\n\n                    if ($module->isFile() || $module->isDot()) continue;\n\n                    if ($this->loadModule($module->getRealPath(), $prefix)) {\n                        $modules[] = \\strtolower($module->getBasename());\n                    }\n                }\n\n                if ($autoload) $this['autoload']->append($dir);\n            }\n        }\n\n        return $modules;\n    }\n\n    protected function bootModule(Module $module): void {\n\n        if (is_file($module->_bootfile)) {\n            $app = $this;\n            require($module->_bootfile);\n        }\n    }\n\n    // accces to services\n    public function __get($name): mixed {\n        return $this[$name];\n    }\n\n    // Array Access implementation\n\n    public function offsetSet(mixed $key, mixed $value): void {\n        $this->registry[$key] = $value;\n    }\n\n    public function offsetGet($key): mixed {\n\n        $value = $this->retrieve($key, null);\n\n        if (!is_null($value)) {\n            return ($value instanceof \\Closure) ? $value($this) : $value;\n        }\n\n        return $value;\n    }\n\n    public function offsetExists($key): bool {\n        return isset($this->registry[$key]);\n    }\n\n    public function offsetUnset(mixed $key): void {\n        unset($this->registry[$key]);\n    }\n\n    // Invoke call\n    public function __invoke($helper) {\n\n        return $this->helper($helper);\n    }\n\n    protected function getRequestfromGlobals(): Request {\n\n        return Request::fromGlobalRequest([\n            'site_url'   => $this->registry['site_url'],\n            'base_url'   => $this->registry['base_url'],\n            'base_route' => $this->registry['base_route']\n        ]);\n    }\n\n} // End App\n\n// Helpers\n\nclass AppAware {\n\n    public App $app;\n    public mixed $context;\n\n    public function __construct(App $app, mixed $context = null) {\n        $this->app = $app;\n        $this->context = $context;\n\n        $this->initialize();\n    }\n\n    protected function initialize() {}\n\n    public function __call($name, $arguments) {\n\n        if (\\is_callable([$this->app, $name])) {\n            return \\call_user_func_array([$this->app, $name], $arguments);\n        }\n        return $this;\n    }\n\n    public function __invoke($helper) {\n\n        return $this->app->helper($helper);\n    }\n\n    // acccess to services\n    public function __get($name) {\n        return $this->app[$name];\n    }\n\n}\n\nclass Module extends AppAware {\n\n    protected $apis = [];\n\n    public ?string $_dir = null;\n    public ?string $_bootfile = null;\n\n    public function extend(array $api) {\n\n        foreach ($api as $name => $value) {\n\n            if ($value instanceof \\Closure) {\n                $value = $value->bindTo($this, $this);\n                $this->apis[$name] = $value;\n            } else {\n                $this->{$name} = $value;\n            }\n        }\n    }\n\n    public function bindApp(App $app) {\n\n        $this->app = $app;\n\n        foreach ($this->apis as $name => $value) {\n\n            if ($value instanceof \\Closure) {\n                $value = $value->bindTo($this, $this);\n            }\n\n            $this->apis[$name] = $value;\n        }\n    }\n\n    public function __set($name , $value) {\n        $this->extend([$name => $value]);\n    }\n    public function __get($name) {\n        return isset($this->apis[$name]) ? $this->apis[$name] : null;\n    }\n    public function __isset($name) {\n        return isset($this->apis[$name]);\n    }\n    public function __unset($name) {\n        unset($this->apis[$name]);\n    }\n    public function __call($name, $arguments) {\n\n        if (isset($this->apis[$name]) && \\is_callable($this->apis[$name])) {\n            return \\call_user_func_array($this->apis[$name], $arguments);\n        }\n\n        if (isset($this->apis['__call']) && \\is_callable($this->apis['__call'])) {\n            return \\call_user_func_array($this->apis['__call'], [$name, $arguments]);\n        }\n\n        return null;\n    }\n}\n\n\nclass Helper extends AppAware { }\n\n\ninclude(__DIR__.'/Helper/Session.php');\ninclude(__DIR__.'/Helper/Cache.php');\n\n// helper functions\n\nfunction fetch_from_array(array &$array, ?string $index = null, mixed $default = null) {\n\n    if (is_null($index)) {\n\n        return $array;\n\n    } elseif (isset($array[$index])) {\n\n        return $array[$index];\n\n    } elseif (\\strpos($index, '/')) {\n\n        $keys = \\explode('/', $index);\n\n        switch (\\count($keys)){\n\n            case 1:\n                if (isset($array[$keys[0]])){\n                    return $array[$keys[0]];\n                }\n                break;\n\n            case 2:\n                if (isset($array[$keys[0]][$keys[1]])){\n                    return $array[$keys[0]][$keys[1]];\n                }\n                break;\n\n            case 3:\n                if (isset($array[$keys[0]][$keys[1]][$keys[2]])){\n                    return $array[$keys[0]][$keys[1]][$keys[2]];\n                }\n                break;\n\n            case 4:\n                if (isset($array[$keys[0]][$keys[1]][$keys[2]][$keys[3]])){\n                    return $array[$keys[0]][$keys[1]][$keys[2]][$keys[3]];\n                }\n                break;\n        }\n    }\n\n    return \\is_callable($default) ? \\call_user_func($default) : $default;\n}\n"], "filenames": ["CHANGELOG.md", "lib/Lime/App.php"], "buggy_code_start_loc": [9, 236], "buggy_code_end_loc": [9, 857], "fixing_code_start_loc": [10, 237], "fixing_code_end_loc": [11, 876], "type": "CWE-613", "message": "Insufficient Session Expiration in GitHub repository cockpit-hq/cockpit prior to 2.2.0.", "other": {"cve": {"id": "CVE-2022-2713", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-08T15:15:08.777", "lastModified": "2022-08-12T14:50:34.847", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insufficient Session Expiration in GitHub repository cockpit-hq/cockpit prior to 2.2.0."}, {"lang": "es", "value": "Una Expiraci\u00f3n no Suficiente de Sesi\u00f3n en el repositorio GitHub cockpit-hq/cockpit versiones anteriores a 2.2.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:agentejo:cockpit:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.0", "matchCriteriaId": "C385E1CE-0E6C-4F72-B012-5BBBABD13157"}]}]}], "references": [{"url": "https://github.com/cockpit-hq/cockpit/commit/dd8d0314912fa6517ebd2cc9939d9fafbe68731b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/3080fc96-75d7-4868-84de-9fc8c9b90290", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cockpit-hq/cockpit/commit/dd8d0314912fa6517ebd2cc9939d9fafbe68731b"}}